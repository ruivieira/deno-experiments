var e3, t3, n3, r11 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global,
        o17 = e3 = {};

function i() {
    throw new Error("setTimeout has not been defined");
}

function u3() {
    throw new Error("clearTimeout has not been defined");
}

function c1(e1) {
    if (t3 === setTimeout) {
        return setTimeout(e1, 0);
    }
    if ((t3 === i || !t3) && setTimeout) {
        return t3 = setTimeout, setTimeout(e1, 0);
    }
    try {
        return t3(e1, 0);
    } catch (n1) {
        try {
            return t3.call(null, e1, 0);
        } catch (n2) {
            return t3.call(this || r11, e1, 0);
        }
    }
}

!function () {
    try {
        t3 = "function" == typeof setTimeout ? setTimeout : i;
    } catch (e1) {
        t3 = i;
    }
    try {
        n3 = "function" == typeof clearTimeout ? clearTimeout : u3;
    } catch (e1) {
        n3 = u3;
    }
}();
var l2, s3 = [], f14 = !1, a10 = -1;

function h6() {
    f14 && l2 && (f14 = !1, l2.length ? s3 = l2.concat(s3) : a10 = -1, s3.length && d6());
}

function d6() {
    if (!f14) {
        var e1 = c1(h6);
        f14 = !0;
        for (var t1 = s3.length; t1;) {
            for (l2 = s3, s3 = []; (++a10) < t1;) {
                l2 && l2[a10].run();
            }
            a10 = -1, t1 = s3.length;
        }
        l2 = null, f14 = !1, (function (e2) {
            if (n3 === clearTimeout) {
                return clearTimeout(e2);
            }
            if ((n3 === u3 || !n3) && clearTimeout) {
                return n3 = clearTimeout, clearTimeout(e2);
            }
            try {
                n3(e2);
            } catch (t2) {
                try {
                    return n3.call(null, e2);
                } catch (t3) {
                    return n3.call(this || r11, e2);
                }
            }
        })(e1);
    }
}

function m(e2, t2) {
    (this || r11).fun = e2, (this || r11).array = t2;
}

function p2() {
}

o17.nextTick = function (e2) {
    var t2 = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var n1 = 1; n1 < arguments.length; n1++) {
            t2[n1 - 1] = arguments[n1];
        }
    }
    s3.push(new m(e2, t2)), 1 !== s3.length || f14 || c1(d6);
}, m.prototype.run = function () {
    (this || r11).fun.apply(null, (this || r11).array);
}, o17.title = "browser", o17.browser = !0, o17.env = {}, o17.argv = [], o17.version = "", o17.versions = {}, o17.on = p2, o17.addListener = p2, o17.once = p2, o17.off = p2, o17.removeListener = p2, o17.removeAllListeners = p2, o17.emit = p2, o17.prependListener = p2, o17.prependOnceListener = p2, o17.listeners = function (e2) {
    return [];
}, o17.binding = function (e2) {
    throw new Error("process.binding is not supported");
}, o17.cwd = function () {
    return "/";
}, o17.chdir = function (e2) {
    throw new Error("process.chdir is not supported");
}, o17.umask = function () {
    return 0;
};
var T1 = e3;
var e2, t2, n1 = "object" == typeof Reflect ? Reflect : null,
        r1 = n1 && "function" == typeof n1.apply ? n1.apply : function (e3, t3, n2) {
            return Function.prototype.apply.call(e3, t3, n2);
        };
t2 = n1 && "function" == typeof n1.ownKeys ? n1.ownKeys : Object.getOwnPropertySymbols ? function (e3) {
    return Object.getOwnPropertyNames(e3).concat(Object.getOwnPropertySymbols(e3));
} : function (e3) {
    return Object.getOwnPropertyNames(e3);
};
var i1 = Number.isNaN || function (e3) {
    return e3 != e3;
};

function o1() {
    o1.init.call(this);
}

e2 = o1, o1.EventEmitter = o1, o1.prototype._events = void 0, o1.prototype._eventsCount = 0, o1.prototype._maxListeners = void 0;
var s1 = 10;

function u1(e3) {
    if ("function" != typeof e3) {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e3);
    }
}

function f1(e3) {
    return (void 0) === e3._maxListeners ? o1.defaultMaxListeners : e3._maxListeners;
}

function v2(e3, t3, n2, r2) {
    var i2, o2, s2, v2;
    if (u1(n2), (void 0) === (o2 = e3._events) ? (o2 = e3._events = Object.create(null), e3._eventsCount = 0) : ((void 0) !== o2.newListener && (e3.emit("newListener", t3, n2.listener ? n2.listener : n2), o2 = e3._events), s2 = o2[t3]), (void 0) === s2) {
        s2 = o2[t3] = n2, ++e3._eventsCount;
    } else if ("function" == typeof s2 ? s2 = o2[t3] = r2 ? [
        n2,
        s2
    ] : [
        s2,
        n2
    ] : r2 ? s2.unshift(n2) : s2.push(n2), (i2 = f1(e3)) > 0 && s2.length > i2 && !s2.warned) {
        s2.warned = !0;
        var a1 = new Error("Possible EventEmitter memory leak detected. " + s2.length + " " + String(t3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        a1.name = "MaxListenersExceededWarning", a1.emitter = e3, a1.type = t3, a1.count = s2.length, v2 = a1, console && console.warn && console.warn(v2);
    }
    return e3;
}

function a2() {
    if (!this.fired) {
        return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
}

function l1(e3, t3, n2) {
    var r2 = {
        fired: !1,
        wrapFn: void 0,
        target: e3,
        type: t3,
        listener: n2
    }, i2 = a2.bind(r2);
    return i2.listener = n2, r2.wrapFn = i2, i2;
}

function h1(e3, t3, n2) {
    var r2 = e3._events;
    if ((void 0) === r2) {
        return [];
    }
    var i2 = r2[t3];
    return (void 0) === i2 ? [] : "function" == typeof i2 ? n2 ? [
        i2.listener || i2
    ] : [
        i2
    ] : n2 ? (function (e4) {
        for (var t4 = new Array(e4.length), n3 = 0; n3 < t4.length; ++n3) {
            t4[n3] = e4[n3].listener || e4[n3];
        }
        return t4;
    })(i2) : c2(i2, i2.length);
}

function p1(e3) {
    var t3 = this._events;
    if ((void 0) !== t3) {
        var n2 = t3[e3];
        if ("function" == typeof n2) {
            return 1;
        }
        if ((void 0) !== n2) {
            return n2.length;
        }
    }
    return 0;
}

function c2(e3, t3) {
    for (var n3 = new Array(t3), r2 = 0; r2 < t3; ++r2) {
        n3[r2] = e3[r2];
    }
    return n3;
}

Object.defineProperty(o1, "defaultMaxListeners", {
    enumerable: !0,
    get: function () {
        return s1;
    },
    set: function (e3) {
        if ("number" != typeof e3 || e3 < 0 || i1(e3)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e3 + ".");
        }
        s1 = e3;
    }
}), o1.init = function () {
    (void 0) !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o1.prototype.setMaxListeners = function (e3) {
    if ("number" != typeof e3 || e3 < 0 || i1(e3)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e3 + ".");
    }
    return this._maxListeners = e3, this;
}, o1.prototype.getMaxListeners = function () {
    return f1(this);
}, o1.prototype.emit = function (e3) {
    for (var t3 = [], n3 = 1; n3 < arguments.length; n3++) {
        t3.push(arguments[n3]);
    }
    var i2 = "error" === e3, o2 = this._events;
    if ((void 0) !== o2) {
        i2 = i2 && (void 0) === o2.error;
    } else if (!i2) {
        return !1;
    }
    if (i2) {
        var s2;
        if (t3.length > 0 && (s2 = t3[0]), s2 instanceof Error) {
            throw s2;
        }
        var u2 = new Error("Unhandled error." + (s2 ? " (" + s2.message + ")" : ""));
        throw u2.context = s2, u2;
    }
    var f2 = o2[e3];
    if ((void 0) === f2) {
        return !1;
    }
    if ("function" == typeof f2) {
        r1(f2, this, t3);
    } else {
        var v1 = f2.length, a3 = c2(f2, v1);
        for (n3 = 0; n3 < v1; ++n3) {
            r1(a3[n3], this, t3);
        }
    }
    return !0;
}, o1.prototype.addListener = function (e3, t3) {
    return v2(this, e3, t3, !1);
}, o1.prototype.on = o1.prototype.addListener, o1.prototype.prependListener = function (e3, t3) {
    return v2(this, e3, t3, !0);
}, o1.prototype.once = function (e3, t3) {
    return u1(t3), this.on(e3, l1(this, e3, t3)), this;
}, o1.prototype.prependOnceListener = function (e3, t3) {
    return u1(t3), this.prependListener(e3, l1(this, e3, t3)), this;
}, o1.prototype.removeListener = function (e3, t3) {
    var n3, r2, i2, o2, s3;
    if (u1(t3), (void 0) === (r2 = this._events)) {
        return this;
    }
    if ((void 0) === (n3 = r2[e3])) {
        return this;
    }
    if (n3 === t3 || n3.listener === t3) {
        0 == --this._eventsCount ? this._events = Object.create(null) : (delete r2[e3], r2.removeListener && this.emit("removeListener", e3, n3.listener || t3));
    } else if ("function" != typeof n3) {
        for (i2 = -1, o2 = n3.length - 1; o2 >= 0; o2--) {
            if (n3[o2] === t3 || n3[o2].listener === t3) {
                s3 = n3[o2].listener, i2 = o2;
                break;
            }
        }
        if (i2 < 0) {
            return this;
        }
        0 === i2 ? n3.shift() : !function (e4, t4) {
            for (; t4 + 1 < e4.length; t4++) {
                e4[t4] = e4[t4 + 1];
            }
            e4.pop();
        }(n3, i2), 1 === n3.length && (r2[e3] = n3[0]), (void 0) !== r2.removeListener && this.emit("removeListener", e3, s3 || t3);
    }
    return this;
}, o1.prototype.off = o1.prototype.removeListener, o1.prototype.removeAllListeners = function (e3) {
    var t3, n3, r2;
    if ((void 0) === (n3 = this._events)) {
        return this;
    }
    if ((void 0) === n3.removeListener) {
        return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : (void 0) !== n3[e3] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n3[e3]), this;
    }
    if (0 === arguments.length) {
        var i2, o2 = Object.keys(n3);
        for (r2 = 0; r2 < o2.length; ++r2) {
            "removeListener" !== (i2 = o2[r2]) && this.removeAllListeners(i2);
        }
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
    }
    if ("function" == typeof (t3 = n3[e3])) {
        this.removeListener(e3, t3);
    } else if ((void 0) !== t3) {
        for (r2 = t3.length - 1; r2 >= 0; r2--) {
            this.removeListener(e3, t3[r2]);
        }
    }
    return this;
}, o1.prototype.listeners = function (e3) {
    return h1(this, e3, !0);
}, o1.prototype.rawListeners = function (e3) {
    return h1(this, e3, !1);
}, o1.listenerCount = function (e3, t3) {
    return "function" == typeof e3.listenerCount ? e3.listenerCount(t3) : p1.call(e3, t3);
}, o1.prototype.listenerCount = p1, o1.prototype.eventNames = function () {
    return this._eventsCount > 0 ? t2(this._events) : [];
};
var y1 = e2;
for (var r2 = {
    byteLength: function (r3) {
        var t3 = u4(r3), e3 = t3[0], n3 = t3[1];
        return 3 * (e3 + n3) / 4 - n3;
    },
    toByteArray: function (r3) {
        var t3, o3, a4 = u4(r3), h2 = a4[0], c3 = a4[1], d1 = new n4(function (r4, t4, e3) {
            return 3 * (t4 + e3) / 4 - e3;
        }(0, h2, c3)), f2 = 0, A = c3 > 0 ? h2 - 4 : h2;
        for (o3 = 0; o3 < A; o3 += 4) {
            t3 = e4[r3.charCodeAt(o3)] << 18 | e4[r3.charCodeAt(o3 + 1)] << 12 | e4[r3.charCodeAt(o3 + 2)] << 6 | e4[r3.charCodeAt(o3 + 3)], d1[f2++] = t3 >> 16 & 255, d1[f2++] = t3 >> 8 & 255, d1[f2++] = 255 & t3;
        }
        2 === c3 && (t3 = e4[r3.charCodeAt(o3)] << 2 | e4[r3.charCodeAt(o3 + 1)] >> 4, d1[f2++] = 255 & t3);
        1 === c3 && (t3 = e4[r3.charCodeAt(o3)] << 10 | e4[r3.charCodeAt(o3 + 1)] << 4 | e4[r3.charCodeAt(o3 + 2)] >> 2, d1[f2++] = t3 >> 8 & 255, d1[f2++] = 255 & t3);
        return d1;
    },
    fromByteArray: function (r3) {
        for (var e4, n4 = r3.length, o3 = n4 % 3, a4 = [], h2 = 0, u4 = n4 - o3; h2 < u4; h2 += 16383) {
            a4.push(c3(r3, h2, h2 + 16383 > u4 ? u4 : h2 + 16383));
        }
        1 === o3 ? (e4 = r3[n4 - 1], a4.push(t4[e4 >> 2] + t4[e4 << 4 & 63] + "==")) : 2 === o3 && (e4 = (r3[n4 - 2] << 8) + r3[n4 - 1], a4.push(t4[e4 >> 10] + t4[e4 >> 4 & 63] + t4[e4 << 2 & 63] + "="));
        return a4.join("");
    }
}, t4 = [], e4 = [], n4 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a4 = 0, h2 = o3.length; a4 < h2; ++a4) {
    t4[a4] = o3[a4], e4[o3.charCodeAt(a4)] = a4;
}

function u4(r3) {
    var t5 = r3.length;
    if (t5 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var e5 = r3.indexOf("=");
    return -1 === e5 && (e5 = t5), [
        e5,
        e5 === t5 ? 0 : 4 - e5 % 4
    ];
}

function c3(r3, e5, n5) {
    for (var o4, a5, h3 = [], u5 = e5; u5 < n5; u5 += 3) {
        o4 = (r3[u5] << 16 & 16711680) + (r3[u5 + 1] << 8 & 65280) + (255 & r3[u5 + 2]), h3.push(t4[(a5 = o4) >> 18 & 63] + t4[a5 >> 12 & 63] + t4[a5 >> 6 & 63] + t4[63 & a5]);
    }
    return h3.join("");
}

e4["-".charCodeAt(0)] = 62, e4["_".charCodeAt(0)] = 63;
var a$1 = {
    read: function (a5, t5, o4, r3, h3) {
        var M, f2, p2 = 8 * h3 - r3 - 1, w = (1 << p2) - 1, e5 = w >> 1, i3 = -7, N = o4 ? h3 - 1 : 0, n5 = o4 ? -1 : 1,
                u5 = a5[t5 + N];
        for ((N += n5, M = u5 & (1 << -i3) - 1, u5 >>= -i3, i3 += p2); i3 > 0; (M = 256 * M + a5[t5 + N], N += n5, i3 -= 8)) {
            ;
        }
        for ((f2 = M & (1 << -i3) - 1, M >>= -i3, i3 += r3); i3 > 0; (f2 = 256 * f2 + a5[t5 + N], N += n5, i3 -= 8)) {
            ;
        }
        if (0 === M) {
            M = 1 - e5;
        } else {
            if (M === w) {
                return f2 ? NaN : 1 / 0 * (u5 ? -1 : 1);
            }
            f2 += Math.pow(2, r3), M -= e5;
        }
        return (u5 ? -1 : 1) * f2 * Math.pow(2, M - r3);
    },
    write: function (a5, t5, o4, r3, h3, M) {
        var f2, p2, w, e5 = 8 * M - h3 - 1, i3 = (1 << e5) - 1, N = i3 >> 1,
                n5 = 23 === h3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u5 = r3 ? 0 : M - 1, l2 = r3 ? 1 : -1,
                s3 = t5 < 0 || 0 === t5 && 1 / t5 < 0 ? 1 : 0;
        for ((t5 = Math.abs(t5), isNaN(t5) || t5 === 1 / 0 ? (p2 = isNaN(t5) ? 1 : 0, f2 = i3) : (f2 = Math.floor(Math.log(t5) / Math.LN2), t5 * (w = Math.pow(2, -f2)) < 1 && (f2--, w *= 2), (t5 += f2 + N >= 1 ? n5 / w : n5 * Math.pow(2, 1 - N)) * w >= 2 && (f2++, w /= 2), f2 + N >= i3 ? (p2 = 0, f2 = i3) : f2 + N >= 1 ? (p2 = (t5 * w - 1) * Math.pow(2, h3), f2 += N) : (p2 = t5 * Math.pow(2, N - 1) * Math.pow(2, h3), f2 = 0))); h3 >= 8; (a5[o4 + u5] = 255 & p2, u5 += l2, p2 /= 256, h3 -= 8)) {
            ;
        }
        for ((f2 = f2 << h3 | p2, e5 += h3); e5 > 0; (a5[o4 + u5] = 255 & f2, u5 += l2, f2 /= 256, e5 -= 8)) {
            ;
        }
        a5[o4 + u5 - l2] |= 128 * s3;
    }
};
var e$1 = {}, n$13 = r2, i3 = a$1,
        o$13 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
e$1.Buffer = u$13, e$1.SlowBuffer = function (t5) {
    +t5 != t5 && (t5 = 0);
    return u$13.alloc(+t5);
}, e$1.INSPECT_MAX_BYTES = 50;

function f2(t5) {
    if (t5 > 2147483647) {
        throw new RangeError('The value "' + t5 + '" is invalid for option "size"');
    }
    var r3 = new Uint8Array(t5);
    return Object.setPrototypeOf(r3, u$13.prototype), r3;
}

function u$13(t5, r3, e5) {
    if ("number" == typeof t5) {
        if ("string" == typeof r3) {
            throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return a$2(t5);
    }
    return s4(t5, r3, e5);
}

function s4(t5, r3, e5) {
    if ("string" == typeof t5) {
        return (function (t6, r4) {
            "string" == typeof r4 && "" !== r4 || (r4 = "utf8");
            if (!u$13.isEncoding(r4)) {
                throw new TypeError("Unknown encoding: " + r4);
            }
            var e6 = 0 | y2(t6, r4), n5 = f2(e6), i4 = n5.write(t6, r4);
            i4 !== e6 && (n5 = n5.slice(0, i4));
            return n5;
        })(t5, r3);
    }
    if (ArrayBuffer.isView(t5)) {
        return p3(t5);
    }
    if (null == t5) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t5);
    }
    if (F1(t5, ArrayBuffer) || t5 && F1(t5.buffer, ArrayBuffer)) {
        return c$1(t5, r3, e5);
    }
    if ("undefined" != typeof SharedArrayBuffer && (F1(t5, SharedArrayBuffer) || t5 && F1(t5.buffer, SharedArrayBuffer))) {
        return c$1(t5, r3, e5);
    }
    if ("number" == typeof t5) {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var n5 = t5.valueOf && t5.valueOf();
    if (null != n5 && n5 !== t5) {
        return u$13.from(n5, r3, e5);
    }
    var i4 = function (t6) {
        if (u$13.isBuffer(t6)) {
            var r4 = 0 | l3(t6.length), e6 = f2(r4);
            return 0 === e6.length || t6.copy(e6, 0, 0, r4), e6;
        }
        if ((void 0) !== t6.length) {
            return "number" != typeof t6.length || N2(t6.length) ? f2(0) : p3(t6);
        }
        if ("Buffer" === t6.type && Array.isArray(t6.data)) {
            return p3(t6.data);
        }
    }(t5);
    if (i4) {
        return i4;
    }
    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t5[Symbol.toPrimitive]) {
        return u$13.from(t5[Symbol.toPrimitive]("string"), r3, e5);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t5);
}

function h$1(t5) {
    if ("number" != typeof t5) {
        throw new TypeError('"size" argument must be of type number');
    }
    if (t5 < 0) {
        throw new RangeError('The value "' + t5 + '" is invalid for option "size"');
    }
}

function a$2(t5) {
    return h$1(t5), f2(t5 < 0 ? 0 : 0 | l3(t5));
}

function p3(t5) {
    for (var r3 = t5.length < 0 ? 0 : 0 | l3(t5.length), e5 = f2(r3), n5 = 0; n5 < r3; n5 += 1) {
        e5[n5] = 255 & t5[n5];
    }
    return e5;
}

function c$1(t5, r3, e5) {
    if (r3 < 0 || t5.byteLength < r3) {
        throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (t5.byteLength < r3 + (e5 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
    }
    var n5;
    return n5 = (void 0) === r3 && (void 0) === e5 ? new Uint8Array(t5) : (void 0) === e5 ? new Uint8Array(t5, r3) : new Uint8Array(t5, r3, e5), Object.setPrototypeOf(n5, u$13.prototype), n5;
}

function l3(t5) {
    if (t5 >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return 0 | t5;
}

function y2(t5, r3) {
    if (u$13.isBuffer(t5)) {
        return t5.length;
    }
    if (ArrayBuffer.isView(t5) || F1(t5, ArrayBuffer)) {
        return t5.byteLength;
    }
    if ("string" != typeof t5) {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t5);
    }
    var e5 = t5.length, n5 = arguments.length > 2 && !0 === arguments[2];
    if (!n5 && 0 === e5) {
        return 0;
    }
    for (var i4 = !1; ;) {
        switch (r3) {
            case "ascii":
            case "latin1":
            case "binary":
                return e5;
            case "utf8":
            case "utf-8":
                return _4(t5).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return 2 * e5;
            case "hex":
                return e5 >>> 1;
            case "base64":
                return z1(t5).length;
            default:
                if (i4) {
                    return n5 ? -1 : _4(t5).length;
                }
                r3 = ("" + r3).toLowerCase(), i4 = !0;
        }
    }
}

function g3(t5, r3, e5) {
    var n5 = !1;
    if (((void 0) === r3 || r3 < 0) && (r3 = 0), r3 > this.length) {
        return "";
    }
    if (((void 0) === e5 || e5 > this.length) && (e5 = this.length), e5 <= 0) {
        return "";
    }
    if ((e5 >>>= 0) <= (r3 >>>= 0)) {
        return "";
    }
    for (t5 || (t5 = "utf8"); ;) {
        switch (t5) {
            case "hex":
                return O(this, r3, e5);
            case "utf8":
            case "utf-8":
                return I1(this, r3, e5);
            case "ascii":
                return S(this, r3, e5);
            case "latin1":
            case "binary":
                return R(this, r3, e5);
            case "base64":
                return T2(this, r3, e5);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return L4(this, r3, e5);
            default:
                if (n5) {
                    throw new TypeError("Unknown encoding: " + t5);
                }
                t5 = (t5 + "").toLowerCase(), n5 = !0;
        }
    }
}

function w(t5, r3, e5) {
    var n5 = t5[r3];
    t5[r3] = t5[e5], t5[e5] = n5;
}

function d1(t5, r3, e5, n5, i4) {
    if (0 === t5.length) {
        return -1;
    }
    if ("string" == typeof e5 ? (n5 = e5, e5 = 0) : e5 > 2147483647 ? e5 = 2147483647 : e5 < -2147483648 && (e5 = -2147483648), N2(e5 = +e5) && (e5 = i4 ? 0 : t5.length - 1), e5 < 0 && (e5 = t5.length + e5), e5 >= t5.length) {
        if (i4) {
            return -1;
        }
        e5 = t5.length - 1;
    } else if (e5 < 0) {
        if (!i4) {
            return -1;
        }
        e5 = 0;
    }
    if ("string" == typeof r3 && (r3 = u$13.from(r3, n5)), u$13.isBuffer(r3)) {
        return 0 === r3.length ? -1 : v3(t5, r3, e5, n5, i4);
    }
    if ("number" == typeof r3) {
        return r3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i4 ? Uint8Array.prototype.indexOf.call(t5, r3, e5) : Uint8Array.prototype.lastIndexOf.call(t5, r3, e5) : v3(t5, [
            r3
        ], e5, n5, i4);
    }
    throw new TypeError("val must be string, number or Buffer");
}

function v3(t5, r3, e5, n5, i4) {
    var o4, f3 = 1, u5 = t5.length, s5 = r3.length;
    if ((void 0) !== n5 && ("ucs2" === (n5 = String(n5).toLowerCase()) || "ucs-2" === n5 || "utf16le" === n5 || "utf-16le" === n5)) {
        if (t5.length < 2 || r3.length < 2) {
            return -1;
        }
        f3 = 2, u5 /= 2, s5 /= 2, e5 /= 2;
    }

    function h3(t6, r5) {
        return 1 === f3 ? t6[r5] : t6.readUInt16BE(r5 * f3);
    }

    if (i4) {
        var a5 = -1;
        for (o4 = e5; o4 < u5; o4++) {
            if (h3(t5, o4) === h3(r3, -1 === a5 ? 0 : o4 - a5)) {
                if (-1 === a5 && (a5 = o4), o4 - a5 + 1 === s5) {
                    return a5 * f3;
                }
            } else {
                -1 !== a5 && (o4 -= o4 - a5), a5 = -1;
            }
        }
    } else {
        for (e5 + s5 > u5 && (e5 = u5 - s5), o4 = e5; o4 >= 0; o4--) {
            for (var p4 = !0, c4 = 0; c4 < s5; c4++) {
                if (h3(t5, o4 + c4) !== h3(r3, c4)) {
                    p4 = !1;
                    break;
                }
            }
            if (p4) {
                return o4;
            }
        }
    }
    return -1;
}

function b8(t5, r3, e5, n5) {
    e5 = Number(e5) || 0;
    var i4 = t5.length - e5;
    n5 ? (n5 = Number(n5)) > i4 && (n5 = i4) : n5 = i4;
    var o4 = r3.length;
    n5 > o4 / 2 && (n5 = o4 / 2);
    for (var f3 = 0; f3 < n5; ++f3) {
        var u5 = parseInt(r3.substr(2 * f3, 2), 16);
        if (N2(u5)) {
            return f3;
        }
        t5[e5 + f3] = u5;
    }
    return f3;
}

function m1(t5, r3, e5, n5) {
    return D1(_4(r3, t5.length - e5), t5, e5, n5);
}

function E1(t5, r3, e5, n5) {
    return D1(function (t6) {
        for (var r5 = [], e7 = 0; e7 < t6.length; ++e7) {
            r5.push(255 & t6.charCodeAt(e7));
        }
        return r5;
    }(r3), t5, e5, n5);
}

function B1(t5, r3, e5, n5) {
    return E1(t5, r3, e5, n5);
}

function A(t5, r3, e5, n5) {
    return D1(z1(r3), t5, e5, n5);
}

function U1(t5, r3, e5, n5) {
    return D1(function (t6, r5) {
        for (var e7, n6, i4, o4 = [], f3 = 0; f3 < t6.length && !((r5 -= 2) < 0); ++f3) {
            e7 = t6.charCodeAt(f3), n6 = e7 >> 8, i4 = e7 % 256, o4.push(i4), o4.push(n6);
        }
        return o4;
    }(r3, t5.length - e5), t5, e5, n5);
}

function T2(t5, r3, e5) {
    return 0 === r3 && e5 === t5.length ? n$13.fromByteArray(t5) : n$13.fromByteArray(t5.slice(r3, e5));
}

function I1(t5, r3, e5) {
    e5 = Math.min(t5.length, e5);
    for (var n5 = [], i4 = r3; i4 < e5;) {
        var o4, f3, u6, s5, h3 = t5[i4], a6 = null, p5 = h3 > 239 ? 4 : h3 > 223 ? 3 : h3 > 191 ? 2 : 1;
        if (i4 + p5 <= e5) {
            switch (p5) {
                case 1:
                    h3 < 128 && (a6 = h3);
                    break;
                case 2:
                    128 == (192 & (o4 = t5[i4 + 1])) && (s5 = (31 & h3) << 6 | 63 & o4) > 127 && (a6 = s5);
                    break;
                case 3:
                    o4 = t5[i4 + 1], f3 = t5[i4 + 2], 128 == (192 & o4) && 128 == (192 & f3) && (s5 = (15 & h3) << 12 | (63 & o4) << 6 | 63 & f3) > 2047 && (s5 < 55296 || s5 > 57343) && (a6 = s5);
                    break;
                case 4:
                    o4 = t5[i4 + 1], f3 = t5[i4 + 2], u6 = t5[i4 + 3], 128 == (192 & o4) && 128 == (192 & f3) && 128 == (192 & u6) && (s5 = (15 & h3) << 18 | (63 & o4) << 12 | (63 & f3) << 6 | 63 & u6) > 65535 && s5 < 1114112 && (a6 = s5);
            }
        }
        null === a6 ? (a6 = 65533, p5 = 1) : a6 > 65535 && (a6 -= 65536, n5.push(a6 >>> 10 & 1023 | 55296), a6 = 56320 | 1023 & a6), n5.push(a6), i4 += p5;
    }
    return (function (t6) {
        var r5 = t6.length;
        if (r5 <= 4096) {
            return String.fromCharCode.apply(String, t6);
        }
        var e7 = "", n6 = 0;
        for (; n6 < r5;) {
            e7 += String.fromCharCode.apply(String, t6.slice(n6, n6 += 4096));
        }
        return e7;
    })(n5);
}

e$1.kMaxLength = 2147483647, u$13.TYPED_ARRAY_SUPPORT = (function () {
    try {
        var t5 = new Uint8Array(1), r3 = {
            foo: function () {
                return 42;
            }
        };
        return Object.setPrototypeOf(r3, Uint8Array.prototype), Object.setPrototypeOf(t5, r3), 42 === t5.foo();
    } catch (t6) {
        return !1;
    }
})(), u$13.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$13.prototype, "parent", {
    enumerable: !0,
    get: function () {
        if (u$13.isBuffer(this)) {
            return this.buffer;
        }
    }
}), Object.defineProperty(u$13.prototype, "offset", {
    enumerable: !0,
    get: function () {
        if (u$13.isBuffer(this)) {
            return this.byteOffset;
        }
    }
}), u$13.poolSize = 8192, u$13.from = function (t5, r3, e5) {
    return s4(t5, r3, e5);
}, Object.setPrototypeOf(u$13.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$13, Uint8Array), u$13.alloc = function (t5, r3, e5) {
    return (function (t6, r5, e7) {
        return h$1(t6), t6 <= 0 ? f2(t6) : (void 0) !== r5 ? "string" == typeof e7 ? f2(t6).fill(r5, e7) : f2(t6).fill(r5) : f2(t6);
    })(t5, r3, e5);
}, u$13.allocUnsafe = function (t5) {
    return a$2(t5);
}, u$13.allocUnsafeSlow = function (t5) {
    return a$2(t5);
}, u$13.isBuffer = function (t5) {
    return null != t5 && !0 === t5._isBuffer && t5 !== u$13.prototype;
}, u$13.compare = function (t5, r3) {
    if (F1(t5, Uint8Array) && (t5 = u$13.from(t5, t5.offset, t5.byteLength)), F1(r3, Uint8Array) && (r3 = u$13.from(r3, r3.offset, r3.byteLength)), !u$13.isBuffer(t5) || !u$13.isBuffer(r3)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (t5 === r3) {
        return 0;
    }
    for (var e5 = t5.length, n5 = r3.length, i4 = 0, o5 = Math.min(e5, n5); i4 < o5; ++i4) {
        if (t5[i4] !== r3[i4]) {
            e5 = t5[i4], n5 = r3[i4];
            break;
        }
    }
    return e5 < n5 ? -1 : n5 < e5 ? 1 : 0;
}, u$13.isEncoding = function (t5) {
    switch (String(t5).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1;
    }
}, u$13.concat = function (t5, r3) {
    if (!Array.isArray(t5)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (0 === t5.length) {
        return u$13.alloc(0);
    }
    var e5;
    if ((void 0) === r3) {
        for (r3 = 0, e5 = 0; e5 < t5.length; ++e5) {
            r3 += t5[e5].length;
        }
    }
    var n5 = u$13.allocUnsafe(r3), i4 = 0;
    for (e5 = 0; e5 < t5.length; ++e5) {
        var o5 = t5[e5];
        if (F1(o5, Uint8Array) && (o5 = u$13.from(o5)), !u$13.isBuffer(o5)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
        }
        o5.copy(n5, i4), i4 += o5.length;
    }
    return n5;
}, u$13.byteLength = y2, u$13.prototype._isBuffer = !0, u$13.prototype.swap16 = function () {
    var t5 = this.length;
    if (t5 % 2 != 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var r3 = 0; r3 < t5; r3 += 2) {
        w(this, r3, r3 + 1);
    }
    return this;
}, u$13.prototype.swap32 = function () {
    var t5 = this.length;
    if (t5 % 4 != 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var r3 = 0; r3 < t5; r3 += 4) {
        w(this, r3, r3 + 3), w(this, r3 + 1, r3 + 2);
    }
    return this;
}, u$13.prototype.swap64 = function () {
    var t5 = this.length;
    if (t5 % 8 != 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var r3 = 0; r3 < t5; r3 += 8) {
        w(this, r3, r3 + 7), w(this, r3 + 1, r3 + 6), w(this, r3 + 2, r3 + 5), w(this, r3 + 3, r3 + 4);
    }
    return this;
}, u$13.prototype.toString = function () {
    var t5 = this.length;
    return 0 === t5 ? "" : 0 === arguments.length ? I1(this, 0, t5) : g3.apply(this, arguments);
}, u$13.prototype.toLocaleString = u$13.prototype.toString, u$13.prototype.equals = function (t5) {
    if (!u$13.isBuffer(t5)) {
        throw new TypeError("Argument must be a Buffer");
    }
    return this === t5 || 0 === u$13.compare(this, t5);
}, u$13.prototype.inspect = function () {
    var t5 = "", r3 = e$1.INSPECT_MAX_BYTES;
    return t5 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (t5 += " ... "), "<Buffer " + t5 + ">";
}, o$13 && (u$13.prototype[o$13] = u$13.prototype.inspect), u$13.prototype.compare = function (t5, r3, e5, n5, i4) {
    if (F1(t5, Uint8Array) && (t5 = u$13.from(t5, t5.offset, t5.byteLength)), !u$13.isBuffer(t5)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t5);
    }
    if ((void 0) === r3 && (r3 = 0), (void 0) === e5 && (e5 = t5 ? t5.length : 0), (void 0) === n5 && (n5 = 0), (void 0) === i4 && (i4 = this.length), r3 < 0 || e5 > t5.length || n5 < 0 || i4 > this.length) {
        throw new RangeError("out of range index");
    }
    if (n5 >= i4 && r3 >= e5) {
        return 0;
    }
    if (n5 >= i4) {
        return -1;
    }
    if (r3 >= e5) {
        return 1;
    }
    if (this === t5) {
        return 0;
    }
    for (var o6 = (i4 >>>= 0) - (n5 >>>= 0), f4 = (e5 >>>= 0) - (r3 >>>= 0), s6 = Math.min(o6, f4), h4 = this.slice(n5, i4), a7 = t5.slice(r3, e5), p6 = 0; p6 < s6; ++p6) {
        if (h4[p6] !== a7[p6]) {
            o6 = h4[p6], f4 = a7[p6];
            break;
        }
    }
    return o6 < f4 ? -1 : f4 < o6 ? 1 : 0;
}, u$13.prototype.includes = function (t5, r3, e5) {
    return -1 !== this.indexOf(t5, r3, e5);
}, u$13.prototype.indexOf = function (t5, r3, e5) {
    return d1(this, t5, r3, e5, !0);
}, u$13.prototype.lastIndexOf = function (t5, r3, e5) {
    return d1(this, t5, r3, e5, !1);
}, u$13.prototype.write = function (t5, r3, e5, n5) {
    if ((void 0) === r3) {
        n5 = "utf8", e5 = this.length, r3 = 0;
    } else if ((void 0) === e5 && "string" == typeof r3) {
        n5 = r3, e5 = this.length, r3 = 0;
    } else {
        if (!isFinite(r3)) {
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }
        r3 >>>= 0, isFinite(e5) ? (e5 >>>= 0, (void 0) === n5 && (n5 = "utf8")) : (n5 = e5, e5 = void 0);
    }
    var i4 = this.length - r3;
    if (((void 0) === e5 || e5 > i4) && (e5 = i4), t5.length > 0 && (e5 < 0 || r3 < 0) || r3 > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
    }
    n5 || (n5 = "utf8");
    for (var o6 = !1; ;) {
        switch (n5) {
            case "hex":
                return b8(this, t5, r3, e5);
            case "utf8":
            case "utf-8":
                return m1(this, t5, r3, e5);
            case "ascii":
                return E1(this, t5, r3, e5);
            case "latin1":
            case "binary":
                return B1(this, t5, r3, e5);
            case "base64":
                return A(this, t5, r3, e5);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return U1(this, t5, r3, e5);
            default:
                if (o6) {
                    throw new TypeError("Unknown encoding: " + n5);
                }
                n5 = ("" + n5).toLowerCase(), o6 = !0;
        }
    }
}, u$13.prototype.toJSON = function () {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};

function S(t5, r3, e5) {
    var n5 = "";
    e5 = Math.min(t5.length, e5);
    for (var i4 = r3; i4 < e5; ++i4) {
        n5 += String.fromCharCode(127 & t5[i4]);
    }
    return n5;
}

function R(t5, r3, e5) {
    var n5 = "";
    e5 = Math.min(t5.length, e5);
    for (var i4 = r3; i4 < e5; ++i4) {
        n5 += String.fromCharCode(t5[i4]);
    }
    return n5;
}

function O(t5, r3, e5) {
    var n5 = t5.length;
    (!r3 || r3 < 0) && (r3 = 0), (!e5 || e5 < 0 || e5 > n5) && (e5 = n5);
    for (var i4 = "", o6 = r3; o6 < e5; ++o6) {
        i4 += Y[t5[o6]];
    }
    return i4;
}

function L4(t5, r3, e5) {
    for (var n5 = t5.slice(r3, e5), i4 = "", o6 = 0; o6 < n5.length; o6 += 2) {
        i4 += String.fromCharCode(n5[o6] + 256 * n5[o6 + 1]);
    }
    return i4;
}

function x1(t5, r3, e5) {
    if (t5 % 1 != 0 || t5 < 0) {
        throw new RangeError("offset is not uint");
    }
    if (t5 + r3 > e5) {
        throw new RangeError("Trying to access beyond buffer length");
    }
}

function C2(t5, r3, e5, n5, i4, o6) {
    if (!u$13.isBuffer(t5)) {
        throw new TypeError('"buffer" argument must be a Buffer instance');
    }
    if (r3 > i4 || r3 < o6) {
        throw new RangeError('"value" argument is out of bounds');
    }
    if (e5 + n5 > t5.length) {
        throw new RangeError("Index out of range");
    }
}

function P1(t5, r3, e5, n5, i4, o6) {
    if (e5 + n5 > t5.length) {
        throw new RangeError("Index out of range");
    }
    if (e5 < 0) {
        throw new RangeError("Index out of range");
    }
}

function k1(t5, r3, e5, n5, o6) {
    return r3 = +r3, e5 >>>= 0, o6 || P1(t5, 0, e5, 4), i3.write(t5, r3, e5, n5, 23, 4), e5 + 4;
}

function M1(t5, r3, e5, n5, o6) {
    return r3 = +r3, e5 >>>= 0, o6 || P1(t5, 0, e5, 8), i3.write(t5, r3, e5, n5, 52, 8), e5 + 8;
}

u$13.prototype.slice = function (t5, r3) {
    var e5 = this.length;
    (t5 = ~~t5) < 0 ? (t5 += e5) < 0 && (t5 = 0) : t5 > e5 && (t5 = e5), (r3 = (void 0) === r3 ? e5 : ~~r3) < 0 ? (r3 += e5) < 0 && (r3 = 0) : r3 > e5 && (r3 = e5), r3 < t5 && (r3 = t5);
    var n5 = this.subarray(t5, r3);
    return Object.setPrototypeOf(n5, u$13.prototype), n5;
}, u$13.prototype.readUIntLE = function (t5, r3, e5) {
    t5 >>>= 0, r3 >>>= 0, e5 || x1(t5, r3, this.length);
    for (var n5 = this[t5], i4 = 1, o6 = 0; (++o6) < r3 && (i4 *= 256);) {
        n5 += this[t5 + o6] * i4;
    }
    return n5;
}, u$13.prototype.readUIntBE = function (t5, r3, e5) {
    t5 >>>= 0, r3 >>>= 0, e5 || x1(t5, r3, this.length);
    for (var n5 = this[t5 + --r3], i4 = 1; r3 > 0 && (i4 *= 256);) {
        n5 += this[t5 + --r3] * i4;
    }
    return n5;
}, u$13.prototype.readUInt8 = function (t5, r3) {
    return t5 >>>= 0, r3 || x1(t5, 1, this.length), this[t5];
}, u$13.prototype.readUInt16LE = function (t5, r3) {
    return t5 >>>= 0, r3 || x1(t5, 2, this.length), this[t5] | this[t5 + 1] << 8;
}, u$13.prototype.readUInt16BE = function (t5, r3) {
    return t5 >>>= 0, r3 || x1(t5, 2, this.length), this[t5] << 8 | this[t5 + 1];
}, u$13.prototype.readUInt32LE = function (t5, r3) {
    return t5 >>>= 0, r3 || x1(t5, 4, this.length), (this[t5] | this[t5 + 1] << 8 | this[t5 + 2] << 16) + 16777216 * this[t5 + 3];
}, u$13.prototype.readUInt32BE = function (t5, r3) {
    return t5 >>>= 0, r3 || x1(t5, 4, this.length), 16777216 * this[t5] + (this[t5 + 1] << 16 | this[t5 + 2] << 8 | this[t5 + 3]);
}, u$13.prototype.readIntLE = function (t5, r3, e5) {
    t5 >>>= 0, r3 >>>= 0, e5 || x1(t5, r3, this.length);
    for (var n5 = this[t5], i4 = 1, o6 = 0; (++o6) < r3 && (i4 *= 256);) {
        n5 += this[t5 + o6] * i4;
    }
    return n5 >= (i4 *= 128) && (n5 -= Math.pow(2, 8 * r3)), n5;
}, u$13.prototype.readIntBE = function (t5, r3, e5) {
    t5 >>>= 0, r3 >>>= 0, e5 || x1(t5, r3, this.length);
    for (var n5 = r3, i4 = 1, o6 = this[t5 + --n5]; n5 > 0 && (i4 *= 256);) {
        o6 += this[t5 + --n5] * i4;
    }
    return o6 >= (i4 *= 128) && (o6 -= Math.pow(2, 8 * r3)), o6;
}, u$13.prototype.readInt8 = function (t5, r3) {
    return t5 >>>= 0, r3 || x1(t5, 1, this.length), 128 & this[t5] ? -1 * (255 - this[t5] + 1) : this[t5];
}, u$13.prototype.readInt16LE = function (t5, r3) {
    t5 >>>= 0, r3 || x1(t5, 2, this.length);
    var e5 = this[t5] | this[t5 + 1] << 8;
    return 32768 & e5 ? 4294901760 | e5 : e5;
}, u$13.prototype.readInt16BE = function (t5, r3) {
    t5 >>>= 0, r3 || x1(t5, 2, this.length);
    var e5 = this[t5 + 1] | this[t5] << 8;
    return 32768 & e5 ? 4294901760 | e5 : e5;
}, u$13.prototype.readInt32LE = function (t5, r3) {
    return t5 >>>= 0, r3 || x1(t5, 4, this.length), this[t5] | this[t5 + 1] << 8 | this[t5 + 2] << 16 | this[t5 + 3] << 24;
}, u$13.prototype.readInt32BE = function (t5, r3) {
    return t5 >>>= 0, r3 || x1(t5, 4, this.length), this[t5] << 24 | this[t5 + 1] << 16 | this[t5 + 2] << 8 | this[t5 + 3];
}, u$13.prototype.readFloatLE = function (t5, r3) {
    return t5 >>>= 0, r3 || x1(t5, 4, this.length), i3.read(this, t5, !0, 23, 4);
}, u$13.prototype.readFloatBE = function (t5, r3) {
    return t5 >>>= 0, r3 || x1(t5, 4, this.length), i3.read(this, t5, !1, 23, 4);
}, u$13.prototype.readDoubleLE = function (t5, r3) {
    return t5 >>>= 0, r3 || x1(t5, 8, this.length), i3.read(this, t5, !0, 52, 8);
}, u$13.prototype.readDoubleBE = function (t5, r3) {
    return t5 >>>= 0, r3 || x1(t5, 8, this.length), i3.read(this, t5, !1, 52, 8);
}, u$13.prototype.writeUIntLE = function (t5, r3, e5, n5) {
    (t5 = +t5, r3 >>>= 0, e5 >>>= 0, n5) || C2(this, t5, r3, e5, Math.pow(2, 8 * e5) - 1, 0);
    var i4 = 1, o6 = 0;
    for (this[r3] = 255 & t5; (++o6) < e5 && (i4 *= 256);) {
        this[r3 + o6] = t5 / i4 & 255;
    }
    return r3 + e5;
}, u$13.prototype.writeUIntBE = function (t5, r3, e5, n5) {
    (t5 = +t5, r3 >>>= 0, e5 >>>= 0, n5) || C2(this, t5, r3, e5, Math.pow(2, 8 * e5) - 1, 0);
    var i4 = e5 - 1, o6 = 1;
    for (this[r3 + i4] = 255 & t5; (--i4) >= 0 && (o6 *= 256);) {
        this[r3 + i4] = t5 / o6 & 255;
    }
    return r3 + e5;
}, u$13.prototype.writeUInt8 = function (t5, r3, e5) {
    return t5 = +t5, r3 >>>= 0, e5 || C2(this, t5, r3, 1, 255, 0), this[r3] = 255 & t5, r3 + 1;
}, u$13.prototype.writeUInt16LE = function (t5, r3, e5) {
    return t5 = +t5, r3 >>>= 0, e5 || C2(this, t5, r3, 2, 65535, 0), this[r3] = 255 & t5, this[r3 + 1] = t5 >>> 8, r3 + 2;
}, u$13.prototype.writeUInt16BE = function (t5, r3, e5) {
    return t5 = +t5, r3 >>>= 0, e5 || C2(this, t5, r3, 2, 65535, 0), this[r3] = t5 >>> 8, this[r3 + 1] = 255 & t5, r3 + 2;
}, u$13.prototype.writeUInt32LE = function (t5, r3, e5) {
    return t5 = +t5, r3 >>>= 0, e5 || C2(this, t5, r3, 4, 4294967295, 0), this[r3 + 3] = t5 >>> 24, this[r3 + 2] = t5 >>> 16, this[r3 + 1] = t5 >>> 8, this[r3] = 255 & t5, r3 + 4;
}, u$13.prototype.writeUInt32BE = function (t5, r3, e5) {
    return t5 = +t5, r3 >>>= 0, e5 || C2(this, t5, r3, 4, 4294967295, 0), this[r3] = t5 >>> 24, this[r3 + 1] = t5 >>> 16, this[r3 + 2] = t5 >>> 8, this[r3 + 3] = 255 & t5, r3 + 4;
}, u$13.prototype.writeIntLE = function (t5, r3, e5, n5) {
    if (t5 = +t5, r3 >>>= 0, !n5) {
        var i4 = Math.pow(2, 8 * e5 - 1);
        C2(this, t5, r3, e5, i4 - 1, -i4);
    }
    var o6 = 0, f4 = 1, u7 = 0;
    for (this[r3] = 255 & t5; (++o6) < e5 && (f4 *= 256);) {
        t5 < 0 && 0 === u7 && 0 !== this[r3 + o6 - 1] && (u7 = 1), this[r3 + o6] = (t5 / f4 >> 0) - u7 & 255;
    }
    return r3 + e5;
}, u$13.prototype.writeIntBE = function (t5, r3, e5, n5) {
    if (t5 = +t5, r3 >>>= 0, !n5) {
        var i5 = Math.pow(2, 8 * e5 - 1);
        C2(this, t5, r3, e5, i5 - 1, -i5);
    }
    var o6 = e5 - 1, f4 = 1, u7 = 0;
    for (this[r3 + o6] = 255 & t5; (--o6) >= 0 && (f4 *= 256);) {
        t5 < 0 && 0 === u7 && 0 !== this[r3 + o6 + 1] && (u7 = 1), this[r3 + o6] = (t5 / f4 >> 0) - u7 & 255;
    }
    return r3 + e5;
}, u$13.prototype.writeInt8 = function (t5, r3, e5) {
    return t5 = +t5, r3 >>>= 0, e5 || C2(this, t5, r3, 1, 127, -128), t5 < 0 && (t5 = 255 + t5 + 1), this[r3] = 255 & t5, r3 + 1;
}, u$13.prototype.writeInt16LE = function (t5, r3, e5) {
    return t5 = +t5, r3 >>>= 0, e5 || C2(this, t5, r3, 2, 32767, -32768), this[r3] = 255 & t5, this[r3 + 1] = t5 >>> 8, r3 + 2;
}, u$13.prototype.writeInt16BE = function (t5, r3, e5) {
    return t5 = +t5, r3 >>>= 0, e5 || C2(this, t5, r3, 2, 32767, -32768), this[r3] = t5 >>> 8, this[r3 + 1] = 255 & t5, r3 + 2;
}, u$13.prototype.writeInt32LE = function (t5, r3, e5) {
    return t5 = +t5, r3 >>>= 0, e5 || C2(this, t5, r3, 4, 2147483647, -2147483648), this[r3] = 255 & t5, this[r3 + 1] = t5 >>> 8, this[r3 + 2] = t5 >>> 16, this[r3 + 3] = t5 >>> 24, r3 + 4;
}, u$13.prototype.writeInt32BE = function (t5, r3, e5) {
    return t5 = +t5, r3 >>>= 0, e5 || C2(this, t5, r3, 4, 2147483647, -2147483648), t5 < 0 && (t5 = 4294967295 + t5 + 1), this[r3] = t5 >>> 24, this[r3 + 1] = t5 >>> 16, this[r3 + 2] = t5 >>> 8, this[r3 + 3] = 255 & t5, r3 + 4;
}, u$13.prototype.writeFloatLE = function (t5, r3, e5) {
    return k1(this, t5, r3, !0, e5);
}, u$13.prototype.writeFloatBE = function (t5, r3, e5) {
    return k1(this, t5, r3, !1, e5);
}, u$13.prototype.writeDoubleLE = function (t5, r3, e5) {
    return M1(this, t5, r3, !0, e5);
}, u$13.prototype.writeDoubleBE = function (t5, r3, e5) {
    return M1(this, t5, r3, !1, e5);
}, u$13.prototype.copy = function (t5, r3, e5, n5) {
    if (!u$13.isBuffer(t5)) {
        throw new TypeError("argument should be a Buffer");
    }
    if (e5 || (e5 = 0), n5 || 0 === n5 || (n5 = this.length), r3 >= t5.length && (r3 = t5.length), r3 || (r3 = 0), n5 > 0 && n5 < e5 && (n5 = e5), n5 === e5) {
        return 0;
    }
    if (0 === t5.length || 0 === this.length) {
        return 0;
    }
    if (r3 < 0) {
        throw new RangeError("targetStart out of bounds");
    }
    if (e5 < 0 || e5 >= this.length) {
        throw new RangeError("Index out of range");
    }
    if (n5 < 0) {
        throw new RangeError("sourceEnd out of bounds");
    }
    n5 > this.length && (n5 = this.length), t5.length - r3 < n5 - e5 && (n5 = t5.length - r3 + e5);
    var i6 = n5 - e5;
    if (this === t5 && "function" == typeof Uint8Array.prototype.copyWithin) {
        this.copyWithin(r3, e5, n5);
    } else if (this === t5 && e5 < r3 && r3 < n5) {
        for (var o6 = i6 - 1; o6 >= 0; --o6) {
            t5[o6 + r3] = this[o6 + e5];
        }
    } else {
        Uint8Array.prototype.set.call(t5, this.subarray(e5, n5), r3);
    }
    return i6;
}, u$13.prototype.fill = function (t5, r3, e5, n5) {
    if ("string" == typeof t5) {
        if ("string" == typeof r3 ? (n5 = r3, r3 = 0, e5 = this.length) : "string" == typeof e5 && (n5 = e5, e5 = this.length), (void 0) !== n5 && "string" != typeof n5) {
            throw new TypeError("encoding must be a string");
        }
        if ("string" == typeof n5 && !u$13.isEncoding(n5)) {
            throw new TypeError("Unknown encoding: " + n5);
        }
        if (1 === t5.length) {
            var i6 = t5.charCodeAt(0);
            ("utf8" === n5 && i6 < 128 || "latin1" === n5) && (t5 = i6);
        }
    } else {
        "number" == typeof t5 ? t5 &= 255 : "boolean" == typeof t5 && (t5 = Number(t5));
    }
    if (r3 < 0 || this.length < r3 || this.length < e5) {
        throw new RangeError("Out of range index");
    }
    if (e5 <= r3) {
        return this;
    }
    var o6;
    if (r3 >>>= 0, e5 = (void 0) === e5 ? this.length : e5 >>> 0, t5 || (t5 = 0), "number" == typeof t5) {
        for (o6 = r3; o6 < e5; ++o6) {
            this[o6] = t5;
        }
    } else {
        var f4 = u$13.isBuffer(t5) ? t5 : u$13.from(t5, n5), s6 = f4.length;
        if (0 === s6) {
            throw new TypeError('The value "' + t5 + '" is invalid for argument "value"');
        }
        for (o6 = 0; o6 < e5 - r3; ++o6) {
            this[o6 + r3] = f4[o6 % s6];
        }
    }
    return this;
};
var j = /[^+/0-9A-Za-z-_]/g;

function _4(t5, r3) {
    var e5;
    r3 = r3 || 1 / 0;
    for (var n5 = t5.length, i7 = null, o6 = [], f5 = 0; f5 < n5; ++f5) {
        if ((e5 = t5.charCodeAt(f5)) > 55295 && e5 < 57344) {
            if (!i7) {
                if (e5 > 56319) {
                    (r3 -= 3) > -1 && o6.push(239, 191, 189);
                    continue;
                }
                if (f5 + 1 === n5) {
                    (r3 -= 3) > -1 && o6.push(239, 191, 189);
                    continue;
                }
                i7 = e5;
                continue;
            }
            if (e5 < 56320) {
                (r3 -= 3) > -1 && o6.push(239, 191, 189), i7 = e5;
                continue;
            }
            e5 = 65536 + (i7 - 55296 << 10 | e5 - 56320);
        } else {
            i7 && (r3 -= 3) > -1 && o6.push(239, 191, 189);
        }
        if (i7 = null, e5 < 128) {
            if ((r3 -= 1) < 0) {
                break;
            }
            o6.push(e5);
        } else if (e5 < 2048) {
            if ((r3 -= 2) < 0) {
                break;
            }
            o6.push(e5 >> 6 | 192, 63 & e5 | 128);
        } else if (e5 < 65536) {
            if ((r3 -= 3) < 0) {
                break;
            }
            o6.push(e5 >> 12 | 224, e5 >> 6 & 63 | 128, 63 & e5 | 128);
        } else {
            if (!(e5 < 1114112)) {
                throw new Error("Invalid code point");
            }
            if ((r3 -= 4) < 0) {
                break;
            }
            o6.push(e5 >> 18 | 240, e5 >> 12 & 63 | 128, e5 >> 6 & 63 | 128, 63 & e5 | 128);
        }
    }
    return o6;
}

function z1(t5) {
    return n$13.toByteArray(function (t6) {
        if ((t6 = (t6 = t6.split("=")[0]).trim().replace(j, "")).length < 2) {
            return "";
        }
        for (; t6.length % 4 != 0;) {
            t6 += "=";
        }
        return t6;
    }(t5));
}

function D1(t5, r3, e5, n5) {
    for (var i7 = 0; i7 < n5 && !(i7 + e5 >= r3.length || i7 >= t5.length); ++i7) {
        r3[i7 + e5] = t5[i7];
    }
    return i7;
}

function F1(t5, r3) {
    return t5 instanceof r3 || null != t5 && null != t5.constructor && null != t5.constructor.name && t5.constructor.name === r3.name;
}

function N2(t5) {
    return t5 != t5;
}

var Y = function () {
    for (var t5 = new Array(256), r3 = 0; r3 < 16; ++r3) {
        for (var e5 = 16 * r3, n5 = 0; n5 < 16; ++n5) {
            t5[e5 + n5] = "0123456789abcdef"[r3] + "0123456789abcdef"[n5];
        }
    }
    return t5;
}();
var exports = {};

class Long {
    constructor(value1) {
        this.value = value1;
    }

    static isLong(obj) {
        return typeof obj.value === "bigint";
    }

    static fromBits(value) {
        return new Long(BigInt(value));
    }

    static fromInt(value) {
        if (isNaN(value)) {
            return Long.ZERO;
        }
        return new Long(BigInt.asIntN(64, BigInt(value)));
    }

    static fromNumber(value) {
        if (isNaN(value)) {
            return Long.ZERO;
        }
        return new Long(BigInt(value));
    }

    static fromValue(val) {
        if (typeof val === "number") {
            return this.fromNumber(val);
        }
        if (typeof val === "string") {
            return this.fromString(val);
        }
        if (typeof val === "bigint") {
            return new Long(val);
        }
        if (this.isLong(val)) {
            return new Long(BigInt(val.value));
        }
        return new Long(BigInt(val));
    }

    static fromString(str) {
        if (str.length === 0) {
            throw Error("empty string");
        }
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") {
            return Long.ZERO;
        }
        return new Long(BigInt(str));
    }

    isZero() {
        return this.value === BigInt(0);
    }

    isNegative() {
        return this.value < BigInt(0);
    }

    toString() {
        return String(this.value);
    }

    toNumber() {
        return Number(this.value);
    }

    toInt() {
        return Number(BigInt.asIntN(32, this.value));
    }

    shiftLeft(numBits) {
        return new Long(this.value << BigInt(numBits));
    }

    shiftRight(numBits) {
        return new Long(this.value >> BigInt(numBits));
    }

    or(other) {
        if (!Long.isLong(other)) {
            other = Long.fromValue(other);
        }
        return Long.fromBits(this.value | other.value);
    }

    xor(other) {
        if (!Long.isLong(other)) {
            other = Long.fromValue(other);
        }
        return new Long(this.value ^ other.value);
    }

    and(other) {
        if (!Long.isLong(other)) {
            other = Long.fromValue(other);
        }
        return new Long(this.value & other.value);
    }

    not() {
        return new Long(~this.value);
    }

    shiftRightUnsigned(numBits) {
        return new Long(this.value >> BigInt.asUintN(64, BigInt(numBits)));
    }

    equals(other) {
        if (!Long.isLong(other)) {
            other = Long.fromValue(other);
        }
        return this.value === other.value;
    }

    greaterThanOrEqual(other) {
        if (!Long.isLong(other)) {
            other = Long.fromValue(other);
        }
        return this.value >= other.value;
    }

    gte(other) {
        return this.greaterThanOrEqual(other);
    }

    notEquals(other) {
        if (!Long.isLong(other)) {
            other = Long.fromValue(other);
        }
        return !this.equals(other);
    }

    add(addend) {
        if (!Long.isLong(addend)) {
            addend = Long.fromValue(addend);
        }
        return new Long(this.value + addend.value);
    }

    subtract(subtrahend) {
        if (!Long.isLong(subtrahend)) {
            subtrahend = Long.fromValue(subtrahend);
        }
        return this.add(subtrahend.negate());
    }

    multiply(multiplier) {
        if (this.isZero()) {
            return Long.ZERO;
        }
        if (!Long.isLong(multiplier)) {
            multiplier = Long.fromValue(multiplier);
        }
        return new Long(this.value * multiplier.value);
    }

    divide(divisor) {
        if (!Long.isLong(divisor)) {
            divisor = Long.fromValue(divisor);
        }
        if (divisor.isZero()) {
            throw Error("division by zero");
        }
        return new Long(this.value / divisor.value);
    }

    compare(other) {
        if (!Long.isLong(other)) {
            other = Long.fromValue(other);
        }
        if (this.value === other.value) {
            return 0;
        }
        if (this.value > other.value) {
            return 1;
        }
        if (other.value > this.value) {
            return -1;
        }
    }

    lessThan(other) {
        if (!Long.isLong(other)) {
            other = Long.fromValue(other);
        }
        return this.value < other.value;
    }

    negate() {
        if (this.equals(Long.MIN_VALUE)) {
            return Long.MIN_VALUE;
        }
        return this.not().add(Long.ONE);
    }

    getHighBits() {
        return Number(BigInt.asIntN(32, this.value >> BigInt(32)));
    }

    getLowBits() {
        return Number(BigInt.asIntN(32, this.value));
    }
}

Long.MIN_VALUE = new Long(BigInt("-9223372036854775808"));
Long.MAX_VALUE = new Long(BigInt("9223372036854775807"));
Long.ZERO = Long.fromInt(0);
Long.ONE = Long.fromInt(1);
exports = Long;
var _long = exports;
var exports$1 = {};
var Buffer = e$1.Buffer;
const Long$1 = _long;
const INT8_SIZE = 1;
const INT16_SIZE = 2;
const INT32_SIZE = 4;
const INT64_SIZE = 8;
const MOST_SIGNIFICANT_BIT = 128;
const OTHER_BITS = 127;
const UNSIGNED_INT32_MAX_NUMBER = 4294967168;
const UNSIGNED_INT64_MAX_NUMBER = 18446744073709551488n;
exports$1 = class Encoder {
    constructor(initialSize = 511) {
        this.buf = Buffer.alloc(Encoder.nextPowerOfTwo(initialSize));
        this.offset = 0;
    }

    get buffer() {
        return this.buf.slice(0, this.offset);
    }

    static encodeZigZag(value) {
        return value << 1 ^ value >> 31;
    }

    static encodeZigZag64(value) {
        const longValue = Long$1.fromValue(value);
        return longValue.shiftLeft(1).xor(longValue.shiftRight(63));
    }

    static sizeOfVarInt(value) {
        let encodedValue = this.encodeZigZag(value);
        let bytes = 1;
        while ((encodedValue & UNSIGNED_INT32_MAX_NUMBER) !== 0) {
            bytes += 1;
            encodedValue >>>= 7;
        }
        return bytes;
    }

    static sizeOfVarLong(value) {
        let longValue = Encoder.encodeZigZag64(value);
        let bytes = 1;
        while (longValue.and(UNSIGNED_INT64_MAX_NUMBER).notEquals(Long$1.fromInt(0))) {
            bytes += 1;
            longValue = longValue.shiftRightUnsigned(7);
        }
        return bytes;
    }

    static sizeOfVarIntBytes(value) {
        const size = value == null ? -1 : Buffer.byteLength(value);
        if (size < 0) {
            return Encoder.sizeOfVarInt(-1);
        }
        return Encoder.sizeOfVarInt(size) + size;
    }

    static nextPowerOfTwo(value) {
        return 1 << 31 - Math.clz32(value) + 1;
    }

    writeBufferInternal(buffer) {
        const bufferLength = buffer.length;
        this.ensureAvailable(bufferLength);
        buffer.copy(this.buf, this.offset, 0);
        this.offset += bufferLength;
    }

    ensureAvailable(length) {
        if (this.offset + length > this.buf.length) {
            const newLength = Encoder.nextPowerOfTwo(this.offset + length);
            const newBuffer = Buffer.alloc(newLength);
            this.buf.copy(newBuffer, 0, 0, this.offset);
            this.buf = newBuffer;
        }
    }

    writeInt8(value) {
        this.ensureAvailable(INT8_SIZE);
        this.buf.writeInt8(value, this.offset);
        this.offset += INT8_SIZE;
        return this;
    }

    writeInt16(value) {
        this.ensureAvailable(INT16_SIZE);
        this.buf.writeInt16BE(value, this.offset);
        this.offset += INT16_SIZE;
        return this;
    }

    writeInt32(value) {
        this.ensureAvailable(INT32_SIZE);
        this.buf.writeInt32BE(value, this.offset);
        this.offset += INT32_SIZE;
        return this;
    }

    writeUInt32(value) {
        this.ensureAvailable(INT32_SIZE);
        this.buf.writeUInt32BE(value, this.offset);
        this.offset += INT32_SIZE;
        return this;
    }

    writeInt64(value) {
        this.ensureAvailable(INT64_SIZE);
        const longValue = Long$1.fromValue(value);
        this.buf.writeInt32BE(longValue.getHighBits(), this.offset);
        this.buf.writeInt32BE(longValue.getLowBits(), this.offset + INT32_SIZE);
        this.offset += INT64_SIZE;
        return this;
    }

    writeBoolean(value) {
        value ? this.writeInt8(1) : this.writeInt8(0);
        return this;
    }

    writeString(value) {
        if (value == null) {
            this.writeInt16(-1);
            return this;
        }
        const byteLength = Buffer.byteLength(value, "utf8");
        this.ensureAvailable(INT16_SIZE + byteLength);
        this.writeInt16(byteLength);
        this.buf.write(value, this.offset, byteLength, "utf8");
        this.offset += byteLength;
        return this;
    }

    writeVarIntString(value) {
        if (value == null) {
            this.writeVarInt(-1);
            return this;
        }
        const byteLength = Buffer.byteLength(value, "utf8");
        this.writeVarInt(byteLength);
        this.ensureAvailable(byteLength);
        this.buf.write(value, this.offset, byteLength, "utf8");
        this.offset += byteLength;
        return this;
    }

    writeBytes(value) {
        if (value == null) {
            this.writeInt32(-1);
            return this;
        }
        if (Buffer.isBuffer(value)) {
            this.ensureAvailable(INT32_SIZE + value.length);
            this.writeInt32(value.length);
            this.writeBufferInternal(value);
        } else {
            const valueToWrite = String(value);
            const byteLength = Buffer.byteLength(valueToWrite, "utf8");
            this.ensureAvailable(INT32_SIZE + byteLength);
            this.writeInt32(byteLength);
            this.buf.write(valueToWrite, this.offset, byteLength, "utf8");
            this.offset += byteLength;
        }
        return this;
    }

    writeVarIntBytes(value) {
        if (value == null) {
            this.writeVarInt(-1);
            return this;
        }
        if (Buffer.isBuffer(value)) {
            this.writeVarInt(value.length);
            this.writeBufferInternal(value);
        } else {
            const valueToWrite = String(value);
            const byteLength = Buffer.byteLength(valueToWrite, "utf8");
            this.writeVarInt(byteLength);
            this.ensureAvailable(byteLength);
            this.buf.write(valueToWrite, this.offset, byteLength, "utf8");
            this.offset += byteLength;
        }
        return this;
    }

    writeEncoder(value) {
        if (value == null || !Buffer.isBuffer(value.buf)) {
            throw new Error("value should be an instance of Encoder");
        }
        this.writeBufferInternal(value.buffer);
        return this;
    }

    writeEncoderArray(value) {
        if (!Array.isArray(value) || value.some((v4) => v4 == null || !Buffer.isBuffer(v4.buf)
        )) {
            throw new Error("all values should be an instance of Encoder[]");
        }
        value.forEach((v4) => {
            this.writeBufferInternal(v4.buffer);
        });
        return this;
    }

    writeBuffer(value) {
        if (!Buffer.isBuffer(value)) {
            throw new Error("value should be an instance of Buffer");
        }
        this.writeBufferInternal(value);
        return this;
    }

    writeNullableArray(array, type) {
        const length = array.length !== 0 ? array.length : -1;
        this.writeArray(array, type, length);
        return this;
    }

    writeArray(array, type, length) {
        const arrayLength = length == null ? array.length : length;
        this.writeInt32(arrayLength);
        if (type !== undefined) {
            switch (type) {
                case "int32":
                case "number":
                    array.forEach((value2) => this.writeInt32(value2)
                    );
                    break;
                case "string":
                    array.forEach((value2) => this.writeString(value2)
                    );
                    break;
                case "object":
                    this.writeEncoderArray(array);
                    break;
            }
        } else {
            array.forEach((value2) => {
                switch (typeof value2) {
                    case "number":
                        this.writeInt32(value2);
                        break;
                    case "string":
                        this.writeString(value2);
                        break;
                    case "object":
                        this.writeEncoder(value2);
                        break;
                }
            });
        }
        return this;
    }

    writeVarIntArray(array, type) {
        if (type === "object") {
            this.writeVarInt(array.length);
            this.writeEncoderArray(array);
        } else {
            const objectArray = array.filter((v4) => typeof v4 === "object"
            );
            this.writeVarInt(objectArray.length);
            this.writeEncoderArray(objectArray);
        }
        return this;
    }

    writeVarInt(value) {
        const byteArray = [];
        let encodedValue = Encoder.encodeZigZag(value);
        while ((encodedValue & UNSIGNED_INT32_MAX_NUMBER) !== 0) {
            byteArray.push(encodedValue & OTHER_BITS | MOST_SIGNIFICANT_BIT);
            encodedValue >>>= 7;
        }
        byteArray.push(encodedValue & OTHER_BITS);
        this.writeBufferInternal(Buffer.from(byteArray));
        return this;
    }

    writeVarLong(value) {
        const byteArray = [];
        let longValue = Encoder.encodeZigZag64(value);
        while (longValue.and(UNSIGNED_INT64_MAX_NUMBER).notEquals(Long$1.fromInt(0))) {
            byteArray.push(longValue.and(OTHER_BITS).or(MOST_SIGNIFICANT_BIT).toInt());
            longValue = longValue.shiftRightUnsigned(7);
        }
        byteArray.push(longValue.toInt());
        this.writeBufferInternal(Buffer.from(byteArray));
        return this;
    }

    size() {
        return this.offset;
    }

    toJSON() {
        return this.buffer.toJSON();
    }
};
var _encoder = exports$1;
var exports$2 = {};
var Buffer$1 = e$1.Buffer;
const Long$2 = _long;
const INT8_SIZE$1 = 1;
const INT16_SIZE$1 = 2;
const INT32_SIZE$1 = 4;
const INT64_SIZE$1 = 8;
const MOST_SIGNIFICANT_BIT$1 = 128;
const OTHER_BITS$1 = 127;
exports$2 = class Decoder {
    constructor(buffer1) {
        this.buffer = buffer1;
        this.offset = 0;
    }

    static int32Size() {
        return INT32_SIZE$1;
    }

    static decodeZigZag(value) {
        return value >>> 1 ^ -(value & 1);
    }

    static decodeZigZag64(longValue) {
        return longValue.shiftRightUnsigned(1).xor(longValue.and(Long$2.fromInt(1)).negate());
    }

    readInt8() {
        const value2 = this.buffer.readInt8(this.offset);
        this.offset += INT8_SIZE$1;
        return value2;
    }

    canReadInt16() {
        return this.canReadBytes(INT16_SIZE$1);
    }

    readInt16() {
        const value2 = this.buffer.readInt16BE(this.offset);
        this.offset += INT16_SIZE$1;
        return value2;
    }

    canReadInt32() {
        return this.canReadBytes(INT32_SIZE$1);
    }

    readInt32() {
        const value2 = this.buffer.readInt32BE(this.offset);
        this.offset += INT32_SIZE$1;
        return value2;
    }

    canReadInt64() {
        return this.canReadBytes(INT64_SIZE$1);
    }

    readInt64() {
        const first = this.buffer[this.offset];
        const last = this.buffer[this.offset + 7];
        const low = (first << 24) + this.buffer[this.offset + 1] * 2 ** 16 + this.buffer[this.offset + 2] * 2 ** 8 + this.buffer[this.offset + 3];
        const high = this.buffer[this.offset + 4] * 2 ** 24 + this.buffer[this.offset + 5] * 2 ** 16 + this.buffer[this.offset + 6] * 2 ** 8 + last;
        this.offset += INT64_SIZE$1;
        return (BigInt(low) << 32n) + BigInt(high);
    }

    readString() {
        const byteLength = this.readInt16();
        if (byteLength === -1) {
            return null;
        }
        const stringBuffer = this.buffer.slice(this.offset, this.offset + byteLength);
        const value2 = stringBuffer.toString("utf8");
        this.offset += byteLength;
        return value2;
    }

    readVarIntString() {
        const byteLength = this.readVarInt();
        if (byteLength === -1) {
            return null;
        }
        const stringBuffer = this.buffer.slice(this.offset, this.offset + byteLength);
        const value2 = stringBuffer.toString("utf8");
        this.offset += byteLength;
        return value2;
    }

    canReadBytes(length) {
        return Buffer$1.byteLength(this.buffer) - this.offset >= length;
    }

    readBytes(byteLength = this.readInt32()) {
        if (byteLength === -1) {
            return null;
        }
        const stringBuffer = this.buffer.slice(this.offset, this.offset + byteLength);
        this.offset += byteLength;
        return stringBuffer;
    }

    readVarIntBytes() {
        const byteLength = this.readVarInt();
        if (byteLength === -1) {
            return null;
        }
        const stringBuffer = this.buffer.slice(this.offset, this.offset + byteLength);
        this.offset += byteLength;
        return stringBuffer;
    }

    readBoolean() {
        return this.readInt8() === 1;
    }

    readAll() {
        const result = this.buffer.slice(this.offset);
        this.offset += Buffer$1.byteLength(this.buffer);
        return result;
    }

    readArray(reader) {
        const length = this.readInt32();
        if (length === -1) {
            return [];
        }
        const array = new Array(length);
        for (let i7 = 0; i7 < length; i7++) {
            array[i7] = reader(this);
        }
        return array;
    }

    readVarIntArray(reader) {
        const length = this.readVarInt();
        if (length === -1) {
            return [];
        }
        const array = new Array(length);
        for (let i7 = 0; i7 < length; i7++) {
            array[i7] = reader(this);
        }
        return array;
    }

    async readArrayAsync(reader) {
        const length = this.readInt32();
        if (length === -1) {
            return [];
        }
        const array = new Array(length);
        for (let i7 = 0; i7 < length; i7++) {
            array[i7] = await reader(this);
        }
        return array;
    }

    readVarInt() {
        let currentByte;
        let result = 0;
        let i7 = 0;
        do {
            currentByte = this.buffer[this.offset++];
            result += (currentByte & OTHER_BITS$1) << i7;
            i7 += 7;
        } while (currentByte >= MOST_SIGNIFICANT_BIT$1)
        return Decoder.decodeZigZag(result);
    }

    readVarLong() {
        let currentByte;
        let result = Long$2.fromInt(0);
        let i7 = 0;
        do {
            currentByte = this.buffer[this.offset++];
            result = result.add(Long$2.fromInt(currentByte & OTHER_BITS$1).shiftLeft(i7));
            i7 += 7;
        } while (currentByte >= MOST_SIGNIFICANT_BIT$1)
        return Decoder.decodeZigZag64(result);
    }

    slice(size) {
        return new Decoder(this.buffer.slice(this.offset, this.offset + size));
    }

    forward(size) {
        this.offset += size;
    }
};
var _decoder = exports$2;
var exports$3 = {};
var Buffer$2 = e$1.Buffer;
const Encoder = _encoder;
const Decoder = _decoder;
const MemberMetadata = {
    encode({version, topics, userData = Buffer$2.alloc(0)}) {
        return new Encoder().writeInt16(version).writeArray(topics).writeBytes(userData).buffer;
    },
    decode(buffer) {
        const decoder = new Decoder(buffer);
        return {
            version: decoder.readInt16(),
            topics: decoder.readArray((d2) => d2.readString()
            ),
            userData: decoder.readBytes()
        };
    }
};
const MemberAssignment = {
    encode({version, assignment, userData = Buffer$2.alloc(0)}) {
        return new Encoder().writeInt16(version).writeArray(Object.keys(assignment).map((topic) => new Encoder().writeString(topic).writeArray(assignment[topic])
        )).writeBytes(userData).buffer;
    },
    decode(buffer) {
        const decoder = new Decoder(buffer);
        const decodePartitions = (d2) => d2.readInt32()
        ;
        const decodeAssignment = (d2) => ({
                    topic: d2.readString(),
                    partitions: d2.readArray(decodePartitions)
                })
        ;
        const indexAssignment = (obj, {topic, partitions}) => Object.assign(obj, {
                    [topic]: partitions
                })
        ;
        if (!decoder.canReadInt16()) {
            return null;
        }
        return {
            version: decoder.readInt16(),
            assignment: decoder.readArray(decodeAssignment).reduce(indexAssignment, {}),
            userData: decoder.readBytes()
        };
    }
};
exports$3 = {
    MemberMetadata,
    MemberAssignment
};
var _assignerProtocol = exports$3;
var t5 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, e5 = Object.prototype.toString,
        o6 = function (o7) {
            return !(t5 && o7 && "object" == typeof o7 && Symbol.toStringTag in o7) && "[object Arguments]" === e5.call(o7);
        }, n5 = function (t6) {
            return !!o6(t6) || null !== t6 && "object" == typeof t6 && "number" == typeof t6.length && t6.length >= 0 && "[object Array]" !== e5.call(t6) && "[object Function]" === e5.call(t6.callee);
        }, r3 = function () {
            return o6(arguments);
        }();
o6.isLegacyArguments = n5;
var l4 = r3 ? o6 : n5;
var t$1 = Object.prototype.toString, o$11 = Function.prototype.toString, n$11 = /^\s*(?:function)?\*/,
        e$11 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, r$1 = Object.getPrototypeOf,
        c5 = function () {
            if (!e$11) {
                return !1;
            }
            try {
                return Function("return function*() {}")();
            } catch (t6) {
            }
        }(), u7 = c5 ? r$1(c5) : {}, i7 = function (c6) {
            return "function" == typeof c6 && (!!n$11.test(o$11.call(c6)) || (e$11 ? r$1(c6) === u7 : "[object GeneratorFunction]" === t$1.call(c6)));
        };
var t$2 = "function" == typeof Object.create ? function (t6, e7) {
    e7 && (t6.super_ = e7, t6.prototype = Object.create(e7.prototype, {
        constructor: {
            value: t6,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }));
} : function (t6, e7) {
    if (e7) {
        t6.super_ = e7;
        var o7 = function () {
        };
        o7.prototype = e7.prototype, t6.prototype = new o7, t6.prototype.constructor = t6;
    }
};
var i$12 = function (e7) {
    return e7 && "object" == typeof e7 && "function" == typeof e7.copy && "function" == typeof e7.fill && "function" == typeof e7.readUInt8;
}, o$2 = {}, u$11 = i$12, f5 = l4, a7 = i7;

function c$11(e7) {
    return e7.call.bind(e7);
}

var s7 = "undefined" != typeof BigInt, p6 = "undefined" != typeof Symbol, y3 = p6 && (void 0) !== Symbol.toStringTag,
        l$1 = "undefined" != typeof Uint8Array, d2 = "undefined" != typeof ArrayBuffer;
if (l$1 && y3) {
    var g1 = Object.getPrototypeOf(Uint8Array.prototype),
            b1 = c$11(Object.getOwnPropertyDescriptor(g1, Symbol.toStringTag).get);
}
var m2 = c$11(Object.prototype.toString), h4 = c$11(Number.prototype.valueOf), j1 = c$11(String.prototype.valueOf),
        A1 = c$11(Boolean.prototype.valueOf);
if (s7) {
    var w1 = c$11(BigInt.prototype.valueOf);
}
if (p6) {
    var v4 = c$11(Symbol.prototype.valueOf);
}

function O1(e7, t6) {
    if ("object" != typeof e7) {
        return !1;
    }
    try {
        return t6(e7), !0;
    } catch (e8) {
        return !1;
    }
}

function S1(e7) {
    return l$1 && y3 ? (void 0) !== b1(e7) : B2(e7) || k2(e7) || E2(e7) || D2(e7) || U2(e7) || P2(e7) || x2(e7) || I2(e7) || M2(e7) || z2(e7) || F2(e7);
}

function B2(e7) {
    return l$1 && y3 ? "Uint8Array" === b1(e7) : "[object Uint8Array]" === m2(e7) || u$11(e7) && (void 0) !== e7.buffer;
}

function k2(e7) {
    return l$1 && y3 ? "Uint8ClampedArray" === b1(e7) : "[object Uint8ClampedArray]" === m2(e7);
}

function E2(e7) {
    return l$1 && y3 ? "Uint16Array" === b1(e7) : "[object Uint16Array]" === m2(e7);
}

function D2(e7) {
    return l$1 && y3 ? "Uint32Array" === b1(e7) : "[object Uint32Array]" === m2(e7);
}

function U2(e7) {
    return l$1 && y3 ? "Int8Array" === b1(e7) : "[object Int8Array]" === m2(e7);
}

function P2(e7) {
    return l$1 && y3 ? "Int16Array" === b1(e7) : "[object Int16Array]" === m2(e7);
}

function x2(e7) {
    return l$1 && y3 ? "Int32Array" === b1(e7) : "[object Int32Array]" === m2(e7);
}

function I2(e7) {
    return l$1 && y3 ? "Float32Array" === b1(e7) : "[object Float32Array]" === m2(e7);
}

function M2(e7) {
    return l$1 && y3 ? "Float64Array" === b1(e7) : "[object Float64Array]" === m2(e7);
}

function z2(e7) {
    return l$1 && y3 ? "BigInt64Array" === b1(e7) : "[object BigInt64Array]" === m2(e7);
}

function F2(e7) {
    return l$1 && y3 ? "BigUint64Array" === b1(e7) : "[object BigUint64Array]" === m2(e7);
}

function T3(e7) {
    return "[object Map]" === m2(e7);
}

function N1(e7) {
    return "[object Set]" === m2(e7);
}

function W3(e7) {
    return "[object WeakMap]" === m2(e7);
}

function $3(e7) {
    return "[object WeakSet]" === m2(e7);
}

function C1(e7) {
    return "[object ArrayBuffer]" === m2(e7);
}

function V(e7) {
    return "undefined" != typeof ArrayBuffer && (C1.working ? C1(e7) : e7 instanceof ArrayBuffer);
}

function G3(e7) {
    return "[object DataView]" === m2(e7);
}

function R1(e7) {
    return "undefined" != typeof DataView && (G3.working ? G3(e7) : e7 instanceof DataView);
}

function J2(e7) {
    return "[object SharedArrayBuffer]" === m2(e7);
}

function _1(e7) {
    return "undefined" != typeof SharedArrayBuffer && (J2.working ? J2(e7) : e7 instanceof SharedArrayBuffer);
}

function H(e7) {
    return O1(e7, h4);
}

function Z2(e7) {
    return O1(e7, j1);
}

function q3(e7) {
    return O1(e7, A1);
}

function K(e7) {
    return s7 && O1(e7, w1);
}

function L1(e7) {
    return p6 && O1(e7, v4);
}

o$2.isArgumentsObject = f5, o$2.isGeneratorFunction = a7, o$2.isPromise = function (e7) {
    return "undefined" != typeof Promise && e7 instanceof Promise || null !== e7 && "object" == typeof e7 && "function" == typeof e7.then && "function" == typeof e7.catch;
}, o$2.isArrayBufferView = function (e7) {
    return d2 && ArrayBuffer.isView ? ArrayBuffer.isView(e7) : S1(e7) || R1(e7);
}, o$2.isTypedArray = S1, o$2.isUint8Array = B2, o$2.isUint8ClampedArray = k2, o$2.isUint16Array = E2, o$2.isUint32Array = D2, o$2.isInt8Array = U2, o$2.isInt16Array = P2, o$2.isInt32Array = x2, o$2.isFloat32Array = I2, o$2.isFloat64Array = M2, o$2.isBigInt64Array = z2, o$2.isBigUint64Array = F2, T3.working = "undefined" != typeof Map && T3(new Map), o$2.isMap = function (e7) {
    return "undefined" != typeof Map && (T3.working ? T3(e7) : e7 instanceof Map);
}, N1.working = "undefined" != typeof Set && N1(new Set), o$2.isSet = function (e7) {
    return "undefined" != typeof Set && (N1.working ? N1(e7) : e7 instanceof Set);
}, W3.working = "undefined" != typeof WeakMap && W3(new WeakMap), o$2.isWeakMap = function (e7) {
    return "undefined" != typeof WeakMap && (W3.working ? W3(e7) : e7 instanceof WeakMap);
}, $3.working = "undefined" != typeof WeakSet && $3(new WeakSet), o$2.isWeakSet = function (e7) {
    return $3(e7);
}, C1.working = "undefined" != typeof ArrayBuffer && C1(new ArrayBuffer), o$2.isArrayBuffer = V, G3.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G3(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R1, J2.working = "undefined" != typeof SharedArrayBuffer && J2(new SharedArrayBuffer), o$2.isSharedArrayBuffer = _1, o$2.isAsyncFunction = function (e7) {
    return "[object AsyncFunction]" === m2(e7);
}, o$2.isMapIterator = function (e7) {
    return "[object Map Iterator]" === m2(e7);
}, o$2.isSetIterator = function (e7) {
    return "[object Set Iterator]" === m2(e7);
}, o$2.isGeneratorObject = function (e7) {
    return "[object Generator]" === m2(e7);
}, o$2.isWebAssemblyCompiledModule = function (e7) {
    return "[object WebAssembly.Module]" === m2(e7);
}, o$2.isNumberObject = H, o$2.isStringObject = Z2, o$2.isBooleanObject = q3, o$2.isBigIntObject = K, o$2.isSymbolObject = L1, o$2.isBoxedPrimitive = function (e7) {
    return H(e7) || Z2(e7) || q3(e7) || K(e7) || L1(e7);
}, o$2.isAnyArrayBuffer = function (e7) {
    return l$1 && (V(e7) || _1(e7));
}, [
    "isProxy",
    "isExternal",
    "isModuleNamespaceObject"
].forEach(function (e7) {
    Object.defineProperty(o$2, e7, {
        enumerable: !1,
        value: function () {
            throw new Error(e7 + " is not supported in userland");
        }
    });
});
var Q1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, X = {}, Y1 = T1,
        ee1 = Object.getOwnPropertyDescriptors || function (e7) {
            for (var t6 = Object.keys(e7), r5 = {}, n6 = 0; n6 < t6.length; n6++) {
                r5[t6[n6]] = Object.getOwnPropertyDescriptor(e7, t6[n6]);
            }
            return r5;
        }, te = /%[sdj%]/g;
X.format = function (e7) {
    if (!ge(e7)) {
        for (var t6 = [], r5 = 0; r5 < arguments.length; r5++) {
            t6.push(oe(arguments[r5]));
        }
        return t6.join(" ");
    }
    r5 = 1;
    for (var n6 = arguments, i8 = n6.length, o8 = String(e7).replace(te, function (e8) {
        if ("%%" === e8) {
            return "%";
        }
        if (r5 >= i8) {
            return e8;
        }
        switch (e8) {
            case "%s":
                return String(n6[r5++]);
            case "%d":
                return Number(n6[r5++]);
            case "%j":
                try {
                    return JSON.stringify(n6[r5++]);
                } catch (e9) {
                    return "[Circular]";
                }
            default:
                return e8;
        }
    }), u8 = n6[r5]; r5 < i8; u8 = n6[++r5]) {
        le(u8) || !he(u8) ? o8 += " " + u8 : o8 += " " + oe(u8);
    }
    return o8;
}, X.deprecate = function (e7, t7) {
    if ((void 0) !== Y1 && !0 === Y1.noDeprecation) {
        return e7;
    }
    if ((void 0) === Y1) {
        return function () {
            return X.deprecate(e7, t7).apply(this || Q1, arguments);
        };
    }
    var r6 = !1;
    return function () {
        if (!r6) {
            if (Y1.throwDeprecation) {
                throw new Error(t7);
            }
            Y1.traceDeprecation ? console.trace(t7) : console.error(t7), r6 = !0;
        }
        return e7.apply(this || Q1, arguments);
    };
};
var re = {}, ne = /^$/;
if (Y1.env.NODE_DEBUG) {
    var ie = Y1.env.NODE_DEBUG;
    ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
}

function oe(e7, t7) {
    var r6 = {
        seen: [],
        stylize: fe
    };
    return arguments.length >= 3 && (r6.depth = arguments[2]), arguments.length >= 4 && (r6.colors = arguments[3]), ye(t7) ? r6.showHidden = t7 : t7 && X._extend(r6, t7), be(r6.showHidden) && (r6.showHidden = !1), be(r6.depth) && (r6.depth = 2), be(r6.colors) && (r6.colors = !1), be(r6.customInspect) && (r6.customInspect = !0), r6.colors && (r6.stylize = ue), ae(r6, e7, r6.depth);
}

function ue(e7, t7) {
    var r6 = oe.styles[t7];
    return r6 ? "[" + oe.colors[r6][0] + "m" + e7 + "[" + oe.colors[r6][1] + "m" : e7;
}

function fe(e7, t7) {
    return e7;
}

function ae(e7, t7, r6) {
    if (e7.customInspect && t7 && we(t7.inspect) && t7.inspect !== X.inspect && (!t7.constructor || t7.constructor.prototype !== t7)) {
        var n6 = t7.inspect(r6, e7);
        return ge(n6) || (n6 = ae(e7, n6, r6)), n6;
    }
    var i8 = function (e8, t8) {
        if (be(t8)) {
            return e8.stylize("undefined", "undefined");
        }
        if (ge(t8)) {
            var r7 = "'" + JSON.stringify(t8).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return e8.stylize(r7, "string");
        }
        if (de(t8)) {
            return e8.stylize("" + t8, "number");
        }
        if (ye(t8)) {
            return e8.stylize("" + t8, "boolean");
        }
        if (le(t8)) {
            return e8.stylize("null", "null");
        }
    }(e7, t7);
    if (i8) {
        return i8;
    }
    var o8 = Object.keys(t7), u8 = function (e8) {
        var t8 = {};
        return e8.forEach(function (e9, r8) {
            t8[e9] = !0;
        }), t8;
    }(o8);
    if (e7.showHidden && (o8 = Object.getOwnPropertyNames(t7)), Ae(t7) && (o8.indexOf("message") >= 0 || o8.indexOf("description") >= 0)) {
        return ce(t7);
    }
    if (0 === o8.length) {
        if (we(t7)) {
            var f6 = t7.name ? ": " + t7.name : "";
            return e7.stylize("[Function" + f6 + "]", "special");
        }
        if (me(t7)) {
            return e7.stylize(RegExp.prototype.toString.call(t7), "regexp");
        }
        if (je(t7)) {
            return e7.stylize(Date.prototype.toString.call(t7), "date");
        }
        if (Ae(t7)) {
            return ce(t7);
        }
    }
    var a8, c6 = "", s8 = !1, p7 = [
        "{",
        "}"
    ];
    (pe(t7) && (s8 = !0, p7 = [
        "[",
        "]"
    ]), we(t7)) && (c6 = " [Function" + (t7.name ? ": " + t7.name : "") + "]");
    return me(t7) && (c6 = " " + RegExp.prototype.toString.call(t7)), je(t7) && (c6 = " " + Date.prototype.toUTCString.call(t7)), Ae(t7) && (c6 = " " + ce(t7)), 0 !== o8.length || s8 && 0 != t7.length ? r6 < 0 ? me(t7) ? e7.stylize(RegExp.prototype.toString.call(t7), "regexp") : e7.stylize("[Object]", "special") : (e7.seen.push(t7), a8 = s8 ? (function (e8, t8, r8, n7, i9) {
        for (var o9 = [], u9 = 0, f7 = t8.length; u9 < f7; ++u9) {
            ke(t8, String(u9)) ? o9.push(se(e8, t8, r8, n7, String(u9), !0)) : o9.push("");
        }
        return i9.forEach(function (i10) {
            i10.match(/^\d+$/) || o9.push(se(e8, t8, r8, n7, i10, !0));
        }), o9;
    })(e7, t7, r6, u8, o8) : o8.map(function (n7) {
        return se(e7, t7, r6, u8, n7, s8);
    }), e7.seen.pop(), (function (e8, t8, r8) {
        var n7 = 0;
        if (e8.reduce(function (e9, t9) {
            return (n7++, t9.indexOf("\n") >= 0 && n7++, e9 + t9.replace(/\u001b\[\d\d?m/g, "").length + 1);
        }, 0) > 60) {
            return r8[0] + ("" === t8 ? "" : t8 + "\n ") + " " + e8.join(",\n  ") + " " + r8[1];
        }
        return r8[0] + t8 + " " + e8.join(", ") + " " + r8[1];
    })(a8, c6, p7)) : p7[0] + c6 + p7[1];
}

function ce(e7) {
    return "[" + Error.prototype.toString.call(e7) + "]";
}

function se(e7, t7, r6, n7, i8, o8) {
    var u8, f7, a8;
    if ((a8 = Object.getOwnPropertyDescriptor(t7, i8) || {
        value: t7[i8]
    }).get ? f7 = a8.set ? e7.stylize("[Getter/Setter]", "special") : e7.stylize("[Getter]", "special") : a8.set && (f7 = e7.stylize("[Setter]", "special")), ke(n7, i8) || (u8 = "[" + i8 + "]"), f7 || (e7.seen.indexOf(a8.value) < 0 ? (f7 = le(r6) ? ae(e7, a8.value, null) : ae(e7, a8.value, r6 - 1)).indexOf("\n") > -1 && (f7 = o8 ? f7.split("\n").map(function (e8) {
        return "  " + e8;
    }).join("\n").substr(2) : "\n" + f7.split("\n").map(function (e8) {
        return "   " + e8;
    }).join("\n")) : f7 = e7.stylize("[Circular]", "special")), be(u8)) {
        if (o8 && i8.match(/^\d+$/)) {
            return f7;
        }
        (u8 = JSON.stringify("" + i8)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u8 = u8.substr(1, u8.length - 2), u8 = e7.stylize(u8, "name")) : (u8 = u8.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u8 = e7.stylize(u8, "string"));
    }
    return u8 + ": " + f7;
}

function pe(e7) {
    return Array.isArray(e7);
}

function ye(e7) {
    return "boolean" == typeof e7;
}

function le(e7) {
    return null === e7;
}

function de(e7) {
    return "number" == typeof e7;
}

function ge(e7) {
    return "string" == typeof e7;
}

function be(e7) {
    return (void 0) === e7;
}

function me(e7) {
    return he(e7) && "[object RegExp]" === ve(e7);
}

function he(e7) {
    return "object" == typeof e7 && null !== e7;
}

function je(e7) {
    return he(e7) && "[object Date]" === ve(e7);
}

function Ae(e7) {
    return he(e7) && ("[object Error]" === ve(e7) || e7 instanceof Error);
}

function we(e7) {
    return "function" == typeof e7;
}

function ve(e7) {
    return Object.prototype.toString.call(e7);
}

function Oe(e7) {
    return e7 < 10 ? "0" + e7.toString(10) : e7.toString(10);
}

X.debuglog = function (e7) {
    if (e7 = e7.toUpperCase(), !re[e7]) {
        if (ne.test(e7)) {
            var t7 = Y1.pid;
            re[e7] = function () {
                var r6 = X.format.apply(X, arguments);
                console.error("%s %d: %s", e7, t7, r6);
            };
        } else {
            re[e7] = function () {
            };
        }
    }
    return re[e7];
}, X.inspect = oe, oe.colors = {
    bold: [
        1,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    inverse: [
        7,
        27
    ],
    white: [
        37,
        39
    ],
    grey: [
        90,
        39
    ],
    black: [
        30,
        39
    ],
    blue: [
        34,
        39
    ],
    cyan: [
        36,
        39
    ],
    green: [
        32,
        39
    ],
    magenta: [
        35,
        39
    ],
    red: [
        31,
        39
    ],
    yellow: [
        33,
        39
    ]
}, oe.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    regexp: "red"
}, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function (e7) {
    return null == e7;
}, X.isNumber = de, X.isString = ge, X.isSymbol = function (e7) {
    return "symbol" == typeof e7;
}, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function (e7) {
    return null === e7 || "boolean" == typeof e7 || "number" == typeof e7 || "string" == typeof e7 || "symbol" == typeof e7 || (void 0) === e7;
}, X.isBuffer = i$12;
var Se = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
];

function Be() {
    var e7 = new Date, t8 = [
        Oe(e7.getHours()),
        Oe(e7.getMinutes()),
        Oe(e7.getSeconds())
    ].join(":");
    return [
        e7.getDate(),
        Se[e7.getMonth()],
        t8
    ].join(" ");
}

function ke(e7, t8) {
    return Object.prototype.hasOwnProperty.call(e7, t8);
}

X.log = function () {
    console.log("%s - %s", Be(), X.format.apply(X, arguments));
}, X.inherits = t$2, X._extend = function (e7, t8) {
    if (!t8 || !he(t8)) {
        return e7;
    }
    for (var r6 = Object.keys(t8), n7 = r6.length; n7--;) {
        e7[r6[n7]] = t8[r6[n7]];
    }
    return e7;
};
var Ee = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;

function De(e7, t8) {
    if (!e7) {
        var r6 = new Error("Promise was rejected with a falsy value");
        r6.reason = e7, e7 = r6;
    }
    return t8(e7);
}

X.promisify = function (e7) {
    if ("function" != typeof e7) {
        throw new TypeError('The "original" argument must be of type Function');
    }
    if (Ee && e7[Ee]) {
        var t8;
        if ("function" != typeof (t8 = e7[Ee])) {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        return Object.defineProperty(t8, Ee, {
            value: t8,
            enumerable: !1,
            writable: !1,
            configurable: !0
        }), t8;
    }

    function t8() {
        for (var t8, r8, n7 = new Promise(function (e8, n8) {
            t8 = e8, r8 = n8;
        }), i8 = [], o8 = 0; o8 < arguments.length; o8++) {
            i8.push(arguments[o8]);
        }
        i8.push(function (e8, n8) {
            e8 ? r8(e8) : t8(n8);
        });
        try {
            e7.apply(this || Q1, i8);
        } catch (e8) {
            r8(e8);
        }
        return n7;
    }

    return Object.setPrototypeOf(t8, Object.getPrototypeOf(e7)), Ee && Object.defineProperty(t8, Ee, {
        value: t8,
        enumerable: !1,
        writable: !1,
        configurable: !0
    }), Object.defineProperties(t8, ee1(e7));
}, X.promisify.custom = Ee, X.callbackify = function (e7) {
    if ("function" != typeof e7) {
        throw new TypeError('The "original" argument must be of type Function');
    }

    function t9() {
        for (var t9 = [], r8 = 0; r8 < arguments.length; r8++) {
            t9.push(arguments[r8]);
        }
        var n7 = t9.pop();
        if ("function" != typeof n7) {
            throw new TypeError("The last argument must be of type Function");
        }
        var i8 = this || Q1, o8 = function () {
            return n7.apply(i8, arguments);
        };
        e7.apply(this || Q1, t9).then(function (e8) {
            Y1.nextTick(o8.bind(null, null, e8));
        }, function (e8) {
            Y1.nextTick(De.bind(null, e8, o8));
        });
    }

    return Object.setPrototypeOf(t9, Object.getPrototypeOf(e7)), Object.defineProperties(t9, ee1(e7)), t9;
};

function e7(e8, r8) {
    if (null == e8) {
        throw new TypeError("Cannot convert first argument to object");
    }
    for (var t9 = Object(e8), n7 = 1; n7 < arguments.length; n7++) {
        var o8 = arguments[n7];
        if (null != o8) {
            for (var a8 = Object.keys(Object(o8)), l5 = 0, i8 = a8.length; l5 < i8; l5++) {
                var c6 = a8[l5], b2 = Object.getOwnPropertyDescriptor(o8, c6);
                (void 0) !== b2 && b2.enumerable && (t9[c6] = o8[c6]);
            }
        }
    }
    return t9;
}

var r8 = {
    assign: e7,
    polyfill: function () {
        Object.assign || Object.defineProperty(Object, "assign", {
            enumerable: !1,
            configurable: !0,
            writable: !0,
            value: e7
        });
    }
};
var t9, e$12 = Object.prototype.toString, r$11 = function (t10) {
    var r9 = e$12.call(t10), n7 = "[object Arguments]" === r9;
    return (n7 || (n7 = "[object Array]" !== r9 && null !== t10 && "object" == typeof t10 && "number" == typeof t10.length && t10.length >= 0 && "[object Function]" === e$12.call(t10.callee)), n7);
};
if (!Object.keys) {
    var n7 = Object.prototype.hasOwnProperty, o9 = Object.prototype.toString, c7 = r$11,
            l6 = Object.prototype.propertyIsEnumerable, i9 = !l6.call({
                toString: null
            }, "toString"), a9 = l6.call(function () {
            }, "prototype"), u8 = [
                "toString",
                "toLocaleString",
                "valueOf",
                "hasOwnProperty",
                "isPrototypeOf",
                "propertyIsEnumerable",
                "constructor"
            ], f7 = function (t10) {
                var e8 = t10.constructor;
                return e8 && e8.prototype === t10;
            }, p7 = {
                $applicationCache: !0,
                $console: !0,
                $external: !0,
                $frame: !0,
                $frameElement: !0,
                $frames: !0,
                $innerHeight: !0,
                $innerWidth: !0,
                $onmozfullscreenchange: !0,
                $onmozfullscreenerror: !0,
                $outerHeight: !0,
                $outerWidth: !0,
                $pageXOffset: !0,
                $pageYOffset: !0,
                $parent: !0,
                $scrollLeft: !0,
                $scrollTop: !0,
                $scrollX: !0,
                $scrollY: !0,
                $self: !0,
                $webkitIndexedDB: !0,
                $webkitStorageInfo: !0,
                $window: !0
            }, s8 = function () {
                if ("undefined" == typeof window) {
                    return !1;
                }
                for (var t10 in window) {
                    try {
                        if (!p7["$" + t10] && n7.call(window, t10) && null !== window[t10] && "object" == typeof window[t10]) {
                            try {
                                f7(window[t10]);
                            } catch (t11) {
                                return !0;
                            }
                        }
                    } catch (t11) {
                        return !0;
                    }
                }
                return !1;
            }();
    t9 = function (t10) {
        var e8 = null !== t10 && "object" == typeof t10, r9 = "[object Function]" === o9.call(t10), l7 = c7(t10),
                p8 = e8 && "[object String]" === o9.call(t10), y4 = [];
        if (!e8 && !r9 && !l7) {
            throw new TypeError("Object.keys called on a non-object");
        }
        var b3 = a9 && r9;
        if (p8 && t10.length > 0 && !n7.call(t10, 0)) {
            for (var g2 = 0; g2 < t10.length; ++g2) {
                y4.push(String(g2));
            }
        }
        if (l7 && t10.length > 0) {
            for (var h5 = 0; h5 < t10.length; ++h5) {
                y4.push(String(h5));
            }
        } else {
            for (var $1 in t10) {
                b3 && "prototype" === $1 || !n7.call(t10, $1) || y4.push(String($1));
            }
        }
        if (i9) {
            for (var j2 = function (t11) {
                if ("undefined" == typeof window || !s8) {
                    return f7(t11);
                }
                try {
                    return f7(t11);
                } catch (t12) {
                    return !1;
                }
            }(t10), w2 = 0; w2 < u8.length; ++w2) {
                j2 && "constructor" === u8[w2] || !n7.call(t10, u8[w2]) || y4.push(u8[w2]);
            }
        }
        return y4;
    };
}
var y4 = t9, b3 = Array.prototype.slice, g2 = r$11, h5 = Object.keys, $1 = h5 ? function (t10) {
    return h5(t10);
} : y4, j2 = Object.keys;
$1.shim = function () {
    Object.keys ? (function () {
        var t10 = Object.keys(arguments);
        return t10 && t10.length === arguments.length;
    })(1, 2) || (Object.keys = function (t10) {
        return g2(t10) ? j2(b3.call(t10)) : j2(t10);
    }) : Object.keys = $1;
    return Object.keys || $1;
};
var w2 = $1;
var r$2 = w2, e$2 = "function" == typeof Symbol && "symbol" == typeof Symbol("foo"), o$12 = Object.prototype.toString,
        n$12 = Array.prototype.concat, a$11 = Object.defineProperty, c$12 = a$11 && function () {
            var t10 = {};
            try {
                for (var r9 in a$11(t10, "x", {
                    enumerable: !1,
                    value: t10
                }), t10) {
                    return !1;
                }
                return t10.x === t10;
            } catch (t11) {
                return !1;
            }
        }(), l$11 = function (t10, r9, e8, n8) {
            var l7;
            (!(r9 in t10) || "function" == typeof (l7 = n8) && "[object Function]" === o$12.call(l7) && n8()) && (c$12 ? a$11(t10, r9, {
                configurable: !0,
                enumerable: !1,
                value: e8,
                writable: !0
            }) : t10[r9] = e8);
        }, u$12 = function (t10, o10) {
            var a10 = arguments.length > 2 ? arguments[2] : {}, c8 = r$2(o10);
            e$2 && (c8 = n$12.call(c8, Object.getOwnPropertySymbols(o10)));
            for (var u9 = 0; u9 < c8.length; u9 += 1) {
                l$11(t10, c8[u9], o10[c8[u9]], a10[c8[u9]]);
            }
        };
u$12.supportsDescriptors = !!c$12;
var f$11 = u$12;
var t$11 = function () {
    if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) {
        return !1;
    }
    if ("symbol" == typeof Symbol.iterator) {
        return !0;
    }
    var t10 = {}, e8 = Symbol("test"), r9 = Object(e8);
    if ("string" == typeof e8) {
        return !1;
    }
    if ("[object Symbol]" !== Object.prototype.toString.call(e8)) {
        return !1;
    }
    if ("[object Symbol]" !== Object.prototype.toString.call(r9)) {
        return !1;
    }
    for (e8 in (t10[e8] = 42, t10)) {
        return !1;
    }
    if ("function" == typeof Object.keys && 0 !== Object.keys(t10).length) {
        return !1;
    }
    if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t10).length) {
        return !1;
    }
    var o10 = Object.getOwnPropertySymbols(t10);
    if (1 !== o10.length || o10[0] !== e8) {
        return !1;
    }
    if (!Object.prototype.propertyIsEnumerable.call(t10, e8)) {
        return !1;
    }
    if ("function" == typeof Object.getOwnPropertyDescriptor) {
        var n8 = Object.getOwnPropertyDescriptor(t10, e8);
        if (42 !== n8.value || !0 !== n8.enumerable) {
            return !1;
        }
    }
    return !0;
};
var f$2 = ("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global).Symbol,
        e$3 = t$11, l$2 = function () {
            return "function" == typeof f$2 && "function" == typeof Symbol && "symbol" == typeof f$2("foo") && "symbol" == typeof Symbol("bar") && e$3();
        };
var t$21 = "Function.prototype.bind called on incompatible ", n$2 = Array.prototype.slice,
        o$21 = Object.prototype.toString, r$3 = function (r9) {
            var e8 = this;
            if ("function" != typeof e8 || "[object Function]" !== o$21.call(e8)) {
                throw new TypeError(t$21 + e8);
            }
            for (var p8, i10 = n$2.call(arguments, 1), c8 = function () {
                if (this instanceof p8) {
                    var t10 = e8.apply(this, i10.concat(n$2.call(arguments)));
                    return Object(t10) === t10 ? t10 : this;
                }
                return e8.apply(r9, i10.concat(n$2.call(arguments)));
            }, a10 = Math.max(0, e8.length - i10.length), l7 = [], u9 = 0; u9 < a10; u9++) {
                l7.push("$" + u9);
            }
            if ((p8 = Function("binder", "return function (" + l7.join(",") + "){ return binder.apply(this,arguments); }")(c8), e8.prototype)) {
                var y5 = function () {
                };
                y5.prototype = e8.prototype, p8.prototype = new y5, y5.prototype = null;
            }
            return p8;
        }, e$4 = Function.prototype.bind || r$3;
var o$3 = TypeError, t$3 = Object.getOwnPropertyDescriptor;
if (t$3) {
    try {
        t$3({}, "");
    } catch (r9) {
        t$3 = null;
    }
}
var n$3 = function () {
            throw new o$3;
        }, y$1 = t$3 ? function () {
            try {
                return arguments.callee, n$3;
            } catch (r9) {
                try {
                    return t$3(arguments, "callee").get;
                } catch (r10) {
                    return n$3;
                }
            }
        }() : n$3, a$21 = l$2(), i$11 = Object.getPrototypeOf || function (r9) {
            return r9.__proto__;
        }, d3 = "undefined" == typeof Uint8Array ? void 0 : i$11(Uint8Array), f$3 = {
            "%Array%": Array,
            "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer,
            "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype,
            "%ArrayIteratorPrototype%": a$21 ? i$11([][Symbol.iterator]()) : void 0,
            "%ArrayPrototype%": Array.prototype,
            "%ArrayProto_entries%": Array.prototype.entries,
            "%ArrayProto_forEach%": Array.prototype.forEach,
            "%ArrayProto_keys%": Array.prototype.keys,
            "%ArrayProto_values%": Array.prototype.values,
            "%AsyncFromSyncIteratorPrototype%": void 0,
            "%AsyncFunction%": void 0,
            "%AsyncFunctionPrototype%": void 0,
            "%AsyncGenerator%": void 0,
            "%AsyncGeneratorFunction%": void 0,
            "%AsyncGeneratorPrototype%": void 0,
            "%AsyncIteratorPrototype%": void 0,
            "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics,
            "%Boolean%": Boolean,
            "%BooleanPrototype%": Boolean.prototype,
            "%DataView%": "undefined" == typeof DataView ? void 0 : DataView,
            "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype,
            "%Date%": Date,
            "%DatePrototype%": Date.prototype,
            "%decodeURI%": decodeURI,
            "%decodeURIComponent%": decodeURIComponent,
            "%encodeURI%": encodeURI,
            "%encodeURIComponent%": encodeURIComponent,
            "%Error%": Error,
            "%ErrorPrototype%": Error.prototype,
            "%eval%": eval,
            "%EvalError%": EvalError,
            "%EvalErrorPrototype%": EvalError.prototype,
            "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array,
            "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype,
            "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array,
            "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype,
            "%Function%": Function,
            "%FunctionPrototype%": Function.prototype,
            "%Generator%": void 0,
            "%GeneratorFunction%": void 0,
            "%GeneratorPrototype%": void 0,
            "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array,
            "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype,
            "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array,
            "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype,
            "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array,
            "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype,
            "%isFinite%": isFinite,
            "%isNaN%": isNaN,
            "%IteratorPrototype%": a$21 ? i$11(i$11([][Symbol.iterator]())) : void 0,
            "%JSON%": "object" == typeof JSON ? JSON : void 0,
            "%JSONParse%": "object" == typeof JSON ? JSON.parse : void 0,
            "%Map%": "undefined" == typeof Map ? void 0 : Map,
            "%MapIteratorPrototype%": "undefined" != typeof Map && a$21 ? i$11((new Map)[Symbol.iterator]()) : void 0,
            "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype,
            "%Math%": Math,
            "%Number%": Number,
            "%NumberPrototype%": Number.prototype,
            "%Object%": Object,
            "%ObjectPrototype%": Object.prototype,
            "%ObjProto_toString%": Object.prototype.toString,
            "%ObjProto_valueOf%": Object.prototype.valueOf,
            "%parseFloat%": parseFloat,
            "%parseInt%": parseInt,
            "%Promise%": "undefined" == typeof Promise ? void 0 : Promise,
            "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype,
            "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then,
            "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all,
            "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject,
            "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve,
            "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy,
            "%RangeError%": RangeError,
            "%RangeErrorPrototype%": RangeError.prototype,
            "%ReferenceError%": ReferenceError,
            "%ReferenceErrorPrototype%": ReferenceError.prototype,
            "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect,
            "%RegExp%": RegExp,
            "%RegExpPrototype%": RegExp.prototype,
            "%Set%": "undefined" == typeof Set ? void 0 : Set,
            "%SetIteratorPrototype%": "undefined" != typeof Set && a$21 ? i$11((new Set)[Symbol.iterator]()) : void 0,
            "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype,
            "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer,
            "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype,
            "%String%": String,
            "%StringIteratorPrototype%": a$21 ? i$11(""[Symbol.iterator]()) : void 0,
            "%StringPrototype%": String.prototype,
            "%Symbol%": a$21 ? Symbol : void 0,
            "%SymbolPrototype%": a$21 ? Symbol.prototype : void 0,
            "%SyntaxError%": SyntaxError,
            "%SyntaxErrorPrototype%": SyntaxError.prototype,
            "%ThrowTypeError%": y$1,
            "%TypedArray%": d3,
            "%TypedArrayPrototype%": d3 ? d3.prototype : void 0,
            "%TypeError%": o$3,
            "%TypeErrorPrototype%": o$3.prototype,
            "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array,
            "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype,
            "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray,
            "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype,
            "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array,
            "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype,
            "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array,
            "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype,
            "%URIError%": URIError,
            "%URIErrorPrototype%": URIError.prototype,
            "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap,
            "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype,
            "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet,
            "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype
        }, u$2 = e$4.call(Function.call, String.prototype.replace),
        A2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
        l$3 = /\\(\\)?/g, v5 = function (r9) {
            var e8 = [];
            return (u$2(r9, A2, function (r10, o10, t11, n9) {
                e8[e8.length] = t11 ? u$2(n9, l$3, "$1") : o10 || r10;
            }), e8);
        }, P3 = function (r9, e8) {
            if (!(r9 in f$3)) {
                throw new SyntaxError("intrinsic " + r9 + " does not exist!");
            }
            if ((void 0) === f$3[r9] && !e8) {
                throw new o$3("intrinsic " + r9 + " exists, but is not available. Please file an issue!");
            }
            return f$3[r9];
        }, c$2 = function (r9, e8) {
            if ("string" != typeof r9 || 0 === r9.length) {
                throw new TypeError("intrinsic name must be a non-empty string");
            }
            if (arguments.length > 1 && "boolean" != typeof e8) {
                throw new TypeError('"allowMissing" argument must be a boolean');
            }
            for (var n9 = v5(r9), y6 = P3("%" + (n9.length > 0 ? n9[0] : "") + "%", e8), a10 = 1; a10 < n9.length; a10 += 1) {
                if (null != y6) {
                    if (t$3 && a10 + 1 >= n9.length) {
                        var i10 = t$3(y6, n9[a10]);
                        if (!e8 && !(n9[a10] in y6)) {
                            throw new o$3("base intrinsic for " + r9 + " exists, but the property is not available.");
                        }
                        y6 = i10 ? i10.get || i10.value : y6[n9[a10]];
                    } else {
                        y6 = y6[n9[a10]];
                    }
                }
            }
            return y6;
        };
var t$4, p$1 = e$4, o$4 = c$2("%Function%"), i$2 = o$4.apply, a$3 = o$4.call;
(t$4 = function () {
    return p$1.apply(a$3, arguments);
}).apply = function () {
    return p$1.apply(i$2, arguments);
};
var l$4 = t$4;
var r$4, n$4, i$3 = function (t11) {
    return t11 != t11;
}, o$5 = (r$4 = function (t11, e8) {
    return 0 === t11 && 0 === e8 ? 1 / t11 == 1 / e8 : t11 === e8 || !(!i$3(t11) || !i$3(e8));
}, r$4), c$3 = (n$4 = function () {
    return "function" == typeof Object.is ? Object.is : o$5;
}, n$4), f$4 = f$11, u$3 = f$11, s$1 = r$4, a$4 = n$4, l$5 = function () {
    var t11 = c$3();
    return (f$4(Object, {
        is: t11
    }, {
        is: function () {
            return Object.is !== t11;
        }
    }), t11);
}, p$2 = l$4(a$4(), Object);
u$3(p$2, {
    getPolyfill: a$4,
    implementation: s$1,
    shim: l$5
});
var m3 = p$2;
N3 = function (r9) {
    return r9 != r9;
};
var N3, e$5, i$4 = N3, n$5 = (e$5 = function () {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : i$4;
}, f$11), t$5 = e$5, u$4 = f$11, a$5 = N3, m$11 = e$5, o$6 = function () {
    var r9 = t$5();
    return (n$5(Number, {
        isNaN: r9
    }, {
        isNaN: function () {
            return Number.isNaN !== r9;
        }
    }), r9);
}, s$2 = m$11();
u$4(s$2, {
    getPolyfill: m$11,
    implementation: a$5,
    shim: o$6
});
var f$5 = s$2;
var c$4 = {}, a$6 = !1;

function i$5() {
    if (a$6) {
        return c$4;
    }

    function e8(t11) {
        return (e8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t12) {
            return typeof t12;
        } : function (t12) {
            return t12 && "function" == typeof Symbol && t12.constructor === Symbol && t12 !== Symbol.prototype ? "symbol" : typeof t12;
        })(t11);
    }

    function n9(t11, n10) {
        return !n10 || "object" !== e8(n10) && "function" != typeof n10 ? (function (t12) {
            if ((void 0) === t12) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return t12;
        })(t11) : n10;
    }

    function r9(t11) {
        return (r9 = Object.setPrototypeOf ? Object.getPrototypeOf : function (t12) {
            return t12.__proto__ || Object.getPrototypeOf(t12);
        })(t11);
    }

    function o10(t11, e9) {
        return (o10 = Object.setPrototypeOf || function (t12, e10) {
            return t12.__proto__ = e10, t12;
        })(t11, e9);
    }

    a$6 = !0;
    var i11, u9, l7 = {};

    function f8(t11, e9, c8) {
        c8 || (c8 = Error);
        var a10 = function (c9) {
            function a10(o11, c10, i12) {
                var u10;
                return !function (t12, e10) {
                    if (!(t12 instanceof e10)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }(this, a10), (u10 = n9(this, r9(a10).call(this, function (t12, n10, r10) {
                    return "string" == typeof e9 ? e9 : e9(t12, n10, r10);
                }(o11, c10, i12)))).code = t11, u10;
            }

            return !function (t12, e10) {
                if ("function" != typeof e10 && null !== e10) {
                    throw new TypeError("Super expression must either be null or a function");
                }
                t12.prototype = Object.create(e10 && e10.prototype, {
                    constructor: {
                        value: t12,
                        writable: !0,
                        configurable: !0
                    }
                }), e10 && o10(t12, e10);
            }(a10, c9), a10;
        }(c8);
        l7[t11] = a10;
    }

    function s9(t11, e9) {
        if (Array.isArray(t11)) {
            var n10 = t11.length;
            return t11 = t11.map(function (t12) {
                return String(t12);
            }), n10 > 2 ? "one of ".concat(e9, " ").concat(t11.slice(0, n10 - 1).join(", "), ", or ") + t11[n10 - 1] : 2 === n10 ? "one of ".concat(e9, " ").concat(t11[0], " or ").concat(t11[1]) : "of ".concat(e9, " ").concat(t11[0]);
        }
        return "of ".concat(e9, " ").concat(String(t11));
    }

    return f8("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), f8("ERR_INVALID_ARG_TYPE", function (t11, n11, r10) {
        var o11, c8, u10;
        if (((void 0) === i11 && (i11 = tt()), i11("string" == typeof t11, "'name' must be a string"), "string" == typeof n11 && (c8 = "not ", n11.substr(0, c8.length) === c8) ? (o11 = "must not be", n11 = n11.replace(/^not /, "")) : o11 = "must be", function (t12, e9, n12) {
            return ((void 0) === n12 || n12 > t12.length) && (n12 = t12.length), t12.substring(n12 - e9.length, n12) === e9;
        }(t11, " argument"))) {
            u10 = "The ".concat(t11, " ").concat(o11, " ").concat(s9(n11, "type"));
        } else {
            var l8 = function (t12, e9, n12) {
                return "number" != typeof n12 && (n12 = 0), !(n12 + e9.length > t12.length) && -1 !== t12.indexOf(e9, n12);
            }(t11, ".") ? "property" : "argument";
            u10 = 'The "'.concat(t11, '" ').concat(l8, " ").concat(o11, " ").concat(s9(n11, "type"));
        }
        return u10 += ". Received type ".concat(e8(r10));
    }, TypeError), f8("ERR_INVALID_ARG_VALUE", function (e9, n11) {
        var r10 = arguments.length > 2 && (void 0) !== arguments[2] ? arguments[2] : "is invalid";
        (void 0) === u9 && (u9 = X);
        var o11 = u9.inspect(n11);
        return (o11.length > 128 && (o11 = "".concat(o11.slice(0, 128), "...")), "The argument '".concat(e9, "' ").concat(r10, ". Received ").concat(o11));
    }, TypeError), f8("ERR_INVALID_RETURN_VALUE", function (t11, n11, r10) {
        var o11;
        return (o11 = r10 && r10.constructor && r10.constructor.name ? "instance of ".concat(r10.constructor.name) : "type ".concat(e8(r10)), "Expected ".concat(t11, ' to be returned from the "').concat(n11, '"') + " function but got ".concat(o11, "."));
    }, TypeError), f8("ERR_MISSING_ARGS", function () {
        for (var t11 = arguments.length, e9 = new Array(t11), n11 = 0; n11 < t11; n11++) {
            e9[n11] = arguments[n11];
        }
        (void 0) === i11 && (i11 = tt()), i11(e9.length > 0, "At least one arg needs to be specified");
        var r10 = "The ", o11 = e9.length;
        switch ((e9 = e9.map(function (t12) {
            return '"'.concat(t12, '"');
        }), o11)) {
            case 1:
                r10 += "".concat(e9[0], " argument");
                break;
            case 2:
                r10 += "".concat(e9[0], " and ").concat(e9[1], " arguments");
                break;
            default:
                r10 += e9.slice(0, o11 - 1).join(", "), r10 += ", and ".concat(e9[o11 - 1], " arguments");
        }
        return "".concat(r10, " must be specified");
    }, TypeError), c$4.codes = l7, c$4;
}

var u$5 = {}, l$6 = !1;

function f$6() {
    if (l$6) {
        return u$5;
    }
    l$6 = !0;
    var n9 = T1;

    function r9(t11, e8, n11) {
        return e8 in t11 ? Object.defineProperty(t11, e8, {
            value: n11,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t11[e8] = n11, t11;
    }

    function o10(t11, e8) {
        for (var n11 = 0; n11 < e8.length; n11++) {
            var r10 = e8[n11];
            r10.enumerable = r10.enumerable || !1, r10.configurable = !0, "value" in r10 && (r10.writable = !0), Object.defineProperty(t11, r10.key, r10);
        }
    }

    function c8(t11, e8) {
        return !e8 || "object" !== y6(e8) && "function" != typeof e8 ? a11(t11) : e8;
    }

    function a11(t11) {
        if ((void 0) === t11) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return t11;
    }

    function f8(t11) {
        var e8 = "function" == typeof Map ? new Map : void 0;
        return (f8 = function (t12) {
            if (null === t12 || (n11 = t12, -1 === Function.toString.call(n11).indexOf("[native code]"))) {
                return t12;
            }
            var n11;
            if ("function" != typeof t12) {
                throw new TypeError("Super expression must either be null or a function");
            }
            if ((void 0) !== e8) {
                if (e8.has(t12)) {
                    return e8.get(t12);
                }
                e8.set(t12, r12);
            }

            function r12() {
                return p8(t12, arguments, h7(this).constructor);
            }

            return r12.prototype = Object.create(t12.prototype, {
                constructor: {
                    value: r12,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), g4(r12, t12);
        })(t11);
    }

    function s9() {
        if ("undefined" == typeof Reflect || !Reflect.construct) {
            return !1;
        }
        if (Reflect.construct.sham) {
            return !1;
        }
        if ("function" == typeof Proxy) {
            return !0;
        }
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
            })), !0;
        } catch (t11) {
            return !1;
        }
    }

    function p8(t11, e8, n11) {
        return (p8 = s9() ? Reflect.construct : function (t12, e9, n12) {
            var r12 = [
                null
            ];
            r12.push.apply(r12, e9);
            var o11 = new (Function.bind.apply(t12, r12));
            return n12 && g4(o11, n12.prototype), o11;
        }).apply(null, arguments);
    }

    function g4(t11, e8) {
        return (g4 = Object.setPrototypeOf || function (t12, e9) {
            return t12.__proto__ = e9, t12;
        })(t11, e8);
    }

    function h7(t11) {
        return (h7 = Object.setPrototypeOf ? Object.getPrototypeOf : function (t12) {
            return t12.__proto__ || Object.getPrototypeOf(t12);
        })(t11);
    }

    function y6(t11) {
        return (y6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t12) {
            return typeof t12;
        } : function (t12) {
            return t12 && "function" == typeof Symbol && t12.constructor === Symbol && t12 !== Symbol.prototype ? "symbol" : typeof t12;
        })(t11);
    }

    var b4 = X.inspect, v6 = i$5().codes.ERR_INVALID_ARG_TYPE;

    function d4(t11, e8, n11) {
        return ((void 0) === n11 || n11 > t11.length) && (n11 = t11.length), t11.substring(n11 - e8.length, n11) === e8;
    }

    var m4 = "", E3 = "", w3 = "", S2 = "", j3 = {
        deepStrictEqual: "Expected values to be strictly deep-equal:",
        strictEqual: "Expected values to be strictly equal:",
        strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
        deepEqual: "Expected values to be loosely deep-equal:",
        equal: "Expected values to be loosely equal:",
        notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
        notStrictEqual: 'Expected "actual" to be strictly unequal to:',
        notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
        notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
        notEqual: 'Expected "actual" to be loosely unequal to:',
        notIdentical: "Values identical but not reference-equal:"
    };

    function O2(t11) {
        var e8 = Object.keys(t11), n11 = Object.create(Object.getPrototypeOf(t11));
        return e8.forEach(function (e9) {
            n11[e9] = t11[e9];
        }), Object.defineProperty(n11, "message", {
            value: t11.message
        }), n11;
    }

    function x3(t11) {
        return b4(t11, {
            compact: !1,
            customInspect: !1,
            depth: 1000,
            maxArrayLength: 1 / 0,
            showHidden: !1,
            breakLength: 1 / 0,
            showProxy: !1,
            sorted: !0,
            getters: !0
        });
    }

    function q1(t11, e8, r12) {
        var o11 = "", c9 = "", a12 = 0, i11 = "", u9 = !1, l7 = x3(t11), f9 = l7.split("\n"), s10 = x3(e8).split("\n"),
                p9 = 0, g5 = "";
        if ("strictEqual" === r12 && "object" === y6(t11) && "object" === y6(e8) && null !== t11 && null !== e8 && (r12 = "strictEqualObject"), 1 === f9.length && 1 === s10.length && f9[0] !== s10[0]) {
            var h8 = f9[0].length + s10[0].length;
            if (h8 <= 10) {
                if (!("object" === y6(t11) && null !== t11 || "object" === y6(e8) && null !== e8 || 0 === t11 && 0 === e8)) {
                    return "".concat(j3[r12], "\n\n") + "".concat(f9[0], " !== ").concat(s10[0], "\n");
                }
            } else if ("strictEqualObject" !== r12) {
                if (h8 < (n9.stderr && n9.stderr.isTTY ? n9.stderr.columns : 80)) {
                    for (; f9[0][p9] === s10[0][p9];) {
                        p9++;
                    }
                    p9 > 2 && (g5 = "\n  ".concat(function (t12, e9) {
                        if (e9 = Math.floor(e9), 0 == t12.length || 0 == e9) {
                            return "";
                        }
                        var n11 = t12.length * e9;
                        for (e9 = Math.floor(Math.log(e9) / Math.log(2)); e9;) {
                            t12 += t12, e9--;
                        }
                        return t12 += t12.substring(0, n11 - t12.length);
                    }(" ", p9), "^"), p9 = 0);
                }
            }
        }
        for (var b5 = f9[f9.length - 1], v7 = s10[s10.length - 1]; b5 === v7 && ((p9++) < 2 ? i11 = "\n  ".concat(b5).concat(i11) : o11 = b5, f9.pop(), s10.pop(), 0 !== f9.length && 0 !== s10.length);) {
            b5 = f9[f9.length - 1], v7 = s10[s10.length - 1];
        }
        var O3 = Math.max(f9.length, s10.length);
        if (0 === O3) {
            var q1 = l7.split("\n");
            if (q1.length > 30) {
                for (q1[26] = "".concat(m4, "...").concat(S2); q1.length > 27;) {
                    q1.pop();
                }
            }
            return "".concat(j3.notIdentical, "\n\n").concat(q1.join("\n"), "\n");
        }
        p9 > 3 && (i11 = "\n".concat(m4, "...").concat(S2).concat(i11), u9 = !0), "" !== o11 && (i11 = "\n  ".concat(o11).concat(i11), o11 = "");
        var R2 = 0, A3 = j3[r12] + "\n".concat(E3, "+ actual").concat(S2, " ").concat(w3, "- expected").concat(S2),
                k3 = " ".concat(m4, "...").concat(S2, " Lines skipped");
        for (p9 = 0; p9 < O3; p9++) {
            var _2 = p9 - a12;
            if (f9.length < p9 + 1) {
                _2 > 1 && p9 > 2 && (_2 > 4 ? (c9 += "\n".concat(m4, "...").concat(S2), u9 = !0) : _2 > 3 && (c9 += "\n  ".concat(s10[p9 - 2]), R2++), c9 += "\n  ".concat(s10[p9 - 1]), R2++), a12 = p9, o11 += "\n".concat(w3, "-").concat(S2, " ").concat(s10[p9]), R2++;
            } else if (s10.length < p9 + 1) {
                _2 > 1 && p9 > 2 && (_2 > 4 ? (c9 += "\n".concat(m4, "...").concat(S2), u9 = !0) : _2 > 3 && (c9 += "\n  ".concat(f9[p9 - 2]), R2++), c9 += "\n  ".concat(f9[p9 - 1]), R2++), a12 = p9, c9 += "\n".concat(E3, "+").concat(S2, " ").concat(f9[p9]), R2++;
            } else {
                var T4 = s10[p9], P4 = f9[p9], I3 = P4 !== T4 && (!d4(P4, ",") || P4.slice(0, -1) !== T4);
                I3 && d4(T4, ",") && T4.slice(0, -1) === P4 && (I3 = !1, P4 += ","), I3 ? (_2 > 1 && p9 > 2 && (_2 > 4 ? (c9 += "\n".concat(m4, "...").concat(S2), u9 = !0) : _2 > 3 && (c9 += "\n  ".concat(f9[p9 - 2]), R2++), c9 += "\n  ".concat(f9[p9 - 1]), R2++), a12 = p9, c9 += "\n".concat(E3, "+").concat(S2, " ").concat(P4), o11 += "\n".concat(w3, "-").concat(S2, " ").concat(T4), R2 += 2) : (c9 += o11, o11 = "", 1 !== _2 && 0 !== p9 || (c9 += "\n  ".concat(P4), R2++));
            }
            if (R2 > 20 && p9 < O3 - 2) {
                return "".concat(A3).concat(k3, "\n").concat(c9, "\n").concat(m4, "...").concat(S2).concat(o11, "\n") + "".concat(m4, "...").concat(S2);
            }
        }
        return "".concat(A3).concat(u9 ? k3 : "", "\n").concat(c9).concat(o11).concat(i11).concat(g5);
    }

    var R2 = function (t11) {
        function e8(t12) {
            var r12;
            if (!function (t13, e9) {
                if (!(t13 instanceof e9)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }(this, e8), "object" !== y6(t12) || null === t12) {
                throw new v6("options", "Object", t12);
            }
            var o11 = t12.message, i11 = t12.operator, u9 = t12.stackStartFn, l7 = t12.actual, f9 = t12.expected,
                    s10 = Error.stackTraceLimit;
            if (Error.stackTraceLimit = 0, null != o11) {
                r12 = c8(this, h7(e8).call(this, String(o11)));
            } else if (n9.stderr && n9.stderr.isTTY && (n9.stderr && n9.stderr.getColorDepth && 1 !== n9.stderr.getColorDepth() ? (m4 = "[34m", E3 = "[32m", S2 = "[39m", w3 = "[31m") : (m4 = "", E3 = "", S2 = "", w3 = "")), "object" === y6(l7) && null !== l7 && "object" === y6(f9) && null !== f9 && "stack" in l7 && l7 instanceof Error && "stack" in f9 && f9 instanceof Error && (l7 = O2(l7), f9 = O2(f9)), "deepStrictEqual" === i11 || "strictEqual" === i11) {
                r12 = c8(this, h7(e8).call(this, q1(l7, f9, i11)));
            } else if ("notDeepStrictEqual" === i11 || "notStrictEqual" === i11) {
                var p9 = j3[i11], g5 = x3(l7).split("\n");
                if ("notStrictEqual" === i11 && "object" === y6(l7) && null !== l7 && (p9 = j3.notStrictEqualObject), g5.length > 30) {
                    for (g5[26] = "".concat(m4, "...").concat(S2); g5.length > 27;) {
                        g5.pop();
                    }
                }
                r12 = 1 === g5.length ? c8(this, h7(e8).call(this, "".concat(p9, " ").concat(g5[0]))) : c8(this, h7(e8).call(this, "".concat(p9, "\n\n").concat(g5.join("\n"), "\n")));
            } else {
                var b5 = x3(l7), d5 = "", R3 = j3[i11];
                "notDeepEqual" === i11 || "notEqual" === i11 ? (b5 = "".concat(j3[i11], "\n\n").concat(b5)).length > 1024 && (b5 = "".concat(b5.slice(0, 1021), "...")) : (d5 = "".concat(x3(f9)), b5.length > 512 && (b5 = "".concat(b5.slice(0, 509), "...")), d5.length > 512 && (d5 = "".concat(d5.slice(0, 509), "...")), "deepEqual" === i11 || "equal" === i11 ? b5 = "".concat(R3, "\n\n").concat(b5, "\n\nshould equal\n\n") : d5 = " ".concat(i11, " ").concat(d5)), r12 = c8(this, h7(e8).call(this, "".concat(b5).concat(d5)));
            }
            return Error.stackTraceLimit = s10, r12.generatedMessage = !o11, Object.defineProperty(a11(r12), "name", {
                value: "AssertionError [ERR_ASSERTION]",
                enumerable: !1,
                writable: !0,
                configurable: !0
            }), r12.code = "ERR_ASSERTION", r12.actual = l7, r12.expected = f9, r12.operator = i11, Error.captureStackTrace && Error.captureStackTrace(a11(r12), u9), r12.stack, r12.name = "AssertionError", c8(r12);
        }

        var i11, u9;
        return !function (t12, e9) {
            if ("function" != typeof e9 && null !== e9) {
                throw new TypeError("Super expression must either be null or a function");
            }
            t12.prototype = Object.create(e9 && e9.prototype, {
                constructor: {
                    value: t12,
                    writable: !0,
                    configurable: !0
                }
            }), e9 && g4(t12, e9);
        }(e8, t11), i11 = e8, (u9 = [
            {
                key: "toString",
                value: function () {
                    return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                }
            },
            {
                key: b4.custom,
                value: function (t12, e9) {
                    return b4(this, function (t13) {
                        for (var e10 = 1; e10 < arguments.length; e10++) {
                            var n11 = null != arguments[e10] ? arguments[e10] : {}, o11 = Object.keys(n11);
                            "function" == typeof Object.getOwnPropertySymbols && (o11 = o11.concat(Object.getOwnPropertySymbols(n11).filter(function (t14) {
                                return Object.getOwnPropertyDescriptor(n11, t14).enumerable;
                            }))), o11.forEach(function (e11) {
                                r9(t13, e11, n11[e11]);
                            });
                        }
                        return t13;
                    }({}, e9, {
                        customInspect: !1,
                        depth: 0
                    }));
                }
            }
        ]) && o10(i11.prototype, u9), e8;
    }(f8(Error));
    return u$5 = R2;
}

function s$3(t11, e8) {
    return (function (t12) {
        if (Array.isArray(t12)) {
            return t12;
        }
    })(t11) || (function (t12, e9) {
        var n9 = [], r9 = !0, o10 = !1, c8 = void 0;
        try {
            for (var a11, i11 = t12[Symbol.iterator](); !(r9 = (a11 = i11.next()).done) && (n9.push(a11.value), !e9 || n9.length !== e9); r9 = !0) {
                ;
            }
        } catch (t13) {
            o10 = !0, c8 = t13;
        } finally {
            try {
                r9 || null == i11.return || i11.return();
            } finally {
                if (o10) {
                    throw c8;
                }
            }
        }
        return n9;
    })(t11, e8) || (function () {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
    })();
}

function p$3(t11) {
    return (p$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t12) {
        return typeof t12;
    } : function (t12) {
        return t12 && "function" == typeof Symbol && t12.constructor === Symbol && t12 !== Symbol.prototype ? "symbol" : typeof t12;
    })(t11);
}

var g$1 = (void 0) !== /a/g.flags, h$11 = function (t11) {
    var e8 = [];
    return (t11.forEach(function (t12) {
        return e8.push(t12);
    }), e8);
}, y$2 = function (t11) {
    var e8 = [];
    return (t11.forEach(function (t12, n9) {
        return e8.push([
            n9,
            t12
        ]);
    }), e8);
}, b$1 = Object.is ? Object.is : m3, v$11 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
    return [];
}, d$1 = Number.isNaN ? Number.isNaN : f$5;

function m$21(t11) {
    return t11.call.bind(t11);
}

var E3 = m$21(Object.prototype.hasOwnProperty), w$1 = m$21(Object.prototype.propertyIsEnumerable),
        S2 = m$21(Object.prototype.toString), j$1 = X.types, O2 = j$1.isAnyArrayBuffer, x3 = j$1.isArrayBufferView,
        q1 = j$1.isDate, R2 = j$1.isMap, A$1 = j$1.isRegExp, k3 = j$1.isSet, _3 = j$1.isNativeError,
        T5 = j$1.isBoxedPrimitive, P$1 = j$1.isNumberObject, I4 = j$1.isStringObject, D3 = j$1.isBooleanObject,
        F3 = j$1.isBigIntObject, N$1 = j$1.isSymbolObject, L2 = j$1.isFloat32Array, M3 = j$1.isFloat64Array;

function U3(t11) {
    if (0 === t11.length || t11.length > 10) {
        return !0;
    }
    for (var e8 = 0; e8 < t11.length; e8++) {
        var n9 = t11.charCodeAt(e8);
        if (n9 < 48 || n9 > 57) {
            return !0;
        }
    }
    return 10 === t11.length && t11 >= Math.pow(2, 32);
}

function G1(t11) {
    return Object.keys(t11).filter(U3).concat(v$11(t11).filter(Object.prototype.propertyIsEnumerable.bind(t11)));
}

function V1(t11, e8) {
    if (t11 === e8) {
        return 0;
    }
    for (var n12 = t11.length, r9 = e8.length, o10 = 0, c8 = Math.min(n12, r9); o10 < c8; ++o10) {
        if (t11[o10] !== e8[o10]) {
            n12 = t11[o10], r9 = e8[o10];
            break;
        }
    }
    return n12 < r9 ? -1 : r9 < n12 ? 1 : 0;
}

function B3(t11, e8, n12, r9) {
    if (t11 === e8) {
        return 0 !== t11 || !n12 || b$1(t11, e8);
    }
    if (n12) {
        if ("object" !== p$3(t11)) {
            return "number" == typeof t11 && d$1(t11) && d$1(e8);
        }
        if ("object" !== p$3(e8) || null === t11 || null === e8) {
            return !1;
        }
        if (Object.getPrototypeOf(t11) !== Object.getPrototypeOf(e8)) {
            return !1;
        }
    } else {
        if (null === t11 || "object" !== p$3(t11)) {
            return (null === e8 || "object" !== p$3(e8)) && t11 == e8;
        }
        if (null === e8 || "object" !== p$3(e8)) {
            return !1;
        }
    }
    var o10, c8, a11, i11, u9 = S2(t11);
    if (u9 !== S2(e8)) {
        return !1;
    }
    if (Array.isArray(t11)) {
        if (t11.length !== e8.length) {
            return !1;
        }
        var l7 = G1(t11), f8 = G1(e8);
        return l7.length === f8.length && C3(t11, e8, n12, r9, 1, l7);
    }
    if ("[object Object]" === u9 && (!R2(t11) && R2(e8) || !k3(t11) && k3(e8))) {
        return !1;
    }
    if (q1(t11)) {
        if (!q1(e8) || Date.prototype.getTime.call(t11) !== Date.prototype.getTime.call(e8)) {
            return !1;
        }
    } else if (A$1(t11)) {
        if (!A$1(e8) || (a11 = t11, i11 = e8, !(g$1 ? a11.source === i11.source && a11.flags === i11.flags : RegExp.prototype.toString.call(a11) === RegExp.prototype.toString.call(i11)))) {
            return !1;
        }
    } else if (_3(t11) || t11 instanceof Error) {
        if (t11.message !== e8.message || t11.name !== e8.name) {
            return !1;
        }
    } else {
        if (x3(t11)) {
            if (n12 || !L2(t11) && !M3(t11)) {
                if (!function (t12, e9) {
                    return t12.byteLength === e9.byteLength && 0 === V1(new Uint8Array(t12.buffer, t12.byteOffset, t12.byteLength), new Uint8Array(e9.buffer, e9.byteOffset, e9.byteLength));
                }(t11, e8)) {
                    return !1;
                }
            } else if (!function (t12, e9) {
                if (t12.byteLength !== e9.byteLength) {
                    return !1;
                }
                for (var n13 = 0; n13 < t12.byteLength; n13++) {
                    if (t12[n13] !== e9[n13]) {
                        return !1;
                    }
                }
                return !0;
            }(t11, e8)) {
                return !1;
            }
            var s9 = G1(t11), h7 = G1(e8);
            return s9.length === h7.length && C3(t11, e8, n12, r9, 0, s9);
        }
        if (k3(t11)) {
            return !(!k3(e8) || t11.size !== e8.size) && C3(t11, e8, n12, r9, 2);
        }
        if (R2(t11)) {
            return !(!R2(e8) || t11.size !== e8.size) && C3(t11, e8, n12, r9, 3);
        }
        if (O2(t11)) {
            if (c8 = e8, (o10 = t11).byteLength !== c8.byteLength || 0 !== V1(new Uint8Array(o10), new Uint8Array(c8))) {
                return !1;
            }
        } else if (T5(t11) && !function (t12, e9) {
            return P$1(t12) ? P$1(e9) && b$1(Number.prototype.valueOf.call(t12), Number.prototype.valueOf.call(e9)) : I4(t12) ? I4(e9) && String.prototype.valueOf.call(t12) === String.prototype.valueOf.call(e9) : D3(t12) ? D3(e9) && Boolean.prototype.valueOf.call(t12) === Boolean.prototype.valueOf.call(e9) : F3(t12) ? F3(e9) && BigInt.prototype.valueOf.call(t12) === BigInt.prototype.valueOf.call(e9) : N$1(e9) && Symbol.prototype.valueOf.call(t12) === Symbol.prototype.valueOf.call(e9);
        }(t11, e8)) {
            return !1;
        }
    }
    return C3(t11, e8, n12, r9, 0);
}

function z3(t11, e8) {
    return e8.filter(function (e9) {
        return w$1(t11, e9);
    });
}

function C3(t11, e8, n12, r9, o10, c8) {
    if (5 === arguments.length) {
        c8 = Object.keys(t11);
        var a11 = Object.keys(e8);
        if (c8.length !== a11.length) {
            return !1;
        }
    }
    for (var i11 = 0; i11 < c8.length; i11++) {
        if (!E3(e8, c8[i11])) {
            return !1;
        }
    }
    if (n12 && 5 === arguments.length) {
        var u9 = v$11(t11);
        if (0 !== u9.length) {
            var l9 = 0;
            for (i11 = 0; i11 < u9.length; i11++) {
                var f9 = u9[i11];
                if (w$1(t11, f9)) {
                    if (!w$1(e8, f9)) {
                        return !1;
                    }
                    c8.push(f9), l9++;
                } else if (w$1(e8, f9)) {
                    return !1;
                }
            }
            var s10 = v$11(e8);
            if (u9.length !== s10.length && z3(e8, s10).length !== l9) {
                return !1;
            }
        } else {
            var p8 = v$11(e8);
            if (0 !== p8.length && 0 !== z3(e8, p8).length) {
                return !1;
            }
        }
    }
    if (0 === c8.length && (0 === o10 || 1 === o10 && 0 === t11.length || 0 === t11.size)) {
        return !0;
    }
    if ((void 0) === r9) {
        r9 = {
            val1: new Map,
            val2: new Map,
            position: 0
        };
    } else {
        var g4 = r9.val1.get(t11);
        if ((void 0) !== g4) {
            var h9 = r9.val2.get(e8);
            if ((void 0) !== h9) {
                return g4 === h9;
            }
        }
        r9.position++;
    }
    r9.val1.set(t11, r9.position), r9.val2.set(e8, r9.position);
    var y6 = Q2(t11, e8, n12, c8, r9, o10);
    return r9.val1.delete(t11), r9.val2.delete(e8), y6;
}

function Y2(t11, e8, n12, r9) {
    for (var o10 = h$11(t11), c8 = 0; c8 < o10.length; c8++) {
        var a12 = o10[c8];
        if (B3(e8, a12, n12, r9)) {
            return t11.delete(a12), !0;
        }
    }
    return !1;
}

function W1(t11) {
    switch (p$3(t11)) {
        case "undefined":
            return null;
        case "object":
            return;
        case "symbol":
            return !1;
        case "string":
            t11 = +t11;
        case "number":
            if (d$1(t11)) {
                return !1;
            }
    }
    return !0;
}

function H1(t11, e8, n12) {
    var r9 = W1(n12);
    return null != r9 ? r9 : e8.has(r9) && !t11.has(r9);
}

function J1(t11, e8, n12, r9, o10) {
    var c8 = W1(n12);
    if (null != c8) {
        return c8;
    }
    var a13 = e8.get(c8);
    return !((void 0) === a13 && !e8.has(c8) || !B3(r9, a13, !1, o10)) && !t11.has(c8) && B3(r9, a13, !1, o10);
}

function K1(t11, e8, n12, r9, o10, c8) {
    for (var a13 = h$11(t11), i11 = 0; i11 < a13.length; i11++) {
        var u10 = a13[i11];
        if (B3(n12, u10, o10, c8) && B3(r9, e8.get(u10), o10, c8)) {
            return t11.delete(u10), !0;
        }
    }
    return !1;
}

function Q2(t11, e8, n12, r9, o10, c8) {
    var a13 = 0;
    if (2 === c8) {
        if (!function (t12, e9, n13, r12) {
            for (var o12 = null, c9 = h$11(t12), a14 = 0; a14 < c9.length; a14++) {
                var i11 = c9[a14];
                if ("object" === p$3(i11) && null !== i11) {
                    null === o12 && (o12 = new Set), o12.add(i11);
                } else if (!e9.has(i11)) {
                    if (n13) {
                        return !1;
                    }
                    if (!H1(t12, e9, i11)) {
                        return !1;
                    }
                    null === o12 && (o12 = new Set), o12.add(i11);
                }
            }
            if (null !== o12) {
                for (var u11 = h$11(e9), l10 = 0; l10 < u11.length; l10++) {
                    var f10 = u11[l10];
                    if ("object" === p$3(f10) && null !== f10) {
                        if (!Y2(o12, f10, n13, r12)) {
                            return !1;
                        }
                    } else if (!n13 && !t12.has(f10) && !Y2(o12, f10, n13, r12)) {
                        return !1;
                    }
                }
                return 0 === o12.size;
            }
            return !0;
        }(t11, e8, n12, o10)) {
            return !1;
        }
    } else if (3 === c8) {
        if (!function (t12, e9, n13, r12) {
            for (var o12 = null, c9 = y$2(t12), a14 = 0; a14 < c9.length; a14++) {
                var i12 = s$3(c9[a14], 2), u12 = i12[0], l11 = i12[1];
                if ("object" === p$3(u12) && null !== u12) {
                    null === o12 && (o12 = new Set), o12.add(u12);
                } else {
                    var f11 = e9.get(u12);
                    if ((void 0) === f11 && !e9.has(u12) || !B3(l11, f11, n13, r12)) {
                        if (n13) {
                            return !1;
                        }
                        if (!J1(t12, e9, u12, l11, r12)) {
                            return !1;
                        }
                        null === o12 && (o12 = new Set), o12.add(u12);
                    }
                }
            }
            if (null !== o12) {
                for (var g6 = y$2(e9), h10 = 0; h10 < g6.length; h10++) {
                    var b4 = s$3(g6[h10], 2), v6 = (u12 = b4[0], b4[1]);
                    if ("object" === p$3(u12) && null !== u12) {
                        if (!K1(o12, t12, u12, v6, n13, r12)) {
                            return !1;
                        }
                    } else if (!(n13 || t12.has(u12) && B3(t12.get(u12), v6, !1, r12) || K1(o12, t12, u12, v6, !1, r12))) {
                        return !1;
                    }
                }
                return 0 === o12.size;
            }
            return !0;
        }(t11, e8, n12, o10)) {
            return !1;
        }
    } else if (1 === c8) {
        for (; a13 < t11.length; a13++) {
            if (!E3(t11, a13)) {
                if (E3(e8, a13)) {
                    return !1;
                }
                for (var i13 = Object.keys(t11); a13 < i13.length; a13++) {
                    var u13 = i13[a13];
                    if (!E3(e8, u13) || !B3(t11[u13], e8[u13], n12, o10)) {
                        return !1;
                    }
                }
                return i13.length === Object.keys(e8).length;
            }
            if (!E3(e8, a13) || !B3(t11[a13], e8[a13], n12, o10)) {
                return !1;
            }
        }
    }
    for (a13 = 0; a13 < r9.length; a13++) {
        var l12 = r9[a13];
        if (!B3(t11[l12], e8[l12], n12, o10)) {
            return !1;
        }
    }
    return !0;
}

var X1 = {
    isDeepEqual: function (t11, e8) {
        return B3(t11, e8, !1);
    },
    isDeepStrictEqual: function (t11, e8) {
        return B3(t11, e8, !0);
    }
}, Z1 = {}, $$1 = !1;

function tt() {
    if ($$1) {
        return Z1;
    }
    $$1 = !0;
    var o10 = T1;

    function c8(t11) {
        return (c8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t12) {
            return typeof t12;
        } : function (t12) {
            return t12 && "function" == typeof Symbol && t12.constructor === Symbol && t12 !== Symbol.prototype ? "symbol" : typeof t12;
        })(t11);
    }

    var a13, u14, l13 = i$5().codes, s11 = l13.ERR_AMBIGUOUS_ARGUMENT, p10 = l13.ERR_INVALID_ARG_TYPE,
            g7 = l13.ERR_INVALID_ARG_VALUE, h11 = l13.ERR_INVALID_RETURN_VALUE, y6 = l13.ERR_MISSING_ARGS, b6 = f$6(),
            v7 = X.inspect, d4 = X.types, m$11 = d4.isPromise, E4 = d4.isRegExp,
            w3 = Object.assign ? Object.assign : r8.assign, S3 = Object.is ? Object.is : m3;

    function j3() {
        a13 = X1.isDeepEqual, u14 = X1.isDeepStrictEqual;
    }

    var O3 = !1, x4 = Z1 = k4, q2 = {};

    function R4(t11) {
        if (t11.message instanceof Error) {
            throw t11.message;
        }
        throw new b6(t11);
    }

    function A3(t11, e8, n12, r9) {
        if (!n12) {
            var o12 = !1;
            if (0 === e8) {
                o12 = !0, r9 = "No value argument passed to `assert.ok()`";
            } else if (r9 instanceof Error) {
                throw r9;
            }
            var c9 = new b6({
                actual: n12,
                expected: !0,
                message: r9,
                operator: "==",
                stackStartFn: t11
            });
            throw c9.generatedMessage = o12, c9;
        }
    }

    function k4() {
        for (var t11 = arguments.length, e8 = new Array(t11), n12 = 0; n12 < t11; n12++) {
            e8[n12] = arguments[n12];
        }
        A3.apply(void 0, [
            k4,
            e8.length
        ].concat(e8));
    }

    x4.fail = function t11(e8, n12, r9, c10, a14) {
        var i14, u15 = arguments.length;
        if (0 === u15) {
            i14 = "Failed";
        } else if (1 === u15) {
            r9 = e8, e8 = void 0;
        } else {
            if (!1 === O3) {
                O3 = !0;
                var l14 = o10.emitWarning ? o10.emitWarning : console.warn.bind(console);
                l14("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
            }
            2 === u15 && (c10 = "!=");
        }
        if (r9 instanceof Error) {
            throw r9;
        }
        var f12 = {
            actual: e8,
            expected: n12,
            operator: (void 0) === c10 ? "fail" : c10,
            stackStartFn: a14 || t11
        };
        (void 0) !== r9 && (f12.message = r9);
        var s12 = new b6(f12);
        throw i14 && (s12.message = i14, s12.generatedMessage = !0), s12;
    }, x4.AssertionError = b6, x4.ok = k4, x4.equal = function t11(e8, n12, r9) {
        if (arguments.length < 2) {
            throw new y6("actual", "expected");
        }
        e8 != n12 && R4({
            actual: e8,
            expected: n12,
            message: r9,
            operator: "==",
            stackStartFn: t11
        });
    }, x4.notEqual = function t11(e8, n12, r9) {
        if (arguments.length < 2) {
            throw new y6("actual", "expected");
        }
        e8 == n12 && R4({
            actual: e8,
            expected: n12,
            message: r9,
            operator: "!=",
            stackStartFn: t11
        });
    }, x4.deepEqual = function t11(e8, n12, r9) {
        if (arguments.length < 2) {
            throw new y6("actual", "expected");
        }
        (void 0) === a13 && j3(), a13(e8, n12) || R4({
            actual: e8,
            expected: n12,
            message: r9,
            operator: "deepEqual",
            stackStartFn: t11
        });
    }, x4.notDeepEqual = function t11(e8, n12, r9) {
        if (arguments.length < 2) {
            throw new y6("actual", "expected");
        }
        (void 0) === a13 && j3(), a13(e8, n12) && R4({
            actual: e8,
            expected: n12,
            message: r9,
            operator: "notDeepEqual",
            stackStartFn: t11
        });
    }, x4.deepStrictEqual = function t11(e8, n12, r9) {
        if (arguments.length < 2) {
            throw new y6("actual", "expected");
        }
        (void 0) === a13 && j3(), u14(e8, n12) || R4({
            actual: e8,
            expected: n12,
            message: r9,
            operator: "deepStrictEqual",
            stackStartFn: t11
        });
    }, x4.notDeepStrictEqual = function t11(e8, n12, r9) {
        if (arguments.length < 2) {
            throw new y6("actual", "expected");
        }
        (void 0) === a13 && j3();
        u14(e8, n12) && R4({
            actual: e8,
            expected: n12,
            message: r9,
            operator: "notDeepStrictEqual",
            stackStartFn: t11
        });
    }, x4.strictEqual = function t11(e8, n12, r9) {
        if (arguments.length < 2) {
            throw new y6("actual", "expected");
        }
        S3(e8, n12) || R4({
            actual: e8,
            expected: n12,
            message: r9,
            operator: "strictEqual",
            stackStartFn: t11
        });
    }, x4.notStrictEqual = function t11(e8, n12, r9) {
        if (arguments.length < 2) {
            throw new y6("actual", "expected");
        }
        S3(e8, n12) && R4({
            actual: e8,
            expected: n12,
            message: r9,
            operator: "notStrictEqual",
            stackStartFn: t11
        });
    };
    var _4 = function t11(e8, n12, r9) {
        var o13 = this;
        !function (t12, e9) {
            if (!(t12 instanceof e9)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }(this, t11), n12.forEach(function (t12) {
            t12 in e8 && ((void 0) !== r9 && "string" == typeof r9[t12] && E4(e8[t12]) && e8[t12].test(r9[t12]) ? o13[t12] = r9[t12] : o13[t12] = e8[t12]);
        });
    };

    function T6(t12, e8, n12, r9, o13, c10) {
        if (!(n12 in t12) || !u14(t12[n12], e8[n12])) {
            if (!r9) {
                var a14 = new _4(t12, o13), i14 = new _4(e8, o13, t12), l15 = new b6({
                    actual: a14,
                    expected: i14,
                    operator: "deepStrictEqual",
                    stackStartFn: c10
                });
                throw l15.actual = t12, l15.expected = e8, l15.operator = c10.name, l15;
            }
            R4({
                actual: t12,
                expected: e8,
                message: r9,
                operator: c10.name,
                stackStartFn: c10
            });
        }
    }

    function P5(t12, e8, n12, r9) {
        if ("function" != typeof e8) {
            if (E4(e8)) {
                return e8.test(t12);
            }
            if (2 === arguments.length) {
                throw new p10("expected", [
                    "Function",
                    "RegExp"
                ], e8);
            }
            if ("object" !== c8(t12) || null === t12) {
                var o13 = new b6({
                    actual: t12,
                    expected: e8,
                    message: n12,
                    operator: "deepStrictEqual",
                    stackStartFn: r9
                });
                throw o13.operator = r9.name, o13;
            }
            var i15 = Object.keys(e8);
            if (e8 instanceof Error) {
                i15.push("name", "message");
            } else if (0 === i15.length) {
                throw new g7("error", e8, "may not be an empty object");
            }
            return (void 0) === a13 && j3(), i15.forEach(function (o14) {
                "string" == typeof t12[o14] && E4(e8[o14]) && e8[o14].test(t12[o14]) || T6(t12, e8, o14, n12, i15, r9);
            }), !0;
        }
        return (void 0) !== e8.prototype && t12 instanceof e8 || !Error.isPrototypeOf(e8) && !0 === e8.call({}, t12);
    }

    function I5(t12) {
        if ("function" != typeof t12) {
            throw new p10("fn", "Function", t12);
        }
        try {
            t12();
        } catch (t13) {
            return t13;
        }
        return q2;
    }

    function D4(t12) {
        return m$11(t12) || null !== t12 && "object" === c8(t12) && "function" == typeof t12.then && "function" == typeof t12.catch;
    }

    function F4(t12) {
        return Promise.resolve().then(function () {
            var e8;
            if ("function" == typeof t12) {
                if (!D4(e8 = t12())) {
                    throw new h11("instance of Promise", "promiseFn", e8);
                }
            } else {
                if (!D4(t12)) {
                    throw new p10("promiseFn", [
                        "Function",
                        "Promise"
                    ], t12);
                }
                e8 = t12;
            }
            return Promise.resolve().then(function () {
                return e8;
            }).then(function () {
                return q2;
            }).catch(function (t13) {
                return t13;
            });
        });
    }

    function N4(t12, e8, n12, r9) {
        if ("string" == typeof n12) {
            if (4 === arguments.length) {
                throw new p10("error", [
                    "Object",
                    "Error",
                    "Function",
                    "RegExp"
                ], n12);
            }
            if ("object" === c8(e8) && null !== e8) {
                if (e8.message === n12) {
                    throw new s11("error/message", 'The error message "'.concat(e8.message, '" is identical to the message.'));
                }
            } else if (e8 === n12) {
                throw new s11("error/message", 'The error "'.concat(e8, '" is identical to the message.'));
            }
            r9 = n12, n12 = void 0;
        } else if (null != n12 && "object" !== c8(n12) && "function" != typeof n12) {
            throw new p10("error", [
                "Object",
                "Error",
                "Function",
                "RegExp"
            ], n12);
        }
        if (e8 === q2) {
            var o14 = "";
            n12 && n12.name && (o14 += " (".concat(n12.name, ")")), o14 += r9 ? ": ".concat(r9) : ".";
            var a15 = "rejects" === t12.name ? "rejection" : "exception";
            R4({
                actual: void 0,
                expected: n12,
                operator: t12.name,
                message: "Missing expected ".concat(a15).concat(o14),
                stackStartFn: t12
            });
        }
        if (n12 && !P5(e8, n12, r9, t12)) {
            throw e8;
        }
    }

    function L3(t12, e8, n12, r9) {
        if (e8 !== q2) {
            if ("string" == typeof n12 && (r9 = n12, n12 = void 0), !n12 || P5(e8, n12)) {
                var o15 = r9 ? ": ".concat(r9) : ".", c10 = "doesNotReject" === t12.name ? "rejection" : "exception";
                R4({
                    actual: e8,
                    expected: n12,
                    operator: t12.name,
                    message: "Got unwanted ".concat(c10).concat(o15, "\n") + 'Actual message: "'.concat(e8 && e8.message, '"'),
                    stackStartFn: t12
                });
            }
            throw e8;
        }
    }

    function M4() {
        for (var t12 = arguments.length, e8 = new Array(t12), n12 = 0; n12 < t12; n12++) {
            e8[n12] = arguments[n12];
        }
        A3.apply(void 0, [
            M4,
            e8.length
        ].concat(e8));
    }

    return x4.throws = function t11(e8) {
        for (var n12 = arguments.length, r9 = new Array(n12 > 1 ? n12 - 1 : 0), o16 = 1; o16 < n12; o16++) {
            r9[o16 - 1] = arguments[o16];
        }
        N4.apply(void 0, [
            t11,
            I5(e8)
        ].concat(r9));
    }, x4.rejects = function t11(e8) {
        for (var n12 = arguments.length, r9 = new Array(n12 > 1 ? n12 - 1 : 0), o16 = 1; o16 < n12; o16++) {
            r9[o16 - 1] = arguments[o16];
        }
        return F4(e8).then(function (e9) {
            return N4.apply(void 0, [
                t11,
                e9
            ].concat(r9));
        });
    }, x4.doesNotThrow = function t11(e8) {
        for (var n12 = arguments.length, r9 = new Array(n12 > 1 ? n12 - 1 : 0), o16 = 1; o16 < n12; o16++) {
            r9[o16 - 1] = arguments[o16];
        }
        L3.apply(void 0, [
            t11,
            I5(e8)
        ].concat(r9));
    }, x4.doesNotReject = function t11(e8) {
        for (var n12 = arguments.length, r9 = new Array(n12 > 1 ? n12 - 1 : 0), o16 = 1; o16 < n12; o16++) {
            r9[o16 - 1] = arguments[o16];
        }
        return F4(e8).then(function (e9) {
            return L3.apply(void 0, [
                t11,
                e9
            ].concat(r9));
        });
    }, x4.ifError = function t11(e8) {
        if (null != e8) {
            var n12 = "ifError got unwanted exception: ";
            "object" === c8(e8) && "string" == typeof e8.message ? 0 === e8.message.length && e8.constructor ? n12 += e8.constructor.name : n12 += e8.message : n12 += v7(e8);
            var r9 = new b6({
                actual: e8,
                expected: null,
                operator: "ifError",
                message: n12,
                stackStartFn: t11
            }), o16 = e8.stack;
            if ("string" == typeof o16) {
                var a16 = o16.split("\n");
                a16.shift();
                for (var i16 = r9.stack.split("\n"), u15 = 0; u15 < a16.length; u15++) {
                    var l16 = i16.indexOf(a16[u15]);
                    if (-1 !== l16) {
                        i16 = i16.slice(0, l16);
                        break;
                    }
                }
                r9.stack = "".concat(i16.join("\n"), "\n").concat(a16.join("\n"));
            }
            throw r9;
        }
    }, x4.strict = w3(M4, x4, {
        equal: x4.strictEqual,
        deepEqual: x4.deepStrictEqual,
        notEqual: x4.notStrictEqual,
        notDeepEqual: x4.notDeepStrictEqual
    }), x4.strict.strict = x4.strict, Z1;
}

var et = tt();
var e8 = {}, n13 = e$1, o10 = n13.Buffer;

function t11(r12, e9) {
    for (var n14 in r12) {
        e9[n14] = r12[n14];
    }
}

function f12(r12, e9, n14) {
    return o10(r12, e9, n14);
}

o10.from && o10.alloc && o10.allocUnsafe && o10.allocUnsafeSlow ? e8 = n13 : (t11(n13, e8), e8.Buffer = f12), f12.prototype = Object.create(o10.prototype), t11(o10, f12), f12.from = function (r12, e9, n14) {
    if ("number" == typeof r12) {
        throw new TypeError("Argument must not be a number");
    }
    return o10(r12, e9, n14);
}, f12.alloc = function (r12, e9, n14) {
    if ("number" != typeof r12) {
        throw new TypeError("Argument must be a number");
    }
    var t12 = o10(r12);
    return (void 0) !== e9 ? "string" == typeof n14 ? t12.fill(e9, n14) : t12.fill(e9) : t12.fill(0), t12;
}, f12.allocUnsafe = function (r12) {
    if ("number" != typeof r12) {
        throw new TypeError("Argument must be a number");
    }
    return o10(r12);
}, f12.allocUnsafeSlow = function (r12) {
    if ("number" != typeof r12) {
        throw new TypeError("Argument must be a number");
    }
    return n13.SlowBuffer(r12);
};
var u14 = e8;
var e$13 = {}, s11 = u14.Buffer, i17 = s11.isEncoding || function (t12) {
    switch ((t12 = "" + t12) && t12.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return !0;
        default:
            return !1;
    }
};

function a13(t12) {
    var e9;
    switch (this.encoding = (function (t13) {
        var e10 = function (t14) {
            if (!t14) {
                return "utf8";
            }
            for (var e10; ;) {
                switch (t14) {
                    case "utf8":
                    case "utf-8":
                        return "utf8";
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return "utf16le";
                    case "latin1":
                    case "binary":
                        return "latin1";
                    case "base64":
                    case "ascii":
                    case "hex":
                        return t14;
                    default:
                        if (e10) {
                            return;
                        }
                        t14 = ("" + t14).toLowerCase(), e10 = !0;
                }
            }
        }(t13);
        if ("string" != typeof e10 && (s11.isEncoding === i17 || !i17(t13))) {
            throw new Error("Unknown encoding: " + t13);
        }
        return e10 || t13;
    })(t12), this.encoding) {
        case "utf16le":
            this.text = h11, this.end = l13, e9 = 4;
            break;
        case "utf8":
            this.fillLast = n$14, e9 = 4;
            break;
        case "base64":
            this.text = u$14, this.end = o$14, e9 = 3;
            break;
        default:
            return this.write = f$12, this.end = c8, void 0;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s11.allocUnsafe(e9);
}

function r12(t12) {
    return t12 <= 127 ? 0 : t12 >> 5 == 6 ? 2 : t12 >> 4 == 14 ? 3 : t12 >> 3 == 30 ? 4 : t12 >> 6 == 2 ? -1 : -2;
}

function n$14(t12) {
    var e9 = this.lastTotal - this.lastNeed, s12 = function (t13, e10, s13) {
        if (128 != (192 & e10[0])) {
            return t13.lastNeed = 0, "";
        }
        if (t13.lastNeed > 1 && e10.length > 1) {
            if (128 != (192 & e10[1])) {
                return t13.lastNeed = 1, "";
            }
            if (t13.lastNeed > 2 && e10.length > 2 && 128 != (192 & e10[2])) {
                return t13.lastNeed = 2, "";
            }
        }
    }(this, t12);
    return (void 0) !== s12 ? s12 : this.lastNeed <= t12.length ? (t12.copy(this.lastChar, e9, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t12.copy(this.lastChar, e9, 0, t12.length), this.lastNeed -= t12.length, void 0);
}

function h11(t12, e9) {
    if ((t12.length - e9) % 2 == 0) {
        var s12 = t12.toString("utf16le", e9);
        if (s12) {
            var i18 = s12.charCodeAt(s12.length - 1);
            if (i18 >= 55296 && i18 <= 56319) {
                return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t12[t12.length - 2], this.lastChar[1] = t12[t12.length - 1], s12.slice(0, -1);
            }
        }
        return s12;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t12[t12.length - 1], t12.toString("utf16le", e9, t12.length - 1);
}

function l13(t12) {
    var e9 = t12 && t12.length ? this.write(t12) : "";
    if (this.lastNeed) {
        var s13 = this.lastTotal - this.lastNeed;
        return e9 + this.lastChar.toString("utf16le", 0, s13);
    }
    return e9;
}

function u$14(t12, e9) {
    var s14 = (t12.length - e9) % 3;
    return 0 === s14 ? t12.toString("base64", e9) : (this.lastNeed = 3 - s14, this.lastTotal = 3, 1 === s14 ? this.lastChar[0] = t12[t12.length - 1] : (this.lastChar[0] = t12[t12.length - 2], this.lastChar[1] = t12[t12.length - 1]), t12.toString("base64", e9, t12.length - s14));
}

function o$14(t12) {
    var e9 = t12 && t12.length ? this.write(t12) : "";
    return this.lastNeed ? e9 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e9;
}

function f$12(t12) {
    return t12.toString(this.encoding);
}

function c8(t12) {
    return t12 && t12.length ? this.write(t12) : "";
}

e$13.StringDecoder = a13, a13.prototype.write = function (t12) {
    if (0 === t12.length) {
        return "";
    }
    var e9, s14;
    if (this.lastNeed) {
        if ((void 0) === (e9 = this.fillLast(t12))) {
            return "";
        }
        s14 = this.lastNeed, this.lastNeed = 0;
    } else {
        s14 = 0;
    }
    return s14 < t12.length ? e9 ? e9 + this.text(t12, s14) : this.text(t12, s14) : e9 || "";
}, a13.prototype.end = function (t12) {
    var e9 = t12 && t12.length ? this.write(t12) : "";
    return this.lastNeed ? e9 + "" : e9;
}, a13.prototype.text = function (t12, e9) {
    var s14 = function (t13, e10, s15) {
        var i19 = e10.length - 1;
        if (i19 < s15) {
            return 0;
        }
        var a17 = r12(e10[i19]);
        if (a17 >= 0) {
            return a17 > 0 && (t13.lastNeed = a17 - 1), a17;
        }
        if ((--i19) < s15 || -2 === a17) {
            return 0;
        }
        if ((a17 = r12(e10[i19])) >= 0) {
            return a17 > 0 && (t13.lastNeed = a17 - 2), a17;
        }
        if ((--i19) < s15 || -2 === a17) {
            return 0;
        }
        if ((a17 = r12(e10[i19])) >= 0) {
            return a17 > 0 && (2 === a17 ? a17 = 0 : t13.lastNeed = a17 - 3), a17;
        }
        return 0;
    }(this, t12, e9);
    if (!this.lastNeed) {
        return t12.toString("utf8", e9);
    }
    this.lastTotal = s14;
    var i19 = t12.length - (s14 - this.lastNeed);
    return t12.copy(this.lastChar, 0, i19), t12.toString("utf8", e9, i19);
}, a13.prototype.fillLast = function (t12) {
    if (this.lastNeed <= t12.length) {
        return t12.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    t12.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t12.length), this.lastNeed -= t12.length;
};
var e9 = y1.EventEmitter;
var e$14 = {};
const t12 = {};

function n14(e10, n15, r13) {
    r13 || (r13 = Error);

    class o17 extends r13 {
        constructor(e11, t13, r14) {
            super(function (e12, t14, r15) {
                return "string" == typeof n15 ? n15 : n15(e12, t14, r15);
            }(e11, t13, r14));
        }
    }

    o17.prototype.name = r13.name, o17.prototype.code = e10, t12[e10] = o17;
}

function r13(e10, t13) {
    if (Array.isArray(e10)) {
        const n15 = e10.length;
        return e10 = e10.map((e11) => String(e11)
        ), n15 > 2 ? `one of ${t13} ${e10.slice(0, n15 - 1).join(", ")}, or ` + e10[n15 - 1] : 2 === n15 ? `one of ${t13} ${e10[0]} or ${e10[1]}` : `of ${t13} ${e10[0]}`;
    }
    return `of ${t13} ${String(e10)}`;
}

n14("ERR_INVALID_OPT_VALUE", function (e10, t13) {
    return 'The value "' + t13 + '" is invalid for option "' + e10 + '"';
}, TypeError), n14("ERR_INVALID_ARG_TYPE", function (e10, t13, n15) {
    let o17;
    var E4;
    let u16;
    if (("string" == typeof t13 && (E4 = "not ", t13.substr(0, E4.length) === E4) ? (o17 = "must not be", t13 = t13.replace(/^not /, "")) : o17 = "must be", function (e11, t14, n16) {
        return ((void 0) === n16 || n16 > e11.length) && (n16 = e11.length), e11.substring(n16 - t14.length, n16) === t14;
    }(e10, " argument"))) {
        u16 = `The ${e10} ${o17} ${r13(t13, "type")}`;
    } else {
        u16 = `The "${e10}" ${(function (e11, t14, n16) {
            return "number" != typeof n16 && (n16 = 0), !(n16 + t14.length > e11.length) && -1 !== e11.indexOf(t14, n16);
        })(e10, ".") ? "property" : "argument"} ${o17} ${r13(t13, "type")}`;
    }
    return (u16 += `. Received type ${typeof n15}`, u16);
}, TypeError), n14("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n14("ERR_METHOD_NOT_IMPLEMENTED", function (e10) {
    return "The " + e10 + " method is not implemented";
}), n14("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n14("ERR_STREAM_DESTROYED", function (e10) {
    return "Cannot call " + e10 + " after a stream was destroyed";
}), n14("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n14("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n14("ERR_STREAM_WRITE_AFTER_END", "write after end"), n14("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n14("ERR_UNKNOWN_ENCODING", function (e10) {
    return "Unknown encoding: " + e10;
}, TypeError), n14("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), e$14.codes = t12;
var r$12 = function () {
    throw new Error("Readable.from is not available in the browser");
};
var r$21 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;

function e$21(e10) {
    try {
        if (!r$21.localStorage) {
            return !1;
        }
    } catch (r14) {
        return !1;
    }
    var t13 = r$21.localStorage[e10];
    return null != t13 && "true" === String(t13).toLowerCase();
}

var t$12 = function (t13, n15) {
    if (e$21("noDeprecation")) {
        return t13;
    }
    var o17 = !1;
    return function () {
        if (!o17) {
            if (e$21("throwDeprecation")) {
                throw new Error(n15);
            }
            e$21("traceDeprecation") ? console.trace(n15) : console.warn(n15), o17 = !0;
        }
        return t13.apply(this || r$21, arguments);
    };
};

function u16(e10, t13) {
    var n15 = Object.keys(e10);
    if (Object.getOwnPropertySymbols) {
        var r14 = Object.getOwnPropertySymbols(e10);
        t13 && (r14 = r14.filter(function (t14) {
            return Object.getOwnPropertyDescriptor(e10, t14).enumerable;
        })), n15.push.apply(n15, r14);
    }
    return n15;
}

function f13(e10, t13, n15) {
    return t13 in e10 ? Object.defineProperty(e10, t13, {
        value: n15,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e10[t13] = n15, e10;
}

function h12(e10, t13) {
    for (var n15 = 0; n15 < t13.length; n15++) {
        var r15 = t13[n15];
        r15.enumerable = r15.enumerable || !1, r15.configurable = !0, "value" in r15 && (r15.writable = !0), Object.defineProperty(e10, r15.key, r15);
    }
}

var c11 = e$1.Buffer, b6 = X.inspect, p10 = b6 && b6.custom || "inspect";
var g7 = function () {
    function e10() {
        !function (e11, t13) {
            if (!(e11 instanceof t13)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }(this, e10), this.head = null, this.tail = null, this.length = 0;
    }

    var t13, n15;
    return t13 = e10, (n15 = [
        {
            key: "push",
            value: function (e11) {
                var t14 = {
                    data: e11,
                    next: null
                };
                this.length > 0 ? this.tail.next = t14 : this.head = t14, this.tail = t14, ++this.length;
            }
        },
        {
            key: "unshift",
            value: function (e11) {
                var t14 = {
                    data: e11,
                    next: this.head
                };
                0 === this.length && (this.tail = t14), this.head = t14, ++this.length;
            }
        },
        {
            key: "shift",
            value: function () {
                if (0 !== this.length) {
                    var e11 = this.head.data;
                    return (1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e11);
                }
            }
        },
        {
            key: "clear",
            value: function () {
                this.head = this.tail = null, this.length = 0;
            }
        },
        {
            key: "join",
            value: function (e12) {
                if (0 === this.length) {
                    return "";
                }
                for (var t14 = this.head, n16 = "" + t14.data; t14 = t14.next;) {
                    n16 += e12 + t14.data;
                }
                return n16;
            }
        },
        {
            key: "concat",
            value: function (e12) {
                if (0 === this.length) {
                    return c11.alloc(0);
                }
                for (var t14, n16, r16, i19 = c11.allocUnsafe(e12 >>> 0), a17 = this.head, o17 = 0; a17;) {
                    t14 = a17.data, n16 = i19, r16 = o17, c11.prototype.copy.call(t14, n16, r16), o17 += a17.data.length, a17 = a17.next;
                }
                return i19;
            }
        },
        {
            key: "consume",
            value: function (e12, t14) {
                var n16;
                return (e12 < this.head.data.length ? (n16 = this.head.data.slice(0, e12), this.head.data = this.head.data.slice(e12)) : n16 = e12 === this.head.data.length ? this.shift() : t14 ? this._getString(e12) : this._getBuffer(e12), n16);
            }
        },
        {
            key: "first",
            value: function () {
                return this.head.data;
            }
        },
        {
            key: "_getString",
            value: function (e12) {
                var t14 = this.head, n16 = 1, r16 = t14.data;
                for (e12 -= r16.length; t14 = t14.next;) {
                    var i19 = t14.data, a17 = e12 > i19.length ? i19.length : e12;
                    if ((a17 === i19.length ? r16 += i19 : r16 += i19.slice(0, e12), 0 == (e12 -= a17))) {
                        a17 === i19.length ? (++n16, t14.next ? this.head = t14.next : this.head = this.tail = null) : (this.head = t14, t14.data = i19.slice(a17));
                        break;
                    }
                    ++n16;
                }
                return (this.length -= n16, r16);
            }
        },
        {
            key: "_getBuffer",
            value: function (e12) {
                var t14 = c11.allocUnsafe(e12), n16 = this.head, r16 = 1;
                for ((n16.data.copy(t14), e12 -= n16.data.length); n16 = n16.next;) {
                    var i20 = n16.data, a18 = e12 > i20.length ? i20.length : e12;
                    if ((i20.copy(t14, t14.length - e12, 0, a18), 0 == (e12 -= a18))) {
                        a18 === i20.length ? (++r16, n16.next ? this.head = n16.next : this.head = this.tail = null) : (this.head = n16, n16.data = i20.slice(a18));
                        break;
                    }
                    ++r16;
                }
                return (this.length -= r16, t14);
            }
        },
        {
            key: p10,
            value: function (e12, t14) {
                return b6(this, function (e13) {
                    for (var t15 = 1; t15 < arguments.length; t15++) {
                        var n16 = null != arguments[t15] ? arguments[t15] : {};
                        t15 % 2 ? u16(Object(n16), !0).forEach(function (t16) {
                            f13(e13, t16, n16[t16]);
                        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e13, Object.getOwnPropertyDescriptors(n16)) : u16(Object(n16)).forEach(function (t16) {
                            Object.defineProperty(e13, t16, Object.getOwnPropertyDescriptor(n16, t16));
                        });
                    }
                    return e13;
                }({}, t14, {
                    depth: 0,
                    customInspect: !1
                }));
            }
        }
    ]) && h12(t13.prototype, n15), e10;
}(), y6 = T1;

function w3(e10, t13) {
    _5(e10, t13), v7(e10);
}

function v7(e10) {
    e10._writableState && !e10._writableState.emitClose || e10._readableState && !e10._readableState.emitClose || e10.emit("close");
}

function _5(e10, t13) {
    e10.emit("error", t13);
}

var m4 = {
    destroy: function (e10, t13) {
        var n15 = this, r16 = this._readableState && this._readableState.destroyed,
                i21 = this._writableState && this._writableState.destroyed;
        return r16 || i21 ? (t13 ? t13(e10) : e10 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, y6.nextTick(_5, this, e10)) : y6.nextTick(_5, this, e10)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e10 || null, function (e12) {
            !t13 && e12 ? n15._writableState ? n15._writableState.errorEmitted ? y6.nextTick(v7, n15) : (n15._writableState.errorEmitted = !0, y6.nextTick(w3, n15, e12)) : y6.nextTick(w3, n15, e12) : t13 ? (y6.nextTick(v7, n15), t13(e12)) : y6.nextTick(v7, n15);
        }), this);
    },
    undestroy: function () {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    },
    errorOrDestroy: function (e10, t13) {
        var n15 = e10._readableState, r16 = e10._writableState;
        n15 && n15.autoDestroy || r16 && r16.autoDestroy ? e10.destroy(t13) : e10.emit("error", t13);
    }
}, S3 = e$14.codes.ERR_INVALID_OPT_VALUE;
var R4 = {
    getHighWaterMark: function (e10, t13, n15, r16) {
        var i21 = function (e12, t14, n17) {
            return null != e12.highWaterMark ? e12.highWaterMark : t14 ? e12[n17] : null;
        }(t13, r16, n15);
        if (null != i21) {
            if (!isFinite(i21) || Math.floor(i21) !== i21 || i21 < 0) {
                throw new S3(r16 ? n15 : "highWaterMark", i21);
            }
            return Math.floor(i21);
        }
        return e10.objectMode ? 16 : 16384;
    }
}, k4 = e$14.codes.ERR_STREAM_PREMATURE_CLOSE;

function E4() {
}

var M4, j3 = function e9(t13, n15, r16) {
    if ("function" == typeof n15) {
        return e9(t13, null, n15);
    }
    n15 || (n15 = {}), r16 = (function (e10) {
        var t14 = !1;
        return function () {
            if (!t14) {
                t14 = !0;
                for (var n17 = arguments.length, r17 = new Array(n17), i21 = 0; i21 < n17; i21++) {
                    r17[i21] = arguments[i21];
                }
                e10.apply(this, r17);
            }
        };
    })(r16 || E4);
    var i22 = n15.readable || !1 !== n15.readable && t13.readable,
            a19 = n15.writable || !1 !== n15.writable && t13.writable, o17 = function () {
                t13.writable || l17();
            }, s14 = t13._writableState && t13._writableState.finished, l17 = function () {
                a19 = !1, s14 = !0, i22 || r16.call(t13);
            }, d4 = t13._readableState && t13._readableState.endEmitted, u17 = function () {
                i22 = !1, d4 = !0, a19 || r16.call(t13);
            }, f14 = function (e10) {
                r16.call(t13, e10);
            }, h13 = function () {
                var e10;
                return i22 && !d4 ? (t13._readableState && t13._readableState.ended || (e10 = new k4), r16.call(t13, e10)) : a19 && !s14 ? (t13._writableState && t13._writableState.ended || (e10 = new k4), r16.call(t13, e10)) : void 0;
            }, c12 = function () {
                t13.req.on("finish", l17);
            };
    return (!function (e10) {
        return e10.setHeader && "function" == typeof e10.abort;
    }(t13) ? a19 && !t13._writableState && (t13.on("end", o17), t13.on("close", o17)) : (t13.on("complete", l17), t13.on("abort", h13), t13.req ? c12() : t13.on("request", c12)), t13.on("end", u17), t13.on("finish", l17), !1 !== n15.error && t13.on("error", f14), t13.on("close", h13), function () {
        t13.removeListener("complete", l17), t13.removeListener("abort", h13), t13.removeListener("request", c12), t13.req && t13.req.removeListener("finish", l17), t13.removeListener("end", o17), t13.removeListener("close", o17), t13.removeListener("finish", l17), t13.removeListener("end", u17), t13.removeListener("error", f14), t13.removeListener("close", h13);
    });
}, O3 = T1;

function T6(e10, t13, n15) {
    return t13 in e10 ? Object.defineProperty(e10, t13, {
        value: n15,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e10[t13] = n15, e10;
}

var P5 = j3, x4 = Symbol("lastResolve"), L3 = Symbol("lastReject"), D4 = Symbol("error"), C4 = Symbol("ended"),
        A3 = Symbol("lastPromise"), q2 = Symbol("handlePromise"), W2 = Symbol("stream");

function B4(e10, t13) {
    return {
        value: e10,
        done: t13
    };
}

function I5(e10) {
    var t13 = e10[x4];
    if (null !== t13) {
        var n15 = e10[W2].read();
        null !== n15 && (e10[A3] = null, e10[x4] = null, e10[L3] = null, t13(B4(n15, !1)));
    }
}

function N4(e10) {
    O3.nextTick(I5, e10);
}

var U4 = Object.getPrototypeOf(function () {
}), H2 = Object.setPrototypeOf((T6(M4 = {
    get stream() {
        return this[W2];
    },
    next: function () {
        var e10 = this, t13 = this[D4];
        if (null !== t13) {
            return Promise.reject(t13);
        }
        if (this[C4]) {
            return Promise.resolve(B4(void 0, !0));
        }
        if (this[W2].destroyed) {
            return new Promise(function (t14, n18) {
                O3.nextTick(function () {
                    e10[D4] ? n18(e10[D4]) : t14(B4(void 0, !0));
                });
            });
        }
        var n18, r16 = this[A3];
        if (r16) {
            n18 = new Promise(function (e12, t14) {
                return function (n19, r18) {
                    e12.then(function () {
                        if (t14[C4]) {
                            return (n19(B4(void 0, !0)), void 0);
                        }
                        t14[q2](n19, r18);
                    }, r18);
                };
            }(r16, this));
        } else {
            var i22 = this[W2].read();
            if (null !== i22) {
                return Promise.resolve(B4(i22, !1));
            }
            n18 = new Promise(this[q2]);
        }
        return (this[A3] = n18, n18);
    }
}, Symbol.asyncIterator, function () {
    return this;
}), T6(M4, "return", function () {
    var e10 = this;
    return new Promise(function (t13, n18) {
        e10[W2].destroy(null, function (e12) {
            if (e12) {
                return (n18(e12), void 0);
            }
            t13(B4(void 0, !0));
        });
    });
}), M4), U4), F4 = function (e10) {
    var t13, n18 = Object.create(H2, (T6(t13 = {}, W2, {
        value: e10,
        writable: !0
    }), T6(t13, x4, {
        value: null,
        writable: !0
    }), T6(t13, L3, {
        value: null,
        writable: !0
    }), T6(t13, D4, {
        value: null,
        writable: !0
    }), T6(t13, C4, {
        value: e10._readableState.endEmitted,
        writable: !0
    }), T6(t13, q2, {
        value: function (e12, t14) {
            var r16 = n18[W2].read();
            r16 ? (n18[A3] = null, n18[x4] = null, n18[L3] = null, e12(B4(r16, !1))) : (n18[x4] = e12, n18[L3] = t14);
        },
        writable: !0
    }), t13));
    return (n18[A3] = null, P5(e10, function (e12) {
        if (e12 && "ERR_STREAM_PREMATURE_CLOSE" !== e12.code) {
            var t14 = n18[L3];
            return (null !== t14 && (n18[A3] = null, n18[x4] = null, n18[L3] = null, t14(e12)), n18[D4] = e12, void 0);
        }
        var r16 = n18[x4];
        null !== r16 && (n18[A3] = null, n18[x4] = null, n18[L3] = null, r16(B4(void 0, !0))), n18[C4] = !0;
    }), e10.on("readable", N4.bind(null, n18)), n18);
}, V2 = {}, G2 = !1, Y3 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;

function K2() {
    if (G2) {
        return V2;
    }
    G2 = !0;
    var d4, u17 = T1;
    V2 = C5, C5.ReadableState = D5;
    y1.EventEmitter;
    var f14 = function (e10, t13) {
        return e10.listeners(t13).length;
    }, h13 = e9, c12 = e$1.Buffer, b7 = Y3.Uint8Array || function () {
    };
    var p11, y7 = X;
    p11 = y7 && y7.debuglog ? y7.debuglog("stream") : function () {
    };
    var w4, v8, _6, S4 = g7, k5 = m4, E5 = R4.getHighWaterMark, M5 = e$14.codes, j4 = M5.ERR_INVALID_ARG_TYPE,
            O4 = M5.ERR_STREAM_PUSH_AFTER_EOF, T7 = M5.ERR_METHOD_NOT_IMPLEMENTED,
            P6 = M5.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    t$2(C5, h13);
    var x5 = k5.errorOrDestroy, L4 = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];

    function D5(e10, t13, n18) {
        d4 = d4 || ee2(), e10 = e10 || {}, "boolean" != typeof n18 && (n18 = t13 instanceof d4), this.objectMode = !!e10.objectMode, n18 && (this.objectMode = this.objectMode || !!e10.readableObjectMode), this.highWaterMark = E5(this, e10, "readableHighWaterMark", n18), this.buffer = new S4, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== e10.emitClose, this.autoDestroy = !!e10.autoDestroy, this.destroyed = !1, this.defaultEncoding = e10.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e10.encoding && (w4 || (w4 = e$13.StringDecoder), this.decoder = new w4(e10.encoding), this.encoding = e10.encoding);
    }

    function C5(e10) {
        if (d4 = d4 || ee2(), !(this instanceof C5)) {
            return new C5(e10);
        }
        var t13 = this instanceof d4;
        this._readableState = new D5(e10, this, t13), this.readable = !0, e10 && ("function" == typeof e10.read && (this._read = e10.read), "function" == typeof e10.destroy && (this._destroy = e10.destroy)), h13.call(this);
    }

    function A4(e10, t13, n18, r16, i23) {
        p11("readableAddChunk", t13);
        var a19, o17 = e10._readableState;
        if (null === t13) {
            o17.reading = !1, (function (e12, t15) {
                if (p11("onEofChunk"), t15.ended) {
                    return;
                }
                if (t15.decoder) {
                    var n19 = t15.decoder.end();
                    n19 && n19.length && (t15.buffer.push(n19), t15.length += t15.objectMode ? 1 : n19.length);
                }
                t15.ended = !0, t15.sync ? B5(e12) : (t15.needReadable = !1, t15.emittedReadable || (t15.emittedReadable = !0, I6(e12)));
            })(e10, o17);
        } else if (i23 || (a19 = (function (e12, t15) {
            var n20;
            r18 = t15, c12.isBuffer(r18) || r18 instanceof b7 || "string" == typeof t15 || (void 0) === t15 || e12.objectMode || (n20 = new j4("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], t15));
            var r18;
            return n20;
        })(o17, t13)), a19) {
            x5(e10, a19);
        } else if (o17.objectMode || t13 && t13.length > 0) {
            if ("string" == typeof t13 || o17.objectMode || Object.getPrototypeOf(t13) === c12.prototype || (t13 = (function (e12) {
                return c12.from(e12);
            })(t13)), r16) {
                o17.endEmitted ? x5(e10, new P6) : q4(e10, o17, t13, !0);
            } else if (o17.ended) {
                x5(e10, new O4);
            } else {
                if (o17.destroyed) {
                    return !1;
                }
                o17.reading = !1, o17.decoder && !n18 ? (t13 = o17.decoder.write(t13), o17.objectMode || 0 !== t13.length ? q4(e10, o17, t13, !1) : N5(e10, o17)) : q4(e10, o17, t13, !1);
            }
        } else {
            r16 || (o17.reading = !1, N5(e10, o17));
        }
        return !o17.ended && (o17.length < o17.highWaterMark || 0 === o17.length);
    }

    function q4(e10, t13, n18, r16) {
        t13.flowing && 0 === t13.length && !t13.sync ? (t13.awaitDrain = 0, e10.emit("data", n18)) : (t13.length += t13.objectMode ? 1 : n18.length, r16 ? t13.buffer.unshift(n18) : t13.buffer.push(n18), t13.needReadable && B5(e10)), N5(e10, t13);
    }

    Object.defineProperty(C5.prototype, "destroyed", {
        enumerable: !1,
        get: function () {
            return (void 0) !== this._readableState && this._readableState.destroyed;
        },
        set: function (e10) {
            this._readableState && (this._readableState.destroyed = e10);
        }
    }), C5.prototype.destroy = k5.destroy, C5.prototype._undestroy = k5.undestroy, C5.prototype._destroy = function (e10, t13) {
        t13(e10);
    }, C5.prototype.push = function (e10, t13) {
        var n18, r16 = this._readableState;
        return r16.objectMode ? n18 = !0 : "string" == typeof e10 && ((t13 = t13 || r16.defaultEncoding) !== r16.encoding && (e10 = c12.from(e10, t13), t13 = ""), n18 = !0), A4(this, e10, t13, !1, n18);
    }, C5.prototype.unshift = function (e10) {
        return A4(this, e10, null, !0, !1);
    }, C5.prototype.isPaused = function () {
        return !1 === this._readableState.flowing;
    }, C5.prototype.setEncoding = function (e10) {
        w4 || (w4 = e$13.StringDecoder);
        var t13 = new w4(e10);
        this._readableState.decoder = t13, this._readableState.encoding = this._readableState.decoder.encoding;
        for (var n18 = this._readableState.buffer.head, r16 = ""; null !== n18;) {
            r16 += t13.write(n18.data), n18 = n18.next;
        }
        return this._readableState.buffer.clear(), "" !== r16 && this._readableState.buffer.push(r16), this._readableState.length = r16.length, this;
    };

    function W3(e10, t13) {
        return e10 <= 0 || 0 === t13.length && t13.ended ? 0 : t13.objectMode ? 1 : e10 != e10 ? t13.flowing && t13.length ? t13.buffer.head.data.length : t13.length : (e10 > t13.highWaterMark && (t13.highWaterMark = (function (e12) {
            return e12 >= 1073741824 ? e12 = 1073741824 : (e12--, e12 |= e12 >>> 1, e12 |= e12 >>> 2, e12 |= e12 >>> 4, e12 |= e12 >>> 8, e12 |= e12 >>> 16, e12++), e12;
        })(e10)), e10 <= t13.length ? e10 : t13.ended ? t13.length : (t13.needReadable = !0, 0));
    }

    function B5(e10) {
        var t13 = e10._readableState;
        p11("emitReadable", t13.needReadable, t13.emittedReadable), t13.needReadable = !1, t13.emittedReadable || (p11("emitReadable", t13.flowing), t13.emittedReadable = !0, u17.nextTick(I6, e10));
    }

    function I6(e10) {
        var t13 = e10._readableState;
        p11("emitReadable_", t13.destroyed, t13.length, t13.ended), t13.destroyed || !t13.length && !t13.ended || (e10.emit("readable"), t13.emittedReadable = !1), t13.needReadable = !t13.flowing && !t13.ended && t13.length <= t13.highWaterMark, J3(e10);
    }

    function N5(e10, t13) {
        t13.readingMore || (t13.readingMore = !0, u17.nextTick(U5, e10, t13));
    }

    function U5(e10, t13) {
        for (; !t13.reading && !t13.ended && (t13.length < t13.highWaterMark || t13.flowing && 0 === t13.length);) {
            var n18 = t13.length;
            if (p11("maybeReadMore read 0"), e10.read(0), n18 === t13.length) {
                break;
            }
        }
        t13.readingMore = !1;
    }

    function H3(e10) {
        var t13 = e10._readableState;
        t13.readableListening = e10.listenerCount("readable") > 0, t13.resumeScheduled && !t13.paused ? t13.flowing = !0 : e10.listenerCount("data") > 0 && e10.resume();
    }

    function K2(e10) {
        p11("readable nexttick read 0"), e10.read(0);
    }

    function z4(e10, t13) {
        p11("resume", t13.reading), t13.reading || e10.read(0), t13.resumeScheduled = !1, e10.emit("resume"), J3(e10), t13.flowing && !t13.reading && e10.read(0);
    }

    function J3(e10) {
        var t13 = e10._readableState;
        for (p11("flow", t13.flowing); t13.flowing && null !== e10.read();) {
            ;
        }
    }

    function Q3(e10, t13) {
        return 0 === t13.length ? null : (t13.objectMode ? n20 = t13.buffer.shift() : !e10 || e10 >= t13.length ? (n20 = t13.decoder ? t13.buffer.join("") : 1 === t13.buffer.length ? t13.buffer.first() : t13.buffer.concat(t13.length), t13.buffer.clear()) : n20 = t13.buffer.consume(e10, t13.decoder), n20);
        var n20;
    }

    function X2(e10) {
        var t13 = e10._readableState;
        p11("endReadable", t13.endEmitted), t13.endEmitted || (t13.ended = !0, u17.nextTick(Z3, t13, e10));
    }

    function Z3(e10, t13) {
        if (p11("endReadableNT", e10.endEmitted, e10.length), !e10.endEmitted && 0 === e10.length && (e10.endEmitted = !0, t13.readable = !1, t13.emit("end"), e10.autoDestroy)) {
            var n20 = t13._writableState;
            (!n20 || n20.autoDestroy && n20.finished) && t13.destroy();
        }
    }

    function $2(e10, t13) {
        for (var n21 = 0, r16 = e10.length; n21 < r16; n21++) {
            if (e10[n21] === t13) {
                return n21;
            }
        }
        return -1;
    }

    return C5.prototype.read = function (e10) {
        p11("read", e10), e10 = parseInt(e10, 10);
        var t13 = this._readableState, n21 = e10;
        if (0 !== e10 && (t13.emittedReadable = !1), 0 === e10 && t13.needReadable && ((0 !== t13.highWaterMark ? t13.length >= t13.highWaterMark : t13.length > 0) || t13.ended)) {
            return p11("read: emitReadable", t13.length, t13.ended), 0 === t13.length && t13.ended ? X2(this) : B5(this), null;
        }
        if (0 === (e10 = W3(e10, t13)) && t13.ended) {
            return 0 === t13.length && X2(this), null;
        }
        var r16, i23 = t13.needReadable;
        return p11("need readable", i23), (0 === t13.length || t13.length - e10 < t13.highWaterMark) && p11("length less than watermark", i23 = !0), t13.ended || t13.reading ? p11("reading or ended", i23 = !1) : i23 && (p11("do read"), t13.reading = !0, t13.sync = !0, 0 === t13.length && (t13.needReadable = !0), this._read(t13.highWaterMark), t13.sync = !1, t13.reading || (e10 = W3(n21, t13))), null === (r16 = e10 > 0 ? Q3(e10, t13) : null) ? (t13.needReadable = t13.length <= t13.highWaterMark, e10 = 0) : (t13.length -= e10, t13.awaitDrain = 0), 0 === t13.length && (t13.ended || (t13.needReadable = !0), n21 !== e10 && t13.ended && X2(this)), null !== r16 && this.emit("data", r16), r16;
    }, C5.prototype._read = function (e10) {
        x5(this, new T7("_read()"));
    }, C5.prototype.pipe = function (e10, t13) {
        var n21 = this, r16 = this._readableState;
        switch (r16.pipesCount) {
            case 0:
                r16.pipes = e10;
                break;
            case 1:
                r16.pipes = [
                    r16.pipes,
                    e10
                ];
                break;
            default:
                r16.pipes.push(e10);
        }
        r16.pipesCount += 1, p11("pipe count=%d opts=%j", r16.pipesCount, t13);
        var i23 = (!t13 || !1 !== t13.end) && e10 !== u17.stdout && e10 !== u17.stderr ? o18 : g8;

        function a19(t15, i24) {
            p11("onunpipe"), t15 === n21 && i24 && !1 === i24.hasUnpiped && (i24.hasUnpiped = !0, p11("cleanup"), e10.removeListener("close", c13), e10.removeListener("finish", b9), e10.removeListener("drain", s14), e10.removeListener("error", h14), e10.removeListener("unpipe", a19), n21.removeListener("end", o18), n21.removeListener("end", g8), n21.removeListener("data", d7), l17 = !0, !r16.awaitDrain || e10._writableState && !e10._writableState.needDrain || s14());
        }

        function o18() {
            p11("onend"), e10.end();
        }

        r16.endEmitted ? u17.nextTick(i23) : n21.once("end", i23), e10.on("unpipe", a19);
        var s14 = function (e12) {
            return function () {
                var t15 = e12._readableState;
                p11("pipeOnDrain", t15.awaitDrain), t15.awaitDrain && t15.awaitDrain--, 0 === t15.awaitDrain && f14(e12, "data") && (t15.flowing = !0, J3(e12));
            };
        }(n21);
        e10.on("drain", s14);
        var l17 = !1;

        function d7(t15) {
            p11("ondata");
            var i24 = e10.write(t15);
            p11("dest.write", i24), !1 === i24 && ((1 === r16.pipesCount && r16.pipes === e10 || r16.pipesCount > 1 && -1 !== $2(r16.pipes, e10)) && !l17 && (p11("false write response, pause", r16.awaitDrain), r16.awaitDrain++), n21.pause());
        }

        function h14(t15) {
            p11("onerror", t15), g8(), e10.removeListener("error", h14), 0 === f14(e10, "error") && x5(e10, t15);
        }

        function c13() {
            e10.removeListener("finish", b9), g8();
        }

        function b9() {
            p11("onfinish"), e10.removeListener("close", c13), g8();
        }

        function g8() {
            p11("unpipe"), n21.unpipe(e10);
        }

        return n21.on("data", d7), (function (e12, t15, n22) {
            if ("function" == typeof e12.prependListener) {
                return e12.prependListener(t15, n22);
            }
            e12._events && e12._events[t15] ? Array.isArray(e12._events[t15]) ? e12._events[t15].unshift(n22) : e12._events[t15] = [
                n22,
                e12._events[t15]
            ] : e12.on(t15, n22);
        })(e10, "error", h14), e10.once("close", c13), e10.once("finish", b9), e10.emit("pipe", n21), r16.flowing || (p11("pipe resume"), n21.resume()), e10;
    }, C5.prototype.unpipe = function (e10) {
        var t13 = this._readableState, n21 = {
            hasUnpiped: !1
        };
        if (0 === t13.pipesCount) {
            return this;
        }
        if (1 === t13.pipesCount) {
            return e10 && e10 !== t13.pipes || (e10 || (e10 = t13.pipes), t13.pipes = null, t13.pipesCount = 0, t13.flowing = !1, e10 && e10.emit("unpipe", this, n21)), this;
        }
        if (!e10) {
            var r16 = t13.pipes, i23 = t13.pipesCount;
            t13.pipes = null, t13.pipesCount = 0, t13.flowing = !1;
            for (var a19 = 0; a19 < i23; a19++) {
                r16[a19].emit("unpipe", this, {
                    hasUnpiped: !1
                });
            }
            return this;
        }
        var o18 = $2(t13.pipes, e10);
        return -1 === o18 || (t13.pipes.splice(o18, 1), t13.pipesCount -= 1, 1 === t13.pipesCount && (t13.pipes = t13.pipes[0]), e10.emit("unpipe", this, n21)), this;
    }, C5.prototype.on = function (e10, t13) {
        var n21 = h13.prototype.on.call(this, e10, t13), r18 = this._readableState;
        return "data" === e10 ? (r18.readableListening = this.listenerCount("readable") > 0, !1 !== r18.flowing && this.resume()) : "readable" === e10 && (r18.endEmitted || r18.readableListening || (r18.readableListening = r18.needReadable = !0, r18.flowing = !1, r18.emittedReadable = !1, p11("on readable", r18.length, r18.reading), r18.length ? B5(this) : r18.reading || u17.nextTick(K2, this))), n21;
    }, C5.prototype.addListener = C5.prototype.on, C5.prototype.removeListener = function (e10, t13) {
        var n21 = h13.prototype.removeListener.call(this, e10, t13);
        return "readable" === e10 && u17.nextTick(H3, this), n21;
    }, C5.prototype.removeAllListeners = function (e10) {
        var t13 = h13.prototype.removeAllListeners.apply(this, arguments);
        return "readable" !== e10 && (void 0) !== e10 || u17.nextTick(H3, this), t13;
    }, C5.prototype.resume = function () {
        var e10 = this._readableState;
        return e10.flowing || (p11("resume"), e10.flowing = !e10.readableListening, (function (e12, t13) {
            t13.resumeScheduled || (t13.resumeScheduled = !0, u17.nextTick(z4, e12, t13));
        })(this, e10)), e10.paused = !1, this;
    }, C5.prototype.pause = function () {
        return p11("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (p11("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
    }, C5.prototype.wrap = function (e10) {
        var t13 = this, n21 = this._readableState, r18 = !1;
        for (var i24 in e10.on("end", function () {
            if ((p11("wrapped end"), n21.decoder && !n21.ended)) {
                var e12 = n21.decoder.end();
                e12 && e12.length && t13.push(e12);
            }
            t13.push(null);
        }), e10.on("data", function (i25) {
            (p11("wrapped data"), n21.decoder && (i25 = n21.decoder.write(i25)), n21.objectMode && null == i25) || (n21.objectMode || i25 && i25.length) && (t13.push(i25) || (r18 = !0, e10.pause()));
        }), e10) {
            (void 0) === this[i24] && "function" == typeof e10[i24] && (this[i24] = (function (t15) {
                return function () {
                    return e10[t15].apply(e10, arguments);
                };
            })(i24));
        }
        for (var a20 = 0; a20 < L4.length; a20++) {
            e10.on(L4[a20], this.emit.bind(this, L4[a20]));
        }
        return this._read = function (t15) {
            p11("wrapped _read", t15), r18 && (r18 = !1, e10.resume());
        }, this;
    }, "function" == typeof Symbol && (C5.prototype[Symbol.asyncIterator] = function () {
        return (void 0) === v8 && (v8 = F4), v8(this);
    }), Object.defineProperty(C5.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function () {
            return this._readableState.highWaterMark;
        }
    }), Object.defineProperty(C5.prototype, "readableBuffer", {
        enumerable: !1,
        get: function () {
            return this._readableState && this._readableState.buffer;
        }
    }), Object.defineProperty(C5.prototype, "readableFlowing", {
        enumerable: !1,
        get: function () {
            return this._readableState.flowing;
        },
        set: function (e10) {
            this._readableState && (this._readableState.flowing = e10);
        }
    }), C5._fromList = Q3, Object.defineProperty(C5.prototype, "readableLength", {
        enumerable: !1,
        get: function () {
            return this._readableState.length;
        }
    }), "function" == typeof Symbol && (C5.from = function (e10, t13) {
        return (void 0) === _6 && (_6 = r$12), _6(C5, e10, t13);
    }), V2;
}

var z4 = {}, J3 = !1, Q3 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;

function X2() {
    if (J3) {
        return z4;
    }
    J3 = !0;
    var e$22, r18 = T1;

    function s14(e10) {
        var t13 = this;
        this.next = null, this.entry = null, this.finish = function () {
            !function (e13, t15, n21) {
                var r19 = e13.entry;
                e13.entry = null;
                for (; r19;) {
                    var i24 = r19.callback;
                    t15.pendingcb--, i24(n21), r19 = r19.next;
                }
                t15.corkedRequestsFree.next = e13;
            }(t13, e10);
        };
    }

    z4 = P6, P6.WritableState = T7;
    var l17 = {
        deprecate: t$12
    }, u17 = e9, f14 = e$1.Buffer, h13 = Q3.Uint8Array || function () {
    };
    var c12, b7 = m4, p11 = R4.getHighWaterMark, g8 = e$14.codes, y7 = g8.ERR_INVALID_ARG_TYPE,
            w4 = g8.ERR_METHOD_NOT_IMPLEMENTED, v8 = g8.ERR_MULTIPLE_CALLBACK, _6 = g8.ERR_STREAM_CANNOT_PIPE,
            S4 = g8.ERR_STREAM_DESTROYED, k5 = g8.ERR_STREAM_NULL_VALUES, E5 = g8.ERR_STREAM_WRITE_AFTER_END,
            M5 = g8.ERR_UNKNOWN_ENCODING, j4 = b7.errorOrDestroy;

    function O4() {
    }

    function T7(t13, n21, i25) {
        e$22 = e$22 || ee2(), t13 = t13 || {}, "boolean" != typeof i25 && (i25 = n21 instanceof e$22), this.objectMode = !!t13.objectMode, i25 && (this.objectMode = this.objectMode || !!t13.writableObjectMode), this.highWaterMark = p11(this, t13, "writableHighWaterMark", i25), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var a20 = !1 === t13.decodeStrings;
        this.decodeStrings = !a20, this.defaultEncoding = t13.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (e10) {
            !function (e13, t15) {
                var n22 = e13._writableState, i26 = n22.sync, a21 = n22.writecb;
                if ("function" != typeof a21) {
                    throw new v8;
                }
                if ((function (e14) {
                    e14.writing = !1, e14.writecb = null, e14.length -= e14.writelen, e14.writelen = 0;
                })(n22), t15) {
                    !function (e14, t16, n23, i27, a22) {
                        --t16.pendingcb, n23 ? (r18.nextTick(a22, i27), r18.nextTick(q4, e14, t16), e14._writableState.errorEmitted = !0, j4(e14, i27)) : (a22(i27), e14._writableState.errorEmitted = !0, j4(e14, i27), q4(e14, t16));
                    }(e13, n22, i26, t15, a21);
                } else {
                    var o18 = C5(n22) || e13.destroyed;
                    o18 || n22.corked || n22.bufferProcessing || !n22.bufferedRequest || D5(e13, n22), i26 ? r18.nextTick(L5, e13, n22, o18, a21) : L5(e13, n22, o18, a21);
                }
            }(n21, e10);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== t13.emitClose, this.autoDestroy = !!t13.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new s14(this);
    }

    function P6(t13) {
        var n21 = this instanceof (e$22 = e$22 || ee2());
        if (!n21 && !c12.call(P6, this)) {
            return new P6(t13);
        }
        this._writableState = new T7(t13, this, n21), this.writable = !0, t13 && ("function" == typeof t13.write && (this._write = t13.write), "function" == typeof t13.writev && (this._writev = t13.writev), "function" == typeof t13.destroy && (this._destroy = t13.destroy), "function" == typeof t13.final && (this._final = t13.final)), u17.call(this);
    }

    function x5(e10, t13, n21, r19, i25, a20, o19) {
        t13.writelen = r19, t13.writecb = o19, t13.writing = !0, t13.sync = !0, t13.destroyed ? t13.onwrite(new S4("write")) : n21 ? e10._writev(i25, t13.onwrite) : e10._write(i25, a20, t13.onwrite), t13.sync = !1;
    }

    function L5(e10, t13, n21, r19) {
        n21 || !function (e13, t15) {
            0 === t15.length && t15.needDrain && (t15.needDrain = !1, e13.emit("drain"));
        }(e10, t13), t13.pendingcb--, r19(), q4(e10, t13);
    }

    function D5(e10, t13) {
        t13.bufferProcessing = !0;
        var n21 = t13.bufferedRequest;
        if (e10._writev && n21 && n21.next) {
            var r19 = t13.bufferedRequestCount, i25 = new Array(r19), a20 = t13.corkedRequestsFree;
            a20.entry = n21;
            for (var o19 = 0, l18 = !0; n21;) {
                i25[o19] = n21, n21.isBuf || (l18 = !1), n21 = n21.next, o19 += 1;
            }
            i25.allBuffers = l18, x5(e10, t13, !0, t13.length, i25, "", a20.finish), t13.pendingcb++, t13.lastBufferedRequest = null, a20.next ? (t13.corkedRequestsFree = a20.next, a20.next = null) : t13.corkedRequestsFree = new s14(t13), t13.bufferedRequestCount = 0;
        } else {
            for (; n21;) {
                var d4 = n21.chunk, u18 = n21.encoding, f15 = n21.callback;
                if (x5(e10, t13, !1, t13.objectMode ? 1 : d4.length, d4, u18, f15), n21 = n21.next, t13.bufferedRequestCount--, t13.writing) {
                    break;
                }
            }
            null === n21 && (t13.lastBufferedRequest = null);
        }
        t13.bufferedRequest = n21, t13.bufferProcessing = !1;
    }

    function C5(e10) {
        return e10.ending && 0 === e10.length && null === e10.bufferedRequest && !e10.finished && !e10.writing;
    }

    function A4(e10, t13) {
        e10._final(function (n21) {
            t13.pendingcb--, n21 && j4(e10, n21), t13.prefinished = !0, e10.emit("prefinish"), q4(e10, t13);
        });
    }

    function q4(e10, t13) {
        var n21 = C5(t13);
        if (n21 && (!function (e13, t15) {
            t15.prefinished || t15.finalCalled || ("function" != typeof e13._final || t15.destroyed ? (t15.prefinished = !0, e13.emit("prefinish")) : (t15.pendingcb++, t15.finalCalled = !0, r18.nextTick(A4, e13, t15)));
        }(e10, t13), 0 === t13.pendingcb && (t13.finished = !0, e10.emit("finish"), t13.autoDestroy))) {
            var i26 = e10._readableState;
            (!i26 || i26.autoDestroy && i26.endEmitted) && e10.destroy();
        }
        return n21;
    }

    return t$2(P6, u17), T7.prototype.getBuffer = function () {
        for (var e10 = this.bufferedRequest, t13 = []; e10;) {
            t13.push(e10), e10 = e10.next;
        }
        return t13;
    }, (function () {
        try {
            Object.defineProperty(T7.prototype, "buffer", {
                get: l17.deprecate(function () {
                    return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch (e10) {
        }
    })(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (c12 = Function.prototype[Symbol.hasInstance], Object.defineProperty(P6, Symbol.hasInstance, {
        value: function (e10) {
            return !!c12.call(this, e10) || this === P6 && e10 && e10._writableState instanceof T7;
        }
    })) : c12 = function (e10) {
        return e10 instanceof this;
    }, P6.prototype.pipe = function () {
        j4(this, new _6);
    }, P6.prototype.write = function (e10, t13, n21) {
        var i27, a21 = this._writableState, o20 = !1,
                s15 = !a21.objectMode && (i27 = e10, f14.isBuffer(i27) || i27 instanceof h13);
        return s15 && !f14.isBuffer(e10) && (e10 = (function (e13) {
            return f14.from(e13);
        })(e10)), "function" == typeof t13 && (n21 = t13, t13 = null), s15 ? t13 = "buffer" : t13 || (t13 = a21.defaultEncoding), "function" != typeof n21 && (n21 = O4), a21.ending ? (function (e13, t15) {
            var n22 = new E5;
            j4(e13, n22), r18.nextTick(t15, n22);
        })(this, n21) : (s15 || (function (e13, t15, n22, i28) {
            var a22;
            return null === n22 ? a22 = new k5 : "string" == typeof n22 || t15.objectMode || (a22 = new y7("chunk", [
                "string",
                "Buffer"
            ], n22)), !a22 || (j4(e13, a22), r18.nextTick(i28, a22), !1);
        })(this, a21, e10, n21)) && (a21.pendingcb++, o20 = (function (e13, t15, n22, r20, i28, a22) {
            if (!n22) {
                var o21 = function (e14, t16, n23) {
                    e14.objectMode || !1 === e14.decodeStrings || "string" != typeof t16 || (t16 = f14.from(t16, n23));
                    return t16;
                }(t15, r20, i28);
                r20 !== o21 && (n22 = !0, i28 = "buffer", r20 = o21);
            }
            var s16 = t15.objectMode ? 1 : r20.length;
            t15.length += s16;
            var l19 = t15.length < t15.highWaterMark;
            l19 || (t15.needDrain = !0);
            if (t15.writing || t15.corked) {
                var d7 = t15.lastBufferedRequest;
                t15.lastBufferedRequest = {
                    chunk: r20,
                    encoding: i28,
                    isBuf: n22,
                    callback: a22,
                    next: null
                }, d7 ? d7.next = t15.lastBufferedRequest : t15.bufferedRequest = t15.lastBufferedRequest, t15.bufferedRequestCount += 1;
            } else {
                x5(e13, t15, !1, s16, r20, i28, a22);
            }
            return l19;
        })(this, a21, s15, e10, t13, n21)), o20;
    }, P6.prototype.cork = function () {
        this._writableState.corked++;
    }, P6.prototype.uncork = function () {
        var e10 = this._writableState;
        e10.corked && (e10.corked--, e10.writing || e10.corked || e10.bufferProcessing || !e10.bufferedRequest || D5(this, e10));
    }, P6.prototype.setDefaultEncoding = function (e10) {
        if ("string" == typeof e10 && (e10 = e10.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((e10 + "").toLowerCase()) > -1)) {
            throw new M5(e10);
        }
        return this._writableState.defaultEncoding = e10, this;
    }, Object.defineProperty(P6.prototype, "writableBuffer", {
        enumerable: !1,
        get: function () {
            return this._writableState && this._writableState.getBuffer();
        }
    }), Object.defineProperty(P6.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function () {
            return this._writableState.highWaterMark;
        }
    }), P6.prototype._write = function (e10, t13, n21) {
        n21(new w4("_write()"));
    }, P6.prototype._writev = null, P6.prototype.end = function (e10, t13, n21) {
        var i27 = this._writableState;
        return "function" == typeof e10 ? (n21 = e10, e10 = null, t13 = null) : "function" == typeof t13 && (n21 = t13, t13 = null), null != e10 && this.write(e10, t13), i27.corked && (i27.corked = 1, this.uncork()), i27.ending || (function (e13, t15, n22) {
            t15.ending = !0, q4(e13, t15), n22 && (t15.finished ? r18.nextTick(n22) : e13.once("finish", n22));
            t15.ended = !0, e13.writable = !1;
        })(this, i27, n21), this;
    }, Object.defineProperty(P6.prototype, "writableLength", {
        enumerable: !1,
        get: function () {
            return this._writableState.length;
        }
    }), Object.defineProperty(P6.prototype, "destroyed", {
        enumerable: !1,
        get: function () {
            return (void 0) !== this._writableState && this._writableState.destroyed;
        },
        set: function (e10) {
            this._writableState && (this._writableState.destroyed = e10);
        }
    }), P6.prototype.destroy = b7.destroy, P6.prototype._undestroy = b7.undestroy, P6.prototype._destroy = function (e10, t13) {
        t13(e10);
    }, z4;
}

var Z3 = {}, $2 = !1;

function ee2() {
    if ($2) {
        return Z3;
    }
    $2 = !0;
    var e10 = T1, t13 = Object.keys || function (e13) {
        var t13 = [];
        for (var n21 in e13) {
            t13.push(n21);
        }
        return t13;
    };
    Z3 = d8;
    var n21 = K2(), r18 = X2();
    t$2(d8, n21);
    for (var a21 = t13(r18.prototype), s14 = 0; s14 < a21.length; s14++) {
        var l17 = a21[s14];
        d8.prototype[l17] || (d8.prototype[l17] = r18.prototype[l17]);
    }

    function d8(e13) {
        if (!(this instanceof d8)) {
            return new d8(e13);
        }
        n21.call(this, e13), r18.call(this, e13), this.allowHalfOpen = !0, e13 && (!1 === e13.readable && (this.readable = !1), !1 === e13.writable && (this.writable = !1), !1 === e13.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", u17)));
    }

    function u17() {
        this._writableState.ended || e10.nextTick(f16, this);
    }

    function f16(e13) {
        e13.end();
    }

    return Object.defineProperty(d8.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function () {
            return this._writableState.highWaterMark;
        }
    }), Object.defineProperty(d8.prototype, "writableBuffer", {
        enumerable: !1,
        get: function () {
            return this._writableState && this._writableState.getBuffer();
        }
    }), Object.defineProperty(d8.prototype, "writableLength", {
        enumerable: !1,
        get: function () {
            return this._writableState.length;
        }
    }), Object.defineProperty(d8.prototype, "destroyed", {
        enumerable: !1,
        get: function () {
            return (void 0) !== this._readableState && (void 0) !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function (e13) {
            (void 0) !== this._readableState && (void 0) !== this._writableState && (this._readableState.destroyed = e13, this._writableState.destroyed = e13);
        }
    }), Z3;
}

var t$22 = K2();
var r$31 = e$14.codes.ERR_STREAM_PREMATURE_CLOSE;

function t$31() {
}

var n$15 = function e9(n21, o20, a21) {
    if ("function" == typeof o20) {
        return e9(n21, null, o20);
    }
    o20 || (o20 = {}), a21 = (function (e10) {
        var r18 = !1;
        return function () {
            if (!r18) {
                r18 = !0;
                for (var t13 = arguments.length, n22 = new Array(t13), o22 = 0; o22 < t13; o22++) {
                    n22[o22] = arguments[o22];
                }
                e10.apply(this, n22);
            }
        };
    })(a21 || t$31);
    var i27 = o20.readable || !1 !== o20.readable && n21.readable,
            l19 = o20.writable || !1 !== o20.writable && n21.writable, c12 = function () {
                n21.writable || s14();
            }, f16 = n21._writableState && n21._writableState.finished, s14 = function () {
                l19 = !1, f16 = !0, i27 || a21.call(n21);
            }, u17 = n21._readableState && n21._readableState.endEmitted, d8 = function () {
                i27 = !1, u17 = !0, l19 || a21.call(n21);
            }, b7 = function (e10) {
                a21.call(n21, e10);
            }, v8 = function () {
                var e10;
                return i27 && !u17 ? (n21._readableState && n21._readableState.ended || (e10 = new r$31), a21.call(n21, e10)) : l19 && !f16 ? (n21._writableState && n21._writableState.ended || (e10 = new r$31), a21.call(n21, e10)) : void 0;
            }, m5 = function () {
                n21.req.on("finish", s14);
            };
    return (!function (e10) {
        return e10.setHeader && "function" == typeof e10.abort;
    }(n21) ? l19 && !n21._writableState && (n21.on("end", c12), n21.on("close", c12)) : (n21.on("complete", s14), n21.on("abort", v8), n21.req ? m5() : n21.on("request", m5)), n21.on("end", d8), n21.on("finish", s14), !1 !== o20.error && n21.on("error", b7), n21.on("close", v8), function () {
        n21.removeListener("complete", s14), n21.removeListener("abort", v8), n21.removeListener("request", m5), n21.req && n21.req.removeListener("finish", s14), n21.removeListener("end", c12), n21.removeListener("close", c12), n21.removeListener("finish", s14), n21.removeListener("end", d8), n21.removeListener("error", b7), n21.removeListener("close", v8);
    });
};

function f$13(e10, t15) {
    var n21 = Object.keys(e10);
    if (Object.getOwnPropertySymbols) {
        var r18 = Object.getOwnPropertySymbols(e10);
        t15 && (r18 = r18.filter(function (t16) {
            return Object.getOwnPropertyDescriptor(e10, t16).enumerable;
        })), n21.push.apply(n21, r18);
    }
    return n21;
}

function h$12(e10, t15, n21) {
    return t15 in e10 ? Object.defineProperty(e10, t15, {
        value: n21,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e10[t15] = n21, e10;
}

function c$13(e10, t15) {
    for (var n21 = 0; n21 < t15.length; n21++) {
        var r20 = t15[n21];
        r20.enumerable = r20.enumerable || !1, r20.configurable = !0, "value" in r20 && (r20.writable = !0), Object.defineProperty(e10, r20.key, r20);
    }
}

var b$11 = e$1.Buffer, p$11 = X.inspect, g$11 = p$11 && p$11.custom || "inspect";
var y$11 = function () {
    function e10() {
        !function (e13, t15) {
            if (!(e13 instanceof t15)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }(this, e10), this.head = null, this.tail = null, this.length = 0;
    }

    var t15, n21;
    return t15 = e10, (n21 = [
        {
            key: "push",
            value: function (e13) {
                var t16 = {
                    data: e13,
                    next: null
                };
                this.length > 0 ? this.tail.next = t16 : this.head = t16, this.tail = t16, ++this.length;
            }
        },
        {
            key: "unshift",
            value: function (e13) {
                var t16 = {
                    data: e13,
                    next: this.head
                };
                0 === this.length && (this.tail = t16), this.head = t16, ++this.length;
            }
        },
        {
            key: "shift",
            value: function () {
                if (0 !== this.length) {
                    var e13 = this.head.data;
                    return (1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e13);
                }
            }
        },
        {
            key: "clear",
            value: function () {
                this.head = this.tail = null, this.length = 0;
            }
        },
        {
            key: "join",
            value: function (e14) {
                if (0 === this.length) {
                    return "";
                }
                for (var t16 = this.head, n23 = "" + t16.data; t16 = t16.next;) {
                    n23 += e14 + t16.data;
                }
                return n23;
            }
        },
        {
            key: "concat",
            value: function (e14) {
                if (0 === this.length) {
                    return b$11.alloc(0);
                }
                for (var t16, n23, r21, i27 = b$11.allocUnsafe(e14 >>> 0), a21 = this.head, o20 = 0; a21;) {
                    t16 = a21.data, n23 = i27, r21 = o20, b$11.prototype.copy.call(t16, n23, r21), o20 += a21.data.length, a21 = a21.next;
                }
                return i27;
            }
        },
        {
            key: "consume",
            value: function (e14, t16) {
                var n23;
                return (e14 < this.head.data.length ? (n23 = this.head.data.slice(0, e14), this.head.data = this.head.data.slice(e14)) : n23 = e14 === this.head.data.length ? this.shift() : t16 ? this._getString(e14) : this._getBuffer(e14), n23);
            }
        },
        {
            key: "first",
            value: function () {
                return this.head.data;
            }
        },
        {
            key: "_getString",
            value: function (e14) {
                var t16 = this.head, n23 = 1, r21 = t16.data;
                for (e14 -= r21.length; t16 = t16.next;) {
                    var i27 = t16.data, a21 = e14 > i27.length ? i27.length : e14;
                    if ((a21 === i27.length ? r21 += i27 : r21 += i27.slice(0, e14), 0 == (e14 -= a21))) {
                        a21 === i27.length ? (++n23, t16.next ? this.head = t16.next : this.head = this.tail = null) : (this.head = t16, t16.data = i27.slice(a21));
                        break;
                    }
                    ++n23;
                }
                return (this.length -= n23, r21);
            }
        },
        {
            key: "_getBuffer",
            value: function (e14) {
                var t16 = b$11.allocUnsafe(e14), n23 = this.head, r21 = 1;
                for ((n23.data.copy(t16), e14 -= n23.data.length); n23 = n23.next;) {
                    var i28 = n23.data, a22 = e14 > i28.length ? i28.length : e14;
                    if ((i28.copy(t16, t16.length - e14, 0, a22), 0 == (e14 -= a22))) {
                        a22 === i28.length ? (++r21, n23.next ? this.head = n23.next : this.head = this.tail = null) : (this.head = n23, n23.data = i28.slice(a22));
                        break;
                    }
                    ++r21;
                }
                return (this.length -= r21, t16);
            }
        },
        {
            key: g$11,
            value: function (e14, t16) {
                return p$11(this, function (e15) {
                    for (var t17 = 1; t17 < arguments.length; t17++) {
                        var n23 = null != arguments[t17] ? arguments[t17] : {};
                        t17 % 2 ? f$13(Object(n23), !0).forEach(function (t18) {
                            h$12(e15, t18, n23[t18]);
                        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e15, Object.getOwnPropertyDescriptors(n23)) : f$13(Object(n23)).forEach(function (t18) {
                            Object.defineProperty(e15, t18, Object.getOwnPropertyDescriptor(n23, t18));
                        });
                    }
                    return e15;
                }({}, t16, {
                    depth: 0,
                    customInspect: !1
                }));
            }
        }
    ]) && c$13(t15.prototype, n21), e10;
}(), w$11 = T1;

function _$1(e10, t15) {
    m$12(e10, t15), v$12(e10);
}

function v$12(e10) {
    e10._writableState && !e10._writableState.emitClose || e10._readableState && !e10._readableState.emitClose || e10.emit("close");
}

function m$12(e10, t15) {
    e10.emit("error", t15);
}

var S$1 = {
    destroy: function (e10, t15) {
        var n21 = this, r21 = this._readableState && this._readableState.destroyed,
                i29 = this._writableState && this._writableState.destroyed;
        return r21 || i29 ? (t15 ? t15(e10) : e10 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, w$11.nextTick(m$12, this, e10)) : w$11.nextTick(m$12, this, e10)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e10 || null, function (e14) {
            !t15 && e14 ? n21._writableState ? n21._writableState.errorEmitted ? w$11.nextTick(v$12, n21) : (n21._writableState.errorEmitted = !0, w$11.nextTick(_$1, n21, e14)) : w$11.nextTick(_$1, n21, e14) : t15 ? (w$11.nextTick(v$12, n21), t15(e14)) : w$11.nextTick(v$12, n21);
        }), this);
    },
    undestroy: function () {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    },
    errorOrDestroy: function (e10, t15) {
        var n21 = e10._readableState, r21 = e10._writableState;
        n21 && n21.autoDestroy || r21 && r21.autoDestroy ? e10.destroy(t15) : e10.emit("error", t15);
    }
}, R$1 = e$14.codes.ERR_INVALID_OPT_VALUE;
var k$1, E$1 = {
    getHighWaterMark: function (e10, t15, n21, r21) {
        var i29 = function (e14, t16, n24) {
            return null != e14.highWaterMark ? e14.highWaterMark : t16 ? e14[n24] : null;
        }(t15, r21, n21);
        if (null != i29) {
            if (!isFinite(i29) || Math.floor(i29) !== i29 || i29 < 0) {
                throw new R$1(r21 ? n21 : "highWaterMark", i29);
            }
            return Math.floor(i29);
        }
        return e10.objectMode ? 16 : 16384;
    }
}, M$1 = T1;

function j$11(e10, t15, n21) {
    return t15 in e10 ? Object.defineProperty(e10, t15, {
        value: n21,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e10[t15] = n21, e10;
}

var O$1 = n$15, T$1 = Symbol("lastResolve"), x$1 = Symbol("lastReject"), P$11 = Symbol("error"), D$1 = Symbol("ended"),
        L$1 = Symbol("lastPromise"), C$1 = Symbol("handlePromise"), A$11 = Symbol("stream");

function W$1(e10, t15) {
    return {
        value: e10,
        done: t15
    };
}

function B$1(e10) {
    var t15 = e10[T$1];
    if (null !== t15) {
        var n21 = e10[A$11].read();
        null !== n21 && (e10[L$1] = null, e10[T$1] = null, e10[x$1] = null, t15(W$1(n21, !1)));
    }
}

function q$1(e10) {
    M$1.nextTick(B$1, e10);
}

var I$1 = Object.getPrototypeOf(function () {
        }), N$11 = Object.setPrototypeOf((j$11(k$1 = {
            get stream() {
                return this[A$11];
            },
            next: function () {
                var e10 = this, t15 = this[P$11];
                if (null !== t15) {
                    return Promise.reject(t15);
                }
                if (this[D$1]) {
                    return Promise.resolve(W$1(void 0, !0));
                }
                if (this[A$11].destroyed) {
                    return new Promise(function (t16, n24) {
                        M$1.nextTick(function () {
                            e10[P$11] ? n24(e10[P$11]) : t16(W$1(void 0, !0));
                        });
                    });
                }
                var n24, r21 = this[L$1];
                if (r21) {
                    n24 = new Promise(function (e14, t16) {
                        return function (n25, r22) {
                            e14.then(function () {
                                if (t16[D$1]) {
                                    return (n25(W$1(void 0, !0)), void 0);
                                }
                                t16[C$1](n25, r22);
                            }, r22);
                        };
                    }(r21, this));
                } else {
                    var i29 = this[A$11].read();
                    if (null !== i29) {
                        return Promise.resolve(W$1(i29, !1));
                    }
                    n24 = new Promise(this[C$1]);
                }
                return (this[L$1] = n24, n24);
            }
        }, Symbol.asyncIterator, function () {
            return this;
        }), j$11(k$1, "return", function () {
            var e10 = this;
            return new Promise(function (t15, n24) {
                e10[A$11].destroy(null, function (e14) {
                    if (e14) {
                        return (n24(e14), void 0);
                    }
                    t15(W$1(void 0, !0));
                });
            });
        }), k$1), I$1), U$1 = function (e10) {
            var t15, n24 = Object.create(N$11, (j$11(t15 = {}, A$11, {
                value: e10,
                writable: !0
            }), j$11(t15, T$1, {
                value: null,
                writable: !0
            }), j$11(t15, x$1, {
                value: null,
                writable: !0
            }), j$11(t15, P$11, {
                value: null,
                writable: !0
            }), j$11(t15, D$1, {
                value: e10._readableState.endEmitted,
                writable: !0
            }), j$11(t15, C$1, {
                value: function (e14, t16) {
                    var r21 = n24[A$11].read();
                    r21 ? (n24[L$1] = null, n24[T$1] = null, n24[x$1] = null, e14(W$1(r21, !1))) : (n24[T$1] = e14, n24[x$1] = t16);
                },
                writable: !0
            }), t15));
            return (n24[L$1] = null, O$1(e10, function (e14) {
                if (e14 && "ERR_STREAM_PREMATURE_CLOSE" !== e14.code) {
                    var t16 = n24[x$1];
                    return (null !== t16 && (n24[L$1] = null, n24[T$1] = null, n24[x$1] = null, t16(e14)), n24[P$11] = e14, void 0);
                }
                var r21 = n24[T$1];
                null !== r21 && (n24[L$1] = null, n24[T$1] = null, n24[x$1] = null, r21(W$1(void 0, !0))), n24[D$1] = !0;
            }), e10.on("readable", q$1.bind(null, n24)), n24);
        }, H$1 = {}, F$1 = !1,
        V$11 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;

function G$1() {
    if (F$1) {
        return H$1;
    }
    F$1 = !0;
    var l19, u17 = T1;
    H$1 = C5, C5.ReadableState = L5;
    y1.EventEmitter;
    var f16 = function (e10, t15) {
        return e10.listeners(t15).length;
    }, h13 = e9, c12 = e$1.Buffer, b7 = V$11.Uint8Array || function () {
    };
    var p11, g8 = X;
    p11 = g8 && g8.debuglog ? g8.debuglog("stream") : function () {
    };
    var w4, _6, v8, m5 = y$11, R5 = S$1, k5 = E$1.getHighWaterMark, M5 = e$14.codes, j4 = M5.ERR_INVALID_ARG_TYPE,
            O4 = M5.ERR_STREAM_PUSH_AFTER_EOF, T7 = M5.ERR_METHOD_NOT_IMPLEMENTED,
            x5 = M5.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    t$2(C5, h13);
    var P6 = R5.errorOrDestroy, D5 = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];

    function L5(e10, t15, n24) {
        l19 = l19 || Z$1(), e10 = e10 || {}, "boolean" != typeof n24 && (n24 = t15 instanceof l19), this.objectMode = !!e10.objectMode, n24 && (this.objectMode = this.objectMode || !!e10.readableObjectMode), this.highWaterMark = k5(this, e10, "readableHighWaterMark", n24), this.buffer = new m5, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== e10.emitClose, this.autoDestroy = !!e10.autoDestroy, this.destroyed = !1, this.defaultEncoding = e10.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e10.encoding && (w4 || (w4 = e$13.StringDecoder), this.decoder = new w4(e10.encoding), this.encoding = e10.encoding);
    }

    function C5(e10) {
        if (l19 = l19 || Z$1(), !(this instanceof C5)) {
            return new C5(e10);
        }
        var t15 = this instanceof l19;
        this._readableState = new L5(e10, this, t15), this.readable = !0, e10 && ("function" == typeof e10.read && (this._read = e10.read), "function" == typeof e10.destroy && (this._destroy = e10.destroy)), h13.call(this);
    }

    function A4(e10, t15, n24, r21, i30) {
        p11("readableAddChunk", t15);
        var a23, o20 = e10._readableState;
        if (null === t15) {
            o20.reading = !1, (function (e14, t17) {
                if (p11("onEofChunk"), t17.ended) {
                    return;
                }
                if (t17.decoder) {
                    var n25 = t17.decoder.end();
                    n25 && n25.length && (t17.buffer.push(n25), t17.length += t17.objectMode ? 1 : n25.length);
                }
                t17.ended = !0, t17.sync ? q4(e14) : (t17.needReadable = !1, t17.emittedReadable || (t17.emittedReadable = !0, I6(e14)));
            })(e10, o20);
        } else if (i30 || (a23 = (function (e14, t17) {
            var n26;
            r22 = t17, c12.isBuffer(r22) || r22 instanceof b7 || "string" == typeof t17 || (void 0) === t17 || e14.objectMode || (n26 = new j4("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], t17));
            var r22;
            return n26;
        })(o20, t15)), a23) {
            P6(e10, a23);
        } else if (o20.objectMode || t15 && t15.length > 0) {
            if ("string" == typeof t15 || o20.objectMode || Object.getPrototypeOf(t15) === c12.prototype || (t15 = (function (e14) {
                return c12.from(e14);
            })(t15)), r21) {
                o20.endEmitted ? P6(e10, new x5) : W4(e10, o20, t15, !0);
            } else if (o20.ended) {
                P6(e10, new O4);
            } else {
                if (o20.destroyed) {
                    return !1;
                }
                o20.reading = !1, o20.decoder && !n24 ? (t15 = o20.decoder.write(t15), o20.objectMode || 0 !== t15.length ? W4(e10, o20, t15, !1) : N5(e10, o20)) : W4(e10, o20, t15, !1);
            }
        } else {
            r21 || (o20.reading = !1, N5(e10, o20));
        }
        return !o20.ended && (o20.length < o20.highWaterMark || 0 === o20.length);
    }

    function W4(e10, t15, n24, r21) {
        t15.flowing && 0 === t15.length && !t15.sync ? (t15.awaitDrain = 0, e10.emit("data", n24)) : (t15.length += t15.objectMode ? 1 : n24.length, r21 ? t15.buffer.unshift(n24) : t15.buffer.push(n24), t15.needReadable && q4(e10)), N5(e10, t15);
    }

    Object.defineProperty(C5.prototype, "destroyed", {
        enumerable: !1,
        get: function () {
            return (void 0) !== this._readableState && this._readableState.destroyed;
        },
        set: function (e10) {
            this._readableState && (this._readableState.destroyed = e10);
        }
    }), C5.prototype.destroy = R5.destroy, C5.prototype._undestroy = R5.undestroy, C5.prototype._destroy = function (e10, t15) {
        t15(e10);
    }, C5.prototype.push = function (e10, t15) {
        var n24, r21 = this._readableState;
        return r21.objectMode ? n24 = !0 : "string" == typeof e10 && ((t15 = t15 || r21.defaultEncoding) !== r21.encoding && (e10 = c12.from(e10, t15), t15 = ""), n24 = !0), A4(this, e10, t15, !1, n24);
    }, C5.prototype.unshift = function (e10) {
        return A4(this, e10, null, !0, !1);
    }, C5.prototype.isPaused = function () {
        return !1 === this._readableState.flowing;
    }, C5.prototype.setEncoding = function (e10) {
        w4 || (w4 = e$13.StringDecoder);
        var t15 = new w4(e10);
        this._readableState.decoder = t15, this._readableState.encoding = this._readableState.decoder.encoding;
        for (var n24 = this._readableState.buffer.head, r21 = ""; null !== n24;) {
            r21 += t15.write(n24.data), n24 = n24.next;
        }
        return this._readableState.buffer.clear(), "" !== r21 && this._readableState.buffer.push(r21), this._readableState.length = r21.length, this;
    };

    function B5(e10, t15) {
        return e10 <= 0 || 0 === t15.length && t15.ended ? 0 : t15.objectMode ? 1 : e10 != e10 ? t15.flowing && t15.length ? t15.buffer.head.data.length : t15.length : (e10 > t15.highWaterMark && (t15.highWaterMark = (function (e14) {
            return e14 >= 1073741824 ? e14 = 1073741824 : (e14--, e14 |= e14 >>> 1, e14 |= e14 >>> 2, e14 |= e14 >>> 4, e14 |= e14 >>> 8, e14 |= e14 >>> 16, e14++), e14;
        })(e10)), e10 <= t15.length ? e10 : t15.ended ? t15.length : (t15.needReadable = !0, 0));
    }

    function q4(e10) {
        var t15 = e10._readableState;
        p11("emitReadable", t15.needReadable, t15.emittedReadable), t15.needReadable = !1, t15.emittedReadable || (p11("emitReadable", t15.flowing), t15.emittedReadable = !0, u17.nextTick(I6, e10));
    }

    function I6(e10) {
        var t15 = e10._readableState;
        p11("emitReadable_", t15.destroyed, t15.length, t15.ended), t15.destroyed || !t15.length && !t15.ended || (e10.emit("readable"), t15.emittedReadable = !1), t15.needReadable = !t15.flowing && !t15.ended && t15.length <= t15.highWaterMark, J4(e10);
    }

    function N5(e10, t15) {
        t15.readingMore || (t15.readingMore = !0, u17.nextTick(G4, e10, t15));
    }

    function G4(e10, t15) {
        for (; !t15.reading && !t15.ended && (t15.length < t15.highWaterMark || t15.flowing && 0 === t15.length);) {
            var n24 = t15.length;
            if (p11("maybeReadMore read 0"), e10.read(0), n24 === t15.length) {
                break;
            }
        }
        t15.readingMore = !1;
    }

    function Y4(e10) {
        var t15 = e10._readableState;
        t15.readableListening = e10.listenerCount("readable") > 0, t15.resumeScheduled && !t15.paused ? t15.flowing = !0 : e10.listenerCount("data") > 0 && e10.resume();
    }

    function K3(e10) {
        p11("readable nexttick read 0"), e10.read(0);
    }

    function z5(e10, t15) {
        p11("resume", t15.reading), t15.reading || e10.read(0), t15.resumeScheduled = !1, e10.emit("resume"), J4(e10), t15.flowing && !t15.reading && e10.read(0);
    }

    function J4(e10) {
        var t15 = e10._readableState;
        for (p11("flow", t15.flowing); t15.flowing && null !== e10.read();) {
            ;
        }
    }

    function Q4(e10, t15) {
        return 0 === t15.length ? null : (t15.objectMode ? n26 = t15.buffer.shift() : !e10 || e10 >= t15.length ? (n26 = t15.decoder ? t15.buffer.join("") : 1 === t15.buffer.length ? t15.buffer.first() : t15.buffer.concat(t15.length), t15.buffer.clear()) : n26 = t15.buffer.consume(e10, t15.decoder), n26);
        var n26;
    }

    function X3(e10) {
        var t15 = e10._readableState;
        p11("endReadable", t15.endEmitted), t15.endEmitted || (t15.ended = !0, u17.nextTick($4, t15, e10));
    }

    function $4(e10, t15) {
        if (p11("endReadableNT", e10.endEmitted, e10.length), !e10.endEmitted && 0 === e10.length && (e10.endEmitted = !0, t15.readable = !1, t15.emit("end"), e10.autoDestroy)) {
            var n26 = t15._writableState;
            (!n26 || n26.autoDestroy && n26.finished) && t15.destroy();
        }
    }

    function ee3(e10, t15) {
        for (var n27 = 0, r21 = e10.length; n27 < r21; n27++) {
            if (e10[n27] === t15) {
                return n27;
            }
        }
        return -1;
    }

    return C5.prototype.read = function (e10) {
        p11("read", e10), e10 = parseInt(e10, 10);
        var t15 = this._readableState, n27 = e10;
        if (0 !== e10 && (t15.emittedReadable = !1), 0 === e10 && t15.needReadable && ((0 !== t15.highWaterMark ? t15.length >= t15.highWaterMark : t15.length > 0) || t15.ended)) {
            return p11("read: emitReadable", t15.length, t15.ended), 0 === t15.length && t15.ended ? X3(this) : q4(this), null;
        }
        if (0 === (e10 = B5(e10, t15)) && t15.ended) {
            return 0 === t15.length && X3(this), null;
        }
        var r21, i30 = t15.needReadable;
        return p11("need readable", i30), (0 === t15.length || t15.length - e10 < t15.highWaterMark) && p11("length less than watermark", i30 = !0), t15.ended || t15.reading ? p11("reading or ended", i30 = !1) : i30 && (p11("do read"), t15.reading = !0, t15.sync = !0, 0 === t15.length && (t15.needReadable = !0), this._read(t15.highWaterMark), t15.sync = !1, t15.reading || (e10 = B5(n27, t15))), null === (r21 = e10 > 0 ? Q4(e10, t15) : null) ? (t15.needReadable = t15.length <= t15.highWaterMark, e10 = 0) : (t15.length -= e10, t15.awaitDrain = 0), 0 === t15.length && (t15.ended || (t15.needReadable = !0), n27 !== e10 && t15.ended && X3(this)), null !== r21 && this.emit("data", r21), r21;
    }, C5.prototype._read = function (e10) {
        P6(this, new T7("_read()"));
    }, C5.prototype.pipe = function (e10, t15) {
        var n27 = this, r21 = this._readableState;
        switch (r21.pipesCount) {
            case 0:
                r21.pipes = e10;
                break;
            case 1:
                r21.pipes = [
                    r21.pipes,
                    e10
                ];
                break;
            default:
                r21.pipes.push(e10);
        }
        r21.pipesCount += 1, p11("pipe count=%d opts=%j", r21.pipesCount, t15);
        var i30 = (!t15 || !1 !== t15.end) && e10 !== u17.stdout && e10 !== u17.stderr ? o20 : g9;

        function a23(t17, i31) {
            p11("onunpipe"), t17 === n27 && i31 && !1 === i31.hasUnpiped && (i31.hasUnpiped = !0, p11("cleanup"), e10.removeListener("close", c13), e10.removeListener("finish", b9), e10.removeListener("drain", s14), e10.removeListener("error", h14), e10.removeListener("unpipe", a23), n27.removeListener("end", o20), n27.removeListener("end", g9), n27.removeListener("data", d8), l20 = !0, !r21.awaitDrain || e10._writableState && !e10._writableState.needDrain || s14());
        }

        function o20() {
            p11("onend"), e10.end();
        }

        r21.endEmitted ? u17.nextTick(i30) : n27.once("end", i30), e10.on("unpipe", a23);
        var s14 = function (e14) {
            return function () {
                var t17 = e14._readableState;
                p11("pipeOnDrain", t17.awaitDrain), t17.awaitDrain && t17.awaitDrain--, 0 === t17.awaitDrain && f16(e14, "data") && (t17.flowing = !0, J4(e14));
            };
        }(n27);
        e10.on("drain", s14);
        var l20 = !1;

        function d8(t17) {
            p11("ondata");
            var i31 = e10.write(t17);
            p11("dest.write", i31), !1 === i31 && ((1 === r21.pipesCount && r21.pipes === e10 || r21.pipesCount > 1 && -1 !== ee3(r21.pipes, e10)) && !l20 && (p11("false write response, pause", r21.awaitDrain), r21.awaitDrain++), n27.pause());
        }

        function h14(t17) {
            p11("onerror", t17), g9(), e10.removeListener("error", h14), 0 === f16(e10, "error") && P6(e10, t17);
        }

        function c13() {
            e10.removeListener("finish", b9), g9();
        }

        function b9() {
            p11("onfinish"), e10.removeListener("close", c13), g9();
        }

        function g9() {
            p11("unpipe"), n27.unpipe(e10);
        }

        return n27.on("data", d8), (function (e14, t17, n28) {
            if ("function" == typeof e14.prependListener) {
                return e14.prependListener(t17, n28);
            }
            e14._events && e14._events[t17] ? Array.isArray(e14._events[t17]) ? e14._events[t17].unshift(n28) : e14._events[t17] = [
                n28,
                e14._events[t17]
            ] : e14.on(t17, n28);
        })(e10, "error", h14), e10.once("close", c13), e10.once("finish", b9), e10.emit("pipe", n27), r21.flowing || (p11("pipe resume"), n27.resume()), e10;
    }, C5.prototype.unpipe = function (e10) {
        var t15 = this._readableState, n27 = {
            hasUnpiped: !1
        };
        if (0 === t15.pipesCount) {
            return this;
        }
        if (1 === t15.pipesCount) {
            return e10 && e10 !== t15.pipes || (e10 || (e10 = t15.pipes), t15.pipes = null, t15.pipesCount = 0, t15.flowing = !1, e10 && e10.emit("unpipe", this, n27)), this;
        }
        if (!e10) {
            var r21 = t15.pipes, i30 = t15.pipesCount;
            t15.pipes = null, t15.pipesCount = 0, t15.flowing = !1;
            for (var a23 = 0; a23 < i30; a23++) {
                r21[a23].emit("unpipe", this, {
                    hasUnpiped: !1
                });
            }
            return this;
        }
        var o20 = ee3(t15.pipes, e10);
        return -1 === o20 || (t15.pipes.splice(o20, 1), t15.pipesCount -= 1, 1 === t15.pipesCount && (t15.pipes = t15.pipes[0]), e10.emit("unpipe", this, n27)), this;
    }, C5.prototype.on = function (e10, t15) {
        var n27 = h13.prototype.on.call(this, e10, t15), r22 = this._readableState;
        return "data" === e10 ? (r22.readableListening = this.listenerCount("readable") > 0, !1 !== r22.flowing && this.resume()) : "readable" === e10 && (r22.endEmitted || r22.readableListening || (r22.readableListening = r22.needReadable = !0, r22.flowing = !1, r22.emittedReadable = !1, p11("on readable", r22.length, r22.reading), r22.length ? q4(this) : r22.reading || u17.nextTick(K3, this))), n27;
    }, C5.prototype.addListener = C5.prototype.on, C5.prototype.removeListener = function (e10, t15) {
        var n27 = h13.prototype.removeListener.call(this, e10, t15);
        return "readable" === e10 && u17.nextTick(Y4, this), n27;
    }, C5.prototype.removeAllListeners = function (e10) {
        var t15 = h13.prototype.removeAllListeners.apply(this, arguments);
        return "readable" !== e10 && (void 0) !== e10 || u17.nextTick(Y4, this), t15;
    }, C5.prototype.resume = function () {
        var e10 = this._readableState;
        return e10.flowing || (p11("resume"), e10.flowing = !e10.readableListening, (function (e14, t15) {
            t15.resumeScheduled || (t15.resumeScheduled = !0, u17.nextTick(z5, e14, t15));
        })(this, e10)), e10.paused = !1, this;
    }, C5.prototype.pause = function () {
        return p11("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (p11("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
    }, C5.prototype.wrap = function (e10) {
        var t15 = this, n27 = this._readableState, r22 = !1;
        for (var i31 in e10.on("end", function () {
            if ((p11("wrapped end"), n27.decoder && !n27.ended)) {
                var e14 = n27.decoder.end();
                e14 && e14.length && t15.push(e14);
            }
            t15.push(null);
        }), e10.on("data", function (i32) {
            (p11("wrapped data"), n27.decoder && (i32 = n27.decoder.write(i32)), n27.objectMode && null == i32) || (n27.objectMode || i32 && i32.length) && (t15.push(i32) || (r22 = !0, e10.pause()));
        }), e10) {
            (void 0) === this[i31] && "function" == typeof e10[i31] && (this[i31] = (function (t17) {
                return function () {
                    return e10[t17].apply(e10, arguments);
                };
            })(i31));
        }
        for (var a24 = 0; a24 < D5.length; a24++) {
            e10.on(D5[a24], this.emit.bind(this, D5[a24]));
        }
        return this._read = function (t17) {
            p11("wrapped _read", t17), r22 && (r22 = !1, e10.resume());
        }, this;
    }, "function" == typeof Symbol && (C5.prototype[Symbol.asyncIterator] = function () {
        return (void 0) === _6 && (_6 = U$1), _6(this);
    }), Object.defineProperty(C5.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function () {
            return this._readableState.highWaterMark;
        }
    }), Object.defineProperty(C5.prototype, "readableBuffer", {
        enumerable: !1,
        get: function () {
            return this._readableState && this._readableState.buffer;
        }
    }), Object.defineProperty(C5.prototype, "readableFlowing", {
        enumerable: !1,
        get: function () {
            return this._readableState.flowing;
        },
        set: function (e10) {
            this._readableState && (this._readableState.flowing = e10);
        }
    }), C5._fromList = Q4, Object.defineProperty(C5.prototype, "readableLength", {
        enumerable: !1,
        get: function () {
            return this._readableState.length;
        }
    }), "function" == typeof Symbol && (C5.from = function (e10, t15) {
        return (void 0) === v8 && (v8 = r$12), v8(C5, e10, t15);
    }), H$1;
}

var Y$1 = {}, K$1 = !1,
        z$1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;

function J$1() {
    if (K$1) {
        return Y$1;
    }
    K$1 = !0;
    var e$22, r22 = T1;

    function s14(e10) {
        var t15 = this;
        this.next = null, this.entry = null, this.finish = function () {
            !function (e15, t17, n27) {
                var r23 = e15.entry;
                e15.entry = null;
                for (; r23;) {
                    var i31 = r23.callback;
                    t17.pendingcb--, i31(n27), r23 = r23.next;
                }
                t17.corkedRequestsFree.next = e15;
            }(t15, e10);
        };
    }

    Y$1 = x5, x5.WritableState = T7;
    var l19 = {
        deprecate: t$12
    }, d8 = e9, f16 = e$1.Buffer, h13 = z$1.Uint8Array || function () {
    };
    var c12, b7 = S$1, p11 = E$1.getHighWaterMark, g8 = e$14.codes, y7 = g8.ERR_INVALID_ARG_TYPE,
            w4 = g8.ERR_METHOD_NOT_IMPLEMENTED, _6 = g8.ERR_MULTIPLE_CALLBACK, v8 = g8.ERR_STREAM_CANNOT_PIPE,
            m5 = g8.ERR_STREAM_DESTROYED, R5 = g8.ERR_STREAM_NULL_VALUES, k5 = g8.ERR_STREAM_WRITE_AFTER_END,
            M5 = g8.ERR_UNKNOWN_ENCODING, j4 = b7.errorOrDestroy;

    function O4() {
    }

    function T7(t15, n27, i32) {
        e$22 = e$22 || Z$1(), t15 = t15 || {}, "boolean" != typeof i32 && (i32 = n27 instanceof e$22), this.objectMode = !!t15.objectMode, i32 && (this.objectMode = this.objectMode || !!t15.writableObjectMode), this.highWaterMark = p11(this, t15, "writableHighWaterMark", i32), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var a24 = !1 === t15.decodeStrings;
        this.decodeStrings = !a24, this.defaultEncoding = t15.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (e10) {
            !function (e15, t17) {
                var n28 = e15._writableState, i33 = n28.sync, a25 = n28.writecb;
                if ("function" != typeof a25) {
                    throw new _6;
                }
                if ((function (e16) {
                    e16.writing = !1, e16.writecb = null, e16.length -= e16.writelen, e16.writelen = 0;
                })(n28), t17) {
                    !function (e16, t18, n29, i34, a26) {
                        --t18.pendingcb, n29 ? (r22.nextTick(a26, i34), r22.nextTick(W4, e16, t18), e16._writableState.errorEmitted = !0, j4(e16, i34)) : (a26(i34), e16._writableState.errorEmitted = !0, j4(e16, i34), W4(e16, t18));
                    }(e15, n28, i33, t17, a25);
                } else {
                    var o20 = C5(n28) || e15.destroyed;
                    o20 || n28.corked || n28.bufferProcessing || !n28.bufferedRequest || L5(e15, n28), i33 ? r22.nextTick(D5, e15, n28, o20, a25) : D5(e15, n28, o20, a25);
                }
            }(n27, e10);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== t15.emitClose, this.autoDestroy = !!t15.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new s14(this);
    }

    function x5(t15) {
        var n27 = this instanceof (e$22 = e$22 || Z$1());
        if (!n27 && !c12.call(x5, this)) {
            return new x5(t15);
        }
        this._writableState = new T7(t15, this, n27), this.writable = !0, t15 && ("function" == typeof t15.write && (this._write = t15.write), "function" == typeof t15.writev && (this._writev = t15.writev), "function" == typeof t15.destroy && (this._destroy = t15.destroy), "function" == typeof t15.final && (this._final = t15.final)), d8.call(this);
    }

    function P6(e10, t15, n27, r23, i32, a24, o23) {
        t15.writelen = r23, t15.writecb = o23, t15.writing = !0, t15.sync = !0, t15.destroyed ? t15.onwrite(new m5("write")) : n27 ? e10._writev(i32, t15.onwrite) : e10._write(i32, a24, t15.onwrite), t15.sync = !1;
    }

    function D5(e10, t15, n27, r23) {
        n27 || !function (e15, t17) {
            0 === t17.length && t17.needDrain && (t17.needDrain = !1, e15.emit("drain"));
        }(e10, t15), t15.pendingcb--, r23(), W4(e10, t15);
    }

    function L5(e10, t15) {
        t15.bufferProcessing = !0;
        var n27 = t15.bufferedRequest;
        if (e10._writev && n27 && n27.next) {
            var r23 = t15.bufferedRequestCount, i32 = new Array(r23), a24 = t15.corkedRequestsFree;
            a24.entry = n27;
            for (var o23 = 0, l20 = !0; n27;) {
                i32[o23] = n27, n27.isBuf || (l20 = !1), n27 = n27.next, o23 += 1;
            }
            i32.allBuffers = l20, P6(e10, t15, !0, t15.length, i32, "", a24.finish), t15.pendingcb++, t15.lastBufferedRequest = null, a24.next ? (t15.corkedRequestsFree = a24.next, a24.next = null) : t15.corkedRequestsFree = new s14(t15), t15.bufferedRequestCount = 0;
        } else {
            for (; n27;) {
                var d9 = n27.chunk, u17 = n27.encoding, f17 = n27.callback;
                if (P6(e10, t15, !1, t15.objectMode ? 1 : d9.length, d9, u17, f17), n27 = n27.next, t15.bufferedRequestCount--, t15.writing) {
                    break;
                }
            }
            null === n27 && (t15.lastBufferedRequest = null);
        }
        t15.bufferedRequest = n27, t15.bufferProcessing = !1;
    }

    function C5(e10) {
        return e10.ending && 0 === e10.length && null === e10.bufferedRequest && !e10.finished && !e10.writing;
    }

    function A4(e10, t15) {
        e10._final(function (n27) {
            t15.pendingcb--, n27 && j4(e10, n27), t15.prefinished = !0, e10.emit("prefinish"), W4(e10, t15);
        });
    }

    function W4(e10, t15) {
        var n27 = C5(t15);
        if (n27 && (!function (e15, t17) {
            t17.prefinished || t17.finalCalled || ("function" != typeof e15._final || t17.destroyed ? (t17.prefinished = !0, e15.emit("prefinish")) : (t17.pendingcb++, t17.finalCalled = !0, r22.nextTick(A4, e15, t17)));
        }(e10, t15), 0 === t15.pendingcb && (t15.finished = !0, e10.emit("finish"), t15.autoDestroy))) {
            var i33 = e10._readableState;
            (!i33 || i33.autoDestroy && i33.endEmitted) && e10.destroy();
        }
        return n27;
    }

    return t$2(x5, d8), T7.prototype.getBuffer = function () {
        for (var e10 = this.bufferedRequest, t15 = []; e10;) {
            t15.push(e10), e10 = e10.next;
        }
        return t15;
    }, (function () {
        try {
            Object.defineProperty(T7.prototype, "buffer", {
                get: l19.deprecate(function () {
                    return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch (e10) {
        }
    })(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (c12 = Function.prototype[Symbol.hasInstance], Object.defineProperty(x5, Symbol.hasInstance, {
        value: function (e10) {
            return !!c12.call(this, e10) || this === x5 && e10 && e10._writableState instanceof T7;
        }
    })) : c12 = function (e10) {
        return e10 instanceof this;
    }, x5.prototype.pipe = function () {
        j4(this, new v8);
    }, x5.prototype.write = function (e10, t15, n27) {
        var i34, a25 = this._writableState, o24 = !1,
                s15 = !a25.objectMode && (i34 = e10, f16.isBuffer(i34) || i34 instanceof h13);
        return s15 && !f16.isBuffer(e10) && (e10 = (function (e15) {
            return f16.from(e15);
        })(e10)), "function" == typeof t15 && (n27 = t15, t15 = null), s15 ? t15 = "buffer" : t15 || (t15 = a25.defaultEncoding), "function" != typeof n27 && (n27 = O4), a25.ending ? (function (e15, t17) {
            var n28 = new k5;
            j4(e15, n28), r22.nextTick(t17, n28);
        })(this, n27) : (s15 || (function (e15, t17, n28, i35) {
            var a26;
            return null === n28 ? a26 = new R5 : "string" == typeof n28 || t17.objectMode || (a26 = new y7("chunk", [
                "string",
                "Buffer"
            ], n28)), !a26 || (j4(e15, a26), r22.nextTick(i35, a26), !1);
        })(this, a25, e10, n27)) && (a25.pendingcb++, o24 = (function (e15, t17, n28, r24, i35, a26) {
            if (!n28) {
                var o25 = function (e16, t18, n29) {
                    e16.objectMode || !1 === e16.decodeStrings || "string" != typeof t18 || (t18 = f16.from(t18, n29));
                    return t18;
                }(t17, r24, i35);
                r24 !== o25 && (n28 = !0, i35 = "buffer", r24 = o25);
            }
            var s16 = t17.objectMode ? 1 : r24.length;
            t17.length += s16;
            var l21 = t17.length < t17.highWaterMark;
            l21 || (t17.needDrain = !0);
            if (t17.writing || t17.corked) {
                var d10 = t17.lastBufferedRequest;
                t17.lastBufferedRequest = {
                    chunk: r24,
                    encoding: i35,
                    isBuf: n28,
                    callback: a26,
                    next: null
                }, d10 ? d10.next = t17.lastBufferedRequest : t17.bufferedRequest = t17.lastBufferedRequest, t17.bufferedRequestCount += 1;
            } else {
                P6(e15, t17, !1, s16, r24, i35, a26);
            }
            return l21;
        })(this, a25, s15, e10, t15, n27)), o24;
    }, x5.prototype.cork = function () {
        this._writableState.corked++;
    }, x5.prototype.uncork = function () {
        var e10 = this._writableState;
        e10.corked && (e10.corked--, e10.writing || e10.corked || e10.bufferProcessing || !e10.bufferedRequest || L5(this, e10));
    }, x5.prototype.setDefaultEncoding = function (e10) {
        if ("string" == typeof e10 && (e10 = e10.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((e10 + "").toLowerCase()) > -1)) {
            throw new M5(e10);
        }
        return this._writableState.defaultEncoding = e10, this;
    }, Object.defineProperty(x5.prototype, "writableBuffer", {
        enumerable: !1,
        get: function () {
            return this._writableState && this._writableState.getBuffer();
        }
    }), Object.defineProperty(x5.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function () {
            return this._writableState.highWaterMark;
        }
    }), x5.prototype._write = function (e10, t15, n27) {
        n27(new w4("_write()"));
    }, x5.prototype._writev = null, x5.prototype.end = function (e10, t15, n27) {
        var i34 = this._writableState;
        return "function" == typeof e10 ? (n27 = e10, e10 = null, t15 = null) : "function" == typeof t15 && (n27 = t15, t15 = null), null != e10 && this.write(e10, t15), i34.corked && (i34.corked = 1, this.uncork()), i34.ending || (function (e15, t17, n28) {
            t17.ending = !0, W4(e15, t17), n28 && (t17.finished ? r22.nextTick(n28) : e15.once("finish", n28));
            t17.ended = !0, e15.writable = !1;
        })(this, i34, n27), this;
    }, Object.defineProperty(x5.prototype, "writableLength", {
        enumerable: !1,
        get: function () {
            return this._writableState.length;
        }
    }), Object.defineProperty(x5.prototype, "destroyed", {
        enumerable: !1,
        get: function () {
            return (void 0) !== this._writableState && this._writableState.destroyed;
        },
        set: function (e10) {
            this._writableState && (this._writableState.destroyed = e10);
        }
    }), x5.prototype.destroy = b7.destroy, x5.prototype._undestroy = b7.undestroy, x5.prototype._destroy = function (e10, t15) {
        t15(e10);
    }, Y$1;
}

var Q$11 = {}, X$1 = !1;

function Z$1() {
    if (X$1) {
        return Q$11;
    }
    X$1 = !0;
    var e10 = T1, t15 = Object.keys || function (e15) {
        var t15 = [];
        for (var n27 in e15) {
            t15.push(n27);
        }
        return t15;
    };
    Q$11 = d8;
    var n27 = G$1(), r22 = J$1();
    t$2(d8, n27);
    for (var a25 = t15(r22.prototype), s14 = 0; s14 < a25.length; s14++) {
        var l19 = a25[s14];
        d8.prototype[l19] || (d8.prototype[l19] = r22.prototype[l19]);
    }

    function d8(e15) {
        if (!(this instanceof d8)) {
            return new d8(e15);
        }
        n27.call(this, e15), r22.call(this, e15), this.allowHalfOpen = !0, e15 && (!1 === e15.readable && (this.readable = !1), !1 === e15.writable && (this.writable = !1), !1 === e15.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", u19)));
    }

    function u19() {
        this._writableState.ended || e10.nextTick(f16, this);
    }

    function f16(e15) {
        e15.end();
    }

    return Object.defineProperty(d8.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function () {
            return this._writableState.highWaterMark;
        }
    }), Object.defineProperty(d8.prototype, "writableBuffer", {
        enumerable: !1,
        get: function () {
            return this._writableState && this._writableState.getBuffer();
        }
    }), Object.defineProperty(d8.prototype, "writableLength", {
        enumerable: !1,
        get: function () {
            return this._writableState.length;
        }
    }), Object.defineProperty(d8.prototype, "destroyed", {
        enumerable: !1,
        get: function () {
            return (void 0) !== this._readableState && (void 0) !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function (e15) {
            (void 0) !== this._readableState && (void 0) !== this._writableState && (this._readableState.destroyed = e15, this._writableState.destroyed = e15);
        }
    }), Q$11;
}

var t$41 = J$1();
var t$51 = ee2();
var n$21;
n$21 = u$15;
var i34 = e$14.codes, a25 = i34.ERR_METHOD_NOT_IMPLEMENTED, o24 = i34.ERR_MULTIPLE_CALLBACK,
        s14 = i34.ERR_TRANSFORM_ALREADY_TRANSFORMING, f$21 = i34.ERR_TRANSFORM_WITH_LENGTH_0, h$2 = t$51;

function l21(t15, r22) {
    var e10 = this._transformState;
    e10.transforming = !1;
    var n27 = e10.writecb;
    if (null === n27) {
        return this.emit("error", new o24);
    }
    e10.writechunk = null, e10.writecb = null, null != r22 && this.push(r22), n27(t15);
    var i35 = this._readableState;
    i35.reading = !1, (i35.needReadable || i35.length < i35.highWaterMark) && this._read(i35.highWaterMark);
}

function u$15(t15) {
    if (!(this instanceof u$15)) {
        return new u$15(t15);
    }
    h$2.call(this, t15), this._transformState = {
        afterTransform: l21.bind(this),
        needTransform: !1,
        transforming: !1,
        writecb: null,
        writechunk: null,
        writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, t15 && ("function" == typeof t15.transform && (this._transform = t15.transform), "function" == typeof t15.flush && (this._flush = t15.flush)), this.on("prefinish", m$22);
}

function m$22() {
    var t15 = this;
    "function" != typeof this._flush || this._readableState.destroyed ? _$2(this, null, null) : this._flush(function (r22, e10) {
        _$2(t15, r22, e10);
    });
}

function _$2(t15, r22, e10) {
    if (r22) {
        return t15.emit("error", r22);
    }
    if (null != e10 && t15.push(e10), t15._writableState.length) {
        throw new f$21;
    }
    if (t15._transformState.transforming) {
        throw new s14;
    }
    return t15.push(null);
}

t$2(u$15, h$2), u$15.prototype.push = function (t15, r22) {
    return this._transformState.needTransform = !1, h$2.prototype.push.call(this, t15, r22);
}, u$15.prototype._transform = function (t15, r22, e10) {
    e10(new a25("_transform()"));
}, u$15.prototype._write = function (t15, r22, e10) {
    var n27 = this._transformState;
    if (n27.writecb = e10, n27.writechunk = t15, n27.writeencoding = r22, !n27.transforming) {
        var i35 = this._readableState;
        (n27.needTransform || i35.needReadable || i35.length < i35.highWaterMark) && this._read(i35.highWaterMark);
    }
}, u$15.prototype._read = function (t15) {
    var r22 = this._transformState;
    null === r22.writechunk || r22.transforming ? r22.needTransform = !0 : (r22.transforming = !0, this._transform(r22.writechunk, r22.writeencoding, r22.afterTransform));
}, u$15.prototype._destroy = function (t15, r22) {
    h$2.prototype._destroy.call(this, t15, function (t17) {
        r22(t17);
    });
};
var p$21 = n$21;
var o$15;
o$15 = i$13;
var e$31 = p$21;

function i$13(r22) {
    if (!(this instanceof i$13)) {
        return new i$13(r22);
    }
    e$31.call(this, r22);
}

t$2(i$13, e$31), i$13.prototype._transform = function (r22, t15, o26) {
    o26(null, r22);
};
var s$11 = o$15;
var t$6;
var o$22 = e$14.codes, e$41 = o$22.ERR_MISSING_ARGS, f$31 = o$22.ERR_STREAM_DESTROYED;

function i$21(r22) {
    if (r22) {
        throw r22;
    }
}

function u$21(r22, o26, e10, i36) {
    i36 = (function (r24) {
        var n27 = !1;
        return function () {
            n27 || (n27 = !0, r24.apply(void 0, arguments));
        };
    })(i36);
    var u19 = !1;
    r22.on("close", function () {
        u19 = !0;
    }), (void 0) === t$6 && (t$6 = n$15), t$6(r22, {
        readable: o26,
        writable: e10
    }, function (r24) {
        if (r24) {
            return i36(r24);
        }
        u19 = !0, i36();
    });
    var a26 = !1;
    return function (n27) {
        if (!u19 && !a26) {
            return a26 = !0, (function (r24) {
                return r24.setHeader && "function" == typeof r24.abort;
            })(r22) ? r22.abort() : "function" == typeof r22.destroy ? r22.destroy() : (i36(n27 || new f$31("pipe")), void 0);
        }
    };
}

function a$12(r22) {
    r22();
}

function c$21(r22, n27) {
    return r22.pipe(n27);
}

function p$31(r22) {
    return r22.length ? "function" != typeof r22[r22.length - 1] ? i$21 : r22.pop() : i$21;
}

var v$2 = function () {
    for (var r22 = arguments.length, n27 = new Array(r22), t15 = 0; t15 < r22; t15++) {
        n27[t15] = arguments[t15];
    }
    var o26, f16 = p$31(n27);
    if ((Array.isArray(n27[0]) && (n27 = n27[0]), n27.length < 2)) {
        throw new e$41("streams");
    }
    var i36 = n27.map(function (r24, t17) {
        var e10 = t17 < n27.length - 1;
        return u$21(r24, e10, t17 > 0, function (r25) {
            o26 || (o26 = r25), r25 && i36.forEach(a$12), e10 || (i36.forEach(a$12), f16(o26));
        });
    });
    return n27.reduce(c$21);
};
var l22, d8 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
l22 = p11;
var f16 = y1.EventEmitter;

function p11() {
    f16.call(this || d8);
}

t$2(p11, f16), p11.Readable = t$22, p11.Writable = t$41, p11.Duplex = t$51, p11.Transform = p$21, p11.PassThrough = s$11, p11.finished = n$15, p11.pipeline = v$2, p11.Stream = p11, p11.prototype.pipe = function (e10, r22) {
    var t15 = this || d8;

    function o26(r24) {
        e10.writable && !1 === e10.write(r24) && t15.pause && t15.pause();
    }

    function i36() {
        t15.readable && t15.resume && t15.resume();
    }

    t15.on("data", o26), e10.on("drain", i36), e10._isStdio || r22 && !1 === r22.end || (t15.on("end", a26), t15.on("close", s15));
    var n27 = !1;

    function a26() {
        n27 || (n27 = !0, e10.end());
    }

    function s15() {
        n27 || (n27 = !0, "function" == typeof e10.destroy && e10.destroy());
    }

    function m5(e15) {
        if (l23(), 0 === f16.listenerCount(this || d8, "error")) {
            throw e15;
        }
    }

    function l23() {
        t15.removeListener("data", o26), e10.removeListener("drain", i36), t15.removeListener("end", a26), t15.removeListener("close", s15), t15.removeListener("error", m5), e10.removeListener("error", m5), t15.removeListener("end", l23), t15.removeListener("close", l23), e10.removeListener("close", l23);
    }

    return t15.on("error", m5), e10.on("error", m5), t15.on("end", l23), t15.on("close", l23), e10.on("close", l23), e10.emit("pipe", t15), e10;
};
var b7 = l22;
var t15 = function () {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
};
var r22 = {},
        n27 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;

function t$13(r24, n28) {
    return Object.prototype.hasOwnProperty.call(r24, n28);
}

r22.assign = function (r24) {
    for (var n28 = Array.prototype.slice.call(arguments, 1); n28.length;) {
        var e10 = n28.shift();
        if (e10) {
            if ("object" != typeof e10) {
                throw new TypeError(e10 + "must be non-object");
            }
            for (var a26 in e10) {
                t$13(e10, a26) && (r24[a26] = e10[a26]);
            }
        }
    }
    return r24;
}, r22.shrinkBuf = function (r24, n28) {
    return r24.length === n28 ? r24 : r24.subarray ? r24.subarray(0, n28) : (r24.length = n28, r24);
};
var e15 = {
    arraySet: function (r24, n28, t17, e16, a27) {
        if (n28.subarray && r24.subarray) {
            return (r24.set(n28.subarray(t17, t17 + e16), a27), void 0);
        }
        for (var f18 = 0; f18 < e16; f18++) {
            r24[a27 + f18] = n28[t17 + f18];
        }
    },
    flattenChunks: function (r24) {
        var n28, t17, e15, a27, f18, u19;
        for ((e15 = 0, n28 = 0, t17 = r24.length); n28 < t17; n28++) {
            e15 += r24[n28].length;
        }
        for ((u19 = new Uint8Array(e15), a27 = 0, n28 = 0, t17 = r24.length); n28 < t17; n28++) {
            f18 = r24[n28], u19.set(f18, a27), a27 += f18.length;
        }
        return u19;
    }
}, a27 = {
    arraySet: function (r24, n28, t17, e16, a28) {
        for (var f18 = 0; f18 < e16; f18++) {
            r24[a28 + f18] = n28[t17 + f18];
        }
    },
    flattenChunks: function (r24) {
        return [].concat.apply([], r24);
    }
};
r22.setTyped = function (n28) {
    n28 ? (r22.Buf8 = Uint8Array, r22.Buf16 = Uint16Array, r22.Buf32 = Int32Array, r22.assign(r22, e15)) : (r22.Buf8 = Array, r22.Buf16 = Array, r22.Buf32 = Array, r22.assign(r22, a27));
}, r22.setTyped(n27);
var r$13 = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
};
var e$15 = function (e16, r24, o26, t17) {
    for (var a28 = 65535 & e16 | 0, f18 = e16 >>> 16 & 65535 | 0, n28 = 0; 0 !== o26;) {
        o26 -= n28 = o26 > 2000 ? 2000 : o26;
        do {
            f18 = f18 + (a28 = a28 + r24[t17++] | 0) | 0;
        } while (--n28)
        a28 %= 65521, f18 %= 65521;
    }
    return a28 | f18 << 16 | 0;
};
var r$22 = function () {
    for (var r24, a28 = [], f18 = 0; f18 < 256; f18++) {
        r24 = f18;
        for (var n28 = 0; n28 < 8; n28++) {
            r24 = 1 & r24 ? 3988292384 ^ r24 >>> 1 : r24 >>> 1;
        }
        a28[f18] = r24;
    }
    return a28;
}();
var a$13 = function (a28, f18, n29, o26) {
    var t17 = r$22, v8 = o26 + n29;
    a28 ^= -1;
    for (var u19 = o26; u19 < v8; u19++) {
        a28 = a28 >>> 8 ^ t17[255 & (a28 ^ f18[u19])];
    }
    return -1 ^ a28;
};
var r$32 = {}, i36 = r22;

function s15(t17) {
    for (var e16 = t17.length; (--e16) >= 0;) {
        t17[e16] = 0;
    }
}

var _6 = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0
], h13 = [
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
], l23 = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    3,
    7
], d11 = [
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
], o26 = new Array(576);
s15(o26);
var u19 = new Array(60);
s15(u19);
var f18 = new Array(512);
s15(f18);
var c12 = new Array(256);
s15(c12);
var g8 = new Array(29);
s15(g8);
var p12, b9, m5, w4 = new Array(30);

function v8(t17, e16, a28, n29, r24) {
    this.static_tree = t17, this.extra_bits = e16, this.extra_base = a28, this.elems = n29, this.max_length = r24, this.has_stree = t17 && t17.length;
}

function k5(t17, e16) {
    this.dyn_tree = t17, this.max_code = 0, this.stat_desc = e16;
}

function z5(t17) {
    return t17 < 256 ? f18[t17] : f18[256 + (t17 >>> 7)];
}

function y7(t17, e16) {
    t17.pending_buf[t17.pending++] = 255 & e16, t17.pending_buf[t17.pending++] = e16 >>> 8 & 255;
}

function x5(t17, e16, a28) {
    t17.bi_valid > 16 - a28 ? (t17.bi_buf |= e16 << t17.bi_valid & 65535, y7(t17, t17.bi_buf), t17.bi_buf = e16 >> 16 - t17.bi_valid, t17.bi_valid += a28 - 16) : (t17.bi_buf |= e16 << t17.bi_valid & 65535, t17.bi_valid += a28);
}

function A4(t17, e16, a28) {
    x5(t17, a28[2 * e16], a28[2 * e16 + 1]);
}

function B5(t17, e16) {
    var a28 = 0;
    do {
        a28 |= 1 & t17, t17 >>>= 1, a28 <<= 1;
    } while ((--e16) > 0)
    return a28 >>> 1;
}

function S4(t17, e16, a28) {
    var n29, r24, i37 = new Array(16), s16 = 0;
    for (n29 = 1; n29 <= 15; n29++) {
        i37[n29] = s16 = s16 + a28[n29 - 1] << 1;
    }
    for (r24 = 0; r24 <= e16; r24++) {
        var _7 = t17[2 * r24 + 1];
        0 !== _7 && (t17[2 * r24] = B5(i37[_7]++, _7));
    }
}

function j4(t17) {
    var e16;
    for (e16 = 0; e16 < 286; e16++) {
        t17.dyn_ltree[2 * e16] = 0;
    }
    for (e16 = 0; e16 < 30; e16++) {
        t17.dyn_dtree[2 * e16] = 0;
    }
    for (e16 = 0; e16 < 19; e16++) {
        t17.bl_tree[2 * e16] = 0;
    }
    t17.dyn_ltree[512] = 1, t17.opt_len = t17.static_len = 0, t17.last_lit = t17.matches = 0;
}

function I6(t17) {
    t17.bi_valid > 8 ? y7(t17, t17.bi_buf) : t17.bi_valid > 0 && (t17.pending_buf[t17.pending++] = t17.bi_buf), t17.bi_buf = 0, t17.bi_valid = 0;
}

function C5(t17, e16, a28, n29) {
    var r24 = 2 * e16, i37 = 2 * a28;
    return t17[r24] < t17[i37] || t17[r24] === t17[i37] && n29[e16] <= n29[a28];
}

function R5(t17, e16, a28) {
    for (var n29 = t17.heap[a28], r24 = a28 << 1; r24 <= t17.heap_len && (r24 < t17.heap_len && C5(e16, t17.heap[r24 + 1], t17.heap[r24], t17.depth) && r24++, !C5(e16, n29, t17.heap[r24], t17.depth));) {
        t17.heap[a28] = t17.heap[r24], a28 = r24, r24 <<= 1;
    }
    t17.heap[a28] = n29;
}

function D5(t17, e16, a28) {
    var n29, r24, i37, s16, l24 = 0;
    if (0 !== t17.last_lit) {
        do {
            n29 = t17.pending_buf[t17.d_buf + 2 * l24] << 8 | t17.pending_buf[t17.d_buf + 2 * l24 + 1], r24 = t17.pending_buf[t17.l_buf + l24], l24++, 0 === n29 ? A4(t17, r24, e16) : (A4(t17, (i37 = c12[r24]) + 256 + 1, e16), 0 !== (s16 = _6[i37]) && x5(t17, r24 -= g8[i37], s16), A4(t17, i37 = z5(--n29), a28), 0 !== (s16 = h13[i37]) && x5(t17, n29 -= w4[i37], s16));
        } while (l24 < t17.last_lit)
    }
    A4(t17, 256, e16);
}

function E5(t17, e16) {
    var a28, n29, r24, i37 = e16.dyn_tree, s16 = e16.stat_desc.static_tree, _8 = e16.stat_desc.has_stree,
            h14 = e16.stat_desc.elems, l24 = -1;
    for (t17.heap_len = 0, t17.heap_max = 573, a28 = 0; a28 < h14; a28++) {
        0 !== i37[2 * a28] ? (t17.heap[++t17.heap_len] = l24 = a28, t17.depth[a28] = 0) : i37[2 * a28 + 1] = 0;
    }
    for (; t17.heap_len < 2;) {
        i37[2 * (r24 = t17.heap[++t17.heap_len] = l24 < 2 ? ++l24 : 0)] = 1, t17.depth[r24] = 0, t17.opt_len--, _8 && (t17.static_len -= s16[2 * r24 + 1]);
    }
    for (e16.max_code = l24, a28 = t17.heap_len >> 1; a28 >= 1; a28--) {
        R5(t17, i37, a28);
    }
    r24 = h14;
    do {
        a28 = t17.heap[1], t17.heap[1] = t17.heap[t17.heap_len--], R5(t17, i37, 1), n29 = t17.heap[1], t17.heap[--t17.heap_max] = a28, t17.heap[--t17.heap_max] = n29, i37[2 * r24] = i37[2 * a28] + i37[2 * n29], t17.depth[r24] = (t17.depth[a28] >= t17.depth[n29] ? t17.depth[a28] : t17.depth[n29]) + 1, i37[2 * a28 + 1] = i37[2 * n29 + 1] = r24, t17.heap[1] = r24++, R5(t17, i37, 1);
    } while (t17.heap_len >= 2)
    t17.heap[--t17.heap_max] = t17.heap[1], (function (t18, e17) {
        var a29, n30, r25, i38, s17, _9, h15 = e17.dyn_tree, l25 = e17.max_code, d12 = e17.stat_desc.static_tree,
                o27 = e17.stat_desc.has_stree, u20 = e17.stat_desc.extra_bits, f19 = e17.stat_desc.extra_base,
                c13 = e17.stat_desc.max_length, g9 = 0;
        for (i38 = 0; i38 <= 15; i38++) {
            t18.bl_count[i38] = 0;
        }
        for (h15[2 * t18.heap[t18.heap_max] + 1] = 0, a29 = t18.heap_max + 1; a29 < 573; a29++) {
            (i38 = h15[2 * h15[2 * (n30 = t18.heap[a29]) + 1] + 1] + 1) > c13 && (i38 = c13, g9++), h15[2 * n30 + 1] = i38, n30 > l25 || (t18.bl_count[i38]++, s17 = 0, n30 >= f19 && (s17 = u20[n30 - f19]), _9 = h15[2 * n30], t18.opt_len += _9 * (i38 + s17), o27 && (t18.static_len += _9 * (d12[2 * n30 + 1] + s17)));
        }
        if (0 !== g9) {
            do {
                for (i38 = c13 - 1; 0 === t18.bl_count[i38];) {
                    i38--;
                }
                t18.bl_count[i38]--, t18.bl_count[i38 + 1] += 2, t18.bl_count[c13]--, g9 -= 2;
            } while (g9 > 0)
            for (i38 = c13; 0 !== i38; i38--) {
                for (n30 = t18.bl_count[i38]; 0 !== n30;) {
                    (r25 = t18.heap[--a29]) > l25 || (h15[2 * r25 + 1] !== i38 && (t18.opt_len += (i38 - h15[2 * r25 + 1]) * h15[2 * r25], h15[2 * r25 + 1] = i38), n30--);
                }
            }
        }
    })(t17, e16), S4(i37, l24, t17.bl_count);
}

function H3(t17, e16, a28) {
    var n29, r24, i37 = -1, s16 = e16[1], _8 = 0, h14 = 7, l24 = 4;
    for (0 === s16 && (h14 = 138, l24 = 3), e16[2 * (a28 + 1) + 1] = 65535, n29 = 0; n29 <= a28; n29++) {
        r24 = s16, s16 = e16[2 * (n29 + 1) + 1], (++_8) < h14 && r24 === s16 || (_8 < l24 ? t17.bl_tree[2 * r24] += _8 : 0 !== r24 ? (r24 !== i37 && t17.bl_tree[2 * r24]++, t17.bl_tree[32]++) : _8 <= 10 ? t17.bl_tree[34]++ : t17.bl_tree[36]++, _8 = 0, i37 = r24, 0 === s16 ? (h14 = 138, l24 = 3) : r24 === s16 ? (h14 = 6, l24 = 3) : (h14 = 7, l24 = 4));
    }
}

function K3(t17, e16, a28) {
    var n29, r24, i37 = -1, s16 = e16[1], _8 = 0, h14 = 7, l24 = 4;
    for (0 === s16 && (h14 = 138, l24 = 3), n29 = 0; n29 <= a28; n29++) {
        if (r24 = s16, s16 = e16[2 * (n29 + 1) + 1], !((++_8) < h14 && r24 === s16)) {
            if (_8 < l24) {
                do {
                    A4(t17, r24, t17.bl_tree);
                } while (0 != --_8)
            } else {
                0 !== r24 ? (r24 !== i37 && (A4(t17, r24, t17.bl_tree), _8--), A4(t17, 16, t17.bl_tree), x5(t17, _8 - 3, 2)) : _8 <= 10 ? (A4(t17, 17, t17.bl_tree), x5(t17, _8 - 3, 3)) : (A4(t17, 18, t17.bl_tree), x5(t17, _8 - 11, 7));
            }
            _8 = 0, i37 = r24, 0 === s16 ? (h14 = 138, l24 = 3) : r24 === s16 ? (h14 = 6, l24 = 3) : (h14 = 7, l24 = 4);
        }
    }
}

s15(w4);
var N5 = !1;

function q4(t17, e16, a28, n29) {
    x5(t17, 0 + (n29 ? 1 : 0), 3), (function (t18, e17, a29, n30) {
        I6(t18), n30 && (y7(t18, a29), y7(t18, ~a29)), i36.arraySet(t18.pending_buf, t18.window, e17, a29, t18.pending), t18.pending += a29;
    })(t17, e16, a28, !0);
}

r$32._tr_init = function (t17) {
    N5 || (!function () {
        var t18, e16, a28, n29, r24, i37 = new Array(16);
        for (a28 = 0, n29 = 0; n29 < 28; n29++) {
            for (g8[n29] = a28, t18 = 0; t18 < 1 << _6[n29]; t18++) {
                c12[a28++] = n29;
            }
        }
        for (c12[a28 - 1] = n29, r24 = 0, n29 = 0; n29 < 16; n29++) {
            for (w4[n29] = r24, t18 = 0; t18 < 1 << h13[n29]; t18++) {
                f18[r24++] = n29;
            }
        }
        for (r24 >>= 7; n29 < 30; n29++) {
            for (w4[n29] = r24 << 7, t18 = 0; t18 < 1 << h13[n29] - 7; t18++) {
                f18[256 + r24++] = n29;
            }
        }
        for (e16 = 0; e16 <= 15; e16++) {
            i37[e16] = 0;
        }
        for (t18 = 0; t18 <= 143;) {
            o26[2 * t18 + 1] = 8, t18++, i37[8]++;
        }
        for (; t18 <= 255;) {
            o26[2 * t18 + 1] = 9, t18++, i37[9]++;
        }
        for (; t18 <= 279;) {
            o26[2 * t18 + 1] = 7, t18++, i37[7]++;
        }
        for (; t18 <= 287;) {
            o26[2 * t18 + 1] = 8, t18++, i37[8]++;
        }
        for (S4(o26, 287, i37), t18 = 0; t18 < 30; t18++) {
            u19[2 * t18 + 1] = 5, u19[2 * t18] = B5(t18, 5);
        }
        p12 = new v8(o26, _6, 257, 286, 15), b9 = new v8(u19, h13, 0, 30, 15), m5 = new v8(new Array(0), l23, 0, 19, 7);
    }(), N5 = !0), t17.l_desc = new k5(t17.dyn_ltree, p12), t17.d_desc = new k5(t17.dyn_dtree, b9), t17.bl_desc = new k5(t17.bl_tree, m5), t17.bi_buf = 0, t17.bi_valid = 0, j4(t17);
}, r$32._tr_stored_block = q4, r$32._tr_flush_block = function (t17, e16, a28, n29) {
    var r24, i37, s16 = 0;
    t17.level > 0 ? (2 === t17.strm.data_type && (t17.strm.data_type = (function (t18) {
        var e17, a29 = 4093624447;
        for (e17 = 0; e17 <= 31; e17++, a29 >>>= 1) {
            if (1 & a29 && 0 !== t18.dyn_ltree[2 * e17]) {
                return 0;
            }
        }
        if (0 !== t18.dyn_ltree[18] || 0 !== t18.dyn_ltree[20] || 0 !== t18.dyn_ltree[26]) {
            return 1;
        }
        for (e17 = 32; e17 < 256; e17++) {
            if (0 !== t18.dyn_ltree[2 * e17]) {
                return 1;
            }
        }
        return 0;
    })(t17)), E5(t17, t17.l_desc), E5(t17, t17.d_desc), s16 = (function (t18) {
        var e17;
        for (H3(t18, t18.dyn_ltree, t18.l_desc.max_code), H3(t18, t18.dyn_dtree, t18.d_desc.max_code), E5(t18, t18.bl_desc), e17 = 18; e17 >= 3 && 0 === t18.bl_tree[2 * d11[e17] + 1]; e17--) {
            ;
        }
        return t18.opt_len += 3 * (e17 + 1) + 5 + 5 + 4, e17;
    })(t17), r24 = t17.opt_len + 3 + 7 >>> 3, (i37 = t17.static_len + 3 + 7 >>> 3) <= r24 && (r24 = i37)) : r24 = i37 = a28 + 5, a28 + 4 <= r24 && -1 !== e16 ? q4(t17, e16, a28, n29) : 4 === t17.strategy || i37 === r24 ? (x5(t17, 2 + (n29 ? 1 : 0), 3), D5(t17, o26, u19)) : (x5(t17, 4 + (n29 ? 1 : 0), 3), (function (t18, e17, a29, n30) {
        var r25;
        for (x5(t18, e17 - 257, 5), x5(t18, a29 - 1, 5), x5(t18, n30 - 4, 4), r25 = 0; r25 < n30; r25++) {
            x5(t18, t18.bl_tree[2 * d11[r25] + 1], 3);
        }
        K3(t18, t18.dyn_ltree, e17 - 1), K3(t18, t18.dyn_dtree, a29 - 1);
    })(t17, t17.l_desc.max_code + 1, t17.d_desc.max_code + 1, s16 + 1), D5(t17, t17.dyn_ltree, t17.dyn_dtree)), j4(t17), n29 && I6(t17);
}, r$32._tr_tally = function (t17, e16, a28) {
    return t17.pending_buf[t17.d_buf + 2 * t17.last_lit] = e16 >>> 8 & 255, t17.pending_buf[t17.d_buf + 2 * t17.last_lit + 1] = 255 & e16, t17.pending_buf[t17.l_buf + t17.last_lit] = 255 & a28, t17.last_lit++, 0 === e16 ? t17.dyn_ltree[2 * a28]++ : (t17.matches++, e16--, t17.dyn_ltree[2 * (c12[a28] + 256 + 1)]++, t17.dyn_dtree[2 * z5(e16)]++), t17.last_lit === t17.lit_bufsize - 1;
}, r$32._tr_align = function (t17) {
    x5(t17, 2, 3), A4(t17, 256, o26), (function (t18) {
        16 === t18.bi_valid ? (y7(t18, t18.bi_buf), t18.bi_buf = 0, t18.bi_valid = 0) : t18.bi_valid >= 8 && (t18.pending_buf[t18.pending++] = 255 & t18.bi_buf, t18.bi_buf >>= 8, t18.bi_valid -= 8);
    })(t17);
};
var F5, G4 = {}, J4 = r22, L5 = r$32, M5 = e$15, O4 = a$13, P6 = r$13;

function Q4(t17, e16) {
    return t17.msg = P6[e16], e16;
}

function T7(t17) {
    return (t17 << 1) - (t17 > 4 ? 9 : 0);
}

function U5(t17) {
    for (var e16 = t17.length; (--e16) >= 0;) {
        t17[e16] = 0;
    }
}

function V3(t17) {
    var e16 = t17.state, a28 = e16.pending;
    a28 > t17.avail_out && (a28 = t17.avail_out), 0 !== a28 && (J4.arraySet(t17.output, e16.pending_buf, e16.pending_out, a28, t17.next_out), t17.next_out += a28, e16.pending_out += a28, t17.total_out += a28, t17.avail_out -= a28, e16.pending -= a28, 0 === e16.pending && (e16.pending_out = 0));
}

function W4(t17, e16) {
    L5._tr_flush_block(t17, t17.block_start >= 0 ? t17.block_start : -1, t17.strstart - t17.block_start, e16), t17.block_start = t17.strstart, V3(t17.strm);
}

function X3(t17, e16) {
    t17.pending_buf[t17.pending++] = e16;
}

function Y4(t17, e16) {
    t17.pending_buf[t17.pending++] = e16 >>> 8 & 255, t17.pending_buf[t17.pending++] = 255 & e16;
}

function Z4(t17, e16) {
    var a28, n29, r24 = t17.max_chain_length, i37 = t17.strstart, s16 = t17.prev_length, _8 = t17.nice_match,
            h14 = t17.strstart > t17.w_size - 262 ? t17.strstart - (t17.w_size - 262) : 0, l24 = t17.window,
            d12 = t17.w_mask, o27 = t17.prev, u20 = t17.strstart + 258, f19 = l24[i37 + s16 - 1], c13 = l24[i37 + s16];
    t17.prev_length >= t17.good_match && (r24 >>= 2), _8 > t17.lookahead && (_8 = t17.lookahead);
    do {
        if (l24[(a28 = e16) + s16] === c13 && l24[a28 + s16 - 1] === f19 && l24[a28] === l24[i37] && l24[++a28] === l24[i37 + 1]) {
            i37 += 2, a28++;
            do {
            } while (l24[++i37] === l24[++a28] && l24[++i37] === l24[++a28] && l24[++i37] === l24[++a28] && l24[++i37] === l24[++a28] && l24[++i37] === l24[++a28] && l24[++i37] === l24[++a28] && l24[++i37] === l24[++a28] && l24[++i37] === l24[++a28] && i37 < u20)
            if (n29 = 258 - (u20 - i37), i37 = u20 - 258, n29 > s16) {
                if (t17.match_start = e16, s16 = n29, n29 >= _8) {
                    break;
                }
                f19 = l24[i37 + s16 - 1], c13 = l24[i37 + s16];
            }
        }
    } while ((e16 = o27[e16 & d12]) > h14 && 0 != --r24)
    return s16 <= t17.lookahead ? s16 : t17.lookahead;
}

function $4(t17) {
    var e16, a28, n29, r24, i37, s16, _8, h14, l24, d12, o27 = t17.w_size;
    do {
        if (r24 = t17.window_size - t17.lookahead - t17.strstart, t17.strstart >= o27 + (o27 - 262)) {
            J4.arraySet(t17.window, t17.window, o27, o27, 0), t17.match_start -= o27, t17.strstart -= o27, t17.block_start -= o27, e16 = a28 = t17.hash_size;
            do {
                n29 = t17.head[--e16], t17.head[e16] = n29 >= o27 ? n29 - o27 : 0;
            } while (--a28)
            e16 = a28 = o27;
            do {
                n29 = t17.prev[--e16], t17.prev[e16] = n29 >= o27 ? n29 - o27 : 0;
            } while (--a28)
            r24 += o27;
        }
        if (0 === t17.strm.avail_in) {
            break;
        }
        if (s16 = t17.strm, _8 = t17.window, h14 = t17.strstart + t17.lookahead, l24 = r24, d12 = void 0, (d12 = s16.avail_in) > l24 && (d12 = l24), a28 = 0 === d12 ? 0 : (s16.avail_in -= d12, J4.arraySet(_8, s16.input, s16.next_in, d12, h14), 1 === s16.state.wrap ? s16.adler = M5(s16.adler, _8, d12, h14) : 2 === s16.state.wrap && (s16.adler = O4(s16.adler, _8, d12, h14)), s16.next_in += d12, s16.total_in += d12, d12), t17.lookahead += a28, t17.lookahead + t17.insert >= 3) {
            for (i37 = t17.strstart - t17.insert, t17.ins_h = t17.window[i37], t17.ins_h = (t17.ins_h << t17.hash_shift ^ t17.window[i37 + 1]) & t17.hash_mask; t17.insert && (t17.ins_h = (t17.ins_h << t17.hash_shift ^ t17.window[i37 + 3 - 1]) & t17.hash_mask, t17.prev[i37 & t17.w_mask] = t17.head[t17.ins_h], t17.head[t17.ins_h] = i37, i37++, t17.insert--, !(t17.lookahead + t17.insert < 3));) {
                ;
            }
        }
    } while (t17.lookahead < 262 && 0 !== t17.strm.avail_in)
}

function tt1(t17, e16) {
    for (var a28, n29; ;) {
        if (t17.lookahead < 262) {
            if ($4(t17), t17.lookahead < 262 && 0 === e16) {
                return 1;
            }
            if (0 === t17.lookahead) {
                break;
            }
        }
        if (a28 = 0, t17.lookahead >= 3 && (t17.ins_h = (t17.ins_h << t17.hash_shift ^ t17.window[t17.strstart + 3 - 1]) & t17.hash_mask, a28 = t17.prev[t17.strstart & t17.w_mask] = t17.head[t17.ins_h], t17.head[t17.ins_h] = t17.strstart), 0 !== a28 && t17.strstart - a28 <= t17.w_size - 262 && (t17.match_length = Z4(t17, a28)), t17.match_length >= 3) {
            if (n29 = L5._tr_tally(t17, t17.strstart - t17.match_start, t17.match_length - 3), t17.lookahead -= t17.match_length, t17.match_length <= t17.max_lazy_match && t17.lookahead >= 3) {
                t17.match_length--;
                do {
                    t17.strstart++, t17.ins_h = (t17.ins_h << t17.hash_shift ^ t17.window[t17.strstart + 3 - 1]) & t17.hash_mask, a28 = t17.prev[t17.strstart & t17.w_mask] = t17.head[t17.ins_h], t17.head[t17.ins_h] = t17.strstart;
                } while (0 != --t17.match_length)
                t17.strstart++;
            } else {
                t17.strstart += t17.match_length, t17.match_length = 0, t17.ins_h = t17.window[t17.strstart], t17.ins_h = (t17.ins_h << t17.hash_shift ^ t17.window[t17.strstart + 1]) & t17.hash_mask;
            }
        } else {
            n29 = L5._tr_tally(t17, 0, t17.window[t17.strstart]), t17.lookahead--, t17.strstart++;
        }
        if (n29 && (W4(t17, !1), 0 === t17.strm.avail_out)) {
            return 1;
        }
    }
    return t17.insert = t17.strstart < 2 ? t17.strstart : 2, 4 === e16 ? (W4(t17, !0), 0 === t17.strm.avail_out ? 3 : 4) : t17.last_lit && (W4(t17, !1), 0 === t17.strm.avail_out) ? 1 : 2;
}

function et1(t17, e16) {
    for (var a28, n29, r24; ;) {
        if (t17.lookahead < 262) {
            if ($4(t17), t17.lookahead < 262 && 0 === e16) {
                return 1;
            }
            if (0 === t17.lookahead) {
                break;
            }
        }
        if (a28 = 0, t17.lookahead >= 3 && (t17.ins_h = (t17.ins_h << t17.hash_shift ^ t17.window[t17.strstart + 3 - 1]) & t17.hash_mask, a28 = t17.prev[t17.strstart & t17.w_mask] = t17.head[t17.ins_h], t17.head[t17.ins_h] = t17.strstart), t17.prev_length = t17.match_length, t17.prev_match = t17.match_start, t17.match_length = 2, 0 !== a28 && t17.prev_length < t17.max_lazy_match && t17.strstart - a28 <= t17.w_size - 262 && (t17.match_length = Z4(t17, a28), t17.match_length <= 5 && (1 === t17.strategy || 3 === t17.match_length && t17.strstart - t17.match_start > 4096) && (t17.match_length = 2)), t17.prev_length >= 3 && t17.match_length <= t17.prev_length) {
            r24 = t17.strstart + t17.lookahead - 3, n29 = L5._tr_tally(t17, t17.strstart - 1 - t17.prev_match, t17.prev_length - 3), t17.lookahead -= t17.prev_length - 1, t17.prev_length -= 2;
            do {
                (++t17.strstart) <= r24 && (t17.ins_h = (t17.ins_h << t17.hash_shift ^ t17.window[t17.strstart + 3 - 1]) & t17.hash_mask, a28 = t17.prev[t17.strstart & t17.w_mask] = t17.head[t17.ins_h], t17.head[t17.ins_h] = t17.strstart);
            } while (0 != --t17.prev_length)
            if (t17.match_available = 0, t17.match_length = 2, t17.strstart++, n29 && (W4(t17, !1), 0 === t17.strm.avail_out)) {
                return 1;
            }
        } else if (t17.match_available) {
            if ((n29 = L5._tr_tally(t17, 0, t17.window[t17.strstart - 1])) && W4(t17, !1), t17.strstart++, t17.lookahead--, 0 === t17.strm.avail_out) {
                return 1;
            }
        } else {
            t17.match_available = 1, t17.strstart++, t17.lookahead--;
        }
    }
    return t17.match_available && (n29 = L5._tr_tally(t17, 0, t17.window[t17.strstart - 1]), t17.match_available = 0), t17.insert = t17.strstart < 2 ? t17.strstart : 2, 4 === e16 ? (W4(t17, !0), 0 === t17.strm.avail_out ? 3 : 4) : t17.last_lit && (W4(t17, !1), 0 === t17.strm.avail_out) ? 1 : 2;
}

function at(t17, e16, a28, n29, r24) {
    this.good_length = t17, this.max_lazy = e16, this.nice_length = a28, this.max_chain = n29, this.func = r24;
}

function nt() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new J4.Buf16(1146), this.dyn_dtree = new J4.Buf16(122), this.bl_tree = new J4.Buf16(78), U5(this.dyn_ltree), U5(this.dyn_dtree), U5(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new J4.Buf16(16), this.heap = new J4.Buf16(573), U5(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new J4.Buf16(573), U5(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}

function rt(t17) {
    var e16;
    return t17 && t17.state ? (t17.total_in = t17.total_out = 0, t17.data_type = 2, (e16 = t17.state).pending = 0, e16.pending_out = 0, e16.wrap < 0 && (e16.wrap = -e16.wrap), e16.status = e16.wrap ? 42 : 113, t17.adler = 2 === e16.wrap ? 0 : 1, e16.last_flush = 0, L5._tr_init(e16), 0) : Q4(t17, -2);
}

function it(t17) {
    var e16, a28 = rt(t17);
    return 0 === a28 && ((e16 = t17.state).window_size = 2 * e16.w_size, U5(e16.head), e16.max_lazy_match = F5[e16.level].max_lazy, e16.good_match = F5[e16.level].good_length, e16.nice_match = F5[e16.level].nice_length, e16.max_chain_length = F5[e16.level].max_chain, e16.strstart = 0, e16.block_start = 0, e16.lookahead = 0, e16.insert = 0, e16.match_length = e16.prev_length = 2, e16.match_available = 0, void (e16.ins_h = 0)), a28;
}

function st(t17, e16, a28, n29, r24, i37) {
    if (!t17) {
        return -2;
    }
    var s16 = 1;
    if (-1 === e16 && (e16 = 6), n29 < 0 ? (s16 = 0, n29 = -n29) : n29 > 15 && (s16 = 2, n29 -= 16), r24 < 1 || r24 > 9 || 8 !== a28 || n29 < 8 || n29 > 15 || e16 < 0 || e16 > 9 || i37 < 0 || i37 > 4) {
        return Q4(t17, -2);
    }
    8 === n29 && (n29 = 9);
    var _8 = new nt;
    return t17.state = _8, _8.strm = t17, _8.wrap = s16, _8.gzhead = null, _8.w_bits = n29, _8.w_size = 1 << _8.w_bits, _8.w_mask = _8.w_size - 1, _8.hash_bits = r24 + 7, _8.hash_size = 1 << _8.hash_bits, _8.hash_mask = _8.hash_size - 1, _8.hash_shift = ~~((_8.hash_bits + 3 - 1) / 3), _8.window = new J4.Buf8(2 * _8.w_size), _8.head = new J4.Buf16(_8.hash_size), _8.prev = new J4.Buf16(_8.w_size), _8.lit_bufsize = 1 << r24 + 6, _8.pending_buf_size = 4 * _8.lit_bufsize, _8.pending_buf = new J4.Buf8(_8.pending_buf_size), _8.d_buf = 1 * _8.lit_bufsize, _8.l_buf = 3 * _8.lit_bufsize, _8.level = e16, _8.strategy = i37, _8.method = a28, it(t17);
}

F5 = [
    new at(0, 0, 0, 0, function (t17, e16) {
        var a28 = 65535;
        for (a28 > t17.pending_buf_size - 5 && (a28 = t17.pending_buf_size - 5); ;) {
            if (t17.lookahead <= 1) {
                if (($4(t17), 0 === t17.lookahead && 0 === e16)) {
                    return 1;
                }
                if (0 === t17.lookahead) {
                    break;
                }
            }
            t17.strstart += t17.lookahead, t17.lookahead = 0;
            var n29 = t17.block_start + a28;
            if ((0 === t17.strstart || t17.strstart >= n29) && (t17.lookahead = t17.strstart - n29, t17.strstart = n29, W4(t17, !1), 0 === t17.strm.avail_out)) {
                return 1;
            }
            if (t17.strstart - t17.block_start >= t17.w_size - 262 && (W4(t17, !1), 0 === t17.strm.avail_out)) {
                return 1;
            }
        }
        return (t17.insert = 0, 4 === e16 ? (W4(t17, !0), 0 === t17.strm.avail_out ? 3 : 4) : (t17.strstart > t17.block_start && (W4(t17, !1), 0 === t17.strm.avail_out), 1));
    }),
    new at(4, 4, 8, 4, tt1),
    new at(4, 5, 16, 8, tt1),
    new at(4, 6, 32, 32, tt1),
    new at(4, 4, 16, 16, et1),
    new at(8, 16, 32, 32, et1),
    new at(8, 16, 128, 128, et1),
    new at(8, 32, 128, 256, et1),
    new at(32, 128, 258, 1024, et1),
    new at(32, 258, 258, 4096, et1)
], G4.deflateInit = function (t17, e16) {
    return st(t17, e16, 8, 15, 8, 0);
}, G4.deflateInit2 = st, G4.deflateReset = it, G4.deflateResetKeep = rt, G4.deflateSetHeader = function (t17, e16) {
    return t17 && t17.state ? 2 !== t17.state.wrap ? -2 : (t17.state.gzhead = e16, 0) : -2;
}, G4.deflate = function (t17, e16) {
    var a28, n30, r24, i37;
    if (!t17 || !t17.state || e16 > 5 || e16 < 0) {
        return t17 ? Q4(t17, -2) : -2;
    }
    if (n30 = t17.state, !t17.output || !t17.input && 0 !== t17.avail_in || 666 === n30.status && 4 !== e16) {
        return Q4(t17, 0 === t17.avail_out ? -5 : -2);
    }
    if (n30.strm = t17, a28 = n30.last_flush, n30.last_flush = e16, 42 === n30.status) {
        if (2 === n30.wrap) {
            t17.adler = 0, X3(n30, 31), X3(n30, 139), X3(n30, 8), n30.gzhead ? (X3(n30, (n30.gzhead.text ? 1 : 0) + (n30.gzhead.hcrc ? 2 : 0) + (n30.gzhead.extra ? 4 : 0) + (n30.gzhead.name ? 8 : 0) + (n30.gzhead.comment ? 16 : 0)), X3(n30, 255 & n30.gzhead.time), X3(n30, n30.gzhead.time >> 8 & 255), X3(n30, n30.gzhead.time >> 16 & 255), X3(n30, n30.gzhead.time >> 24 & 255), X3(n30, 9 === n30.level ? 2 : n30.strategy >= 2 || n30.level < 2 ? 4 : 0), X3(n30, 255 & n30.gzhead.os), n30.gzhead.extra && n30.gzhead.extra.length && (X3(n30, 255 & n30.gzhead.extra.length), X3(n30, n30.gzhead.extra.length >> 8 & 255)), n30.gzhead.hcrc && (t17.adler = O4(t17.adler, n30.pending_buf, n30.pending, 0)), n30.gzindex = 0, n30.status = 69) : (X3(n30, 0), X3(n30, 0), X3(n30, 0), X3(n30, 0), X3(n30, 0), X3(n30, 9 === n30.level ? 2 : n30.strategy >= 2 || n30.level < 2 ? 4 : 0), X3(n30, 3), n30.status = 113);
        } else {
            var s16 = 8 + (n30.w_bits - 8 << 4) << 8;
            s16 |= (n30.strategy >= 2 || n30.level < 2 ? 0 : n30.level < 6 ? 1 : 6 === n30.level ? 2 : 3) << 6, 0 !== n30.strstart && (s16 |= 32), s16 += 31 - s16 % 31, n30.status = 113, Y4(n30, s16), 0 !== n30.strstart && (Y4(n30, t17.adler >>> 16), Y4(n30, 65535 & t17.adler)), t17.adler = 1;
        }
    }
    if (69 === n30.status) {
        if (n30.gzhead.extra) {
            for (r24 = n30.pending; n30.gzindex < (65535 & n30.gzhead.extra.length) && (n30.pending !== n30.pending_buf_size || (n30.gzhead.hcrc && n30.pending > r24 && (t17.adler = O4(t17.adler, n30.pending_buf, n30.pending - r24, r24)), V3(t17), r24 = n30.pending, n30.pending !== n30.pending_buf_size));) {
                X3(n30, 255 & n30.gzhead.extra[n30.gzindex]), n30.gzindex++;
            }
            n30.gzhead.hcrc && n30.pending > r24 && (t17.adler = O4(t17.adler, n30.pending_buf, n30.pending - r24, r24)), n30.gzindex === n30.gzhead.extra.length && (n30.gzindex = 0, n30.status = 73);
        } else {
            n30.status = 73;
        }
    }
    if (73 === n30.status) {
        if (n30.gzhead.name) {
            r24 = n30.pending;
            do {
                if (n30.pending === n30.pending_buf_size && (n30.gzhead.hcrc && n30.pending > r24 && (t17.adler = O4(t17.adler, n30.pending_buf, n30.pending - r24, r24)), V3(t17), r24 = n30.pending, n30.pending === n30.pending_buf_size)) {
                    i37 = 1;
                    break;
                }
                i37 = n30.gzindex < n30.gzhead.name.length ? 255 & n30.gzhead.name.charCodeAt(n30.gzindex++) : 0, X3(n30, i37);
            } while (0 !== i37)
            n30.gzhead.hcrc && n30.pending > r24 && (t17.adler = O4(t17.adler, n30.pending_buf, n30.pending - r24, r24)), 0 === i37 && (n30.gzindex = 0, n30.status = 91);
        } else {
            n30.status = 91;
        }
    }
    if (91 === n30.status) {
        if (n30.gzhead.comment) {
            r24 = n30.pending;
            do {
                if (n30.pending === n30.pending_buf_size && (n30.gzhead.hcrc && n30.pending > r24 && (t17.adler = O4(t17.adler, n30.pending_buf, n30.pending - r24, r24)), V3(t17), r24 = n30.pending, n30.pending === n30.pending_buf_size)) {
                    i37 = 1;
                    break;
                }
                i37 = n30.gzindex < n30.gzhead.comment.length ? 255 & n30.gzhead.comment.charCodeAt(n30.gzindex++) : 0, X3(n30, i37);
            } while (0 !== i37)
            n30.gzhead.hcrc && n30.pending > r24 && (t17.adler = O4(t17.adler, n30.pending_buf, n30.pending - r24, r24)), 0 === i37 && (n30.status = 103);
        } else {
            n30.status = 103;
        }
    }
    if (103 === n30.status && (n30.gzhead.hcrc ? (n30.pending + 2 > n30.pending_buf_size && V3(t17), n30.pending + 2 <= n30.pending_buf_size && (X3(n30, 255 & t17.adler), X3(n30, t17.adler >> 8 & 255), t17.adler = 0, n30.status = 113)) : n30.status = 113), 0 !== n30.pending) {
        if (V3(t17), 0 === t17.avail_out) {
            return n30.last_flush = -1, 0;
        }
    } else if (0 === t17.avail_in && T7(e16) <= T7(a28) && 4 !== e16) {
        return Q4(t17, -5);
    }
    if (666 === n30.status && 0 !== t17.avail_in) {
        return Q4(t17, -5);
    }
    if (0 !== t17.avail_in || 0 !== n30.lookahead || 0 !== e16 && 666 !== n30.status) {
        var _8 = 2 === n30.strategy ? function (t18, e17) {
            for (var a29; ;) {
                if (0 === t18.lookahead && ($4(t18), 0 === t18.lookahead)) {
                    if (0 === e17) {
                        return 1;
                    }
                    break;
                }
                if (t18.match_length = 0, a29 = L5._tr_tally(t18, 0, t18.window[t18.strstart]), t18.lookahead--, t18.strstart++, a29 && (W4(t18, !1), 0 === t18.strm.avail_out)) {
                    return 1;
                }
            }
            return t18.insert = 0, 4 === e17 ? (W4(t18, !0), 0 === t18.strm.avail_out ? 3 : 4) : t18.last_lit && (W4(t18, !1), 0 === t18.strm.avail_out) ? 1 : 2;
        }(n30, e16) : 3 === n30.strategy ? function (t18, e17) {
            for (var a29, n31, r25, i38, s17 = t18.window; ;) {
                if (t18.lookahead <= 258) {
                    if ($4(t18), t18.lookahead <= 258 && 0 === e17) {
                        return 1;
                    }
                    if (0 === t18.lookahead) {
                        break;
                    }
                }
                if (t18.match_length = 0, t18.lookahead >= 3 && t18.strstart > 0 && (n31 = s17[r25 = t18.strstart - 1]) === s17[++r25] && n31 === s17[++r25] && n31 === s17[++r25]) {
                    i38 = t18.strstart + 258;
                    do {
                    } while (n31 === s17[++r25] && n31 === s17[++r25] && n31 === s17[++r25] && n31 === s17[++r25] && n31 === s17[++r25] && n31 === s17[++r25] && n31 === s17[++r25] && n31 === s17[++r25] && r25 < i38)
                    t18.match_length = 258 - (i38 - r25), t18.match_length > t18.lookahead && (t18.match_length = t18.lookahead);
                }
                if (t18.match_length >= 3 ? (a29 = L5._tr_tally(t18, 1, t18.match_length - 3), t18.lookahead -= t18.match_length, t18.strstart += t18.match_length, t18.match_length = 0) : (a29 = L5._tr_tally(t18, 0, t18.window[t18.strstart]), t18.lookahead--, t18.strstart++), a29 && (W4(t18, !1), 0 === t18.strm.avail_out)) {
                    return 1;
                }
            }
            return t18.insert = 0, 4 === e17 ? (W4(t18, !0), 0 === t18.strm.avail_out ? 3 : 4) : t18.last_lit && (W4(t18, !1), 0 === t18.strm.avail_out) ? 1 : 2;
        }(n30, e16) : F5[n30.level].func(n30, e16);
        if (3 !== _8 && 4 !== _8 || (n30.status = 666), 1 === _8 || 3 === _8) {
            return 0 === t17.avail_out && (n30.last_flush = -1), 0;
        }
        if (2 === _8 && (1 === e16 ? L5._tr_align(n30) : 5 !== e16 && (L5._tr_stored_block(n30, 0, 0, !1), 3 === e16 && (U5(n30.head), 0 === n30.lookahead && (n30.strstart = 0, n30.block_start = 0, n30.insert = 0))), V3(t17), 0 === t17.avail_out)) {
            return n30.last_flush = -1, 0;
        }
    }
    return 4 !== e16 ? 0 : n30.wrap <= 0 ? 1 : (2 === n30.wrap ? (X3(n30, 255 & t17.adler), X3(n30, t17.adler >> 8 & 255), X3(n30, t17.adler >> 16 & 255), X3(n30, t17.adler >> 24 & 255), X3(n30, 255 & t17.total_in), X3(n30, t17.total_in >> 8 & 255), X3(n30, t17.total_in >> 16 & 255), X3(n30, t17.total_in >> 24 & 255)) : (Y4(n30, t17.adler >>> 16), Y4(n30, 65535 & t17.adler)), V3(t17), n30.wrap > 0 && (n30.wrap = -n30.wrap), 0 !== n30.pending ? 0 : 1);
}, G4.deflateEnd = function (t17) {
    var e16;
    return t17 && t17.state ? 42 !== (e16 = t17.state.status) && 69 !== e16 && 73 !== e16 && 91 !== e16 && 103 !== e16 && 113 !== e16 && 666 !== e16 ? Q4(t17, -2) : (t17.state = null, 113 === e16 ? Q4(t17, -3) : 0) : -2;
}, G4.deflateSetDictionary = function (t17, e16) {
    var a28, n30, r24, i37, s17, _9, h14, l24, d12 = e16.length;
    if (!t17 || !t17.state) {
        return -2;
    }
    if (2 === (i37 = (a28 = t17.state).wrap) || 1 === i37 && 42 !== a28.status || a28.lookahead) {
        return -2;
    }
    for (1 === i37 && (t17.adler = M5(t17.adler, e16, d12, 0)), a28.wrap = 0, d12 >= a28.w_size && (0 === i37 && (U5(a28.head), a28.strstart = 0, a28.block_start = 0, a28.insert = 0), l24 = new J4.Buf8(a28.w_size), J4.arraySet(l24, e16, d12 - a28.w_size, a28.w_size, 0), e16 = l24, d12 = a28.w_size), s17 = t17.avail_in, _9 = t17.next_in, h14 = t17.input, t17.avail_in = d12, t17.next_in = 0, t17.input = e16, $4(a28); a28.lookahead >= 3;) {
        n30 = a28.strstart, r24 = a28.lookahead - 2;
        do {
            a28.ins_h = (a28.ins_h << a28.hash_shift ^ a28.window[n30 + 3 - 1]) & a28.hash_mask, a28.prev[n30 & a28.w_mask] = a28.head[a28.ins_h], a28.head[a28.ins_h] = n30, n30++;
        } while (--r24)
        a28.strstart = n30, a28.lookahead = 2, $4(a28);
    }
    return a28.strstart += a28.lookahead, a28.block_start = a28.strstart, a28.insert = a28.lookahead, a28.lookahead = 0, a28.match_length = a28.prev_length = 2, a28.match_available = 0, t17.next_in = _9, t17.input = h14, t17.avail_in = s17, a28.wrap = i37, 0;
}, G4.deflateInfo = "pako deflate (from Nodeca project)";
var i$14 = r22, n$16 = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
], s$12 = [
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
], o$16 = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
], r$41 = [
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
], l$12 = {}, d$11 = r22, f$14 = e$15, c$14 = a$13, h$13 = function (e16, a28) {
    var t17, i37, n30, s17, o27, r24, l24, d12, f19, c13, h14, b10, k6, m6, w5, u20, g9, v9, x6, _9, p13, y8, z6, B6,
            S5;
    t17 = e16.state, i37 = e16.next_in, B6 = e16.input, n30 = i37 + (e16.avail_in - 5), s17 = e16.next_out, S5 = e16.output, o27 = s17 - (a28 - e16.avail_out), r24 = s17 + (e16.avail_out - 257), l24 = t17.dmax, d12 = t17.wsize, f19 = t17.whave, c13 = t17.wnext, h14 = t17.window, b10 = t17.hold, k6 = t17.bits, m6 = t17.lencode, w5 = t17.distcode, u20 = (1 << t17.lenbits) - 1, g9 = (1 << t17.distbits) - 1;
    e: do {
        k6 < 15 && (b10 += B6[i37++] << k6, k6 += 8, b10 += B6[i37++] << k6, k6 += 8), v9 = m6[b10 & u20];
        a: for (; ;) {
            if ((b10 >>>= x6 = v9 >>> 24, k6 -= x6, 0 === (x6 = v9 >>> 16 & 255))) {
                S5[s17++] = 65535 & v9;
            } else {
                if (!(16 & x6)) {
                    if (0 == (64 & x6)) {
                        v9 = m6[(65535 & v9) + (b10 & (1 << x6) - 1)];
                        continue a;
                    }
                    if (32 & x6) {
                        t17.mode = 12;
                        break e;
                    }
                    e16.msg = "invalid literal/length code", t17.mode = 30;
                    break e;
                }
                _9 = 65535 & v9, (x6 &= 15) && (k6 < x6 && (b10 += B6[i37++] << k6, k6 += 8), _9 += b10 & (1 << x6) - 1, b10 >>>= x6, k6 -= x6), k6 < 15 && (b10 += B6[i37++] << k6, k6 += 8, b10 += B6[i37++] << k6, k6 += 8), v9 = w5[b10 & g9];
                t: for (; ;) {
                    if ((b10 >>>= x6 = v9 >>> 24, k6 -= x6, !(16 & (x6 = v9 >>> 16 & 255)))) {
                        if (0 == (64 & x6)) {
                            v9 = w5[(65535 & v9) + (b10 & (1 << x6) - 1)];
                            continue t;
                        }
                        e16.msg = "invalid distance code", t17.mode = 30;
                        break e;
                    }
                    if ((p13 = 65535 & v9, k6 < (x6 &= 15) && (b10 += B6[i37++] << k6, (k6 += 8) < x6 && (b10 += B6[i37++] << k6, k6 += 8)), (p13 += b10 & (1 << x6) - 1) > l24)) {
                        e16.msg = "invalid distance too far back", t17.mode = 30;
                        break e;
                    }
                    if ((b10 >>>= x6, k6 -= x6, p13 > (x6 = s17 - o27))) {
                        if ((x6 = p13 - x6) > f19 && t17.sane) {
                            e16.msg = "invalid distance too far back", t17.mode = 30;
                            break e;
                        }
                        if ((y8 = 0, z6 = h14, 0 === c13)) {
                            if ((y8 += d12 - x6, x6 < _9)) {
                                _9 -= x6;
                                do {
                                    S5[s17++] = h14[y8++];
                                } while (--x6)
                                y8 = s17 - p13, z6 = S5;
                            }
                        } else if (c13 < x6) {
                            if ((y8 += d12 + c13 - x6, (x6 -= c13) < _9)) {
                                _9 -= x6;
                                do {
                                    S5[s17++] = h14[y8++];
                                } while (--x6)
                                if ((y8 = 0, c13 < _9)) {
                                    _9 -= x6 = c13;
                                    do {
                                        S5[s17++] = h14[y8++];
                                    } while (--x6)
                                    y8 = s17 - p13, z6 = S5;
                                }
                            }
                        } else if ((y8 += c13 - x6, x6 < _9)) {
                            _9 -= x6;
                            do {
                                S5[s17++] = h14[y8++];
                            } while (--x6)
                            y8 = s17 - p13, z6 = S5;
                        }
                        for (; _9 > 2;) {
                            S5[s17++] = z6[y8++], S5[s17++] = z6[y8++], S5[s17++] = z6[y8++], _9 -= 3;
                        }
                        _9 && (S5[s17++] = z6[y8++], _9 > 1 && (S5[s17++] = z6[y8++]));
                    } else {
                        y8 = s17 - p13;
                        do {
                            S5[s17++] = S5[y8++], S5[s17++] = S5[y8++], S5[s17++] = S5[y8++], _9 -= 3;
                        } while (_9 > 2)
                        _9 && (S5[s17++] = S5[y8++], _9 > 1 && (S5[s17++] = S5[y8++]));
                    }
                    break;
                }
            }
            break;
        }
    } while (i37 < n30 && s17 < r24)
    i37 -= _9 = k6 >> 3, b10 &= (1 << (k6 -= _9 << 3)) - 1, e16.next_in = i37, e16.next_out = s17, e16.avail_in = i37 < n30 ? n30 - i37 + 5 : 5 - (i37 - n30), e16.avail_out = s17 < r24 ? r24 - s17 + 257 : 257 - (s17 - r24), t17.hold = b10, t17.bits = k6;
}, b$12 = function (e16, a28, t17, l24, d12, f19, c13, h14) {
    var b10, k6, m6, w5, u20, g9, v9, x6, _9, p13 = h14.bits, y8 = 0, z6 = 0, B6 = 0, S5 = 0, j5 = 0, C6 = 0, I7 = 0,
            R6 = 0, A5 = 0, D6 = 0, E6 = null, G5 = 0, H4 = new i$14.Buf16(16), K4 = new i$14.Buf16(16), N6 = null,
            q5 = 0;
    for (y8 = 0; y8 <= 15; y8++) {
        H4[y8] = 0;
    }
    for (z6 = 0; z6 < l24; z6++) {
        H4[a28[t17 + z6]]++;
    }
    for ((j5 = p13, S5 = 15); S5 >= 1 && 0 === H4[S5]; S5--) {
        ;
    }
    if ((j5 > S5 && (j5 = S5), 0 === S5)) {
        return (d12[f19++] = 20971520, d12[f19++] = 20971520, h14.bits = 1, 0);
    }
    for (B6 = 1; B6 < S5 && 0 === H4[B6]; B6++) {
        ;
    }
    for ((j5 < B6 && (j5 = B6), R6 = 1, y8 = 1); y8 <= 15; y8++) {
        if ((R6 <<= 1, (R6 -= H4[y8]) < 0)) {
            return -1;
        }
    }
    if (R6 > 0 && (0 === e16 || 1 !== S5)) {
        return -1;
    }
    for ((K4[1] = 0, y8 = 1); y8 < 15; y8++) {
        K4[y8 + 1] = K4[y8] + H4[y8];
    }
    for (z6 = 0; z6 < l24; z6++) {
        0 !== a28[t17 + z6] && (c13[K4[a28[t17 + z6]]++] = z6);
    }
    if ((0 === e16 ? (E6 = N6 = c13, g9 = 19) : 1 === e16 ? (E6 = n$16, G5 -= 257, N6 = s$12, q5 -= 257, g9 = 256) : (E6 = o$16, N6 = r$41, g9 = -1), D6 = 0, z6 = 0, y8 = B6, u20 = f19, C6 = j5, I7 = 0, m6 = -1, w5 = (A5 = 1 << j5) - 1, 1 === e16 && A5 > 852 || 2 === e16 && A5 > 592)) {
        return 1;
    }
    for (; ;) {
        v9 = y8 - I7, c13[z6] < g9 ? (x6 = 0, _9 = c13[z6]) : c13[z6] > g9 ? (x6 = N6[q5 + c13[z6]], _9 = E6[G5 + c13[z6]]) : (x6 = 96, _9 = 0), b10 = 1 << y8 - I7, B6 = k6 = 1 << C6;
        do {
            d12[u20 + (D6 >> I7) + (k6 -= b10)] = v9 << 24 | x6 << 16 | _9 | 0;
        } while (0 !== k6)
        for (b10 = 1 << y8 - 1; D6 & b10;) {
            b10 >>= 1;
        }
        if ((0 !== b10 ? (D6 &= b10 - 1, D6 += b10) : D6 = 0, z6++, 0 == --H4[y8])) {
            if (y8 === S5) {
                break;
            }
            y8 = a28[t17 + c13[z6]];
        }
        if (y8 > j5 && (D6 & w5) !== m6) {
            for ((0 === I7 && (I7 = j5), u20 += B6, R6 = 1 << (C6 = y8 - I7)); C6 + I7 < S5 && !((R6 -= H4[C6 + I7]) <= 0);) {
                C6++, R6 <<= 1;
            }
            if ((A5 += 1 << C6, 1 === e16 && A5 > 852 || 2 === e16 && A5 > 592)) {
                return 1;
            }
            d12[m6 = D6 & w5] = j5 << 24 | C6 << 16 | u20 - f19 | 0;
        }
    }
    return (0 !== D6 && (d12[u20 + D6] = y8 - I7 << 24 | 64 << 16 | 0), h14.bits = j5, 0);
};

function k$11(e16) {
    return (e16 >>> 24 & 255) + (e16 >>> 8 & 65280) + ((65280 & e16) << 8) + ((255 & e16) << 24);
}

function m$13() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new d$11.Buf16(320), this.work = new d$11.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}

function w$12(e16) {
    var a28;
    return e16 && e16.state ? (a28 = e16.state, e16.total_in = e16.total_out = a28.total = 0, e16.msg = "", a28.wrap && (e16.adler = 1 & a28.wrap), a28.mode = 1, a28.last = 0, a28.havedict = 0, a28.dmax = 32768, a28.head = null, a28.hold = 0, a28.bits = 0, a28.lencode = a28.lendyn = new d$11.Buf32(852), a28.distcode = a28.distdyn = new d$11.Buf32(592), a28.sane = 1, a28.back = -1, 0) : -2;
}

function u$16(e16) {
    var a28;
    return e16 && e16.state ? ((a28 = e16.state).wsize = 0, a28.whave = 0, a28.wnext = 0, w$12(e16)) : -2;
}

function g$12(e16, a28) {
    var t17, i37;
    return e16 && e16.state ? (i37 = e16.state, a28 < 0 ? (t17 = 0, a28 = -a28) : (t17 = 1 + (a28 >> 4), a28 < 48 && (a28 &= 15)), a28 && (a28 < 8 || a28 > 15) ? -2 : (null !== i37.window && i37.wbits !== a28 && (i37.window = null), i37.wrap = t17, i37.wbits = a28, u$16(e16))) : -2;
}

function v$13(e16, a28) {
    var t17, i37;
    return e16 ? (i37 = new m$13, e16.state = i37, i37.window = null, 0 !== (t17 = g$12(e16, a28)) && (e16.state = null), t17) : -2;
}

var x$11, _$11, p$12 = !0;

function y$12(e16) {
    if (p$12) {
        var a28;
        for (x$11 = new d$11.Buf32(512), _$11 = new d$11.Buf32(32), a28 = 0; a28 < 144;) {
            e16.lens[a28++] = 8;
        }
        for (; a28 < 256;) {
            e16.lens[a28++] = 9;
        }
        for (; a28 < 280;) {
            e16.lens[a28++] = 7;
        }
        for (; a28 < 288;) {
            e16.lens[a28++] = 8;
        }
        for (b$12(1, e16.lens, 0, 288, x$11, 0, e16.work, {
            bits: 9
        }), a28 = 0; a28 < 32;) {
            e16.lens[a28++] = 5;
        }
        b$12(2, e16.lens, 0, 32, _$11, 0, e16.work, {
            bits: 5
        }), p$12 = !1;
    }
    e16.lencode = x$11, e16.lenbits = 9, e16.distcode = _$11, e16.distbits = 5;
}

function z$11(e16, a29, t17, i37) {
    var n30, s17 = e16.state;
    return null === s17.window && (s17.wsize = 1 << s17.wbits, s17.wnext = 0, s17.whave = 0, s17.window = new d$11.Buf8(s17.wsize)), i37 >= s17.wsize ? (d$11.arraySet(s17.window, a29, t17 - s17.wsize, s17.wsize, 0), s17.wnext = 0, s17.whave = s17.wsize) : ((n30 = s17.wsize - s17.wnext) > i37 && (n30 = i37), d$11.arraySet(s17.window, a29, t17 - i37, n30, s17.wnext), (i37 -= n30) ? (d$11.arraySet(s17.window, a29, t17 - i37, i37, 0), s17.wnext = i37, s17.whave = s17.wsize) : (s17.wnext += n30, s17.wnext === s17.wsize && (s17.wnext = 0), s17.whave < s17.wsize && (s17.whave += n30))), 0;
}

l$12.inflateReset = u$16, l$12.inflateReset2 = g$12, l$12.inflateResetKeep = w$12, l$12.inflateInit = function (e16) {
    return v$13(e16, 15);
}, l$12.inflateInit2 = v$13, l$12.inflate = function (e16, a29) {
    var t17, i37, n30, s17, o27, r24, l24, m6, w5, u20, g9, v9, x6, _9, p13, B6, S5, j5, C6, I7, R6, A5, D6, E6, G5 = 0,
            H4 = new d$11.Buf8(4), K4 = [
                16,
                17,
                18,
                0,
                8,
                7,
                9,
                6,
                10,
                5,
                11,
                4,
                12,
                3,
                13,
                2,
                14,
                1,
                15
            ];
    if (!e16 || !e16.state || !e16.output || !e16.input && 0 !== e16.avail_in) {
        return -2;
    }
    12 === (t17 = e16.state).mode && (t17.mode = 13), o27 = e16.next_out, n30 = e16.output, l24 = e16.avail_out, s17 = e16.next_in, i37 = e16.input, r24 = e16.avail_in, m6 = t17.hold, w5 = t17.bits, u20 = r24, g9 = l24, A5 = 0;
    e: for (; ;) {
        switch (t17.mode) {
            case 1:
                if (0 === t17.wrap) {
                    t17.mode = 13;
                    break;
                }
                for (; w5 < 16;) {
                    if (0 === r24) {
                        break e;
                    }
                    r24--, m6 += i37[s17++] << w5, w5 += 8;
                }
                if (2 & t17.wrap && 35615 === m6) {
                    t17.check = 0, H4[0] = 255 & m6, H4[1] = m6 >>> 8 & 255, t17.check = c$14(t17.check, H4, 2, 0), m6 = 0, w5 = 0, t17.mode = 2;
                    break;
                }
                if (t17.flags = 0, t17.head && (t17.head.done = !1), !(1 & t17.wrap) || (((255 & m6) << 8) + (m6 >> 8)) % 31) {
                    e16.msg = "incorrect header check", t17.mode = 30;
                    break;
                }
                if (8 != (15 & m6)) {
                    e16.msg = "unknown compression method", t17.mode = 30;
                    break;
                }
                if (w5 -= 4, R6 = 8 + (15 & (m6 >>>= 4)), 0 === t17.wbits) {
                    t17.wbits = R6;
                } else if (R6 > t17.wbits) {
                    e16.msg = "invalid window size", t17.mode = 30;
                    break;
                }
                t17.dmax = 1 << R6, e16.adler = t17.check = 1, t17.mode = 512 & m6 ? 10 : 12, m6 = 0, w5 = 0;
                break;
            case 2:
                for (; w5 < 16;) {
                    if (0 === r24) {
                        break e;
                    }
                    r24--, m6 += i37[s17++] << w5, w5 += 8;
                }
                if (t17.flags = m6, 8 != (255 & t17.flags)) {
                    e16.msg = "unknown compression method", t17.mode = 30;
                    break;
                }
                if (57344 & t17.flags) {
                    e16.msg = "unknown header flags set", t17.mode = 30;
                    break;
                }
                t17.head && (t17.head.text = m6 >> 8 & 1), 512 & t17.flags && (H4[0] = 255 & m6, H4[1] = m6 >>> 8 & 255, t17.check = c$14(t17.check, H4, 2, 0)), m6 = 0, w5 = 0, t17.mode = 3;
            case 3:
                for (; w5 < 32;) {
                    if (0 === r24) {
                        break e;
                    }
                    r24--, m6 += i37[s17++] << w5, w5 += 8;
                }
                t17.head && (t17.head.time = m6), 512 & t17.flags && (H4[0] = 255 & m6, H4[1] = m6 >>> 8 & 255, H4[2] = m6 >>> 16 & 255, H4[3] = m6 >>> 24 & 255, t17.check = c$14(t17.check, H4, 4, 0)), m6 = 0, w5 = 0, t17.mode = 4;
            case 4:
                for (; w5 < 16;) {
                    if (0 === r24) {
                        break e;
                    }
                    r24--, m6 += i37[s17++] << w5, w5 += 8;
                }
                t17.head && (t17.head.xflags = 255 & m6, t17.head.os = m6 >> 8), 512 & t17.flags && (H4[0] = 255 & m6, H4[1] = m6 >>> 8 & 255, t17.check = c$14(t17.check, H4, 2, 0)), m6 = 0, w5 = 0, t17.mode = 5;
            case 5:
                if (1024 & t17.flags) {
                    for (; w5 < 16;) {
                        if (0 === r24) {
                            break e;
                        }
                        r24--, m6 += i37[s17++] << w5, w5 += 8;
                    }
                    t17.length = m6, t17.head && (t17.head.extra_len = m6), 512 & t17.flags && (H4[0] = 255 & m6, H4[1] = m6 >>> 8 & 255, t17.check = c$14(t17.check, H4, 2, 0)), m6 = 0, w5 = 0;
                } else {
                    t17.head && (t17.head.extra = null);
                }
                t17.mode = 6;
            case 6:
                if (1024 & t17.flags && ((v9 = t17.length) > r24 && (v9 = r24), v9 && (t17.head && (R6 = t17.head.extra_len - t17.length, t17.head.extra || (t17.head.extra = new Array(t17.head.extra_len)), d$11.arraySet(t17.head.extra, i37, s17, v9, R6)), 512 & t17.flags && (t17.check = c$14(t17.check, i37, v9, s17)), r24 -= v9, s17 += v9, t17.length -= v9), t17.length)) {
                    break e;
                }
                t17.length = 0, t17.mode = 7;
            case 7:
                if (2048 & t17.flags) {
                    if (0 === r24) {
                        break e;
                    }
                    v9 = 0;
                    do {
                        R6 = i37[s17 + v9++], t17.head && R6 && t17.length < 65536 && (t17.head.name += String.fromCharCode(R6));
                    } while (R6 && v9 < r24)
                    if (512 & t17.flags && (t17.check = c$14(t17.check, i37, v9, s17)), r24 -= v9, s17 += v9, R6) {
                        break e;
                    }
                } else {
                    t17.head && (t17.head.name = null);
                }
                t17.length = 0, t17.mode = 8;
            case 8:
                if (4096 & t17.flags) {
                    if (0 === r24) {
                        break e;
                    }
                    v9 = 0;
                    do {
                        R6 = i37[s17 + v9++], t17.head && R6 && t17.length < 65536 && (t17.head.comment += String.fromCharCode(R6));
                    } while (R6 && v9 < r24)
                    if (512 & t17.flags && (t17.check = c$14(t17.check, i37, v9, s17)), r24 -= v9, s17 += v9, R6) {
                        break e;
                    }
                } else {
                    t17.head && (t17.head.comment = null);
                }
                t17.mode = 9;
            case 9:
                if (512 & t17.flags) {
                    for (; w5 < 16;) {
                        if (0 === r24) {
                            break e;
                        }
                        r24--, m6 += i37[s17++] << w5, w5 += 8;
                    }
                    if (m6 !== (65535 & t17.check)) {
                        e16.msg = "header crc mismatch", t17.mode = 30;
                        break;
                    }
                    m6 = 0, w5 = 0;
                }
                t17.head && (t17.head.hcrc = t17.flags >> 9 & 1, t17.head.done = !0), e16.adler = t17.check = 0, t17.mode = 12;
                break;
            case 10:
                for (; w5 < 32;) {
                    if (0 === r24) {
                        break e;
                    }
                    r24--, m6 += i37[s17++] << w5, w5 += 8;
                }
                e16.adler = t17.check = k$11(m6), m6 = 0, w5 = 0, t17.mode = 11;
            case 11:
                if (0 === t17.havedict) {
                    return e16.next_out = o27, e16.avail_out = l24, e16.next_in = s17, e16.avail_in = r24, t17.hold = m6, t17.bits = w5, 2;
                }
                e16.adler = t17.check = 1, t17.mode = 12;
            case 12:
                if (5 === a29 || 6 === a29) {
                    break e;
                }
            case 13:
                if (t17.last) {
                    m6 >>>= 7 & w5, w5 -= 7 & w5, t17.mode = 27;
                    break;
                }
                for (; w5 < 3;) {
                    if (0 === r24) {
                        break e;
                    }
                    r24--, m6 += i37[s17++] << w5, w5 += 8;
                }
                switch (t17.last = 1 & m6, w5 -= 1, 3 & (m6 >>>= 1)) {
                    case 0:
                        t17.mode = 14;
                        break;
                    case 1:
                        if (y$12(t17), t17.mode = 20, 6 === a29) {
                            m6 >>>= 2, w5 -= 2;
                            break e;
                        }
                        break;
                    case 2:
                        t17.mode = 17;
                        break;
                    case 3:
                        e16.msg = "invalid block type", t17.mode = 30;
                }
                m6 >>>= 2, w5 -= 2;
                break;
            case 14:
                for (m6 >>>= 7 & w5, w5 -= 7 & w5; w5 < 32;) {
                    if (0 === r24) {
                        break e;
                    }
                    r24--, m6 += i37[s17++] << w5, w5 += 8;
                }
                if ((65535 & m6) != (m6 >>> 16 ^ 65535)) {
                    e16.msg = "invalid stored block lengths", t17.mode = 30;
                    break;
                }
                if (t17.length = 65535 & m6, m6 = 0, w5 = 0, t17.mode = 15, 6 === a29) {
                    break e;
                }
            case 15:
                t17.mode = 16;
            case 16:
                if (v9 = t17.length) {
                    if (v9 > r24 && (v9 = r24), v9 > l24 && (v9 = l24), 0 === v9) {
                        break e;
                    }
                    d$11.arraySet(n30, i37, s17, v9, o27), r24 -= v9, s17 += v9, l24 -= v9, o27 += v9, t17.length -= v9;
                    break;
                }
                t17.mode = 12;
                break;
            case 17:
                for (; w5 < 14;) {
                    if (0 === r24) {
                        break e;
                    }
                    r24--, m6 += i37[s17++] << w5, w5 += 8;
                }
                if (t17.nlen = 257 + (31 & m6), m6 >>>= 5, w5 -= 5, t17.ndist = 1 + (31 & m6), m6 >>>= 5, w5 -= 5, t17.ncode = 4 + (15 & m6), m6 >>>= 4, w5 -= 4, t17.nlen > 286 || t17.ndist > 30) {
                    e16.msg = "too many length or distance symbols", t17.mode = 30;
                    break;
                }
                t17.have = 0, t17.mode = 18;
            case 18:
                for (; t17.have < t17.ncode;) {
                    for (; w5 < 3;) {
                        if (0 === r24) {
                            break e;
                        }
                        r24--, m6 += i37[s17++] << w5, w5 += 8;
                    }
                    t17.lens[K4[t17.have++]] = 7 & m6, m6 >>>= 3, w5 -= 3;
                }
                for (; t17.have < 19;) {
                    t17.lens[K4[t17.have++]] = 0;
                }
                if (t17.lencode = t17.lendyn, t17.lenbits = 7, D6 = {
                    bits: t17.lenbits
                }, A5 = b$12(0, t17.lens, 0, 19, t17.lencode, 0, t17.work, D6), t17.lenbits = D6.bits, A5) {
                    e16.msg = "invalid code lengths set", t17.mode = 30;
                    break;
                }
                t17.have = 0, t17.mode = 19;
            case 19:
                for (; t17.have < t17.nlen + t17.ndist;) {
                    for (; B6 = (G5 = t17.lencode[m6 & (1 << t17.lenbits) - 1]) >>> 16 & 255, S5 = 65535 & G5, !((p13 = G5 >>> 24) <= w5);) {
                        if (0 === r24) {
                            break e;
                        }
                        r24--, m6 += i37[s17++] << w5, w5 += 8;
                    }
                    if (S5 < 16) {
                        m6 >>>= p13, w5 -= p13, t17.lens[t17.have++] = S5;
                    } else {
                        if (16 === S5) {
                            for (E6 = p13 + 2; w5 < E6;) {
                                if (0 === r24) {
                                    break e;
                                }
                                r24--, m6 += i37[s17++] << w5, w5 += 8;
                            }
                            if (m6 >>>= p13, w5 -= p13, 0 === t17.have) {
                                e16.msg = "invalid bit length repeat", t17.mode = 30;
                                break;
                            }
                            R6 = t17.lens[t17.have - 1], v9 = 3 + (3 & m6), m6 >>>= 2, w5 -= 2;
                        } else if (17 === S5) {
                            for (E6 = p13 + 3; w5 < E6;) {
                                if (0 === r24) {
                                    break e;
                                }
                                r24--, m6 += i37[s17++] << w5, w5 += 8;
                            }
                            w5 -= p13, R6 = 0, v9 = 3 + (7 & (m6 >>>= p13)), m6 >>>= 3, w5 -= 3;
                        } else {
                            for (E6 = p13 + 7; w5 < E6;) {
                                if (0 === r24) {
                                    break e;
                                }
                                r24--, m6 += i37[s17++] << w5, w5 += 8;
                            }
                            w5 -= p13, R6 = 0, v9 = 11 + (127 & (m6 >>>= p13)), m6 >>>= 7, w5 -= 7;
                        }
                        if (t17.have + v9 > t17.nlen + t17.ndist) {
                            e16.msg = "invalid bit length repeat", t17.mode = 30;
                            break;
                        }
                        for (; v9--;) {
                            t17.lens[t17.have++] = R6;
                        }
                    }
                }
                if (30 === t17.mode) {
                    break;
                }
                if (0 === t17.lens[256]) {
                    e16.msg = "invalid code -- missing end-of-block", t17.mode = 30;
                    break;
                }
                if (t17.lenbits = 9, D6 = {
                    bits: t17.lenbits
                }, A5 = b$12(1, t17.lens, 0, t17.nlen, t17.lencode, 0, t17.work, D6), t17.lenbits = D6.bits, A5) {
                    e16.msg = "invalid literal/lengths set", t17.mode = 30;
                    break;
                }
                if (t17.distbits = 6, t17.distcode = t17.distdyn, D6 = {
                    bits: t17.distbits
                }, A5 = b$12(2, t17.lens, t17.nlen, t17.ndist, t17.distcode, 0, t17.work, D6), t17.distbits = D6.bits, A5) {
                    e16.msg = "invalid distances set", t17.mode = 30;
                    break;
                }
                if (t17.mode = 20, 6 === a29) {
                    break e;
                }
            case 20:
                t17.mode = 21;
            case 21:
                if (r24 >= 6 && l24 >= 258) {
                    e16.next_out = o27, e16.avail_out = l24, e16.next_in = s17, e16.avail_in = r24, t17.hold = m6, t17.bits = w5, h$13(e16, g9), o27 = e16.next_out, n30 = e16.output, l24 = e16.avail_out, s17 = e16.next_in, i37 = e16.input, r24 = e16.avail_in, m6 = t17.hold, w5 = t17.bits, 12 === t17.mode && (t17.back = -1);
                    break;
                }
                for (t17.back = 0; B6 = (G5 = t17.lencode[m6 & (1 << t17.lenbits) - 1]) >>> 16 & 255, S5 = 65535 & G5, !((p13 = G5 >>> 24) <= w5);) {
                    if (0 === r24) {
                        break e;
                    }
                    r24--, m6 += i37[s17++] << w5, w5 += 8;
                }
                if (B6 && 0 == (240 & B6)) {
                    for (j5 = p13, C6 = B6, I7 = S5; B6 = (G5 = t17.lencode[I7 + ((m6 & (1 << j5 + C6) - 1) >> j5)]) >>> 16 & 255, S5 = 65535 & G5, !(j5 + (p13 = G5 >>> 24) <= w5);) {
                        if (0 === r24) {
                            break e;
                        }
                        r24--, m6 += i37[s17++] << w5, w5 += 8;
                    }
                    m6 >>>= j5, w5 -= j5, t17.back += j5;
                }
                if (m6 >>>= p13, w5 -= p13, t17.back += p13, t17.length = S5, 0 === B6) {
                    t17.mode = 26;
                    break;
                }
                if (32 & B6) {
                    t17.back = -1, t17.mode = 12;
                    break;
                }
                if (64 & B6) {
                    e16.msg = "invalid literal/length code", t17.mode = 30;
                    break;
                }
                t17.extra = 15 & B6, t17.mode = 22;
            case 22:
                if (t17.extra) {
                    for (E6 = t17.extra; w5 < E6;) {
                        if (0 === r24) {
                            break e;
                        }
                        r24--, m6 += i37[s17++] << w5, w5 += 8;
                    }
                    t17.length += m6 & (1 << t17.extra) - 1, m6 >>>= t17.extra, w5 -= t17.extra, t17.back += t17.extra;
                }
                t17.was = t17.length, t17.mode = 23;
            case 23:
                for (; B6 = (G5 = t17.distcode[m6 & (1 << t17.distbits) - 1]) >>> 16 & 255, S5 = 65535 & G5, !((p13 = G5 >>> 24) <= w5);) {
                    if (0 === r24) {
                        break e;
                    }
                    r24--, m6 += i37[s17++] << w5, w5 += 8;
                }
                if (0 == (240 & B6)) {
                    for (j5 = p13, C6 = B6, I7 = S5; B6 = (G5 = t17.distcode[I7 + ((m6 & (1 << j5 + C6) - 1) >> j5)]) >>> 16 & 255, S5 = 65535 & G5, !(j5 + (p13 = G5 >>> 24) <= w5);) {
                        if (0 === r24) {
                            break e;
                        }
                        r24--, m6 += i37[s17++] << w5, w5 += 8;
                    }
                    m6 >>>= j5, w5 -= j5, t17.back += j5;
                }
                if (m6 >>>= p13, w5 -= p13, t17.back += p13, 64 & B6) {
                    e16.msg = "invalid distance code", t17.mode = 30;
                    break;
                }
                t17.offset = S5, t17.extra = 15 & B6, t17.mode = 24;
            case 24:
                if (t17.extra) {
                    for (E6 = t17.extra; w5 < E6;) {
                        if (0 === r24) {
                            break e;
                        }
                        r24--, m6 += i37[s17++] << w5, w5 += 8;
                    }
                    t17.offset += m6 & (1 << t17.extra) - 1, m6 >>>= t17.extra, w5 -= t17.extra, t17.back += t17.extra;
                }
                if (t17.offset > t17.dmax) {
                    e16.msg = "invalid distance too far back", t17.mode = 30;
                    break;
                }
                t17.mode = 25;
            case 25:
                if (0 === l24) {
                    break e;
                }
                if (v9 = g9 - l24, t17.offset > v9) {
                    if ((v9 = t17.offset - v9) > t17.whave && t17.sane) {
                        e16.msg = "invalid distance too far back", t17.mode = 30;
                        break;
                    }
                    v9 > t17.wnext ? (v9 -= t17.wnext, x6 = t17.wsize - v9) : x6 = t17.wnext - v9, v9 > t17.length && (v9 = t17.length), _9 = t17.window;
                } else {
                    _9 = n30, x6 = o27 - t17.offset, v9 = t17.length;
                }
                v9 > l24 && (v9 = l24), l24 -= v9, t17.length -= v9;
                do {
                    n30[o27++] = _9[x6++];
                } while (--v9)
                0 === t17.length && (t17.mode = 21);
                break;
            case 26:
                if (0 === l24) {
                    break e;
                }
                n30[o27++] = t17.length, l24--, t17.mode = 21;
                break;
            case 27:
                if (t17.wrap) {
                    for (; w5 < 32;) {
                        if (0 === r24) {
                            break e;
                        }
                        r24--, m6 |= i37[s17++] << w5, w5 += 8;
                    }
                    if (g9 -= l24, e16.total_out += g9, t17.total += g9, g9 && (e16.adler = t17.check = t17.flags ? c$14(t17.check, n30, g9, o27 - g9) : f$14(t17.check, n30, g9, o27 - g9)), g9 = l24, (t17.flags ? m6 : k$11(m6)) !== t17.check) {
                        e16.msg = "incorrect data check", t17.mode = 30;
                        break;
                    }
                    m6 = 0, w5 = 0;
                }
                t17.mode = 28;
            case 28:
                if (t17.wrap && t17.flags) {
                    for (; w5 < 32;) {
                        if (0 === r24) {
                            break e;
                        }
                        r24--, m6 += i37[s17++] << w5, w5 += 8;
                    }
                    if (m6 !== (4294967295 & t17.total)) {
                        e16.msg = "incorrect length check", t17.mode = 30;
                        break;
                    }
                    m6 = 0, w5 = 0;
                }
                t17.mode = 29;
            case 29:
                A5 = 1;
                break e;
            case 30:
                A5 = -3;
                break e;
            case 31:
                return -4;
            case 32:
            default:
                return -2;
        }
    }
    return e16.next_out = o27, e16.avail_out = l24, e16.next_in = s17, e16.avail_in = r24, t17.hold = m6, t17.bits = w5, (t17.wsize || g9 !== e16.avail_out && t17.mode < 30 && (t17.mode < 27 || 4 !== a29)) && z$11(e16, e16.output, e16.next_out, g9 - e16.avail_out) ? (t17.mode = 31, -4) : (u20 -= e16.avail_in, g9 -= e16.avail_out, e16.total_in += u20, e16.total_out += g9, t17.total += g9, t17.wrap && g9 && (e16.adler = t17.check = t17.flags ? c$14(t17.check, n30, g9, e16.next_out - g9) : f$14(t17.check, n30, g9, e16.next_out - g9)), e16.data_type = t17.bits + (t17.last ? 64 : 0) + (12 === t17.mode ? 128 : 0) + (20 === t17.mode || 15 === t17.mode ? 256 : 0), (0 === u20 && 0 === g9 || 4 === a29) && 0 === A5 && (A5 = -5), A5);
}, l$12.inflateEnd = function (e16) {
    if (!e16 || !e16.state) {
        return -2;
    }
    var a29 = e16.state;
    return a29.window && (a29.window = null), e16.state = null, 0;
}, l$12.inflateGetHeader = function (e16, a29) {
    var t17;
    return e16 && e16.state ? 0 == (2 & (t17 = e16.state).wrap) ? -2 : (t17.head = a29, a29.done = !1, 0) : -2;
}, l$12.inflateSetDictionary = function (e16, a29) {
    var t17, i37 = a29.length;
    return e16 && e16.state ? 0 !== (t17 = e16.state).wrap && 11 !== t17.mode ? -2 : 11 === t17.mode && f$14(1, a29, i37, 0) !== t17.check ? -3 : z$11(e16, a29, i37, i37) ? (t17.mode = 31, -4) : (t17.havedict = 1, 0) : -2;
}, l$12.inflateInfo = "pako inflate (from Nodeca project)";
var _$21 = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
};
var _$3 = {}, l$21 = e$1.Buffer, f$22 = T1, c$22 = et, u$22 = t15, d$2 = G4, E$11 = l$12, w$2 = _$21;
for (var p$22 in w$2) {
    _$3[p$22] = w$2[p$22];
}
_$3.NONE = 0, _$3.DEFLATE = 1, _$3.INFLATE = 2, _$3.GZIP = 3, _$3.GUNZIP = 4, _$3.DEFLATERAW = 5, _$3.INFLATERAW = 6, _$3.UNZIP = 7;

function m$23(t17) {
    if ("number" != typeof t17 || t17 < _$3.DEFLATE || t17 > _$3.UNZIP) {
        throw new TypeError("Bad argument");
    }
    this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = t17, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
}

m$23.prototype.close = function () {
    if (this.write_in_progress) {
        return this.pending_close = !0, void 0;
    }
    this.pending_close = !1, c$22(this.init_done, "close before init"), c$22(this.mode <= _$3.UNZIP), this.mode === _$3.DEFLATE || this.mode === _$3.GZIP || this.mode === _$3.DEFLATERAW ? d$2.deflateEnd(this.strm) : this.mode !== _$3.INFLATE && this.mode !== _$3.GUNZIP && this.mode !== _$3.INFLATERAW && this.mode !== _$3.UNZIP || E$11.inflateEnd(this.strm), this.mode = _$3.NONE, this.dictionary = null;
}, m$23.prototype.write = function (t17, e16, i37, r24, n30, s17, o27) {
    return this._write(!0, t17, e16, i37, r24, n30, s17, o27);
}, m$23.prototype.writeSync = function (t17, e16, i37, r24, n30, s17, o27) {
    return this._write(!1, t17, e16, i37, r24, n30, s17, o27);
}, m$23.prototype._write = function (t17, e16, i37, r24, n30, s17, o27, h14) {
    if (c$22.equal(arguments.length, 8), c$22(this.init_done, "write before init"), c$22(this.mode !== _$3.NONE, "already finalized"), c$22.equal(!1, this.write_in_progress, "write already in progress"), c$22.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, c$22.equal(!1, (void 0) === e16, "must provide flush value"), this.write_in_progress = !0, e16 !== _$3.Z_NO_FLUSH && e16 !== _$3.Z_PARTIAL_FLUSH && e16 !== _$3.Z_SYNC_FLUSH && e16 !== _$3.Z_FULL_FLUSH && e16 !== _$3.Z_FINISH && e16 !== _$3.Z_BLOCK) {
        throw new Error("Invalid flush value");
    }
    if (null == i37 && (i37 = l$21.alloc(0), n30 = 0, r24 = 0), this.strm.avail_in = n30, this.strm.input = i37, this.strm.next_in = r24, this.strm.avail_out = h14, this.strm.output = s17, this.strm.next_out = o27, this.flush = e16, !t17) {
        return this._process(), this._checkError() ? this._afterSync() : void 0;
    }
    var a29 = this;
    return f$22.nextTick(function () {
        a29._process(), a29._after();
    }), this;
}, m$23.prototype._afterSync = function () {
    var t17 = this.strm.avail_out, e16 = this.strm.avail_in;
    return this.write_in_progress = !1, [
        e16,
        t17
    ];
}, m$23.prototype._process = function () {
    var t17 = null;
    switch (this.mode) {
        case _$3.DEFLATE:
        case _$3.GZIP:
        case _$3.DEFLATERAW:
            this.err = d$2.deflate(this.strm, this.flush);
            break;
        case _$3.UNZIP:
            switch (this.strm.avail_in > 0 && (t17 = this.strm.next_in), this.gzip_id_bytes_read) {
                case 0:
                    if (null === t17) {
                        break;
                    }
                    if (31 !== this.strm.input[t17]) {
                        this.mode = _$3.INFLATE;
                        break;
                    }
                    if (this.gzip_id_bytes_read = 1, t17++, 1 === this.strm.avail_in) {
                        break;
                    }
                case 1:
                    if (null === t17) {
                        break;
                    }
                    139 === this.strm.input[t17] ? (this.gzip_id_bytes_read = 2, this.mode = _$3.GUNZIP) : this.mode = _$3.INFLATE;
                    break;
                default:
                    throw new Error("invalid number of gzip magic number bytes read");
            }
        case _$3.INFLATE:
        case _$3.GUNZIP:
        case _$3.INFLATERAW:
            for (this.err = E$11.inflate(this.strm, this.flush), this.err === _$3.Z_NEED_DICT && this.dictionary && (this.err = E$11.inflateSetDictionary(this.strm, this.dictionary), this.err === _$3.Z_OK ? this.err = E$11.inflate(this.strm, this.flush) : this.err === _$3.Z_DATA_ERROR && (this.err = _$3.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === _$3.GUNZIP && this.err === _$3.Z_STREAM_END && 0 !== this.strm.next_in[0];) {
                this.reset(), this.err = E$11.inflate(this.strm, this.flush);
            }
            break;
        default:
            throw new Error("Unknown mode " + this.mode);
    }
}, m$23.prototype._checkError = function () {
    switch (this.err) {
        case _$3.Z_OK:
        case _$3.Z_BUF_ERROR:
            if (0 !== this.strm.avail_out && this.flush === _$3.Z_FINISH) {
                return this._error("unexpected end of file"), !1;
            }
            break;
        case _$3.Z_STREAM_END:
            break;
        case _$3.Z_NEED_DICT:
            return null == this.dictionary ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
        default:
            return this._error("Zlib error"), !1;
    }
    return !0;
}, m$23.prototype._after = function () {
    if (this._checkError()) {
        var t17 = this.strm.avail_out, e16 = this.strm.avail_in;
        this.write_in_progress = !1, this.callback(e16, t17), this.pending_close && this.close();
    }
}, m$23.prototype._error = function (t18) {
    this.strm.msg && (t18 = this.strm.msg), this.onerror(t18, this.err), this.write_in_progress = !1, this.pending_close && this.close();
}, m$23.prototype.init = function (t18, e17, i37, r24, n30) {
    c$22(4 === arguments.length || 5 === arguments.length, "init(windowBits, level, memLevel, strategy, [dictionary])"), c$22(t18 >= 8 && t18 <= 15, "invalid windowBits"), c$22(e17 >= -1 && e17 <= 9, "invalid compression level"), c$22(i37 >= 1 && i37 <= 9, "invalid memlevel"), c$22(r24 === _$3.Z_FILTERED || r24 === _$3.Z_HUFFMAN_ONLY || r24 === _$3.Z_RLE || r24 === _$3.Z_FIXED || r24 === _$3.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(e17, t18, i37, r24, n30), this._setDictionary();
}, m$23.prototype.params = function () {
    throw new Error("deflateParams Not supported");
}, m$23.prototype.reset = function () {
    this._reset(), this._setDictionary();
}, m$23.prototype._init = function (t18, e17, i37, r24, n30) {
    switch (this.level = t18, this.windowBits = e17, this.memLevel = i37, this.strategy = r24, this.flush = _$3.Z_NO_FLUSH, this.err = _$3.Z_OK, this.mode !== _$3.GZIP && this.mode !== _$3.GUNZIP || (this.windowBits += 16), this.mode === _$3.UNZIP && (this.windowBits += 32), this.mode !== _$3.DEFLATERAW && this.mode !== _$3.INFLATERAW || (this.windowBits = -1 * this.windowBits), this.strm = new u$22, this.mode) {
        case _$3.DEFLATE:
        case _$3.GZIP:
        case _$3.DEFLATERAW:
            this.err = d$2.deflateInit2(this.strm, this.level, _$3.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
            break;
        case _$3.INFLATE:
        case _$3.GUNZIP:
        case _$3.INFLATERAW:
        case _$3.UNZIP:
            this.err = E$11.inflateInit2(this.strm, this.windowBits);
            break;
        default:
            throw new Error("Unknown mode " + this.mode);
    }
    this.err !== _$3.Z_OK && this._error("Init error"), this.dictionary = n30, this.write_in_progress = !1, this.init_done = !0;
}, m$23.prototype._setDictionary = function () {
    if (null != this.dictionary) {
        switch (this.err = _$3.Z_OK, this.mode) {
            case _$3.DEFLATE:
            case _$3.DEFLATERAW:
                this.err = d$2.deflateSetDictionary(this.strm, this.dictionary);
        }
        this.err !== _$3.Z_OK && this._error("Failed to set dictionary");
    }
}, m$23.prototype._reset = function () {
    switch (this.err = _$3.Z_OK, this.mode) {
        case _$3.DEFLATE:
        case _$3.DEFLATERAW:
        case _$3.GZIP:
            this.err = d$2.deflateReset(this.strm);
            break;
        case _$3.INFLATE:
        case _$3.INFLATERAW:
        case _$3.GUNZIP:
            this.err = E$11.inflateReset(this.strm);
    }
    this.err !== _$3.Z_OK && this._error("Failed to reset stream");
}, _$3.Zlib = m$23;
var Z$11 = {}, L$11 = T1, I$11 = e$1.Buffer, y$21 = b7.Transform, v$21 = _$3, F$11 = X, N$12 = et.ok,
        A$12 = e$1.kMaxLength,
        R$11 = "Cannot create final Buffer. It would be larger than 0x" + A$12.toString(16) + " bytes";
v$21.Z_MIN_WINDOWBITS = 8, v$21.Z_MAX_WINDOWBITS = 15, v$21.Z_DEFAULT_WINDOWBITS = 15, v$21.Z_MIN_CHUNK = 64, v$21.Z_MAX_CHUNK = 1 / 0, v$21.Z_DEFAULT_CHUNK = 16384, v$21.Z_MIN_MEMLEVEL = 1, v$21.Z_MAX_MEMLEVEL = 9, v$21.Z_DEFAULT_MEMLEVEL = 8, v$21.Z_MIN_LEVEL = -1, v$21.Z_MAX_LEVEL = 9, v$21.Z_DEFAULT_LEVEL = v$21.Z_DEFAULT_COMPRESSION;
for (var g$2 = Object.keys(v$21), T$11 = 0; T$11 < g$2.length; T$11++) {
    var b$2 = g$2[T$11];
    b$2.match(/^Z/) && Object.defineProperty(Z$11, b$2, {
        enumerable: !0,
        value: v$21[b$2],
        writable: !1
    });
}
for (var D$11 = {
    Z_OK: v$21.Z_OK,
    Z_STREAM_END: v$21.Z_STREAM_END,
    Z_NEED_DICT: v$21.Z_NEED_DICT,
    Z_ERRNO: v$21.Z_ERRNO,
    Z_STREAM_ERROR: v$21.Z_STREAM_ERROR,
    Z_DATA_ERROR: v$21.Z_DATA_ERROR,
    Z_MEM_ERROR: v$21.Z_MEM_ERROR,
    Z_BUF_ERROR: v$21.Z_BUF_ERROR,
    Z_VERSION_ERROR: v$21.Z_VERSION_ERROR
}, S$11 = Object.keys(D$11), U$11 = 0; U$11 < S$11.length; U$11++) {
    var O$11 = S$11[U$11];
    D$11[D$11[O$11]] = O$11;
}

function k$2(t18, e17, i37) {
    var r24 = [], n30 = 0;

    function s17() {
        for (var e18; null !== (e18 = t18.read());) {
            r24.push(e18), n30 += e18.length;
        }
        t18.once("readable", s17);
    }

    function o27() {
        var e18, s18 = null;
        n30 >= A$12 ? s18 = new RangeError(R$11) : e18 = I$11.concat(r24, n30), r24 = [], t18.close(), i37(s18, e18);
    }

    t18.on("error", function (e18) {
        t18.removeListener("end", o27), t18.removeListener("readable", s17), i37(e18);
    }), t18.on("end", o27), t18.end(e17), s17();
}

function M$11(t18, e17) {
    if ("string" == typeof e17 && (e17 = I$11.from(e17)), !I$11.isBuffer(e17)) {
        throw new TypeError("Not a string or buffer");
    }
    var i37 = t18._finishFlushFlag;
    return t18._processChunk(e17, i37);
}

function z$2(t18) {
    if (!(this instanceof z$2)) {
        return new z$2(t18);
    }
    V$12.call(this, t18, v$21.DEFLATE);
}

function B$11(t18) {
    if (!(this instanceof B$11)) {
        return new B$11(t18);
    }
    V$12.call(this, t18, v$21.INFLATE);
}

function P$12(t18) {
    if (!(this instanceof P$12)) {
        return new P$12(t18);
    }
    V$12.call(this, t18, v$21.GZIP);
}

function W$11(t18) {
    if (!(this instanceof W$11)) {
        return new W$11(t18);
    }
    V$12.call(this, t18, v$21.GUNZIP);
}

function H$11(t18) {
    if (!(this instanceof H$11)) {
        return new H$11(t18);
    }
    V$12.call(this, t18, v$21.DEFLATERAW);
}

function G$11(t18) {
    if (!(this instanceof G$11)) {
        return new G$11(t18);
    }
    V$12.call(this, t18, v$21.INFLATERAW);
}

function C$11(t18) {
    if (!(this instanceof C$11)) {
        return new C$11(t18);
    }
    V$12.call(this, t18, v$21.UNZIP);
}

function K$11(t18) {
    return t18 === v$21.Z_NO_FLUSH || t18 === v$21.Z_PARTIAL_FLUSH || t18 === v$21.Z_SYNC_FLUSH || t18 === v$21.Z_FULL_FLUSH || t18 === v$21.Z_FINISH || t18 === v$21.Z_BLOCK;
}

function V$12(t18, e17) {
    var i37 = this;
    if (this._opts = t18 = t18 || {}, this._chunkSize = t18.chunkSize || Z$11.Z_DEFAULT_CHUNK, y$21.call(this, t18), t18.flush && !K$11(t18.flush)) {
        throw new Error("Invalid flush flag: " + t18.flush);
    }
    if (t18.finishFlush && !K$11(t18.finishFlush)) {
        throw new Error("Invalid flush flag: " + t18.finishFlush);
    }
    if (this._flushFlag = t18.flush || v$21.Z_NO_FLUSH, this._finishFlushFlag = (void 0) !== t18.finishFlush ? t18.finishFlush : v$21.Z_FINISH, t18.chunkSize && (t18.chunkSize < Z$11.Z_MIN_CHUNK || t18.chunkSize > Z$11.Z_MAX_CHUNK)) {
        throw new Error("Invalid chunk size: " + t18.chunkSize);
    }
    if (t18.windowBits && (t18.windowBits < Z$11.Z_MIN_WINDOWBITS || t18.windowBits > Z$11.Z_MAX_WINDOWBITS)) {
        throw new Error("Invalid windowBits: " + t18.windowBits);
    }
    if (t18.level && (t18.level < Z$11.Z_MIN_LEVEL || t18.level > Z$11.Z_MAX_LEVEL)) {
        throw new Error("Invalid compression level: " + t18.level);
    }
    if (t18.memLevel && (t18.memLevel < Z$11.Z_MIN_MEMLEVEL || t18.memLevel > Z$11.Z_MAX_MEMLEVEL)) {
        throw new Error("Invalid memLevel: " + t18.memLevel);
    }
    if (t18.strategy && t18.strategy != Z$11.Z_FILTERED && t18.strategy != Z$11.Z_HUFFMAN_ONLY && t18.strategy != Z$11.Z_RLE && t18.strategy != Z$11.Z_FIXED && t18.strategy != Z$11.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + t18.strategy);
    }
    if (t18.dictionary && !I$11.isBuffer(t18.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
    }
    this._handle = new v$21.Zlib(e17);
    var r24 = this;
    this._hadError = !1, this._handle.onerror = function (t19, e18) {
        x$2(r24), r24._hadError = !0;
        var i38 = new Error(t19);
        i38.errno = e18, i38.code = Z$11.codes[e18], r24.emit("error", i38);
    };
    var n30 = Z$11.Z_DEFAULT_COMPRESSION;
    "number" == typeof t18.level && (n30 = t18.level);
    var s17 = Z$11.Z_DEFAULT_STRATEGY;
    "number" == typeof t18.strategy && (s17 = t18.strategy), this._handle.init(t18.windowBits || Z$11.Z_DEFAULT_WINDOWBITS, n30, t18.memLevel || Z$11.Z_DEFAULT_MEMLEVEL, s17, t18.dictionary), this._buffer = I$11.allocUnsafe(this._chunkSize), this._offset = 0, this._level = n30, this._strategy = s17, this.once("end", this.close), Object.defineProperty(this, "_closed", {
        get: function () {
            return !i37._handle;
        },
        configurable: !0,
        enumerable: !0
    });
}

function x$2(t18, e17) {
    e17 && L$11.nextTick(e17), t18._handle && (t18._handle.close(), t18._handle = null);
}

function X$11(t18) {
    t18.emit("close");
}

Object.defineProperty(Z$11, "codes", {
    enumerable: !0,
    value: Object.freeze(D$11),
    writable: !1
}), Z$11.Deflate = z$2, Z$11.Inflate = B$11, Z$11.Gzip = P$12, Z$11.Gunzip = W$11, Z$11.DeflateRaw = H$11, Z$11.InflateRaw = G$11, Z$11.Unzip = C$11, Z$11.createDeflate = function (t18) {
    return new z$2(t18);
}, Z$11.createInflate = function (t18) {
    return new B$11(t18);
}, Z$11.createDeflateRaw = function (t18) {
    return new H$11(t18);
}, Z$11.createInflateRaw = function (t18) {
    return new G$11(t18);
}, Z$11.createGzip = function (t18) {
    return new P$12(t18);
}, Z$11.createGunzip = function (t18) {
    return new W$11(t18);
}, Z$11.createUnzip = function (t18) {
    return new C$11(t18);
}, Z$11.deflate = function (t18, e17, i37) {
    return "function" == typeof e17 && (i37 = e17, e17 = {}), k$2(new z$2(e17), t18, i37);
}, Z$11.deflateSync = function (t18, e17) {
    return M$11(new z$2(e17), t18);
}, Z$11.gzip = function (t18, e17, i37) {
    return "function" == typeof e17 && (i37 = e17, e17 = {}), k$2(new P$12(e17), t18, i37);
}, Z$11.gzipSync = function (t18, e17) {
    return M$11(new P$12(e17), t18);
}, Z$11.deflateRaw = function (t18, e17, i37) {
    return "function" == typeof e17 && (i37 = e17, e17 = {}), k$2(new H$11(e17), t18, i37);
}, Z$11.deflateRawSync = function (t18, e17) {
    return M$11(new H$11(e17), t18);
}, Z$11.unzip = function (t18, e17, i37) {
    return "function" == typeof e17 && (i37 = e17, e17 = {}), k$2(new C$11(e17), t18, i37);
}, Z$11.unzipSync = function (t18, e17) {
    return M$11(new C$11(e17), t18);
}, Z$11.inflate = function (t18, e17, i37) {
    return "function" == typeof e17 && (i37 = e17, e17 = {}), k$2(new B$11(e17), t18, i37);
}, Z$11.inflateSync = function (t18, e17) {
    return M$11(new B$11(e17), t18);
}, Z$11.gunzip = function (t18, e17, i37) {
    return "function" == typeof e17 && (i37 = e17, e17 = {}), k$2(new W$11(e17), t18, i37);
}, Z$11.gunzipSync = function (t18, e17) {
    return M$11(new W$11(e17), t18);
}, Z$11.inflateRaw = function (t18, e17, i37) {
    return "function" == typeof e17 && (i37 = e17, e17 = {}), k$2(new G$11(e17), t18, i37);
}, Z$11.inflateRawSync = function (t18, e17) {
    return M$11(new G$11(e17), t18);
}, F$11.inherits(V$12, y$21), V$12.prototype.params = function (t18, e17, i37) {
    if (t18 < Z$11.Z_MIN_LEVEL || t18 > Z$11.Z_MAX_LEVEL) {
        throw new RangeError("Invalid compression level: " + t18);
    }
    if (e17 != Z$11.Z_FILTERED && e17 != Z$11.Z_HUFFMAN_ONLY && e17 != Z$11.Z_RLE && e17 != Z$11.Z_FIXED && e17 != Z$11.Z_DEFAULT_STRATEGY) {
        throw new TypeError("Invalid strategy: " + e17);
    }
    if (this._level !== t18 || this._strategy !== e17) {
        var r24 = this;
        this.flush(v$21.Z_SYNC_FLUSH, function () {
            N$12(r24._handle, "zlib binding closed"), r24._handle.params(t18, e17), r24._hadError || (r24._level = t18, r24._strategy = e17, i37 && i37());
        });
    } else {
        L$11.nextTick(i37);
    }
}, V$12.prototype.reset = function () {
    return N$12(this._handle, "zlib binding closed"), this._handle.reset();
}, V$12.prototype._flush = function (t18) {
    this._transform(I$11.alloc(0), "", t18);
}, V$12.prototype.flush = function (t18, e17) {
    var i37 = this, r25 = this._writableState;
    ("function" == typeof t18 || (void 0) === t18 && !e17) && (e17 = t18, t18 = v$21.Z_FULL_FLUSH), r25.ended ? e17 && L$11.nextTick(e17) : r25.ending ? e17 && this.once("end", e17) : r25.needDrain ? e17 && this.once("drain", function () {
        return i37.flush(t18, e17);
    }) : (this._flushFlag = t18, this.write(I$11.alloc(0), "", e17));
}, V$12.prototype.close = function (t18) {
    x$2(this, t18), L$11.nextTick(X$11, this);
}, V$12.prototype._transform = function (t18, e17, i37) {
    var r25, n30 = this._writableState, s17 = (n30.ending || n30.ended) && (!t18 || n30.length === t18.length);
    return null === t18 || I$11.isBuffer(t18) ? this._handle ? (s17 ? r25 = this._finishFlushFlag : (r25 = this._flushFlag, t18.length >= n30.length && (this._flushFlag = this._opts.flush || v$21.Z_NO_FLUSH)), this._processChunk(t18, r25, i37), void 0) : i37(new Error("zlib binding closed")) : i37(new Error("invalid input"));
}, V$12.prototype._processChunk = function (t18, e17, i37) {
    var r25 = t18 && t18.length, n30 = this._chunkSize - this._offset, s17 = 0, o27 = this,
            h14 = "function" == typeof i37;
    if (!h14) {
        var a29, _9 = [], l24 = 0;
        this.on("error", function (t19) {
            a29 = t19;
        }), N$12(this._handle, "zlib binding closed");
        do {
            var f19 = this._handle.writeSync(e17, t18, s17, r25, this._buffer, this._offset, n30);
        } while (!this._hadError && d12(f19[0], f19[1]))
        if (this._hadError) {
            throw a29;
        }
        if (l24 >= A$12) {
            throw x$2(this), new RangeError(R$11);
        }
        var c13 = I$11.concat(_9, l24);
        return x$2(this), c13;
    }
    N$12(this._handle, "zlib binding closed");
    var u20 = this._handle.write(e17, t18, s17, r25, this._buffer, this._offset, n30);

    function d12(a30, f20) {
        if (this && (this.buffer = null, this.callback = null), !o27._hadError) {
            var c14 = n30 - f20;
            if (N$12(c14 >= 0, "have should not go down"), c14 > 0) {
                var u21 = o27._buffer.slice(o27._offset, o27._offset + c14);
                o27._offset += c14, h14 ? o27.push(u21) : (_9.push(u21), l24 += u21.length);
            }
            if ((0 === f20 || o27._offset >= o27._chunkSize) && (n30 = o27._chunkSize, o27._offset = 0, o27._buffer = I$11.allocUnsafe(o27._chunkSize)), 0 === f20) {
                if (s17 += r25 - a30, r25 = a30, !h14) {
                    return !0;
                }
                var E6 = o27._handle.write(e17, t18, s17, r25, o27._buffer, o27._offset, o27._chunkSize);
                return E6.callback = d12, E6.buffer = t18, void 0;
            }
            if (!h14) {
                return !1;
            }
            i37();
        }
    }

    u20.buffer = t18, u20.callback = d12;
}, F$11.inherits(z$2, V$12), F$11.inherits(B$11, V$12), F$11.inherits(P$12, V$12), F$11.inherits(W$11, V$12), F$11.inherits(H$11, V$12), F$11.inherits(G$11, V$12), F$11.inherits(C$11, V$12);
var _global = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, exports1 = {},
        indexOf = function (e17, t18) {
            if (e17.indexOf) {
                return e17.indexOf(t18);
            }
            for (var n30 = 0; n30 < e17.length; n30++) {
                if (e17[n30] === t18) {
                    return n30;
                }
            }
            return -1;
        }, Object_keys = function (e17) {
            if (Object.keys) {
                return Object.keys(e17);
            }
            var t18 = [];
            for (var n30 in e17) {
                t18.push(n30);
            }
            return t18;
        }, forEach = function (e17, t18) {
            if (e17.forEach) {
                return e17.forEach(t18);
            }
            for (var n30 = 0; n30 < e17.length; n30++) {
                t18(e17[n30], n30, e17);
            }
        }, defineProp = function () {
            try {
                return Object.defineProperty({}, "_", {}), function (e17, t18, n30) {
                    Object.defineProperty(e17, t18, {
                        writable: !0,
                        enumerable: !1,
                        configurable: !0,
                        value: n30
                    });
                };
            } catch (e17) {
                return function (e18, t18, n30) {
                    e18[t18] = n30;
                };
            }
        }(), globals = [
            "Array",
            "Boolean",
            "Date",
            "Error",
            "EvalError",
            "Function",
            "Infinity",
            "JSON",
            "Math",
            "NaN",
            "Number",
            "Object",
            "RangeError",
            "ReferenceError",
            "RegExp",
            "String",
            "SyntaxError",
            "TypeError",
            "URIError",
            "decodeURI",
            "decodeURIComponent",
            "encodeURI",
            "encodeURIComponent",
            "escape",
            "eval",
            "isFinite",
            "isNaN",
            "parseFloat",
            "parseInt",
            "undefined",
            "unescape"
        ];

function Context() {
}

Context.prototype = {};
var Script = exports1.Script = function (e17) {
    if (!((this || _global) instanceof Script)) {
        return new Script(e17);
    }
    (this || _global).code = e17;
};
Script.prototype.runInContext = function (e17) {
    if (!(e17 instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    var t18 = document.createElement("iframe");
    t18.style || (t18.style = {}), t18.style.display = "none", document.body.appendChild(t18);
    var n30 = t18.contentWindow, r25 = n30.eval, o27 = n30.execScript;
    !r25 && o27 && (o27.call(n30, "null"), r25 = n30.eval), forEach(Object_keys(e17), function (t19) {
        n30[t19] = e17[t19];
    }), forEach(globals, function (t19) {
        e17[t19] && (n30[t19] = e17[t19]);
    });
    var c15 = Object_keys(n30), i37 = r25.call(n30, (this || _global).code);
    return forEach(Object_keys(n30), function (t19) {
        (t19 in e17 || -1 === indexOf(c15, t19)) && (e17[t19] = n30[t19]);
    }), forEach(globals, function (t19) {
        t19 in e17 || defineProp(e17, t19, n30[t19]);
    }), document.body.removeChild(t18), i37;
}, Script.prototype.runInThisContext = function () {
    return eval((this || _global).code);
}, Script.prototype.runInNewContext = function (e17) {
    var t18 = Script.createContext(e17), n30 = this.runInContext(t18);
    return e17 && forEach(Object_keys(t18), function (n31) {
        e17[n31] = t18[n31];
    }), n30;
}, forEach(Object_keys(Script.prototype), function (e17) {
    exports1[e17] = Script[e17] = function (t18) {
        var n30 = Script(t18);
        return n30[e17].apply(n30, [].slice.call(arguments, 1));
    };
}), exports1.isContext = function (e17) {
    return e17 instanceof Context;
}, exports1.createScript = function (e17) {
    return exports1.Script(e17);
}, exports1.createContext = Script.createContext = function (e17) {
    var t18 = new Context;
    return "object" == typeof e17 && forEach(Object_keys(e17), function (n30) {
        t18[n30] = e17[n30];
    }), t18;
};
var o27 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, n30 = T1;
var t18 = u14.Buffer, f20 = o27.crypto || o27.msCrypto;
var a30 = f20 && f20.getRandomValues ? function (e17, r25) {
    if (e17 > 4294967295) {
        throw new RangeError("requested too many random bytes");
    }
    var o28 = t18.allocUnsafe(e17);
    if (e17 > 0) {
        if (e17 > 65536) {
            for (var a30 = 0; a30 < e17; a30 += 65536) {
                f20.getRandomValues(o28.slice(a30, a30 + 65536));
            }
        } else {
            f20.getRandomValues(o28);
        }
    }
    if ("function" == typeof r25) {
        return n30.nextTick(function () {
            r25(null, o28);
        });
    }
    return o28;
} : function () {
    throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
};
var e17 = u14.Buffer, o$17 = b7.Transform;

function s17(t19) {
    o$17.call(this), this._block = e17.allocUnsafe(t19), this._blockSize = t19, this._blockOffset = 0, this._length = [
        0,
        0,
        0,
        0
    ], this._finalized = !1;
}

t$2(s17, o$17), s17.prototype._transform = function (t19, i37, r25) {
    var e18 = null;
    try {
        this.update(t19, i37);
    } catch (t20) {
        e18 = t20;
    }
    r25(e18);
}, s17.prototype._flush = function (t19) {
    var i37 = null;
    try {
        this.push(this.digest());
    } catch (t20) {
        i37 = t20;
    }
    t19(i37);
}, s17.prototype.update = function (t19, i37) {
    if (!function (t20, i38) {
        if (!e17.isBuffer(t20) && "string" != typeof t20) {
            throw new TypeError(i38 + " must be a string or a buffer");
        }
    }(t19, "Data"), this._finalized) {
        throw new Error("Digest already called");
    }
    e17.isBuffer(t19) || (t19 = e17.from(t19, i37));
    for (var r25 = this._block, o28 = 0; this._blockOffset + t19.length - o28 >= this._blockSize;) {
        for (var s18 = this._blockOffset; s18 < this._blockSize;) {
            r25[s18++] = t19[o28++];
        }
        this._update(), this._blockOffset = 0;
    }
    for (; o28 < t19.length;) {
        r25[this._blockOffset++] = t19[o28++];
    }
    for (var f21 = 0, n31 = 8 * t19.length; n31 > 0; ++f21) {
        this._length[f21] += n31, (n31 = this._length[f21] / 4294967296 | 0) > 0 && (this._length[f21] -= 4294967296 * n31);
    }
    return this;
}, s17.prototype._update = function () {
    throw new Error("_update is not implemented");
}, s17.prototype.digest = function (t19) {
    if (this._finalized) {
        throw new Error("Digest already called");
    }
    this._finalized = !0;
    var i37 = this._digest();
    (void 0) !== t19 && (i37 = i37.toString(t19)), this._block.fill(0), this._blockOffset = 0;
    for (var r25 = 0; r25 < 4; ++r25) {
        this._length[r25] = 0;
    }
    return i37;
}, s17.prototype._digest = function () {
    throw new Error("_digest is not implemented");
};
var f$15 = s17;
var h14 = t$2, r25 = f$15, _10 = u14.Buffer, e$16 = new Array(16);

function n$17() {
    r25.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}

function o$23(t19, i37) {
    return t19 << i37 | t19 >>> 32 - i37;
}

function f$23(t19, i37, s19, h15, r26, _11, e18) {
    return o$23(t19 + (i37 & s19 | ~i37 & h15) + r26 + _11 | 0, e18) + i37 | 0;
}

function c15(t19, i37, s19, h15, r26, _11, e18) {
    return o$23(t19 + (i37 & h15 | s19 & ~h15) + r26 + _11 | 0, e18) + i37 | 0;
}

function a$14(t19, i37, s19, h15, r26, _11, e18) {
    return o$23(t19 + (i37 ^ s19 ^ h15) + r26 + _11 | 0, e18) + i37 | 0;
}

function l25(t19, i37, s19, h15, r26, _11, e18) {
    return o$23(t19 + (s19 ^ (i37 | ~h15)) + r26 + _11 | 0, e18) + i37 | 0;
}

h14(n$17, r25), n$17.prototype._update = function () {
    for (var t19 = e$16, i37 = 0; i37 < 16; ++i37) {
        t19[i37] = this._block.readInt32LE(4 * i37);
    }
    var s19 = this._a, h15 = this._b, r26 = this._c, _11 = this._d;
    s19 = f$23(s19, h15, r26, _11, t19[0], 3614090360, 7), _11 = f$23(_11, s19, h15, r26, t19[1], 3905402710, 12), r26 = f$23(r26, _11, s19, h15, t19[2], 606105819, 17), h15 = f$23(h15, r26, _11, s19, t19[3], 3250441966, 22), s19 = f$23(s19, h15, r26, _11, t19[4], 4118548399, 7), _11 = f$23(_11, s19, h15, r26, t19[5], 1200080426, 12), r26 = f$23(r26, _11, s19, h15, t19[6], 2821735955, 17), h15 = f$23(h15, r26, _11, s19, t19[7], 4249261313, 22), s19 = f$23(s19, h15, r26, _11, t19[8], 1770035416, 7), _11 = f$23(_11, s19, h15, r26, t19[9], 2336552879, 12), r26 = f$23(r26, _11, s19, h15, t19[10], 4294925233, 17), h15 = f$23(h15, r26, _11, s19, t19[11], 2304563134, 22), s19 = f$23(s19, h15, r26, _11, t19[12], 1804603682, 7), _11 = f$23(_11, s19, h15, r26, t19[13], 4254626195, 12), r26 = f$23(r26, _11, s19, h15, t19[14], 2792965006, 17), s19 = c15(s19, h15 = f$23(h15, r26, _11, s19, t19[15], 1236535329, 22), r26, _11, t19[1], 4129170786, 5), _11 = c15(_11, s19, h15, r26, t19[6], 3225465664, 9), r26 = c15(r26, _11, s19, h15, t19[11], 643717713, 14), h15 = c15(h15, r26, _11, s19, t19[0], 3921069994, 20), s19 = c15(s19, h15, r26, _11, t19[5], 3593408605, 5), _11 = c15(_11, s19, h15, r26, t19[10], 38016083, 9), r26 = c15(r26, _11, s19, h15, t19[15], 3634488961, 14), h15 = c15(h15, r26, _11, s19, t19[4], 3889429448, 20), s19 = c15(s19, h15, r26, _11, t19[9], 568446438, 5), _11 = c15(_11, s19, h15, r26, t19[14], 3275163606, 9), r26 = c15(r26, _11, s19, h15, t19[3], 4107603335, 14), h15 = c15(h15, r26, _11, s19, t19[8], 1163531501, 20), s19 = c15(s19, h15, r26, _11, t19[13], 2850285829, 5), _11 = c15(_11, s19, h15, r26, t19[2], 4243563512, 9), r26 = c15(r26, _11, s19, h15, t19[7], 1735328473, 14), s19 = a$14(s19, h15 = c15(h15, r26, _11, s19, t19[12], 2368359562, 20), r26, _11, t19[5], 4294588738, 4), _11 = a$14(_11, s19, h15, r26, t19[8], 2272392833, 11), r26 = a$14(r26, _11, s19, h15, t19[11], 1839030562, 16), h15 = a$14(h15, r26, _11, s19, t19[14], 4259657740, 23), s19 = a$14(s19, h15, r26, _11, t19[1], 2763975236, 4), _11 = a$14(_11, s19, h15, r26, t19[4], 1272893353, 11), r26 = a$14(r26, _11, s19, h15, t19[7], 4139469664, 16), h15 = a$14(h15, r26, _11, s19, t19[10], 3200236656, 23), s19 = a$14(s19, h15, r26, _11, t19[13], 681279174, 4), _11 = a$14(_11, s19, h15, r26, t19[0], 3936430074, 11), r26 = a$14(r26, _11, s19, h15, t19[3], 3572445317, 16), h15 = a$14(h15, r26, _11, s19, t19[6], 76029189, 23), s19 = a$14(s19, h15, r26, _11, t19[9], 3654602809, 4), _11 = a$14(_11, s19, h15, r26, t19[12], 3873151461, 11), r26 = a$14(r26, _11, s19, h15, t19[15], 530742520, 16), s19 = l25(s19, h15 = a$14(h15, r26, _11, s19, t19[2], 3299628645, 23), r26, _11, t19[0], 4096336452, 6), _11 = l25(_11, s19, h15, r26, t19[7], 1126891415, 10), r26 = l25(r26, _11, s19, h15, t19[14], 2878612391, 15), h15 = l25(h15, r26, _11, s19, t19[5], 4237533241, 21), s19 = l25(s19, h15, r26, _11, t19[12], 1700485571, 6), _11 = l25(_11, s19, h15, r26, t19[3], 2399980690, 10), r26 = l25(r26, _11, s19, h15, t19[10], 4293915773, 15), h15 = l25(h15, r26, _11, s19, t19[1], 2240044497, 21), s19 = l25(s19, h15, r26, _11, t19[8], 1873313359, 6), _11 = l25(_11, s19, h15, r26, t19[15], 4264355552, 10), r26 = l25(r26, _11, s19, h15, t19[6], 2734768916, 15), h15 = l25(h15, r26, _11, s19, t19[13], 1309151649, 21), s19 = l25(s19, h15, r26, _11, t19[4], 4149444226, 6), _11 = l25(_11, s19, h15, r26, t19[11], 3174756917, 10), r26 = l25(r26, _11, s19, h15, t19[2], 718787259, 15), h15 = l25(h15, r26, _11, s19, t19[9], 3951481745, 21), this._a = this._a + s19 | 0, this._b = this._b + h15 | 0, this._c = this._c + r26 | 0, this._d = this._d + _11 | 0;
}, n$17.prototype._digest = function () {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t19 = _10.allocUnsafe(16);
    return t19.writeInt32LE(this._a, 0), t19.writeInt32LE(this._b, 4), t19.writeInt32LE(this._c, 8), t19.writeInt32LE(this._d, 12), t19;
};
var u20 = n$17;
var h$14 = e$1.Buffer, _$12 = t$2, r$14 = f$15, e$22 = new Array(16), n$22 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
], o$31 = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
], f$32 = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
], c$15 = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
], a$22 = [
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
], l$13 = [
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
];

function u$17() {
    r$14.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}

function b10(t19, i37) {
    return t19 << i37 | t19 >>> 32 - i37;
}

function d12(t19, i37, s19, h15, _11, r26, e18, n31) {
    return b10(t19 + (i37 ^ s19 ^ h15) + r26 + e18 | 0, n31) + _11 | 0;
}

function k6(t19, i37, s19, h15, _11, r26, e18, n31) {
    return b10(t19 + (i37 & s19 | ~i37 & h15) + r26 + e18 | 0, n31) + _11 | 0;
}

function p13(t19, i37, s19, h15, _11, r26, e18, n31) {
    return b10(t19 + ((i37 | ~s19) ^ h15) + r26 + e18 | 0, n31) + _11 | 0;
}

function w5(t19, i37, s19, h15, _11, r26, e18, n31) {
    return b10(t19 + (i37 & h15 | s19 & ~h15) + r26 + e18 | 0, n31) + _11 | 0;
}

function E7(t19, i37, s19, h15, _11, r26, e18, n31) {
    return b10(t19 + (i37 ^ (s19 | ~h15)) + r26 + e18 | 0, n31) + _11 | 0;
}

_$12(u$17, r$14), u$17.prototype._update = function () {
    for (var t19 = e$22, i37 = 0; i37 < 16; ++i37) {
        t19[i37] = this._block.readInt32LE(4 * i37);
    }
    for (var s19 = 0 | this._a, h15 = 0 | this._b, _11 = 0 | this._c, r26 = 0 | this._d, u22 = 0 | this._e, I7 = 0 | this._a, L6 = 0 | this._b, v9 = 0 | this._c, m6 = 0 | this._d, O5 = 0 | this._e, g9 = 0; g9 < 80; g9 += 1) {
        var y8, U6;
        g9 < 16 ? (y8 = d12(s19, h15, _11, r26, u22, t19[n$22[g9]], a$22[0], f$32[g9]), U6 = E7(I7, L6, v9, m6, O5, t19[o$31[g9]], l$13[0], c$15[g9])) : g9 < 32 ? (y8 = k6(s19, h15, _11, r26, u22, t19[n$22[g9]], a$22[1], f$32[g9]), U6 = w5(I7, L6, v9, m6, O5, t19[o$31[g9]], l$13[1], c$15[g9])) : g9 < 48 ? (y8 = p13(s19, h15, _11, r26, u22, t19[n$22[g9]], a$22[2], f$32[g9]), U6 = p13(I7, L6, v9, m6, O5, t19[o$31[g9]], l$13[2], c$15[g9])) : g9 < 64 ? (y8 = w5(s19, h15, _11, r26, u22, t19[n$22[g9]], a$22[3], f$32[g9]), U6 = k6(I7, L6, v9, m6, O5, t19[o$31[g9]], l$13[3], c$15[g9])) : (y8 = E7(s19, h15, _11, r26, u22, t19[n$22[g9]], a$22[4], f$32[g9]), U6 = d12(I7, L6, v9, m6, O5, t19[o$31[g9]], l$13[4], c$15[g9])), s19 = u22, u22 = r26, r26 = b10(_11, 10), _11 = h15, h15 = y8, I7 = O5, O5 = m6, m6 = b10(v9, 10), v9 = L6, L6 = U6;
    }
    var x6 = this._b + _11 + m6 | 0;
    this._b = this._c + r26 + O5 | 0, this._c = this._d + u22 + I7 | 0, this._d = this._e + s19 + L6 | 0, this._e = this._a + h15 + v9 | 0, this._a = x6;
}, u$17.prototype._digest = function () {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t19 = h$14.alloc ? h$14.alloc(20) : new h$14(20);
    return t19.writeInt32LE(this._a, 0), t19.writeInt32LE(this._b, 4), t19.writeInt32LE(this._c, 8), t19.writeInt32LE(this._d, 12), t19.writeInt32LE(this._e, 16), t19;
};
var I7 = u$17;
var s$13 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global,
        h$21 = u14.Buffer;

function e$32(t19, i37) {
    (this || s$13)._block = h$21.alloc(t19), (this || s$13)._finalSize = i37, (this || s$13)._blockSize = t19, (this || s$13)._len = 0;
}

e$32.prototype.update = function (t19, i37) {
    "string" == typeof t19 && (i37 = i37 || "utf8", t19 = h$21.from(t19, i37));
    for (var e18 = (this || s$13)._block, _11 = (this || s$13)._blockSize, n31 = t19.length, r26 = (this || s$13)._len, o28 = 0; o28 < n31;) {
        for (var f21 = r26 % _11, l26 = Math.min(n31 - o28, _11 - f21), a31 = 0; a31 < l26; a31++) {
            e18[f21 + a31] = t19[o28 + a31];
        }
        o28 += l26, (r26 += l26) % _11 == 0 && this._update(e18);
    }
    return (this || s$13)._len += n31, this || s$13;
}, e$32.prototype.digest = function (t19) {
    var i37 = (this || s$13)._len % (this || s$13)._blockSize;
    (this || s$13)._block[i37] = 128, (this || s$13)._block.fill(0, i37 + 1), i37 >= (this || s$13)._finalSize && (this._update((this || s$13)._block), (this || s$13)._block.fill(0));
    var h15 = 8 * (this || s$13)._len;
    if (h15 <= 4294967295) {
        (this || s$13)._block.writeUInt32BE(h15, (this || s$13)._blockSize - 4);
    } else {
        var e18 = (4294967295 & h15) >>> 0, _11 = (h15 - e18) / 4294967296;
        (this || s$13)._block.writeUInt32BE(_11, (this || s$13)._blockSize - 8), (this || s$13)._block.writeUInt32BE(e18, (this || s$13)._blockSize - 4);
    }
    this._update((this || s$13)._block);
    var n31 = this._hash();
    return t19 ? n31.toString(t19) : n31;
}, e$32.prototype._update = function () {
    throw new Error("_update must be implemented by subclass");
};
var _$22 = e$32, n$31 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global,
        r$23 = t$2, o$41 = _$22, f$41 = u14.Buffer, l$22 = [
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
        ], a$31 = new Array(64);

function u$23() {
    this.init(), (this || n$31)._w = a$31, o$41.call(this || n$31, 64, 56);
}

function c$23(t19, i37, s19) {
    return s19 ^ t19 & (i37 ^ s19);
}

function b$13(t19, i37, s19) {
    return t19 & i37 | s19 & (t19 | i37);
}

function p$13(t19) {
    return (t19 >>> 2 | t19 << 30) ^ (t19 >>> 13 | t19 << 19) ^ (t19 >>> 22 | t19 << 10);
}

function d$12(t19) {
    return (t19 >>> 6 | t19 << 26) ^ (t19 >>> 11 | t19 << 21) ^ (t19 >>> 25 | t19 << 7);
}

function k$12(t19) {
    return (t19 >>> 7 | t19 << 25) ^ (t19 >>> 18 | t19 << 14) ^ t19 >>> 3;
}

r$23(u$23, o$41), u$23.prototype.init = function () {
    return (this || n$31)._a = 1779033703, (this || n$31)._b = 3144134277, (this || n$31)._c = 1013904242, (this || n$31)._d = 2773480762, (this || n$31)._e = 1359893119, (this || n$31)._f = 2600822924, (this || n$31)._g = 528734635, (this || n$31)._h = 1541459225, this || n$31;
}, u$23.prototype._update = function (t19) {
    for (var i37, s19 = (this || n$31)._w, h15 = 0 | (this || n$31)._a, e19 = 0 | (this || n$31)._b, _12 = 0 | (this || n$31)._c, r26 = 0 | (this || n$31)._d, o28 = 0 | (this || n$31)._e, f22 = 0 | (this || n$31)._f, a32 = 0 | (this || n$31)._g, u22 = 0 | (this || n$31)._h, w6 = 0; w6 < 16; ++w6) {
        s19[w6] = t19.readInt32BE(4 * w6);
    }
    for (; w6 < 64; ++w6) {
        s19[w6] = 0 | (((i37 = s19[w6 - 2]) >>> 17 | i37 << 15) ^ (i37 >>> 19 | i37 << 13) ^ i37 >>> 10) + s19[w6 - 7] + k$12(s19[w6 - 15]) + s19[w6 - 16];
    }
    for (var g9 = 0; g9 < 64; ++g9) {
        var B6 = u22 + d$12(o28) + c$23(o28, f22, a32) + l$22[g9] + s19[g9] | 0,
                v9 = p$13(h15) + b$13(h15, e19, _12) | 0;
        u22 = a32, a32 = f22, f22 = o28, o28 = r26 + B6 | 0, r26 = _12, _12 = e19, e19 = h15, h15 = B6 + v9 | 0;
    }
    (this || n$31)._a = h15 + (this || n$31)._a | 0, (this || n$31)._b = e19 + (this || n$31)._b | 0, (this || n$31)._c = _12 + (this || n$31)._c | 0, (this || n$31)._d = r26 + (this || n$31)._d | 0, (this || n$31)._e = o28 + (this || n$31)._e | 0, (this || n$31)._f = f22 + (this || n$31)._f | 0, (this || n$31)._g = a32 + (this || n$31)._g | 0, (this || n$31)._h = u22 + (this || n$31)._h | 0;
}, u$23.prototype._hash = function () {
    var t19 = f$41.allocUnsafe(32);
    return t19.writeInt32BE((this || n$31)._a, 0), t19.writeInt32BE((this || n$31)._b, 4), t19.writeInt32BE((this || n$31)._c, 8), t19.writeInt32BE((this || n$31)._d, 12), t19.writeInt32BE((this || n$31)._e, 16), t19.writeInt32BE((this || n$31)._f, 20), t19.writeInt32BE((this || n$31)._g, 24), t19.writeInt32BE((this || n$31)._h, 28), t19;
};
var w$13 = u$23;
var _$31 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, e$42 = t$2,
        n$41 = _$22, r$33 = u14.Buffer, l$31 = [
            1518500249,
            1859775393,
            -1894007588,
            -899497514
        ], o$51 = new Array(80);

function f$51() {
    this.init(), (this || _$31)._w = o$51, n$41.call(this || _$31, 64, 56);
}

function a$41(t19) {
    return t19 << 30 | t19 >>> 2;
}

function u$31(t19, i37, h15, s19) {
    return 0 === t19 ? i37 & h15 | ~i37 & s19 : 2 === t19 ? i37 & h15 | i37 & s19 | h15 & s19 : i37 ^ h15 ^ s19;
}

e$42(f$51, n$41), f$51.prototype.init = function () {
    return (this || _$31)._a = 1732584193, (this || _$31)._b = 4023233417, (this || _$31)._c = 2562383102, (this || _$31)._d = 271733878, (this || _$31)._e = 3285377520, this || _$31;
}, f$51.prototype._update = function (t19) {
    for (var i37, h15 = (this || _$31)._w, s19 = 0 | (this || _$31)._a, e19 = 0 | (this || _$31)._b, n31 = 0 | (this || _$31)._c, r26 = 0 | (this || _$31)._d, o28 = 0 | (this || _$31)._e, f22 = 0; f22 < 16; ++f22) {
        h15[f22] = t19.readInt32BE(4 * f22);
    }
    for (; f22 < 80; ++f22) {
        h15[f22] = h15[f22 - 3] ^ h15[f22 - 8] ^ h15[f22 - 14] ^ h15[f22 - 16];
    }
    for (var c16 = 0; c16 < 80; ++c16) {
        var d13 = ~~(c16 / 20),
                p14 = 0 | ((i37 = s19) << 5 | i37 >>> 27) + u$31(d13, e19, n31, r26) + o28 + h15[c16] + l$31[d13];
        o28 = r26, r26 = n31, n31 = a$41(e19), e19 = s19, s19 = p14;
    }
    (this || _$31)._a = s19 + (this || _$31)._a | 0, (this || _$31)._b = e19 + (this || _$31)._b | 0, (this || _$31)._c = n31 + (this || _$31)._c | 0, (this || _$31)._d = r26 + (this || _$31)._d | 0, (this || _$31)._e = o28 + (this || _$31)._e | 0;
}, f$51.prototype._hash = function () {
    var t19 = r$33.allocUnsafe(20);
    return t19.writeInt32BE(0 | (this || _$31)._a, 0), t19.writeInt32BE(0 | (this || _$31)._b, 4), t19.writeInt32BE(0 | (this || _$31)._c, 8), t19.writeInt32BE(0 | (this || _$31)._d, 12), t19.writeInt32BE(0 | (this || _$31)._e, 16), t19;
};
var c$31 = f$51, d$21 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global,
        p$23 = t$2, b$2 = _$22, w$21 = u14.Buffer, g9 = [
            1518500249,
            1859775393,
            -1894007588,
            -899497514
        ], B7 = new Array(80);

function y9() {
    this.init(), (this || d$21)._w = B7, b$2.call(this || d$21, 64, 56);
}

function E$12(t19) {
    return t19 << 5 | t19 >>> 27;
}

function I$12(t19) {
    return t19 << 30 | t19 >>> 2;
}

function v10(t19, i37, h15, s19) {
    return 0 === t19 ? i37 & h15 | ~i37 & s19 : 2 === t19 ? i37 & h15 | i37 & s19 | h15 & s19 : i37 ^ h15 ^ s19;
}

p$23(y9, b$2), y9.prototype.init = function () {
    return (this || d$21)._a = 1732584193, (this || d$21)._b = 4023233417, (this || d$21)._c = 2562383102, (this || d$21)._d = 271733878, (this || d$21)._e = 3285377520, this || d$21;
}, y9.prototype._update = function (t19) {
    for (var i37, h15 = (this || d$21)._w, s19 = 0 | (this || d$21)._a, _12 = 0 | (this || d$21)._b, e19 = 0 | (this || d$21)._c, n31 = 0 | (this || d$21)._d, r26 = 0 | (this || d$21)._e, l27 = 0; l27 < 16; ++l27) {
        h15[l27] = t19.readInt32BE(4 * l27);
    }
    for (; l27 < 80; ++l27) {
        h15[l27] = (i37 = h15[l27 - 3] ^ h15[l27 - 8] ^ h15[l27 - 14] ^ h15[l27 - 16]) << 1 | i37 >>> 31;
    }
    for (var o28 = 0; o28 < 80; ++o28) {
        var f22 = ~~(o28 / 20), a32 = E$12(s19) + v10(f22, _12, e19, n31) + r26 + h15[o28] + g9[f22] | 0;
        r26 = n31, n31 = e19, e19 = I$12(_12), _12 = s19, s19 = a32;
    }
    (this || d$21)._a = s19 + (this || d$21)._a | 0, (this || d$21)._b = _12 + (this || d$21)._b | 0, (this || d$21)._c = e19 + (this || d$21)._c | 0, (this || d$21)._d = n31 + (this || d$21)._d | 0, (this || d$21)._e = r26 + (this || d$21)._e | 0;
}, y9.prototype._hash = function () {
    var t19 = w$21.allocUnsafe(20);
    return t19.writeInt32BE(0 | (this || d$21)._a, 0), t19.writeInt32BE(0 | (this || d$21)._b, 4), t19.writeInt32BE(0 | (this || d$21)._c, 8), t19.writeInt32BE(0 | (this || d$21)._d, 12), t19.writeInt32BE(0 | (this || d$21)._e, 16), t19;
};
var T8 = y9, m6 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, A5 = t$2,
        U7 = w$13, x6 = _$22, j5 = u14.Buffer, q5 = new Array(64);

function C6() {
    this.init(), (this || m6)._w = q5, x6.call(this || m6, 64, 56);
}

A5(C6, U7), C6.prototype.init = function () {
    return (this || m6)._a = 3238371032, (this || m6)._b = 914150663, (this || m6)._c = 812702999, (this || m6)._d = 4144912697, (this || m6)._e = 4290775857, (this || m6)._f = 1750603025, (this || m6)._g = 1694076839, (this || m6)._h = 3204075428, this || m6;
}, C6.prototype._hash = function () {
    var t19 = j5.allocUnsafe(28);
    return t19.writeInt32BE((this || m6)._a, 0), t19.writeInt32BE((this || m6)._b, 4), t19.writeInt32BE((this || m6)._c, 8), t19.writeInt32BE((this || m6)._d, 12), t19.writeInt32BE((this || m6)._e, 16), t19.writeInt32BE((this || m6)._f, 20), t19.writeInt32BE((this || m6)._g, 24), t19;
};
var L6 = C6, k$21 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global,
        z6 = t$2, D6 = _$22, F6 = u14.Buffer, G5 = [
            1116352408,
            3609767458,
            1899447441,
            602891725,
            3049323471,
            3964484399,
            3921009573,
            2173295548,
            961987163,
            4081628472,
            1508970993,
            3053834265,
            2453635748,
            2937671579,
            2870763221,
            3664609560,
            3624381080,
            2734883394,
            310598401,
            1164996542,
            607225278,
            1323610764,
            1426881987,
            3590304994,
            1925078388,
            4068182383,
            2162078206,
            991336113,
            2614888103,
            633803317,
            3248222580,
            3479774868,
            3835390401,
            2666613458,
            4022224774,
            944711139,
            264347078,
            2341262773,
            604807628,
            2007800933,
            770255983,
            1495990901,
            1249150122,
            1856431235,
            1555081692,
            3175218132,
            1996064986,
            2198950837,
            2554220882,
            3999719339,
            2821834349,
            766784016,
            2952996808,
            2566594879,
            3210313671,
            3203337956,
            3336571891,
            1034457026,
            3584528711,
            2466948901,
            113926993,
            3758326383,
            338241895,
            168717936,
            666307205,
            1188179964,
            773529912,
            1546045734,
            1294757372,
            1522805485,
            1396182291,
            2643833823,
            1695183700,
            2343527390,
            1986661051,
            1014477480,
            2177026350,
            1206759142,
            2456956037,
            344077627,
            2730485921,
            1290863460,
            2820302411,
            3158454273,
            3259730800,
            3505952657,
            3345764771,
            106217008,
            3516065817,
            3606008344,
            3600352804,
            1432725776,
            4094571909,
            1467031594,
            275423344,
            851169720,
            430227734,
            3100823752,
            506948616,
            1363258195,
            659060556,
            3750685593,
            883997877,
            3785050280,
            958139571,
            3318307427,
            1322822218,
            3812723403,
            1537002063,
            2003034995,
            1747873779,
            3602036899,
            1955562222,
            1575990012,
            2024104815,
            1125592928,
            2227730452,
            2716904306,
            2361852424,
            442776044,
            2428436474,
            593698344,
            2756734187,
            3733110249,
            3204031479,
            2999351573,
            3329325298,
            3815920427,
            3391569614,
            3928383900,
            3515267271,
            566280711,
            3940187606,
            3454069534,
            4118630271,
            4000239992,
            116418474,
            1914138554,
            174292421,
            2731055270,
            289380356,
            3203993006,
            460393269,
            320620315,
            685471733,
            587496836,
            852142971,
            1086792851,
            1017036298,
            365543100,
            1126000580,
            2618297676,
            1288033470,
            3409855158,
            1501505948,
            4234509866,
            1607167915,
            987167468,
            1816402316,
            1246189591
        ], H4 = new Array(160);

function J5() {
    this.init(), (this || k$21)._w = H4, D6.call(this || k$21, 128, 112);
}

function K4(t19, i37, h15) {
    return h15 ^ t19 & (i37 ^ h15);
}

function M6(t19, i37, h15) {
    return t19 & i37 | h15 & (t19 | i37);
}

function N6(t19, i37) {
    return (t19 >>> 28 | i37 << 4) ^ (i37 >>> 2 | t19 << 30) ^ (i37 >>> 7 | t19 << 25);
}

function O5(t19, i37) {
    return (t19 >>> 14 | i37 << 18) ^ (t19 >>> 18 | i37 << 14) ^ (i37 >>> 9 | t19 << 23);
}

function P7(t19, i37) {
    return (t19 >>> 1 | i37 << 31) ^ (t19 >>> 8 | i37 << 24) ^ t19 >>> 7;
}

function Q5(t19, i37) {
    return (t19 >>> 1 | i37 << 31) ^ (t19 >>> 8 | i37 << 24) ^ (t19 >>> 7 | i37 << 25);
}

function R6(t19, i37) {
    return (t19 >>> 19 | i37 << 13) ^ (i37 >>> 29 | t19 << 3) ^ t19 >>> 6;
}

function S5(t19, i37) {
    return (t19 >>> 19 | i37 << 13) ^ (i37 >>> 29 | t19 << 3) ^ (t19 >>> 6 | i37 << 26);
}

function V4(t19, i37) {
    return t19 >>> 0 < i37 >>> 0 ? 1 : 0;
}

z6(J5, D6), J5.prototype.init = function () {
    return (this || k$21)._ah = 1779033703, (this || k$21)._bh = 3144134277, (this || k$21)._ch = 1013904242, (this || k$21)._dh = 2773480762, (this || k$21)._eh = 1359893119, (this || k$21)._fh = 2600822924, (this || k$21)._gh = 528734635, (this || k$21)._hh = 1541459225, (this || k$21)._al = 4089235720, (this || k$21)._bl = 2227873595, (this || k$21)._cl = 4271175723, (this || k$21)._dl = 1595750129, (this || k$21)._el = 2917565137, (this || k$21)._fl = 725511199, (this || k$21)._gl = 4215389547, (this || k$21)._hl = 327033209, this || k$21;
}, J5.prototype._update = function (t19) {
    for (var i37 = (this || k$21)._w, h15 = 0 | (this || k$21)._ah, s19 = 0 | (this || k$21)._bh, _12 = 0 | (this || k$21)._ch, e19 = 0 | (this || k$21)._dh, n31 = 0 | (this || k$21)._eh, r26 = 0 | (this || k$21)._fh, l27 = 0 | (this || k$21)._gh, o28 = 0 | (this || k$21)._hh, f23 = 0 | (this || k$21)._al, a33 = 0 | (this || k$21)._bl, u22 = 0 | (this || k$21)._cl, c16 = 0 | (this || k$21)._dl, d14 = 0 | (this || k$21)._el, p15 = 0 | (this || k$21)._fl, b11 = 0 | (this || k$21)._gl, w6 = 0 | (this || k$21)._hl, g10 = 0; g10 < 32; g10 += 2) {
        i37[g10] = t19.readInt32BE(4 * g10), i37[g10 + 1] = t19.readInt32BE(4 * g10 + 4);
    }
    for (; g10 < 160; g10 += 2) {
        var B8 = i37[g10 - 30], y10 = i37[g10 - 30 + 1], E8 = P7(B8, y10), I8 = Q5(y10, B8),
                v11 = R6(B8 = i37[g10 - 4], y10 = i37[g10 - 4 + 1]), T9 = S5(y10, B8), m7 = i37[g10 - 14],
                A6 = i37[g10 - 14 + 1], U8 = i37[g10 - 32], x7 = i37[g10 - 32 + 1], j6 = I8 + A6 | 0,
                q6 = E8 + m7 + V4(j6, I8) | 0;
        q6 = (q6 = q6 + v11 + V4(j6 = j6 + T9 | 0, T9) | 0) + U8 + V4(j6 = j6 + x7 | 0, x7) | 0, i37[g10] = q6, i37[g10 + 1] = j6;
    }
    for (var C7 = 0; C7 < 160; C7 += 2) {
        q6 = i37[C7], j6 = i37[C7 + 1];
        var L7 = M6(h15, s19, _12), z7 = M6(f23, a33, u22), D7 = N6(h15, f23), F7 = N6(f23, h15), H5 = O5(n31, d14),
                J6 = O5(d14, n31), W5 = G5[C7], X4 = G5[C7 + 1], Y5 = K4(n31, r26, l27), Z5 = K4(d14, p15, b11),
                $5 = w6 + J6 | 0, tt2 = o28 + H5 + V4($5, w6) | 0;
        tt2 = (tt2 = (tt2 = tt2 + Y5 + V4($5 = $5 + Z5 | 0, Z5) | 0) + W5 + V4($5 = $5 + X4 | 0, X4) | 0) + q6 + V4($5 = $5 + j6 | 0, j6) | 0;
        var it1 = F7 + z7 | 0, ht = D7 + L7 + V4(it1, F7) | 0;
        o28 = l27, w6 = b11, l27 = r26, b11 = p15, r26 = n31, p15 = d14, n31 = e19 + tt2 + V4(d14 = c16 + $5 | 0, c16) | 0, e19 = _12, c16 = u22, _12 = s19, u22 = a33, s19 = h15, a33 = f23, h15 = tt2 + ht + V4(f23 = $5 + it1 | 0, $5) | 0;
    }
    (this || k$21)._al = (this || k$21)._al + f23 | 0, (this || k$21)._bl = (this || k$21)._bl + a33 | 0, (this || k$21)._cl = (this || k$21)._cl + u22 | 0, (this || k$21)._dl = (this || k$21)._dl + c16 | 0, (this || k$21)._el = (this || k$21)._el + d14 | 0, (this || k$21)._fl = (this || k$21)._fl + p15 | 0, (this || k$21)._gl = (this || k$21)._gl + b11 | 0, (this || k$21)._hl = (this || k$21)._hl + w6 | 0, (this || k$21)._ah = (this || k$21)._ah + h15 + V4((this || k$21)._al, f23) | 0, (this || k$21)._bh = (this || k$21)._bh + s19 + V4((this || k$21)._bl, a33) | 0, (this || k$21)._ch = (this || k$21)._ch + _12 + V4((this || k$21)._cl, u22) | 0, (this || k$21)._dh = (this || k$21)._dh + e19 + V4((this || k$21)._dl, c16) | 0, (this || k$21)._eh = (this || k$21)._eh + n31 + V4((this || k$21)._el, d14) | 0, (this || k$21)._fh = (this || k$21)._fh + r26 + V4((this || k$21)._fl, p15) | 0, (this || k$21)._gh = (this || k$21)._gh + l27 + V4((this || k$21)._gl, b11) | 0, (this || k$21)._hh = (this || k$21)._hh + o28 + V4((this || k$21)._hl, w6) | 0;
}, J5.prototype._hash = function () {
    var t19 = F6.allocUnsafe(64);

    function i37(i38, h15, s19) {
        t19.writeInt32BE(i38, s19), t19.writeInt32BE(h15, s19 + 4);
    }

    return i37((this || k$21)._ah, (this || k$21)._al, 0), i37((this || k$21)._bh, (this || k$21)._bl, 8), i37((this || k$21)._ch, (this || k$21)._cl, 16), i37((this || k$21)._dh, (this || k$21)._dl, 24), i37((this || k$21)._eh, (this || k$21)._el, 32), i37((this || k$21)._fh, (this || k$21)._fl, 40), i37((this || k$21)._gh, (this || k$21)._gl, 48), i37((this || k$21)._hh, (this || k$21)._hl, 56), t19;
};
var W6 = J5, X5 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, Y6 = t$2,
        Z6 = W6, $6 = _$22, tt3 = u14.Buffer, it2 = new Array(160);

function ht() {
    this.init(), (this || X5)._w = it2, $6.call(this || X5, 128, 112);
}

Y6(ht, Z6), ht.prototype.init = function () {
    return (this || X5)._ah = 3418070365, (this || X5)._bh = 1654270250, (this || X5)._ch = 2438529370, (this || X5)._dh = 355462360, (this || X5)._eh = 1731405415, (this || X5)._fh = 2394180231, (this || X5)._gh = 3675008525, (this || X5)._hh = 1203062813, (this || X5)._al = 3238371032, (this || X5)._bl = 914150663, (this || X5)._cl = 812702999, (this || X5)._dl = 4144912697, (this || X5)._el = 4290775857, (this || X5)._fl = 1750603025, (this || X5)._gl = 1694076839, (this || X5)._hl = 3204075428, this || X5;
}, ht.prototype._hash = function () {
    var t19 = tt3.allocUnsafe(48);

    function i37(i38, h15, s19) {
        t19.writeInt32BE(i38, s19), t19.writeInt32BE(h15, s19 + 4);
    }

    return i37((this || X5)._ah, (this || X5)._al, 0), i37((this || X5)._bh, (this || X5)._bl, 8), i37((this || X5)._ch, (this || X5)._cl, 16), i37((this || X5)._dh, (this || X5)._dl, 24), i37((this || X5)._eh, (this || X5)._el, 32), i37((this || X5)._fh, (this || X5)._fl, 40), t19;
};
var st1, _t = ht, et2 = {
    exports: st1 = {}
};
(st1 = et2.exports = function (t19) {
    t19 = t19.toLowerCase();
    var i37 = st1[t19];
    if (!i37) {
        throw new Error(t19 + " is not supported (we accept pull requests)");
    }
    return new i37;
}).sha = c$31, st1.sha1 = T8, st1.sha224 = L6, st1.sha256 = w$13, st1.sha384 = _t, st1.sha512 = W6;
var nt1 = et2.exports;
var e$51 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global,
        n$51 = u14.Buffer, s$21 = b7.Transform, h$3 = e$13.StringDecoder;

function a$51(t19) {
    s$21.call(this || e$51), (this || e$51).hashMode = "string" == typeof t19, (this || e$51).hashMode ? (this || e$51)[t19] = (this || e$51)._finalOrDigest : (this || e$51).final = (this || e$51)._finalOrDigest, (this || e$51)._final && ((this || e$51).__final = (this || e$51)._final, (this || e$51)._final = null), (this || e$51)._decoder = null, (this || e$51)._encoding = null;
}

t$2(a$51, s$21), a$51.prototype.update = function (t19, i37, r26) {
    "string" == typeof t19 && (t19 = n$51.from(t19, i37));
    var o28 = this._update(t19);
    return (this || e$51).hashMode ? this || e$51 : (r26 && (o28 = this._toString(o28, r26)), o28);
}, a$51.prototype.setAutoPadding = function () {
}, a$51.prototype.getAuthTag = function () {
    throw new Error("trying to get auth tag in unsupported state");
}, a$51.prototype.setAuthTag = function () {
    throw new Error("trying to set auth tag in unsupported state");
}, a$51.prototype.setAAD = function () {
    throw new Error("trying to set aad in unsupported state");
}, a$51.prototype._transform = function (t19, i37, r26) {
    var o28;
    try {
        (this || e$51).hashMode ? this._update(t19) : this.push(this._update(t19));
    } catch (t20) {
        o28 = t20;
    } finally {
        r26(o28);
    }
}, a$51.prototype._flush = function (t19) {
    var i37;
    try {
        this.push(this.__final());
    } catch (t20) {
        i37 = t20;
    }
    t19(i37);
}, a$51.prototype._finalOrDigest = function (t19) {
    var i37 = this.__final() || n$51.alloc(0);
    return t19 && (i37 = this._toString(i37, t19, !0)), i37;
}, a$51.prototype._toString = function (t19, i37, r26) {
    if ((this || e$51)._decoder || ((this || e$51)._decoder = new h$3(i37), (this || e$51)._encoding = i37), (this || e$51)._encoding !== i37) {
        throw new Error("can't switch encodings");
    }
    var o28 = (this || e$51)._decoder.write(t19);
    return r26 && (o28 += (this || e$51)._decoder.end()), o28;
};
var f$61 = a$51;
var m$14 = u20, n$6 = I7, p$32 = nt1, s$31 = f$61;

function a$61(t19) {
    s$31.call(this, "digest"), this._hash = t19;
}

t$2(a$61, s$31), a$61.prototype._update = function (t19) {
    this._hash.update(t19);
}, a$61.prototype._final = function () {
    return this._hash.digest();
};
var h$4 = function (t19) {
    return "md5" === (t19 = t19.toLowerCase()) ? new m$14 : "rmd160" === t19 || "ripemd160" === t19 ? new n$6 : new a$61(p$32(t19));
};
var e$6 = u20, r$42 = function (t19) {
    return (new e$6).update(t19).digest();
};
var o$61 = t$2, h$5 = u14.Buffer, n$7 = f$61, p$4 = h$5.alloc(128);

function f$7(t19, a33) {
    n$7.call(this, "digest"), "string" == typeof a33 && (a33 = h$5.from(a33)), this._alg = t19, this._key = a33, a33.length > 64 ? a33 = t19(a33) : a33.length < 64 && (a33 = h$5.concat([
        a33,
        p$4
    ], 64));
    for (var e19 = this._ipad = h$5.allocUnsafe(64), i37 = this._opad = h$5.allocUnsafe(64), r26 = 0; r26 < 64; r26++) {
        e19[r26] = 54 ^ a33[r26], i37[r26] = 92 ^ a33[r26];
    }
    this._hash = [
        e19
    ];
}

o$61(f$7, n$7), f$7.prototype._update = function (t19) {
    this._hash.push(t19);
}, f$7.prototype._final = function () {
    var t19 = this._alg(h$5.concat(this._hash));
    return this._alg(h$5.concat([
        this._opad,
        t19
    ]));
};
var l$41 = t$2, d$3 = f$7, c$41 = f$61, _$4 = u14.Buffer, m$24 = r$42, u$41 = I7, g$13 = nt1, v$14 = _$4.alloc(128);

function y$13(t19, a33) {
    c$41.call(this, "digest"), "string" == typeof a33 && (a33 = _$4.from(a33));
    var e19 = "sha512" === t19 || "sha384" === t19 ? 128 : 64;
    (this._alg = t19, this._key = a33, a33.length > e19) ? a33 = ("rmd160" === t19 ? new u$41 : g$13(t19)).update(a33).digest() : a33.length < e19 && (a33 = _$4.concat([
        a33,
        v$14
    ], e19));
    for (var i37 = this._ipad = _$4.allocUnsafe(e19), r26 = this._opad = _$4.allocUnsafe(e19), s19 = 0; s19 < e19; s19++) {
        i37[s19] = 54 ^ a33[s19], r26[s19] = 92 ^ a33[s19];
    }
    this._hash = "rmd160" === t19 ? new u$41 : g$13(t19), this._hash.update(i37);
}

l$41(y$13, c$41), y$13.prototype._update = function (t19) {
    this._hash.update(t19);
}, y$13.prototype._final = function () {
    var t19 = this._hash.digest();
    return ("rmd160" === this._alg ? new u$41 : g$13(this._alg)).update(this._opad).update(t19).digest();
};
var w$3 = function (t19, a33) {
    return "rmd160" === (t19 = t19.toLowerCase()) || "ripemd160" === t19 ? new y$13("rmd160", a33) : "md5" === t19 ? new d$3(m$24, a33) : new y$13(t19, a33);
};
var s$4 = {
    sha224WithRSAEncryption: {
        sign: "rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
    },
    "RSA-SHA224": {
        sign: "ecdsa/rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
    },
    sha256WithRSAEncryption: {
        sign: "rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
    },
    "RSA-SHA256": {
        sign: "ecdsa/rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
    },
    sha384WithRSAEncryption: {
        sign: "rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
    },
    "RSA-SHA384": {
        sign: "ecdsa/rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
    },
    sha512WithRSAEncryption: {
        sign: "rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
    },
    "RSA-SHA512": {
        sign: "ecdsa/rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
    },
    "RSA-SHA1": {
        sign: "rsa",
        hash: "sha1",
        id: "3021300906052b0e03021a05000414"
    },
    "ecdsa-with-SHA1": {
        sign: "ecdsa",
        hash: "sha1",
        id: ""
    },
    sha256: {
        sign: "ecdsa",
        hash: "sha256",
        id: ""
    },
    sha224: {
        sign: "ecdsa",
        hash: "sha224",
        id: ""
    },
    sha384: {
        sign: "ecdsa",
        hash: "sha384",
        id: ""
    },
    sha512: {
        sign: "ecdsa",
        hash: "sha512",
        id: ""
    },
    "DSA-SHA": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    "DSA-SHA1": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    DSA: {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    "DSA-WITH-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-WITH-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-WITH-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-WITH-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-RIPEMD160": {
        sign: "dsa",
        hash: "rmd160",
        id: ""
    },
    ripemd160WithRSA: {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
    },
    "RSA-RIPEMD160": {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
    },
    md5WithRSAEncryption: {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
    },
    "RSA-MD5": {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
    }
};
var f$8 = e$1.Buffer, a$7 = Math.pow(2, 30) - 1;

function s$5(r26, e19) {
    if ("string" != typeof r26 && !f$8.isBuffer(r26)) {
        throw new TypeError(e19 + " must be a buffer or string");
    }
}

var u$51, h$6 = function (r26, e19, t19, n31) {
    if ((s$5(r26, "Password"), s$5(e19, "Salt"), "number" != typeof t19)) {
        throw new TypeError("Iterations not a number");
    }
    if (t19 < 0) {
        throw new TypeError("Bad iterations");
    }
    if ("number" != typeof n31) {
        throw new TypeError("Key length not a number");
    }
    if (n31 < 0 || n31 > a$7 || n31 != n31) {
        throw new TypeError("Bad key length");
    }
}, c$5 = T1;
c$5.browser ? u$51 = "utf-8" : u$51 = parseInt(c$5.version.split(".")[0].slice(1), 10) >= 6 ? "utf-8" : "binary";
var l$51 = u$51, p$5 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global,
        d$4 = r$42, m$3 = I7, y$22 = nt1, b$3 = h$6, v$22 = l$51, w$4 = u14.Buffer, g$21 = w$4.alloc(128), B$12 = {
            md5: 16,
            sha1: 20,
            sha224: 28,
            sha256: 32,
            sha384: 48,
            sha512: 64,
            rmd160: 20,
            ripemd160: 20
        };

function T$12(r26, e19, t19) {
    var n31 = function (r27) {
        function e20(e21) {
            return y$22(r27).update(e21).digest();
        }

        return "rmd160" === r27 || "ripemd160" === r27 ? function (r28) {
            return (new m$3).update(r28).digest();
        } : "md5" === r27 ? d$4 : e20;
    }(r26), o28 = "sha512" === r26 || "sha384" === r26 ? 128 : 64;
    e19.length > o28 ? e19 = n31(e19) : e19.length < o28 && (e19 = w$4.concat([
        e19,
        g$21
    ], o28));
    for (var i37 = w$4.allocUnsafe(o28 + B$12[r26]), f23 = w$4.allocUnsafe(o28 + B$12[r26]), a33 = 0; a33 < o28; a33++) {
        i37[a33] = 54 ^ e19[a33], f23[a33] = 92 ^ e19[a33];
    }
    var s19 = w$4.allocUnsafe(o28 + t19 + 4);
    i37.copy(s19, 0, 0, o28), (this || p$5).ipad1 = s19, (this || p$5).ipad2 = i37, (this || p$5).opad = f23, (this || p$5).alg = r26, (this || p$5).blocksize = o28, (this || p$5).hash = n31, (this || p$5).size = B$12[r26];
}

T$12.prototype.run = function (r26, e19) {
    return r26.copy(e19, (this || p$5).blocksize), this.hash(e19).copy((this || p$5).opad, (this || p$5).blocksize), this.hash((this || p$5).opad);
};
var k$3, S$12 = function (r26, e19, t19, n31, o28) {
            b$3(r26, e19, t19, n31), w$4.isBuffer(r26) || (r26 = w$4.from(r26, v$22)), w$4.isBuffer(e19) || (e19 = w$4.from(e19, v$22));
            var i37 = new T$12(o28 = o28 || "sha1", r26, e19.length), f23 = w$4.allocUnsafe(n31),
                    a33 = w$4.allocUnsafe(e19.length + 4);
            e19.copy(a33, 0, 0, e19.length);
            for (var s19 = 0, u22 = B$12[o28], h15 = Math.ceil(n31 / u22), c16 = 1; c16 <= h15; c16++) {
                a33.writeUInt32BE(c16, e19.length);
                for (var l27 = i37.run(a33, i37.ipad1), p15 = l27, d14 = 1; d14 < t19; d14++) {
                    p15 = i37.run(p15, i37.ipad2);
                    for (var m8 = 0; m8 < u22; m8++) {
                        l27[m8] ^= p15[m8];
                    }
                }
                l27.copy(f23, s19), s19 += u22;
            }
            return f23;
        }, A$13 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, H$12 = T1,
        E$2 = h$6, P$13 = l$51, U$12 = S$12, K$12 = u14.Buffer, x$12 = A$13.crypto && A$13.crypto.subtle, z$12 = {
            sha: "SHA-1",
            "sha-1": "SHA-1",
            sha1: "SHA-1",
            sha256: "SHA-256",
            "sha-256": "SHA-256",
            sha384: "SHA-384",
            "sha-384": "SHA-384",
            "sha-512": "SHA-512",
            sha512: "SHA-512"
        }, I$2 = [];

function D$12(r26, e19, t19, n31, o28) {
    return x$12.importKey("raw", r26, {
        name: "PBKDF2"
    }, !1, [
        "deriveBits"
    ]).then(function (r27) {
        return x$12.deriveBits({
            name: "PBKDF2",
            salt: e19,
            iterations: t19,
            hash: {
                name: o28
            }
        }, r27, n31 << 3);
    }).then(function (r27) {
        return K$12.from(r27);
    });
}

var F$12 = function (r26, e19, t19, n31, o28, i37) {
    "function" == typeof o28 && (i37 = o28, o28 = void 0);
    var f23 = z$12[(o28 = o28 || "sha1").toLowerCase()];
    if (!f23 || "function" != typeof A$13.Promise) {
        return H$12.nextTick(function () {
            var f24;
            try {
                f24 = U$12(r26, e19, t19, n31, o28);
            } catch (r27) {
                return i37(r27);
            }
            i37(null, f24);
        });
    }
    if ((E$2(r26, e19, t19, n31), "function" != typeof i37)) {
        throw new Error("No callback provided to pbkdf2");
    }
    K$12.isBuffer(r26) || (r26 = K$12.from(r26, P$13)), K$12.isBuffer(e19) || (e19 = K$12.from(e19, P$13)), (function (r27, e20) {
        r27.then(function (r28) {
            H$12.nextTick(function () {
                e20(null, r28);
            });
        }, function (r28) {
            H$12.nextTick(function () {
                e20(r28);
            });
        });
    })((function (r27) {
        if (A$13.process && !A$13.process.browser) {
            return Promise.resolve(!1);
        }
        if (!x$12 || !x$12.importKey || !x$12.deriveBits) {
            return Promise.resolve(!1);
        }
        if ((void 0) !== I$2[r27]) {
            return I$2[r27];
        }
        var e20 = D$12(k$3 = k$3 || K$12.alloc(8), k$3, 10, 128, r27).then(function () {
            return !0;
        }).catch(function () {
            return !1;
        });
        return I$2[r27] = e20, e20;
    })(f23).then(function (i38) {
        return i38 ? D$12(r26, e19, t19, n31, f23) : U$12(r26, e19, t19, n31, o28);
    }), i37);
}, M$12 = {};
M$12.pbkdf2 = F$12, M$12.pbkdf2Sync = S$12;
var r$5;

function e$7(r26, e19) {
    if (!r26) {
        throw new Error(e19 || "Assertion failed");
    }
}

r$5 = e$7, e$7.equal = function (r26, e19, o28) {
    if (r26 != e19) {
        throw new Error(o28 || "Assertion failed: " + r26 + " != " + e19);
    }
};
var o$7 = r$5;
var r$6 = {
    readUInt32BE: function (t19, e19) {
        return (t19[0 + e19] << 24 | t19[1 + e19] << 16 | t19[2 + e19] << 8 | t19[3 + e19]) >>> 0;
    },
    writeUInt32BE: function (t19, e19, r26) {
        t19[0 + r26] = e19 >>> 24, t19[1 + r26] = e19 >>> 16 & 255, t19[2 + r26] = e19 >>> 8 & 255, t19[3 + r26] = 255 & e19;
    },
    ip: function (t19, e19, r26, i37) {
        for (var n31 = 0, f23 = 0, o28 = 6; o28 >= 0; o28 -= 2) {
            for (var p16 = 0; p16 <= 24; p16 += 8) {
                n31 <<= 1, n31 |= e19 >>> p16 + o28 & 1;
            }
            for (p16 = 0; p16 <= 24; p16 += 8) {
                n31 <<= 1, n31 |= t19 >>> p16 + o28 & 1;
            }
        }
        for (o28 = 6; o28 >= 0; o28 -= 2) {
            for (p16 = 1; p16 <= 25; p16 += 8) {
                f23 <<= 1, f23 |= e19 >>> p16 + o28 & 1;
            }
            for (p16 = 1; p16 <= 25; p16 += 8) {
                f23 <<= 1, f23 |= t19 >>> p16 + o28 & 1;
            }
        }
        r26[i37 + 0] = n31 >>> 0, r26[i37 + 1] = f23 >>> 0;
    },
    rip: function (t19, e19, r26, i37) {
        for (var n31 = 0, f23 = 0, o28 = 0; o28 < 4; o28++) {
            for (var p17 = 24; p17 >= 0; p17 -= 8) {
                n31 <<= 1, n31 |= e19 >>> p17 + o28 & 1, n31 <<= 1, n31 |= t19 >>> p17 + o28 & 1;
            }
        }
        for (o28 = 4; o28 < 8; o28++) {
            for (p17 = 24; p17 >= 0; p17 -= 8) {
                f23 <<= 1, f23 |= e19 >>> p17 + o28 & 1, f23 <<= 1, f23 |= t19 >>> p17 + o28 & 1;
            }
        }
        r26[i37 + 0] = n31 >>> 0, r26[i37 + 1] = f23 >>> 0;
    },
    pc1: function (t19, e19, r26, i37) {
        for (var n31 = 0, f23 = 0, o28 = 7; o28 >= 5; o28--) {
            for (var p17 = 0; p17 <= 24; p17 += 8) {
                n31 <<= 1, n31 |= e19 >> p17 + o28 & 1;
            }
            for (p17 = 0; p17 <= 24; p17 += 8) {
                n31 <<= 1, n31 |= t19 >> p17 + o28 & 1;
            }
        }
        for (p17 = 0; p17 <= 24; p17 += 8) {
            n31 <<= 1, n31 |= e19 >> p17 + o28 & 1;
        }
        for (o28 = 1; o28 <= 3; o28++) {
            for (p17 = 0; p17 <= 24; p17 += 8) {
                f23 <<= 1, f23 |= e19 >> p17 + o28 & 1;
            }
            for (p17 = 0; p17 <= 24; p17 += 8) {
                f23 <<= 1, f23 |= t19 >> p17 + o28 & 1;
            }
        }
        for (p17 = 0; p17 <= 24; p17 += 8) {
            f23 <<= 1, f23 |= t19 >> p17 + o28 & 1;
        }
        r26[i37 + 0] = n31 >>> 0, r26[i37 + 1] = f23 >>> 0;
    },
    r28shl: function (t19, e19) {
        return t19 << e19 & 268435455 | t19 >>> 28 - e19;
    }
}, i37 = [
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
];
r$6.pc2 = function (t19, e19, r26, n31) {
    for (var f23 = 0, o28 = 0, p18 = i37.length >>> 1, u22 = 0; u22 < p18; u22++) {
        f23 <<= 1, f23 |= t19 >>> i37[u22] & 1;
    }
    for (u22 = p18; u22 < i37.length; u22++) {
        o28 <<= 1, o28 |= e19 >>> i37[u22] & 1;
    }
    r26[n31 + 0] = f23 >>> 0, r26[n31 + 1] = o28 >>> 0;
}, r$6.expand = function (t19, e19, r26) {
    var i38 = 0, n31 = 0;
    i38 = (1 & t19) << 5 | t19 >>> 27;
    for (var f23 = 23; f23 >= 15; f23 -= 4) {
        i38 <<= 6, i38 |= t19 >>> f23 & 63;
    }
    for (f23 = 11; f23 >= 3; f23 -= 4) {
        n31 |= t19 >>> f23 & 63, n31 <<= 6;
    }
    n31 |= (31 & t19) << 1 | t19 >>> 31, e19[r26 + 0] = i38 >>> 0, e19[r26 + 1] = n31 >>> 0;
};
var n$8 = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
];
r$6.substitute = function (t19, e19) {
    for (var r26 = 0, i38 = 0; i38 < 4; i38++) {
        r26 <<= 4, r26 |= n$8[64 * i38 + (t19 >>> 18 - 6 * i38 & 63)];
    }
    for (i38 = 0; i38 < 4; i38++) {
        r26 <<= 4, r26 |= n$8[256 + 64 * i38 + (e19 >>> 18 - 6 * i38 & 63)];
    }
    return r26 >>> 0;
};
var f$9 = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
];
r$6.permute = function (t19) {
    for (var e19 = 0, r26 = 0; r26 < f$9.length; r26++) {
        e19 <<= 1, e19 |= t19 >>> f$9[r26] & 1;
    }
    return e19 >>> 0;
}, r$6.padSplit = function (t19, e19, r26) {
    for (var i38 = t19.toString(2); i38.length < e19;) {
        i38 = "0" + i38;
    }
    for (var n31 = [], f23 = 0; f23 < e19; f23 += r26) {
        n31.push(i38.slice(f23, f23 + r26));
    }
    return n31.join(" ");
};
var o$8, p$6 = o$7;

function u$6(t19) {
    this.options = t19, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
}

o$8 = u$6, u$6.prototype._init = function () {
}, u$6.prototype.update = function (t19) {
    return 0 === t19.length ? [] : "decrypt" === this.type ? this._updateDecrypt(t19) : this._updateEncrypt(t19);
}, u$6.prototype._buffer = function (t19, e19) {
    for (var r26 = Math.min(this.buffer.length - this.bufferOff, t19.length - e19), i38 = 0; i38 < r26; i38++) {
        this.buffer[this.bufferOff + i38] = t19[e19 + i38];
    }
    return this.bufferOff += r26, r26;
}, u$6.prototype._flushBuffer = function (t19, e19) {
    return this._update(this.buffer, 0, t19, e19), this.bufferOff = 0, this.blockSize;
}, u$6.prototype._updateEncrypt = function (t19) {
    var e19 = 0, r26 = 0, i38 = (this.bufferOff + t19.length) / this.blockSize | 0,
            n31 = new Array(i38 * this.blockSize);
    0 !== this.bufferOff && (e19 += this._buffer(t19, e19), this.bufferOff === this.buffer.length && (r26 += this._flushBuffer(n31, r26)));
    for (var f23 = t19.length - (t19.length - e19) % this.blockSize; e19 < f23; e19 += this.blockSize) {
        this._update(t19, e19, n31, r26), r26 += this.blockSize;
    }
    for (; e19 < t19.length; e19++, this.bufferOff++) {
        this.buffer[this.bufferOff] = t19[e19];
    }
    return n31;
}, u$6.prototype._updateDecrypt = function (t19) {
    for (var e19 = 0, r26 = 0, i38 = Math.ceil((this.bufferOff + t19.length) / this.blockSize) - 1, n31 = new Array(i38 * this.blockSize); i38 > 0; i38--) {
        e19 += this._buffer(t19, e19), r26 += this._flushBuffer(n31, r26);
    }
    return e19 += this._buffer(t19, e19), n31;
}, u$6.prototype.final = function (t19) {
    var e19, r26;
    return t19 && (e19 = this.update(t19)), r26 = "encrypt" === this.type ? this._finalEncrypt() : this._finalDecrypt(), e19 ? e19.concat(r26) : r26;
}, u$6.prototype._pad = function (t19, e19) {
    if (0 === e19) {
        return !1;
    }
    for (; e19 < t19.length;) {
        t19[e19++] = 0;
    }
    return !0;
}, u$6.prototype._finalEncrypt = function () {
    if (!this._pad(this.buffer, this.bufferOff)) {
        return [];
    }
    var t19 = new Array(this.blockSize);
    return this._update(this.buffer, 0, t19, 0), t19;
}, u$6.prototype._unpad = function (t19) {
    return t19;
}, u$6.prototype._finalDecrypt = function () {
    p$6.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var t19 = new Array(this.blockSize);
    return this._flushBuffer(t19, 0), this._unpad(t19);
};
var s$6, a$8 = o$8, h$7 = o$7, c$6 = r$6, l$61 = a$8;

function y$3() {
    this.tmp = new Array(2), this.keys = null;
}

function v$3(t19) {
    l$61.call(this, t19);
    var e19 = new y$3;
    this._desState = e19, this.deriveKeys(e19, t19.key);
}

t$2(v$3, l$61), s$6 = v$3, v$3.create = function (t19) {
    return new v$3(t19);
};
var d$5 = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
];
v$3.prototype.deriveKeys = function (t19, e19) {
    t19.keys = new Array(32), h$7.equal(e19.length, this.blockSize, "Invalid key length");
    var r26 = c$6.readUInt32BE(e19, 0), i38 = c$6.readUInt32BE(e19, 4);
    c$6.pc1(r26, i38, t19.tmp, 0), r26 = t19.tmp[0], i38 = t19.tmp[1];
    for (var n31 = 0; n31 < t19.keys.length; n31 += 2) {
        var f23 = d$5[n31 >>> 1];
        r26 = c$6.r28shl(r26, f23), i38 = c$6.r28shl(i38, f23), c$6.pc2(r26, i38, t19.keys, n31);
    }
}, v$3.prototype._update = function (t19, e19, r26, i38) {
    var n31 = this._desState, f24 = c$6.readUInt32BE(t19, e19), o28 = c$6.readUInt32BE(t19, e19 + 4);
    c$6.ip(f24, o28, n31.tmp, 0), f24 = n31.tmp[0], o28 = n31.tmp[1], "encrypt" === this.type ? this._encrypt(n31, f24, o28, n31.tmp, 0) : this._decrypt(n31, f24, o28, n31.tmp, 0), f24 = n31.tmp[0], o28 = n31.tmp[1], c$6.writeUInt32BE(r26, f24, i38), c$6.writeUInt32BE(r26, o28, i38 + 4);
}, v$3.prototype._pad = function (t19, e19) {
    for (var r26 = t19.length - e19, i38 = e19; i38 < t19.length; i38++) {
        t19[i38] = r26;
    }
    return !0;
}, v$3.prototype._unpad = function (t19) {
    for (var e19 = t19[t19.length - 1], r26 = t19.length - e19; r26 < t19.length; r26++) {
        h$7.equal(t19[r26], e19);
    }
    return t19.slice(0, t19.length - e19);
}, v$3.prototype._encrypt = function (t19, e19, r26, i38, n31) {
    for (var f24 = e19, o28 = r26, p18 = 0; p18 < t19.keys.length; p18 += 2) {
        var u22 = t19.keys[p18], s19 = t19.keys[p18 + 1];
        c$6.expand(o28, t19.tmp, 0), u22 ^= t19.tmp[0], s19 ^= t19.tmp[1];
        var a33 = c$6.substitute(u22, s19), h15 = o28;
        o28 = (f24 ^ c$6.permute(a33)) >>> 0, f24 = h15;
    }
    c$6.rip(o28, f24, i38, n31);
}, v$3.prototype._decrypt = function (t19, e19, r26, i38, n31) {
    for (var f24 = r26, o28 = e19, p18 = t19.keys.length - 2; p18 >= 0; p18 -= 2) {
        var u23 = t19.keys[p18], s20 = t19.keys[p18 + 1];
        c$6.expand(f24, t19.tmp, 0), u23 ^= t19.tmp[0], s20 ^= t19.tmp[1];
        var a34 = c$6.substitute(u23, s20), h16 = f24;
        f24 = (o28 ^ c$6.permute(a34)) >>> 0, o28 = h16;
    }
    c$6.rip(f24, o28, i38, n31);
};
var _$5 = s$6, b$4 = {}, k$4 = o$7, g$3 = t$2, m$4 = {};

function S$2(t19) {
    k$4.equal(t19.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var e19 = 0; e19 < this.iv.length; e19++) {
        this.iv[e19] = t19[e19];
    }
}

b$4.instantiate = function (t19) {
    function e19(e20) {
        t19.call(this, e20), this._cbcInit();
    }

    g$3(e19, t19);
    for (var r26 = Object.keys(m$4), i38 = 0; i38 < r26.length; i38++) {
        var n31 = r26[i38];
        e19.prototype[n31] = m$4[n31];
    }
    return e19.create = function (t20) {
        return new e19(t20);
    }, e19;
}, m$4._cbcInit = function () {
    var t19 = new S$2(this.options.iv);
    this._cbcState = t19;
}, m$4._update = function (t19, e19, r26, i38) {
    var n32 = this._cbcState, f24 = this.constructor.super_.prototype, o28 = n32.iv;
    if ("encrypt" === this.type) {
        for (var p18 = 0; p18 < this.blockSize; p18++) {
            o28[p18] ^= t19[e19 + p18];
        }
        f24._update.call(this, o28, 0, r26, i38);
        for (p18 = 0; p18 < this.blockSize; p18++) {
            o28[p18] = r26[i38 + p18];
        }
    } else {
        f24._update.call(this, t19, e19, r26, i38);
        for (p18 = 0; p18 < this.blockSize; p18++) {
            r26[i38 + p18] ^= o28[p18];
        }
        for (p18 = 0; p18 < this.blockSize; p18++) {
            o28[p18] = t19[e19 + p18];
        }
    }
};
var z$21, w$5 = o$7, E$3 = a$8, I$3 = _$5;

function O$12(t19, e19) {
    w$5.equal(e19.length, 24, "Invalid key length");
    var r26 = e19.slice(0, 8), i38 = e19.slice(8, 16), n32 = e19.slice(16, 24);
    this.ciphers = "encrypt" === t19 ? [
        I$3.create({
            type: "encrypt",
            key: r26
        }),
        I$3.create({
            type: "decrypt",
            key: i38
        }),
        I$3.create({
            type: "encrypt",
            key: n32
        })
    ] : [
        I$3.create({
            type: "decrypt",
            key: n32
        }),
        I$3.create({
            type: "encrypt",
            key: i38
        }),
        I$3.create({
            type: "decrypt",
            key: r26
        })
    ];
}

function B$2(t19) {
    E$3.call(this, t19);
    var e19 = new O$12(this.type, this.options.key);
    this._edeState = e19;
}

t$2(B$2, E$3), z$21 = B$2, B$2.create = function (t19) {
    return new B$2(t19);
}, B$2.prototype._update = function (t19, e19, r26, i38) {
    var n32 = this._edeState;
    n32.ciphers[0]._update(t19, e19, r26, i38), n32.ciphers[1]._update(r26, i38, r26, i38), n32.ciphers[2]._update(r26, i38, r26, i38);
}, B$2.prototype._pad = I$3.prototype._pad, B$2.prototype._unpad = I$3.prototype._unpad;
var A$2 = z$21, U$2 = {};
U$2.utils = r$6, U$2.Cipher = a$8, U$2.DES = _$5, U$2.CBC = b$4, U$2.EDE = A$2;
var d$6, i$15 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, f$a = f$61,
        o$9 = U$2, a$9 = t$2, c$7 = u14.Buffer, n$9 = {
            "des-ede3-cbc": o$9.CBC.instantiate(o$9.EDE),
            "des-ede3": o$9.EDE,
            "des-ede-cbc": o$9.CBC.instantiate(o$9.EDE),
            "des-ede": o$9.EDE,
            "des-cbc": o$9.CBC.instantiate(o$9.DES),
            "des-ecb": o$9.DES
        };

function p$7(e19) {
    f$a.call(this || i$15);
    var t19, r26 = e19.mode.toLowerCase(), s21 = n$9[r26];
    t19 = e19.decrypt ? "decrypt" : "encrypt";
    var d15 = e19.key;
    c$7.isBuffer(d15) || (d15 = c$7.from(d15)), "des-ede" !== r26 && "des-ede-cbc" !== r26 || (d15 = c$7.concat([
        d15,
        d15.slice(0, 8)
    ]));
    var o28 = e19.iv;
    c$7.isBuffer(o28) || (o28 = c$7.from(o28)), (this || i$15)._des = s21.create({
        key: d15,
        iv: o28,
        type: t19
    });
}

n$9.des = n$9["des-cbc"], n$9.des3 = n$9["des-ede3-cbc"], d$6 = p$7, a$9(p$7, f$a), p$7.prototype._update = function (e19) {
    return c$7.from((this || i$15)._des.update(e19));
}, p$7.prototype._final = function () {
    return c$7.from((this || i$15)._des.final());
};
var l$7 = d$6;
var e$8 = e$1.Buffer, f$b = function (r26, f24) {
    for (var t19 = Math.min(r26.length, f24.length), n32 = new e$8(t19), o28 = 0; o28 < t19; ++o28) {
        n32[o28] = r26[o28] ^ f24[o28];
    }
    return n32;
};
var t$14 = function (e19) {
    for (var c16, r26 = e19.length; r26--;) {
        if (255 !== (c16 = e19.readUInt8(r26))) {
            c16++, e19.writeUInt8(c16, r26);
            break;
        }
        e19.writeUInt8(0, r26);
    }
}, a$a = {
    encrypt: function (e19, c16) {
        return e19._cipher.encryptBlock(c16);
    },
    decrypt: function (e19, c16) {
        return e19._cipher.decryptBlock(c16);
    }
}, p$8 = {}, n$a = f$b;
p$8.encrypt = function (e19, c16) {
    var r26 = n$a(c16, e19._prev);
    return e19._prev = e19._cipher.encryptBlock(r26), e19._prev;
}, p$8.decrypt = function (e19, c16) {
    var r26 = e19._prev;
    e19._prev = c16;
    var t19 = e19._cipher.decryptBlock(c16);
    return n$a(t19, r26);
};
var i$22 = {}, o$a = u14.Buffer, h$8 = f$b;

function v$4(e19, c16, r26) {
    var t19 = c16.length, a35 = h$8(c16, e19._cache);
    return e19._cache = e19._cache.slice(t19), e19._prev = o$a.concat([
        e19._prev,
        r26 ? c16 : a35
    ]), a35;
}

i$22.encrypt = function (e19, c16, r26) {
    for (var t19, a35 = o$a.allocUnsafe(0); c16.length;) {
        if (0 === e19._cache.length && (e19._cache = e19._cipher.encryptBlock(e19._prev), e19._prev = o$a.allocUnsafe(0)), !(e19._cache.length <= c16.length)) {
            a35 = o$a.concat([
                a35,
                v$4(e19, c16, r26)
            ]);
            break;
        }
        t19 = e19._cache.length, a35 = o$a.concat([
            a35,
            v$4(e19, c16.slice(0, t19), r26)
        ]), c16 = c16.slice(t19);
    }
    return a35;
};
var y$4 = {}, f$c = u14.Buffer;

function s$7(e19, c16, r26) {
    var t19 = e19._cipher.encryptBlock(e19._prev)[0] ^ c16;
    return e19._prev = f$c.concat([
        e19._prev.slice(1),
        f$c.from([
            r26 ? c16 : t19
        ])
    ]), t19;
}

y$4.encrypt = function (e19, c16, r26) {
    for (var t19 = c16.length, a35 = f$c.allocUnsafe(t19), p19 = -1; (++p19) < t19;) {
        a35[p19] = s$7(e19, c16[p19], r26);
    }
    return a35;
};
var l$8 = {}, m$5 = u14.Buffer;

function _$6(e19, c16, r26) {
    for (var t19, a35, p19 = -1, n32 = 0; (++p19) < 8;) {
        t19 = c16 & 1 << 7 - p19 ? 128 : 0, n32 += (128 & (a35 = e19._cipher.encryptBlock(e19._prev)[0] ^ t19)) >> p19 % 8, e19._prev = k$5(e19._prev, r26 ? t19 : a35);
    }
    return n32;
}

function k$5(e19, c16) {
    var r26 = e19.length, t19 = -1, a35 = m$5.allocUnsafe(e19.length);
    for (e19 = m$5.concat([
        e19,
        m$5.from([
            c16
        ])
    ]); (++t19) < r26;) {
        a35[t19] = e19[t19] << 1 | e19[t19 + 1] >> 7;
    }
    return a35;
}

l$8.encrypt = function (e19, c16, r26) {
    for (var t19 = c16.length, a35 = m$5.allocUnsafe(t19), p19 = -1; (++p19) < t19;) {
        a35[p19] = _$6(e19, c16[p19], r26);
    }
    return a35;
};
var B$3 = {}, u$7 = e$1.Buffer, C$12 = f$b;

function E$4(e19) {
    return e19._prev = e19._cipher.encryptBlock(e19._prev), e19._prev;
}

B$3.encrypt = function (e19, c16) {
    for (; e19._cache.length < c16.length;) {
        e19._cache = u$7.concat([
            e19._cache,
            E$4(e19)
        ]);
    }
    var r26 = e19._cache.slice(0, c16.length);
    return e19._cache = e19._cache.slice(c16.length), C$12(c16, r26);
};
var d$7 = {}, b$5 = f$b, A$3 = u14.Buffer, S$3 = t$14;

function g$4(e19) {
    var c16 = e19._cipher.encryptBlockRaw(e19._prev);
    return S$3(e19._prev), c16;
}

d$7.encrypt = function (e19, c16) {
    var r26 = Math.ceil(c16.length / 16), t19 = e19._cache.length;
    e19._cache = A$3.concat([
        e19._cache,
        A$3.allocUnsafe(16 * r26)
    ]);
    for (var a35 = 0; a35 < r26; a35++) {
        var p19 = g$4(e19), n32 = t19 + 16 * a35;
        e19._cache.writeUInt32BE(p19[0], n32 + 0), e19._cache.writeUInt32BE(p19[1], n32 + 4), e19._cache.writeUInt32BE(p19[2], n32 + 8), e19._cache.writeUInt32BE(p19[3], n32 + 12);
    }
    var i38 = e19._cache.slice(0, c16.length);
    return e19._cache = e19._cache.slice(c16.length), b$5(c16, i38);
};
var F$2 = {
    "aes-128-ecb": {
        cipher: "AES",
        key: 128,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-192-ecb": {
        cipher: "AES",
        key: 192,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-256-ecb": {
        cipher: "AES",
        key: 256,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-128-cbc": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-192-cbc": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-256-cbc": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    aes128: {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    aes192: {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    aes256: {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-128-cfb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-192-cfb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-256-cfb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-128-cfb8": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-192-cfb8": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-256-cfb8": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-128-cfb1": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-192-cfb1": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-256-cfb1": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-128-ofb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-192-ofb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-256-ofb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-128-ctr": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-192-ctr": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-256-ctr": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-128-gcm": {
        cipher: "AES",
        key: 128,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-192-gcm": {
        cipher: "AES",
        key: 192,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-256-gcm": {
        cipher: "AES",
        key: 256,
        iv: 12,
        mode: "GCM",
        type: "auth"
    }
}, U$3 = {
    ECB: a$a,
    CBC: p$8,
    CFB: i$22,
    CFB8: y$4,
    CFB1: l$8,
    OFB: B$3,
    CTR: d$7,
    GCM: d$7
}, w$6 = F$2;
for (var I$4 in w$6) {
    w$6[I$4].module = U$3[w$6[I$4].mode];
}
var M$2 = w$6;
var a$b = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, h$9 = {},
        o$b = u14.Buffer;

function s$8(t19) {
    o$b.isBuffer(t19) || (t19 = o$b.from(t19));
    for (var e19 = t19.length / 4 | 0, i38 = new Array(e19), r26 = 0; r26 < e19; r26++) {
        i38[r26] = t19.readUInt32BE(4 * r26);
    }
    return i38;
}

function c$8(t19) {
    for (; 0 < t19.length; t19++) {
        t19[0] = 0;
    }
}

function l$9(t19, e19, i38, r26, n33) {
    for (var a35, h17, o28, s21, c16 = i38[0], l28 = i38[1], f24 = i38[2], u24 = i38[3], p20 = t19[0] ^ e19[0], _12 = t19[1] ^ e19[1], d15 = t19[2] ^ e19[2], y11 = t19[3] ^ e19[3], B9 = 4, g10 = 1; g10 < n33; g10++) {
        a35 = c16[p20 >>> 24] ^ l28[_12 >>> 16 & 255] ^ f24[d15 >>> 8 & 255] ^ u24[255 & y11] ^ e19[B9++], h17 = c16[_12 >>> 24] ^ l28[d15 >>> 16 & 255] ^ f24[y11 >>> 8 & 255] ^ u24[255 & p20] ^ e19[B9++], o28 = c16[d15 >>> 24] ^ l28[y11 >>> 16 & 255] ^ f24[p20 >>> 8 & 255] ^ u24[255 & _12] ^ e19[B9++], s21 = c16[y11 >>> 24] ^ l28[p20 >>> 16 & 255] ^ f24[_12 >>> 8 & 255] ^ u24[255 & d15] ^ e19[B9++], p20 = a35, _12 = h17, d15 = o28, y11 = s21;
    }
    return a35 = (r26[p20 >>> 24] << 24 | r26[_12 >>> 16 & 255] << 16 | r26[d15 >>> 8 & 255] << 8 | r26[255 & y11]) ^ e19[B9++], h17 = (r26[_12 >>> 24] << 24 | r26[d15 >>> 16 & 255] << 16 | r26[y11 >>> 8 & 255] << 8 | r26[255 & p20]) ^ e19[B9++], o28 = (r26[d15 >>> 24] << 24 | r26[y11 >>> 16 & 255] << 16 | r26[p20 >>> 8 & 255] << 8 | r26[255 & _12]) ^ e19[B9++], s21 = (r26[y11 >>> 24] << 24 | r26[p20 >>> 16 & 255] << 16 | r26[_12 >>> 8 & 255] << 8 | r26[255 & d15]) ^ e19[B9++], [
        a35 >>>= 0,
        h17 >>>= 0,
        o28 >>>= 0,
        s21 >>>= 0
    ];
}

var f$d = [
    0,
    1,
    2,
    4,
    8,
    16,
    32,
    64,
    128,
    27,
    54
], u$8 = function () {
    for (var t19 = new Array(256), e19 = 0; e19 < 256; e19++) {
        t19[e19] = e19 < 128 ? e19 << 1 : e19 << 1 ^ 283;
    }
    for (var i38 = [], r26 = [], n33 = [
        [],
        [],
        [],
        []
    ], a35 = [
        [],
        [],
        [],
        []
    ], h17 = 0, o28 = 0, s21 = 0; s21 < 256; ++s21) {
        var c16 = o28 ^ o28 << 1 ^ o28 << 2 ^ o28 << 3 ^ o28 << 4;
        c16 = c16 >>> 8 ^ 255 & c16 ^ 99, i38[h17] = c16, r26[c16] = h17;
        var l28 = t19[h17], f24 = t19[l28], u24 = t19[f24], p20 = 257 * t19[c16] ^ 16843008 * c16;
        n33[0][h17] = p20 << 24 | p20 >>> 8, n33[1][h17] = p20 << 16 | p20 >>> 16, n33[2][h17] = p20 << 8 | p20 >>> 24, n33[3][h17] = p20, p20 = 16843009 * u24 ^ 65537 * f24 ^ 257 * l28 ^ 16843008 * h17, a35[0][c16] = p20 << 24 | p20 >>> 8, a35[1][c16] = p20 << 16 | p20 >>> 16, a35[2][c16] = p20 << 8 | p20 >>> 24, a35[3][c16] = p20, 0 === h17 ? h17 = o28 = 1 : (h17 = l28 ^ t19[t19[t19[u24 ^ l28]]], o28 ^= t19[t19[o28]]);
    }
    return {
        SBOX: i38,
        INV_SBOX: r26,
        SUB_MIX: n33,
        INV_SUB_MIX: a35
    };
}();

function p$9(t19) {
    (this || a$b)._key = s$8(t19), this._reset();
}

p$9.blockSize = 16, p$9.keySize = 32, p$9.prototype.blockSize = p$9.blockSize, p$9.prototype.keySize = p$9.keySize, p$9.prototype._reset = function () {
    for (var t19 = (this || a$b)._key, e19 = t19.length, i38 = e19 + 6, r26 = 4 * (i38 + 1), n33 = [], h17 = 0; h17 < e19; h17++) {
        n33[h17] = t19[h17];
    }
    for (h17 = e19; h17 < r26; h17++) {
        var o28 = n33[h17 - 1];
        h17 % e19 == 0 ? (o28 = o28 << 8 | o28 >>> 24, o28 = u$8.SBOX[o28 >>> 24] << 24 | u$8.SBOX[o28 >>> 16 & 255] << 16 | u$8.SBOX[o28 >>> 8 & 255] << 8 | u$8.SBOX[255 & o28], o28 ^= f$d[h17 / e19 | 0] << 24) : e19 > 6 && h17 % e19 == 4 && (o28 = u$8.SBOX[o28 >>> 24] << 24 | u$8.SBOX[o28 >>> 16 & 255] << 16 | u$8.SBOX[o28 >>> 8 & 255] << 8 | u$8.SBOX[255 & o28]), n33[h17] = n33[h17 - e19] ^ o28;
    }
    for (var s21 = [], c17 = 0; c17 < r26; c17++) {
        var l29 = r26 - c17, p21 = n33[l29 - (c17 % 4 ? 0 : 4)];
        s21[c17] = c17 < 4 || l29 <= 4 ? p21 : u$8.INV_SUB_MIX[0][u$8.SBOX[p21 >>> 24]] ^ u$8.INV_SUB_MIX[1][u$8.SBOX[p21 >>> 16 & 255]] ^ u$8.INV_SUB_MIX[2][u$8.SBOX[p21 >>> 8 & 255]] ^ u$8.INV_SUB_MIX[3][u$8.SBOX[255 & p21]];
    }
    (this || a$b)._nRounds = i38, (this || a$b)._keySchedule = n33, (this || a$b)._invKeySchedule = s21;
}, p$9.prototype.encryptBlockRaw = function (t19) {
    return l$9(t19 = s$8(t19), (this || a$b)._keySchedule, u$8.SUB_MIX, u$8.SBOX, (this || a$b)._nRounds);
}, p$9.prototype.encryptBlock = function (t19) {
    var e19 = this.encryptBlockRaw(t19), i38 = o$b.allocUnsafe(16);
    return i38.writeUInt32BE(e19[0], 0), i38.writeUInt32BE(e19[1], 4), i38.writeUInt32BE(e19[2], 8), i38.writeUInt32BE(e19[3], 12), i38;
}, p$9.prototype.decryptBlock = function (t19) {
    var e19 = (t19 = s$8(t19))[1];
    t19[1] = t19[3], t19[3] = e19;
    var i38 = l$9(t19, (this || a$b)._invKeySchedule, u$8.INV_SUB_MIX, u$8.INV_SBOX, (this || a$b)._nRounds),
            r26 = o$b.allocUnsafe(16);
    return r26.writeUInt32BE(i38[0], 0), r26.writeUInt32BE(i38[3], 4), r26.writeUInt32BE(i38[2], 8), r26.writeUInt32BE(i38[1], 12), r26;
}, p$9.prototype.scrub = function () {
    c$8((this || a$b)._keySchedule), c$8((this || a$b)._invKeySchedule), c$8((this || a$b)._key);
}, h$9.AES = p$9;
var _$7 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, d$8 = u14.Buffer,
        y$5 = d$8.alloc(16, 0);

function B$4(t19) {
    var e19 = d$8.allocUnsafe(16);
    return e19.writeUInt32BE(t19[0] >>> 0, 0), e19.writeUInt32BE(t19[1] >>> 0, 4), e19.writeUInt32BE(t19[2] >>> 0, 8), e19.writeUInt32BE(t19[3] >>> 0, 12), e19;
}

function g$5(t19) {
    (this || _$7).h = t19, (this || _$7).state = d$8.alloc(16, 0), (this || _$7).cache = d$8.allocUnsafe(0);
}

g$5.prototype.ghash = function (t19) {
    for (var e19 = -1; (++e19) < t19.length;) {
        (this || _$7).state[e19] ^= t19[e19];
    }
    this._multiply();
}, g$5.prototype._multiply = function () {
    for (var t19, e19, i38, r26 = [
        (t19 = (this || _$7).h).readUInt32BE(0),
        t19.readUInt32BE(4),
        t19.readUInt32BE(8),
        t19.readUInt32BE(12)
    ], n33 = [
        0,
        0,
        0,
        0
    ], a35 = -1; (++a35) < 128;) {
        for (0 != ((this || _$7).state[~~(a35 / 8)] & 1 << 7 - a35 % 8) && (n33[0] ^= r26[0], n33[1] ^= r26[1], n33[2] ^= r26[2], n33[3] ^= r26[3]), i38 = 0 != (1 & r26[3]), e19 = 3; e19 > 0; e19--) {
            r26[e19] = r26[e19] >>> 1 | (1 & r26[e19 - 1]) << 31;
        }
        r26[0] = r26[0] >>> 1, i38 && (r26[0] = r26[0] ^ 225 << 24);
    }
    (this || _$7).state = B$4(n33);
}, g$5.prototype.update = function (t19) {
    var e19;
    for ((this || _$7).cache = d$8.concat([
        (this || _$7).cache,
        t19
    ]); (this || _$7).cache.length >= 16;) {
        e19 = (this || _$7).cache.slice(0, 16), (this || _$7).cache = (this || _$7).cache.slice(16), this.ghash(e19);
    }
}, g$5.prototype.final = function (t19, e19) {
    return (this || _$7).cache.length && this.ghash(d$8.concat([
        (this || _$7).cache,
        y$5
    ], 16)), this.ghash(B$4([
        0,
        t19,
        0,
        e19
    ])), (this || _$7).state;
};
var S$4 = g$5, v$5 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global,
        I$5 = h$9, U$4 = u14.Buffer, w$7 = f$61, m$6 = S$4, E$5 = f$b, b$6 = t$14;

function X$12(t19, e19, i38, r26) {
    w$7.call(this || v$5);
    var n33 = U$4.alloc(4, 0);
    (this || v$5)._cipher = new I$5.AES(e19);
    var a35 = (this || v$5)._cipher.encryptBlock(n33);
    (this || v$5)._ghash = new m$6(a35), i38 = (function (t20, e20, i39) {
        if (12 === e20.length) {
            return t20._finID = U$4.concat([
                e20,
                U$4.from([
                    0,
                    0,
                    0,
                    1
                ])
            ]), U$4.concat([
                e20,
                U$4.from([
                    0,
                    0,
                    0,
                    2
                ])
            ]);
        }
        var r27 = new m$6(i39), n34 = e20.length, a36 = n34 % 16;
        r27.update(e20), a36 && (a36 = 16 - a36, r27.update(U$4.alloc(a36, 0))), r27.update(U$4.alloc(8, 0));
        var h17 = 8 * n34, o29 = U$4.alloc(8);
        o29.writeUIntBE(h17, 0, 8), r27.update(o29), t20._finID = r27.state;
        var s21 = U$4.from(t20._finID);
        return b$6(s21), s21;
    })(this || v$5, i38, a35), (this || v$5)._prev = U$4.from(i38), (this || v$5)._cache = U$4.allocUnsafe(0), (this || v$5)._secCache = U$4.allocUnsafe(0), (this || v$5)._decrypt = r26, (this || v$5)._alen = 0, (this || v$5)._len = 0, (this || v$5)._mode = t19, (this || v$5)._authTag = null, (this || v$5)._called = !1;
}

t$2(X$12, w$7), X$12.prototype._update = function (t19) {
    if (!(this || v$5)._called && (this || v$5)._alen) {
        var e19 = 16 - (this || v$5)._alen % 16;
        e19 < 16 && (e19 = U$4.alloc(e19, 0), (this || v$5)._ghash.update(e19));
    }
    (this || v$5)._called = !0;
    var i38 = (this || v$5)._mode.encrypt(this || v$5, t19);
    return (this || v$5)._decrypt ? (this || v$5)._ghash.update(t19) : (this || v$5)._ghash.update(i38), (this || v$5)._len += t19.length, i38;
}, X$12.prototype._final = function () {
    if ((this || v$5)._decrypt && !(this || v$5)._authTag) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    var t19 = E$5((this || v$5)._ghash.final(8 * (this || v$5)._alen, 8 * (this || v$5)._len), (this || v$5)._cipher.encryptBlock((this || v$5)._finID));
    if ((this || v$5)._decrypt && (function (t20, e20) {
        var i38 = 0;
        t20.length !== e20.length && i38++;
        for (var r26 = Math.min(t20.length, e20.length), n33 = 0; n33 < r26; ++n33) {
            i38 += t20[n33] ^ e20[n33];
        }
        return i38;
    })(t19, (this || v$5)._authTag)) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    (this || v$5)._authTag = t19, (this || v$5)._cipher.scrub();
}, X$12.prototype.getAuthTag = function () {
    if ((this || v$5)._decrypt || !U$4.isBuffer((this || v$5)._authTag)) {
        throw new Error("Attempting to get auth tag in unsupported state");
    }
    return (this || v$5)._authTag;
}, X$12.prototype.setAuthTag = function (t19) {
    if (!(this || v$5)._decrypt) {
        throw new Error("Attempting to set auth tag in unsupported state");
    }
    (this || v$5)._authTag = t19;
}, X$12.prototype.setAAD = function (t19) {
    if ((this || v$5)._called) {
        throw new Error("Attempting to set AAD in unsupported state");
    }
    (this || v$5)._ghash.update(t19), (this || v$5)._alen += t19.length;
};
var k$6 = X$12, T$2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global,
        O$2 = h$9, A$4 = u14.Buffer, M$3 = f$61;

function N$13(t19, e20, i38, r26) {
    M$3.call(this || T$2), (this || T$2)._cipher = new O$2.AES(e20), (this || T$2)._prev = A$4.from(i38), (this || T$2)._cache = A$4.allocUnsafe(0), (this || T$2)._secCache = A$4.allocUnsafe(0), (this || T$2)._decrypt = r26, (this || T$2)._mode = t19;
}

t$2(N$13, M$3), N$13.prototype._update = function (t19) {
    return (this || T$2)._mode.encrypt(this || T$2, t19, (this || T$2)._decrypt);
}, N$13.prototype._final = function () {
    (this || T$2)._cipher.scrub();
};
var V$13 = N$13;
var t$23 = u14.Buffer, f$e = u20;
var a$c = function (r26, e20, a35, l30) {
    if ((t$23.isBuffer(r26) || (r26 = t$23.from(r26, "binary")), e20 && (t$23.isBuffer(e20) || (e20 = t$23.from(e20, "binary")), 8 !== e20.length))) {
        throw new RangeError("salt should be Buffer with 8 byte length");
    }
    for (var n33 = a35 / 8, o29 = t$23.alloc(n33), i38 = t$23.alloc(l30 || 0), h17 = t$23.alloc(0); n33 > 0 || l30 > 0;) {
        var u25 = new f$e;
        u25.update(h17), u25.update(r26), e20 && u25.update(e20), h17 = u25.digest();
        var g10 = 0;
        if (n33 > 0) {
            var m9 = o29.length - n33;
            g10 = Math.min(n33, h17.length), h17.copy(o29, m9, 0, g10), n33 -= g10;
        }
        if (g10 < h17.length && l30 > 0) {
            var p22 = i38.length - l30, v12 = Math.min(l30, h17.length - g10);
            h17.copy(i38, p22, g10, g10 + v12), l30 -= v12;
        }
    }
    return (h17.fill(0), {
        key: o29,
        iv: i38
    });
};
var c$9 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, s$9 = {},
        f$f = k$6, p$a = u14.Buffer, u$9 = M$2, l$a = V$13, d$9 = f$61, y$6 = h$9, m$7 = a$c;

function g$6(t19, e20, r26) {
    d$9.call(this || c$9), (this || c$9)._cache = new v$6, (this || c$9)._last = void 0, (this || c$9)._cipher = new y$6.AES(e20), (this || c$9)._prev = p$a.from(r26), (this || c$9)._mode = t19, (this || c$9)._autopadding = !0;
}

function v$6() {
    (this || c$9).cache = p$a.allocUnsafe(0);
}

function w$8(t19, e20, r26) {
    var i38 = u$9[t19.toLowerCase()];
    if (!i38) {
        throw new TypeError("invalid suite type");
    }
    if ("string" == typeof r26 && (r26 = p$a.from(r26)), "GCM" !== i38.mode && r26.length !== i38.iv) {
        throw new TypeError("invalid iv length " + r26.length);
    }
    if ("string" == typeof e20 && (e20 = p$a.from(e20)), e20.length !== i38.key / 8) {
        throw new TypeError("invalid key length " + e20.length);
    }
    return "stream" === i38.type ? new l$a(i38.module, e20, r26, !0) : "auth" === i38.type ? new f$f(i38.module, e20, r26, !0) : new g$6(i38.module, e20, r26);
}

t$2(g$6, d$9), g$6.prototype._update = function (t19) {
    var e20, r26;
    (this || c$9)._cache.add(t19);
    for (var i38 = []; e20 = (this || c$9)._cache.get((this || c$9)._autopadding);) {
        r26 = (this || c$9)._mode.decrypt(this || c$9, e20), i38.push(r26);
    }
    return p$a.concat(i38);
}, g$6.prototype._final = function () {
    var t19 = (this || c$9)._cache.flush();
    if ((this || c$9)._autopadding) {
        return (function (t20) {
            var e20 = t20[15];
            if (e20 < 1 || e20 > 16) {
                throw new Error("unable to decrypt data");
            }
            var r26 = -1;
            for (; (++r26) < e20;) {
                if (t20[r26 + (16 - e20)] !== e20) {
                    throw new Error("unable to decrypt data");
                }
            }
            if (16 === e20) {
                return;
            }
            return t20.slice(0, 16 - e20);
        })((this || c$9)._mode.decrypt(this || c$9, t19));
    }
    if (t19) {
        throw new Error("data not multiple of block length");
    }
}, g$6.prototype.setAutoPadding = function (t19) {
    return (this || c$9)._autopadding = !!t19, this || c$9;
}, v$6.prototype.add = function (t19) {
    (this || c$9).cache = p$a.concat([
        (this || c$9).cache,
        t19
    ]);
}, v$6.prototype.get = function (t19) {
    var e20;
    if (t19) {
        if ((this || c$9).cache.length > 16) {
            return e20 = (this || c$9).cache.slice(0, 16), (this || c$9).cache = (this || c$9).cache.slice(16), e20;
        }
    } else if ((this || c$9).cache.length >= 16) {
        return e20 = (this || c$9).cache.slice(0, 16), (this || c$9).cache = (this || c$9).cache.slice(16), e20;
    }
    return null;
}, v$6.prototype.flush = function () {
    if ((this || c$9).cache.length) {
        return (this || c$9).cache;
    }
}, s$9.createDecipher = function (t19, e20) {
    var r26 = u$9[t19.toLowerCase()];
    if (!r26) {
        throw new TypeError("invalid suite type");
    }
    var i38 = m$7(e20, !1, r26.key, r26.iv);
    return w$8(t19, i38.key, i38.iv);
}, s$9.createDecipheriv = w$8;
var c$a = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, s$a = {},
        f$g = M$2, p$b = k$6, l$b = u14.Buffer, u$a = V$13, d$a = f$61, m$8 = h$9, y$7 = a$c;

function v$7(t19, e20, r26) {
    d$a.call(this || c$a), (this || c$a)._cache = new g$7, (this || c$a)._cipher = new m$8.AES(e20), (this || c$a)._prev = l$b.from(r26), (this || c$a)._mode = t19, (this || c$a)._autopadding = !0;
}

t$2(v$7, d$a), v$7.prototype._update = function (t19) {
    var e20, r26;
    (this || c$a)._cache.add(t19);
    for (var i38 = []; e20 = (this || c$a)._cache.get();) {
        r26 = (this || c$a)._mode.encrypt(this || c$a, e20), i38.push(r26);
    }
    return l$b.concat(i38);
};
var _$8 = l$b.alloc(16, 16);

function g$7() {
    (this || c$a).cache = l$b.allocUnsafe(0);
}

function w$9(t19, e20, r26) {
    var i38 = f$g[t19.toLowerCase()];
    if (!i38) {
        throw new TypeError("invalid suite type");
    }
    if ("string" == typeof e20 && (e20 = l$b.from(e20)), e20.length !== i38.key / 8) {
        throw new TypeError("invalid key length " + e20.length);
    }
    if ("string" == typeof r26 && (r26 = l$b.from(r26)), "GCM" !== i38.mode && r26.length !== i38.iv) {
        throw new TypeError("invalid iv length " + r26.length);
    }
    return "stream" === i38.type ? new u$a(i38.module, e20, r26) : "auth" === i38.type ? new p$b(i38.module, e20, r26) : new v$7(i38.module, e20, r26);
}

v$7.prototype._final = function () {
    var t19 = (this || c$a)._cache.flush();
    if ((this || c$a)._autopadding) {
        return t19 = (this || c$a)._mode.encrypt(this || c$a, t19), (this || c$a)._cipher.scrub(), t19;
    }
    if (!t19.equals(_$8)) {
        throw (this || c$a)._cipher.scrub(), new Error("data not multiple of block length");
    }
}, v$7.prototype.setAutoPadding = function (t19) {
    return (this || c$a)._autopadding = !!t19, this || c$a;
}, g$7.prototype.add = function (t19) {
    (this || c$a).cache = l$b.concat([
        (this || c$a).cache,
        t19
    ]);
}, g$7.prototype.get = function () {
    if ((this || c$a).cache.length > 15) {
        var t19 = (this || c$a).cache.slice(0, 16);
        return (this || c$a).cache = (this || c$a).cache.slice(16), t19;
    }
    return null;
}, g$7.prototype.flush = function () {
    for (var t20 = 16 - (this || c$a).cache.length, e20 = l$b.allocUnsafe(t20), r26 = -1; (++r26) < t20;) {
        e20.writeUInt8(t20, r26);
    }
    return l$b.concat([
        (this || c$a).cache,
        e20
    ]);
}, s$a.createCipheriv = w$9, s$a.createCipher = function (t20, e20) {
    var r26 = f$g[t20.toLowerCase()];
    if (!r26) {
        throw new TypeError("invalid suite type");
    }
    var i38 = y$7(e20, !1, r26.key, r26.iv);
    return w$9(t20, i38.key, i38.iv);
};
var t$32 = {}, p$c = s$a, c$b = s$9, o$c = F$2;
t$32.createCipher = t$32.Cipher = p$c.createCipher, t$32.createCipheriv = t$32.Cipheriv = p$c.createCipheriv, t$32.createDecipher = t$32.Decipher = c$b.createDecipher, t$32.createDecipheriv = t$32.Decipheriv = c$b.createDecipheriv, t$32.listCiphers = t$32.getCiphers = function () {
    return Object.keys(o$c);
};
var e$9 = {
    "des-ecb": {
        key: 8,
        iv: 0
    }
};
e$9["des-cbc"] = e$9.des = {
    key: 8,
    iv: 8
}, e$9["des-ede3-cbc"] = e$9.des3 = {
    key: 24,
    iv: 8
}, e$9["des-ede3"] = {
    key: 24,
    iv: 0
}, e$9["des-ede-cbc"] = {
    key: 16,
    iv: 8
}, e$9["des-ede"] = {
    key: 16,
    iv: 0
};
var p$d = {}, n$b = l$7, s$b = t$32, v$8 = M$2, y$8 = e$9, a$d = a$c;

function f$h(e20, r26, i38) {
    if (e20 = e20.toLowerCase(), v$8[e20]) {
        return s$b.createCipheriv(e20, r26, i38);
    }
    if (y$8[e20]) {
        return new n$b({
            key: r26,
            iv: i38,
            mode: e20
        });
    }
    throw new TypeError("invalid suite type");
}

function c$c(e20, r26, i38) {
    if (e20 = e20.toLowerCase(), v$8[e20]) {
        return s$b.createDecipheriv(e20, r26, i38);
    }
    if (y$8[e20]) {
        return new n$b({
            key: r26,
            iv: i38,
            mode: e20,
            decrypt: !0
        });
    }
    throw new TypeError("invalid suite type");
}

p$d.createCipher = p$d.Cipher = function (e20, r26) {
    var i38, t20;
    if (e20 = e20.toLowerCase(), v$8[e20]) {
        i38 = v$8[e20].key, t20 = v$8[e20].iv;
    } else {
        if (!y$8[e20]) {
            throw new TypeError("invalid suite type");
        }
        i38 = 8 * y$8[e20].key, t20 = y$8[e20].iv;
    }
    var o29 = a$d(r26, !1, i38, t20);
    return f$h(e20, o29.key, o29.iv);
}, p$d.createCipheriv = p$d.Cipheriv = f$h, p$d.createDecipher = p$d.Decipher = function (e20, r26) {
    var i38, t20;
    if (e20 = e20.toLowerCase(), v$8[e20]) {
        i38 = v$8[e20].key, t20 = v$8[e20].iv;
    } else {
        if (!y$8[e20]) {
            throw new TypeError("invalid suite type");
        }
        i38 = 8 * y$8[e20].key, t20 = y$8[e20].iv;
    }
    var o29 = a$d(r26, !1, i38, t20);
    return c$c(e20, o29.key, o29.iv);
}, p$d.createDecipheriv = p$d.Decipheriv = c$c, p$d.listCiphers = p$d.getCiphers = function () {
    return Object.keys(y$8).concat(s$b.getCiphers());
};
var t$42 = Object.freeze({}),
        i$31 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, r$7 = {},
        h$a = {
            exports: r$7
        };
!function (r26, h17) {
    function n33(t20, i38) {
        if (!t20) {
            throw new Error(i38 || "Assertion failed");
        }
    }

    function e20(t20, i38) {
        t20.super_ = i38;
        var r27 = function () {
        };
        r27.prototype = i38.prototype, t20.prototype = new r27, t20.prototype.constructor = t20;
    }

    function o29(t20, r27, h18) {
        if (o29.isBN(t20)) {
            return t20;
        }
        (this || i$31).negative = 0, (this || i$31).words = null, (this || i$31).length = 0, (this || i$31).red = null, null !== t20 && ("le" !== r27 && "be" !== r27 || (h18 = r27, r27 = 10), this._init(t20 || 0, r27 || 10, h18 || "be"));
    }

    var s21;
    "object" == typeof r26 ? r26.exports = o29 : h17.BN = o29, o29.BN = o29, o29.wordSize = 26;
    try {
        s21 = t$42.Buffer;
    } catch (t20) {
    }

    function u26(t20, i38, r27) {
        for (var h18 = 0, n34 = Math.min(t20.length, r27), e21 = i38; e21 < n34; e21++) {
            var o30 = t20.charCodeAt(e21) - 48;
            h18 <<= 4, h18 |= o30 >= 49 && o30 <= 54 ? o30 - 49 + 10 : o30 >= 17 && o30 <= 22 ? o30 - 17 + 10 : 15 & o30;
        }
        return h18;
    }

    function a35(t20, i38, r27, h18) {
        for (var n34 = 0, e21 = Math.min(t20.length, r27), o31 = i38; o31 < e21; o31++) {
            var s22 = t20.charCodeAt(o31) - 48;
            n34 *= h18, n34 += s22 >= 49 ? s22 - 49 + 10 : s22 >= 17 ? s22 - 17 + 10 : s22;
        }
        return n34;
    }

    o29.isBN = function (t20) {
        return t20 instanceof o29 || null !== t20 && "object" == typeof t20 && t20.constructor.wordSize === o29.wordSize && Array.isArray(t20.words);
    }, o29.max = function (t20, i38) {
        return t20.cmp(i38) > 0 ? t20 : i38;
    }, o29.min = function (t20, i38) {
        return t20.cmp(i38) < 0 ? t20 : i38;
    }, o29.prototype._init = function (t20, r27, h18) {
        if ("number" == typeof t20) {
            return this._initNumber(t20, r27, h18);
        }
        if ("object" == typeof t20) {
            return this._initArray(t20, r27, h18);
        }
        "hex" === r27 && (r27 = 16), n33(r27 === (0 | r27) && r27 >= 2 && r27 <= 36);
        var e21 = 0;
        "-" === (t20 = t20.toString().replace(/\s+/g, ""))[0] && e21++, 16 === r27 ? this._parseHex(t20, e21) : this._parseBase(t20, r27, e21), "-" === t20[0] && ((this || i$31).negative = 1), this.strip(), "le" === h18 && this._initArray(this.toArray(), r27, h18);
    }, o29.prototype._initNumber = function (t20, r27, h18) {
        t20 < 0 && ((this || i$31).negative = 1, t20 = -t20), t20 < 67108864 ? ((this || i$31).words = [
            67108863 & t20
        ], (this || i$31).length = 1) : t20 < 4503599627370496 ? ((this || i$31).words = [
            67108863 & t20,
            t20 / 67108864 & 67108863
        ], (this || i$31).length = 2) : (n33(t20 < 9007199254740992), (this || i$31).words = [
            67108863 & t20,
            t20 / 67108864 & 67108863,
            1
        ], (this || i$31).length = 3), "le" === h18 && this._initArray(this.toArray(), r27, h18);
    }, o29.prototype._initArray = function (t20, r27, h18) {
        if (n33("number" == typeof t20.length), t20.length <= 0) {
            return (this || i$31).words = [
                0
            ], (this || i$31).length = 1, this || i$31;
        }
        (this || i$31).length = Math.ceil(t20.length / 3), (this || i$31).words = new Array((this || i$31).length);
        for (var e21 = 0; e21 < (this || i$31).length; e21++) {
            (this || i$31).words[e21] = 0;
        }
        var o31, s23, u27 = 0;
        if ("be" === h18) {
            for (e21 = t20.length - 1, o31 = 0; e21 >= 0; e21 -= 3) {
                s23 = t20[e21] | t20[e21 - 1] << 8 | t20[e21 - 2] << 16, (this || i$31).words[o31] |= s23 << u27 & 67108863, (this || i$31).words[o31 + 1] = s23 >>> 26 - u27 & 67108863, (u27 += 24) >= 26 && (u27 -= 26, o31++);
            }
        } else if ("le" === h18) {
            for (e21 = 0, o31 = 0; e21 < t20.length; e21 += 3) {
                s23 = t20[e21] | t20[e21 + 1] << 8 | t20[e21 + 2] << 16, (this || i$31).words[o31] |= s23 << u27 & 67108863, (this || i$31).words[o31 + 1] = s23 >>> 26 - u27 & 67108863, (u27 += 24) >= 26 && (u27 -= 26, o31++);
            }
        }
        return this.strip();
    }, o29.prototype._parseHex = function (t20, r27) {
        (this || i$31).length = Math.ceil((t20.length - r27) / 6), (this || i$31).words = new Array((this || i$31).length);
        for (var h18 = 0; h18 < (this || i$31).length; h18++) {
            (this || i$31).words[h18] = 0;
        }
        var n34, e21, o31 = 0;
        for (h18 = t20.length - 6, n34 = 0; h18 >= r27; h18 -= 6) {
            e21 = u26(t20, h18, h18 + 6), (this || i$31).words[n34] |= e21 << o31 & 67108863, (this || i$31).words[n34 + 1] |= e21 >>> 26 - o31 & 4194303, (o31 += 24) >= 26 && (o31 -= 26, n34++);
        }
        h18 + 6 !== r27 && (e21 = u26(t20, r27, h18 + 6), (this || i$31).words[n34] |= e21 << o31 & 67108863, (this || i$31).words[n34 + 1] |= e21 >>> 26 - o31 & 4194303), this.strip();
    }, o29.prototype._parseBase = function (t20, r27, h18) {
        (this || i$31).words = [
            0
        ], (this || i$31).length = 1;
        for (var n34 = 0, e21 = 1; e21 <= 67108863; e21 *= r27) {
            n34++;
        }
        n34--, e21 = e21 / r27 | 0;
        for (var o31 = t20.length - h18, s23 = o31 % n34, u27 = Math.min(o31, o31 - s23) + h18, l30 = 0, m10 = h18; m10 < u27; m10 += n34) {
            l30 = a35(t20, m10, m10 + n34, r27), this.imuln(e21), (this || i$31).words[0] + l30 < 67108864 ? (this || i$31).words[0] += l30 : this._iaddn(l30);
        }
        if (0 !== s23) {
            var f25 = 1;
            for (l30 = a35(t20, m10, t20.length, r27), m10 = 0; m10 < s23; m10++) {
                f25 *= r27;
            }
            this.imuln(f25), (this || i$31).words[0] + l30 < 67108864 ? (this || i$31).words[0] += l30 : this._iaddn(l30);
        }
    }, o29.prototype.copy = function (t20) {
        t20.words = new Array((this || i$31).length);
        for (var r27 = 0; r27 < (this || i$31).length; r27++) {
            t20.words[r27] = (this || i$31).words[r27];
        }
        t20.length = (this || i$31).length, t20.negative = (this || i$31).negative, t20.red = (this || i$31).red;
    }, o29.prototype.clone = function () {
        var t20 = new o29(null);
        return this.copy(t20), t20;
    }, o29.prototype._expand = function (t20) {
        for (; (this || i$31).length < t20;) {
            (this || i$31).words[(this || i$31).length++] = 0;
        }
        return this || i$31;
    }, o29.prototype.strip = function () {
        for (; (this || i$31).length > 1 && 0 === (this || i$31).words[(this || i$31).length - 1];) {
            (this || i$31).length--;
        }
        return this._normSign();
    }, o29.prototype._normSign = function () {
        return 1 === (this || i$31).length && 0 === (this || i$31).words[0] && ((this || i$31).negative = 0), this || i$31;
    }, o29.prototype.inspect = function () {
        return ((this || i$31).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var l30 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
    ], m10 = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ], f26 = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];

    function d15(t20, i38, r27) {
        r27.negative = i38.negative ^ t20.negative;
        var h18 = t20.length + i38.length | 0;
        r27.length = h18, h18 = h18 - 1 | 0;
        var n34 = 0 | t20.words[0], e21 = 0 | i38.words[0], o31 = n34 * e21, s23 = 67108863 & o31,
                u27 = o31 / 67108864 | 0;
        r27.words[0] = s23;
        for (var a36 = 1; a36 < h18; a36++) {
            for (var l31 = u27 >>> 26, m11 = 67108863 & u27, f27 = Math.min(a36, i38.length - 1), d15 = Math.max(0, a36 - t20.length + 1); d15 <= f27; d15++) {
                var p23 = a36 - d15 | 0;
                l31 += (o31 = (n34 = 0 | t20.words[p23]) * (e21 = 0 | i38.words[d15]) + m11) / 67108864 | 0, m11 = 67108863 & o31;
            }
            r27.words[a36] = 0 | m11, u27 = 0 | l31;
        }
        return 0 !== u27 ? r27.words[a36] = 0 | u27 : r27.length--, r27.strip();
    }

    o29.prototype.toString = function (t20, r27) {
        var h18;
        if (r27 = 0 | r27 || 1, 16 === (t20 = t20 || 10) || "hex" === t20) {
            h18 = "";
            for (var e21 = 0, o31 = 0, s23 = 0; s23 < (this || i$31).length; s23++) {
                var u27 = (this || i$31).words[s23], a36 = (16777215 & (u27 << e21 | o31)).toString(16);
                h18 = 0 !== (o31 = u27 >>> 24 - e21 & 16777215) || s23 !== (this || i$31).length - 1 ? l30[6 - a36.length] + a36 + h18 : a36 + h18, (e21 += 2) >= 26 && (e21 -= 26, s23--);
            }
            for (0 !== o31 && (h18 = o31.toString(16) + h18); h18.length % r27 != 0;) {
                h18 = "0" + h18;
            }
            return 0 !== (this || i$31).negative && (h18 = "-" + h18), h18;
        }
        if (t20 === (0 | t20) && t20 >= 2 && t20 <= 36) {
            var d16 = m10[t20], p24 = f26[t20];
            h18 = "";
            var M7 = this.clone();
            for (M7.negative = 0; !M7.isZero();) {
                var v13 = M7.modn(p24).toString(t20);
                h18 = (M7 = M7.idivn(p24)).isZero() ? v13 + h18 : l30[d16 - v13.length] + v13 + h18;
            }
            for (this.isZero() && (h18 = "0" + h18); h18.length % r27 != 0;) {
                h18 = "0" + h18;
            }
            return 0 !== (this || i$31).negative && (h18 = "-" + h18), h18;
        }
        n33(!1, "Base should be between 2 and 36");
    }, o29.prototype.toNumber = function () {
        var t20 = (this || i$31).words[0];
        return 2 === (this || i$31).length ? t20 += 67108864 * (this || i$31).words[1] : 3 === (this || i$31).length && 1 === (this || i$31).words[2] ? t20 += 4503599627370496 + 67108864 * (this || i$31).words[1] : (this || i$31).length > 2 && n33(!1, "Number can only safely store up to 53 bits"), 0 !== (this || i$31).negative ? -t20 : t20;
    }, o29.prototype.toJSON = function () {
        return this.toString(16);
    }, o29.prototype.toBuffer = function (t20, i38) {
        return n33((void 0) !== s21), this.toArrayLike(s21, t20, i38);
    }, o29.prototype.toArray = function (t20, i38) {
        return this.toArrayLike(Array, t20, i38);
    }, o29.prototype.toArrayLike = function (t20, i38, r27) {
        var h18 = this.byteLength(), e22 = r27 || Math.max(1, h18);
        n33(h18 <= e22, "byte array longer than desired length"), n33(e22 > 0, "Requested array length <= 0"), this.strip();
        var o32, s24, u28 = "le" === i38, a37 = new t20(e22), l32 = this.clone();
        if (u28) {
            for (s24 = 0; !l32.isZero(); s24++) {
                o32 = l32.andln(255), l32.iushrn(8), a37[s24] = o32;
            }
            for (; s24 < e22; s24++) {
                a37[s24] = 0;
            }
        } else {
            for (s24 = 0; s24 < e22 - h18; s24++) {
                a37[s24] = 0;
            }
            for (s24 = 0; !l32.isZero(); s24++) {
                o32 = l32.andln(255), l32.iushrn(8), a37[e22 - s24 - 1] = o32;
            }
        }
        return a37;
    }, Math.clz32 ? o29.prototype._countBits = function (t20) {
        return 32 - Math.clz32(t20);
    } : o29.prototype._countBits = function (t20) {
        var i38 = t20, r27 = 0;
        return i38 >= 4096 && (r27 += 13, i38 >>>= 13), i38 >= 64 && (r27 += 7, i38 >>>= 7), i38 >= 8 && (r27 += 4, i38 >>>= 4), i38 >= 2 && (r27 += 2, i38 >>>= 2), r27 + i38;
    }, o29.prototype._zeroBits = function (t20) {
        if (0 === t20) {
            return 26;
        }
        var i38 = t20, r27 = 0;
        return 0 == (8191 & i38) && (r27 += 13, i38 >>>= 13), 0 == (127 & i38) && (r27 += 7, i38 >>>= 7), 0 == (15 & i38) && (r27 += 4, i38 >>>= 4), 0 == (3 & i38) && (r27 += 2, i38 >>>= 2), 0 == (1 & i38) && r27++, r27;
    }, o29.prototype.bitLength = function () {
        var t20 = (this || i$31).words[(this || i$31).length - 1], r27 = this._countBits(t20);
        return 26 * ((this || i$31).length - 1) + r27;
    }, o29.prototype.zeroBits = function () {
        if (this.isZero()) {
            return 0;
        }
        for (var t20 = 0, r27 = 0; r27 < (this || i$31).length; r27++) {
            var h18 = this._zeroBits((this || i$31).words[r27]);
            if (t20 += h18, 26 !== h18) {
                break;
            }
        }
        return t20;
    }, o29.prototype.byteLength = function () {
        return Math.ceil(this.bitLength() / 8);
    }, o29.prototype.toTwos = function (t20) {
        return 0 !== (this || i$31).negative ? this.abs().inotn(t20).iaddn(1) : this.clone();
    }, o29.prototype.fromTwos = function (t20) {
        return this.testn(t20 - 1) ? this.notn(t20).iaddn(1).ineg() : this.clone();
    }, o29.prototype.isNeg = function () {
        return 0 !== (this || i$31).negative;
    }, o29.prototype.neg = function () {
        return this.clone().ineg();
    }, o29.prototype.ineg = function () {
        return this.isZero() || ((this || i$31).negative ^= 1), this || i$31;
    }, o29.prototype.iuor = function (t20) {
        for (; (this || i$31).length < t20.length;) {
            (this || i$31).words[(this || i$31).length++] = 0;
        }
        for (var r27 = 0; r27 < t20.length; r27++) {
            (this || i$31).words[r27] = (this || i$31).words[r27] | t20.words[r27];
        }
        return this.strip();
    }, o29.prototype.ior = function (t20) {
        return n33(0 == ((this || i$31).negative | t20.negative)), this.iuor(t20);
    }, o29.prototype.or = function (t20) {
        return (this || i$31).length > t20.length ? this.clone().ior(t20) : t20.clone().ior(this || i$31);
    }, o29.prototype.uor = function (t20) {
        return (this || i$31).length > t20.length ? this.clone().iuor(t20) : t20.clone().iuor(this || i$31);
    }, o29.prototype.iuand = function (t20) {
        var r27;
        r27 = (this || i$31).length > t20.length ? t20 : this || i$31;
        for (var h19 = 0; h19 < r27.length; h19++) {
            (this || i$31).words[h19] = (this || i$31).words[h19] & t20.words[h19];
        }
        return (this || i$31).length = r27.length, this.strip();
    }, o29.prototype.iand = function (t20) {
        return n33(0 == ((this || i$31).negative | t20.negative)), this.iuand(t20);
    }, o29.prototype.and = function (t20) {
        return (this || i$31).length > t20.length ? this.clone().iand(t20) : t20.clone().iand(this || i$31);
    }, o29.prototype.uand = function (t20) {
        return (this || i$31).length > t20.length ? this.clone().iuand(t20) : t20.clone().iuand(this || i$31);
    }, o29.prototype.iuxor = function (t20) {
        var r27, h19;
        (this || i$31).length > t20.length ? (r27 = this || i$31, h19 = t20) : (r27 = t20, h19 = this || i$31);
        for (var n34 = 0; n34 < h19.length; n34++) {
            (this || i$31).words[n34] = r27.words[n34] ^ h19.words[n34];
        }
        if ((this || i$31) !== r27) {
            for (; n34 < r27.length; n34++) {
                (this || i$31).words[n34] = r27.words[n34];
            }
        }
        return (this || i$31).length = r27.length, this.strip();
    }, o29.prototype.ixor = function (t20) {
        return n33(0 == ((this || i$31).negative | t20.negative)), this.iuxor(t20);
    }, o29.prototype.xor = function (t20) {
        return (this || i$31).length > t20.length ? this.clone().ixor(t20) : t20.clone().ixor(this || i$31);
    }, o29.prototype.uxor = function (t20) {
        return (this || i$31).length > t20.length ? this.clone().iuxor(t20) : t20.clone().iuxor(this || i$31);
    }, o29.prototype.inotn = function (t20) {
        n33("number" == typeof t20 && t20 >= 0);
        var r27 = 0 | Math.ceil(t20 / 26), h19 = t20 % 26;
        this._expand(r27), h19 > 0 && r27--;
        for (var e22 = 0; e22 < r27; e22++) {
            (this || i$31).words[e22] = 67108863 & ~(this || i$31).words[e22];
        }
        return h19 > 0 && ((this || i$31).words[e22] = ~(this || i$31).words[e22] & 67108863 >> 26 - h19), this.strip();
    }, o29.prototype.notn = function (t20) {
        return this.clone().inotn(t20);
    }, o29.prototype.setn = function (t20, r27) {
        n33("number" == typeof t20 && t20 >= 0);
        var h19 = t20 / 26 | 0, e22 = t20 % 26;
        return this._expand(h19 + 1), (this || i$31).words[h19] = r27 ? (this || i$31).words[h19] | 1 << e22 : (this || i$31).words[h19] & ~(1 << e22), this.strip();
    }, o29.prototype.iadd = function (t20) {
        var r27, h19, n34;
        if (0 !== (this || i$31).negative && 0 === t20.negative) {
            return (this || i$31).negative = 0, r27 = this.isub(t20), (this || i$31).negative ^= 1, this._normSign();
        }
        if (0 === (this || i$31).negative && 0 !== t20.negative) {
            return t20.negative = 0, r27 = this.isub(t20), t20.negative = 1, r27._normSign();
        }
        (this || i$31).length > t20.length ? (h19 = this || i$31, n34 = t20) : (h19 = t20, n34 = this || i$31);
        for (var e22 = 0, o32 = 0; o32 < n34.length; o32++) {
            r27 = (0 | h19.words[o32]) + (0 | n34.words[o32]) + e22, (this || i$31).words[o32] = 67108863 & r27, e22 = r27 >>> 26;
        }
        for (; 0 !== e22 && o32 < h19.length; o32++) {
            r27 = (0 | h19.words[o32]) + e22, (this || i$31).words[o32] = 67108863 & r27, e22 = r27 >>> 26;
        }
        if ((this || i$31).length = h19.length, 0 !== e22) {
            (this || i$31).words[(this || i$31).length] = e22, (this || i$31).length++;
        } else if (h19 !== (this || i$31)) {
            for (; o32 < h19.length; o32++) {
                (this || i$31).words[o32] = h19.words[o32];
            }
        }
        return this || i$31;
    }, o29.prototype.add = function (t20) {
        var r27;
        return 0 !== t20.negative && 0 === (this || i$31).negative ? (t20.negative = 0, r27 = this.sub(t20), t20.negative ^= 1, r27) : 0 === t20.negative && 0 !== (this || i$31).negative ? ((this || i$31).negative = 0, r27 = t20.sub(this || i$31), (this || i$31).negative = 1, r27) : (this || i$31).length > t20.length ? this.clone().iadd(t20) : t20.clone().iadd(this || i$31);
    }, o29.prototype.isub = function (t20) {
        if (0 !== t20.negative) {
            t20.negative = 0;
            var r27 = this.iadd(t20);
            return t20.negative = 1, r27._normSign();
        }
        if (0 !== (this || i$31).negative) {
            return (this || i$31).negative = 0, this.iadd(t20), (this || i$31).negative = 1, this._normSign();
        }
        var h19, n34, e22 = this.cmp(t20);
        if (0 === e22) {
            return (this || i$31).negative = 0, (this || i$31).length = 1, (this || i$31).words[0] = 0, this || i$31;
        }
        e22 > 0 ? (h19 = this || i$31, n34 = t20) : (h19 = t20, n34 = this || i$31);
        for (var o32 = 0, s24 = 0; s24 < n34.length; s24++) {
            o32 = (r27 = (0 | h19.words[s24]) - (0 | n34.words[s24]) + o32) >> 26, (this || i$31).words[s24] = 67108863 & r27;
        }
        for (; 0 !== o32 && s24 < h19.length; s24++) {
            o32 = (r27 = (0 | h19.words[s24]) + o32) >> 26, (this || i$31).words[s24] = 67108863 & r27;
        }
        if (0 === o32 && s24 < h19.length && h19 !== (this || i$31)) {
            for (; s24 < h19.length; s24++) {
                (this || i$31).words[s24] = h19.words[s24];
            }
        }
        return (this || i$31).length = Math.max((this || i$31).length, s24), h19 !== (this || i$31) && ((this || i$31).negative = 1), this.strip();
    }, o29.prototype.sub = function (t20) {
        return this.clone().isub(t20);
    };
    var p25 = function (t20, i38, r28) {
        var h19, n34, e22, o32 = t20.words, s24 = i38.words, u28 = r28.words, a37 = 0, l32 = 0 | o32[0],
                m12 = 8191 & l32, f28 = l32 >>> 13, d17 = 0 | o32[1], p25 = 8191 & d17, M8 = d17 >>> 13,
                v14 = 0 | o32[2], g11 = 8191 & v14, c17 = v14 >>> 13, w6 = 0 | o32[3], y11 = 8191 & w6, b11 = w6 >>> 13,
                _12 = 0 | o32[4], k7 = 8191 & _12, A7 = _12 >>> 13, x8 = 0 | o32[5], S6 = 8191 & x8, Z7 = x8 >>> 13,
                R7 = 0 | o32[6], q7 = 8191 & R7, B9 = R7 >>> 13, N7 = 0 | o32[7], L8 = 8191 & N7, I9 = N7 >>> 13,
                T10 = 0 | o32[8], z8 = 8191 & T10, E9 = T10 >>> 13, O6 = 0 | o32[9], j7 = 8191 & O6, K5 = O6 >>> 13,
                P8 = 0 | s24[0], F8 = 8191 & P8, C7 = P8 >>> 13, D8 = 0 | s24[1], H6 = 8191 & D8, J7 = D8 >>> 13,
                U9 = 0 | s24[2], G6 = 8191 & U9, Q6 = U9 >>> 13, V5 = 0 | s24[3], W7 = 8191 & V5, X6 = V5 >>> 13,
                Y7 = 0 | s24[4], $7 = 8191 & Y7, tt4 = Y7 >>> 13, it3 = 0 | s24[5], rt1 = 8191 & it3, ht1 = it3 >>> 13,
                nt2 = 0 | s24[6], et3 = 8191 & nt2, ot = nt2 >>> 13, st2 = 0 | s24[7], ut = 8191 & st2,
                at1 = st2 >>> 13, lt = 0 | s24[8], mt = 8191 & lt, ft = lt >>> 13, dt = 0 | s24[9], pt = 8191 & dt,
                Mt = dt >>> 13;
        r28.negative = t20.negative ^ i38.negative, r28.length = 19;
        var vt = (a37 + (h19 = Math.imul(m12, F8)) | 0) + ((8191 & (n34 = (n34 = Math.imul(m12, C7)) + Math.imul(f28, F8) | 0)) << 13) | 0;
        a37 = ((e22 = Math.imul(f28, C7)) + (n34 >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, h19 = Math.imul(p25, F8), n34 = (n34 = Math.imul(p25, C7)) + Math.imul(M8, F8) | 0, e22 = Math.imul(M8, C7);
        var gt = (a37 + (h19 = h19 + Math.imul(m12, H6) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(m12, J7) | 0) + Math.imul(f28, H6) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(f28, J7) | 0) + (n34 >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, h19 = Math.imul(g11, F8), n34 = (n34 = Math.imul(g11, C7)) + Math.imul(c17, F8) | 0, e22 = Math.imul(c17, C7), h19 = h19 + Math.imul(p25, H6) | 0, n34 = (n34 = n34 + Math.imul(p25, J7) | 0) + Math.imul(M8, H6) | 0, e22 = e22 + Math.imul(M8, J7) | 0;
        var ct = (a37 + (h19 = h19 + Math.imul(m12, G6) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(m12, Q6) | 0) + Math.imul(f28, G6) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(f28, Q6) | 0) + (n34 >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, h19 = Math.imul(y11, F8), n34 = (n34 = Math.imul(y11, C7)) + Math.imul(b11, F8) | 0, e22 = Math.imul(b11, C7), h19 = h19 + Math.imul(g11, H6) | 0, n34 = (n34 = n34 + Math.imul(g11, J7) | 0) + Math.imul(c17, H6) | 0, e22 = e22 + Math.imul(c17, J7) | 0, h19 = h19 + Math.imul(p25, G6) | 0, n34 = (n34 = n34 + Math.imul(p25, Q6) | 0) + Math.imul(M8, G6) | 0, e22 = e22 + Math.imul(M8, Q6) | 0;
        var wt = (a37 + (h19 = h19 + Math.imul(m12, W7) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(m12, X6) | 0) + Math.imul(f28, W7) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(f28, X6) | 0) + (n34 >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, h19 = Math.imul(k7, F8), n34 = (n34 = Math.imul(k7, C7)) + Math.imul(A7, F8) | 0, e22 = Math.imul(A7, C7), h19 = h19 + Math.imul(y11, H6) | 0, n34 = (n34 = n34 + Math.imul(y11, J7) | 0) + Math.imul(b11, H6) | 0, e22 = e22 + Math.imul(b11, J7) | 0, h19 = h19 + Math.imul(g11, G6) | 0, n34 = (n34 = n34 + Math.imul(g11, Q6) | 0) + Math.imul(c17, G6) | 0, e22 = e22 + Math.imul(c17, Q6) | 0, h19 = h19 + Math.imul(p25, W7) | 0, n34 = (n34 = n34 + Math.imul(p25, X6) | 0) + Math.imul(M8, W7) | 0, e22 = e22 + Math.imul(M8, X6) | 0;
        var yt = (a37 + (h19 = h19 + Math.imul(m12, $7) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(m12, tt4) | 0) + Math.imul(f28, $7) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(f28, tt4) | 0) + (n34 >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, h19 = Math.imul(S6, F8), n34 = (n34 = Math.imul(S6, C7)) + Math.imul(Z7, F8) | 0, e22 = Math.imul(Z7, C7), h19 = h19 + Math.imul(k7, H6) | 0, n34 = (n34 = n34 + Math.imul(k7, J7) | 0) + Math.imul(A7, H6) | 0, e22 = e22 + Math.imul(A7, J7) | 0, h19 = h19 + Math.imul(y11, G6) | 0, n34 = (n34 = n34 + Math.imul(y11, Q6) | 0) + Math.imul(b11, G6) | 0, e22 = e22 + Math.imul(b11, Q6) | 0, h19 = h19 + Math.imul(g11, W7) | 0, n34 = (n34 = n34 + Math.imul(g11, X6) | 0) + Math.imul(c17, W7) | 0, e22 = e22 + Math.imul(c17, X6) | 0, h19 = h19 + Math.imul(p25, $7) | 0, n34 = (n34 = n34 + Math.imul(p25, tt4) | 0) + Math.imul(M8, $7) | 0, e22 = e22 + Math.imul(M8, tt4) | 0;
        var bt = (a37 + (h19 = h19 + Math.imul(m12, rt1) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(m12, ht1) | 0) + Math.imul(f28, rt1) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(f28, ht1) | 0) + (n34 >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, h19 = Math.imul(q7, F8), n34 = (n34 = Math.imul(q7, C7)) + Math.imul(B9, F8) | 0, e22 = Math.imul(B9, C7), h19 = h19 + Math.imul(S6, H6) | 0, n34 = (n34 = n34 + Math.imul(S6, J7) | 0) + Math.imul(Z7, H6) | 0, e22 = e22 + Math.imul(Z7, J7) | 0, h19 = h19 + Math.imul(k7, G6) | 0, n34 = (n34 = n34 + Math.imul(k7, Q6) | 0) + Math.imul(A7, G6) | 0, e22 = e22 + Math.imul(A7, Q6) | 0, h19 = h19 + Math.imul(y11, W7) | 0, n34 = (n34 = n34 + Math.imul(y11, X6) | 0) + Math.imul(b11, W7) | 0, e22 = e22 + Math.imul(b11, X6) | 0, h19 = h19 + Math.imul(g11, $7) | 0, n34 = (n34 = n34 + Math.imul(g11, tt4) | 0) + Math.imul(c17, $7) | 0, e22 = e22 + Math.imul(c17, tt4) | 0, h19 = h19 + Math.imul(p25, rt1) | 0, n34 = (n34 = n34 + Math.imul(p25, ht1) | 0) + Math.imul(M8, rt1) | 0, e22 = e22 + Math.imul(M8, ht1) | 0;
        var _t1 = (a37 + (h19 = h19 + Math.imul(m12, et3) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(m12, ot) | 0) + Math.imul(f28, et3) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(f28, ot) | 0) + (n34 >>> 13) | 0) + (_t1 >>> 26) | 0, _t1 &= 67108863, h19 = Math.imul(L8, F8), n34 = (n34 = Math.imul(L8, C7)) + Math.imul(I9, F8) | 0, e22 = Math.imul(I9, C7), h19 = h19 + Math.imul(q7, H6) | 0, n34 = (n34 = n34 + Math.imul(q7, J7) | 0) + Math.imul(B9, H6) | 0, e22 = e22 + Math.imul(B9, J7) | 0, h19 = h19 + Math.imul(S6, G6) | 0, n34 = (n34 = n34 + Math.imul(S6, Q6) | 0) + Math.imul(Z7, G6) | 0, e22 = e22 + Math.imul(Z7, Q6) | 0, h19 = h19 + Math.imul(k7, W7) | 0, n34 = (n34 = n34 + Math.imul(k7, X6) | 0) + Math.imul(A7, W7) | 0, e22 = e22 + Math.imul(A7, X6) | 0, h19 = h19 + Math.imul(y11, $7) | 0, n34 = (n34 = n34 + Math.imul(y11, tt4) | 0) + Math.imul(b11, $7) | 0, e22 = e22 + Math.imul(b11, tt4) | 0, h19 = h19 + Math.imul(g11, rt1) | 0, n34 = (n34 = n34 + Math.imul(g11, ht1) | 0) + Math.imul(c17, rt1) | 0, e22 = e22 + Math.imul(c17, ht1) | 0, h19 = h19 + Math.imul(p25, et3) | 0, n34 = (n34 = n34 + Math.imul(p25, ot) | 0) + Math.imul(M8, et3) | 0, e22 = e22 + Math.imul(M8, ot) | 0;
        var kt = (a37 + (h19 = h19 + Math.imul(m12, ut) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(m12, at1) | 0) + Math.imul(f28, ut) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(f28, at1) | 0) + (n34 >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, h19 = Math.imul(z8, F8), n34 = (n34 = Math.imul(z8, C7)) + Math.imul(E9, F8) | 0, e22 = Math.imul(E9, C7), h19 = h19 + Math.imul(L8, H6) | 0, n34 = (n34 = n34 + Math.imul(L8, J7) | 0) + Math.imul(I9, H6) | 0, e22 = e22 + Math.imul(I9, J7) | 0, h19 = h19 + Math.imul(q7, G6) | 0, n34 = (n34 = n34 + Math.imul(q7, Q6) | 0) + Math.imul(B9, G6) | 0, e22 = e22 + Math.imul(B9, Q6) | 0, h19 = h19 + Math.imul(S6, W7) | 0, n34 = (n34 = n34 + Math.imul(S6, X6) | 0) + Math.imul(Z7, W7) | 0, e22 = e22 + Math.imul(Z7, X6) | 0, h19 = h19 + Math.imul(k7, $7) | 0, n34 = (n34 = n34 + Math.imul(k7, tt4) | 0) + Math.imul(A7, $7) | 0, e22 = e22 + Math.imul(A7, tt4) | 0, h19 = h19 + Math.imul(y11, rt1) | 0, n34 = (n34 = n34 + Math.imul(y11, ht1) | 0) + Math.imul(b11, rt1) | 0, e22 = e22 + Math.imul(b11, ht1) | 0, h19 = h19 + Math.imul(g11, et3) | 0, n34 = (n34 = n34 + Math.imul(g11, ot) | 0) + Math.imul(c17, et3) | 0, e22 = e22 + Math.imul(c17, ot) | 0, h19 = h19 + Math.imul(p25, ut) | 0, n34 = (n34 = n34 + Math.imul(p25, at1) | 0) + Math.imul(M8, ut) | 0, e22 = e22 + Math.imul(M8, at1) | 0;
        var At = (a37 + (h19 = h19 + Math.imul(m12, mt) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(m12, ft) | 0) + Math.imul(f28, mt) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(f28, ft) | 0) + (n34 >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, h19 = Math.imul(j7, F8), n34 = (n34 = Math.imul(j7, C7)) + Math.imul(K5, F8) | 0, e22 = Math.imul(K5, C7), h19 = h19 + Math.imul(z8, H6) | 0, n34 = (n34 = n34 + Math.imul(z8, J7) | 0) + Math.imul(E9, H6) | 0, e22 = e22 + Math.imul(E9, J7) | 0, h19 = h19 + Math.imul(L8, G6) | 0, n34 = (n34 = n34 + Math.imul(L8, Q6) | 0) + Math.imul(I9, G6) | 0, e22 = e22 + Math.imul(I9, Q6) | 0, h19 = h19 + Math.imul(q7, W7) | 0, n34 = (n34 = n34 + Math.imul(q7, X6) | 0) + Math.imul(B9, W7) | 0, e22 = e22 + Math.imul(B9, X6) | 0, h19 = h19 + Math.imul(S6, $7) | 0, n34 = (n34 = n34 + Math.imul(S6, tt4) | 0) + Math.imul(Z7, $7) | 0, e22 = e22 + Math.imul(Z7, tt4) | 0, h19 = h19 + Math.imul(k7, rt1) | 0, n34 = (n34 = n34 + Math.imul(k7, ht1) | 0) + Math.imul(A7, rt1) | 0, e22 = e22 + Math.imul(A7, ht1) | 0, h19 = h19 + Math.imul(y11, et3) | 0, n34 = (n34 = n34 + Math.imul(y11, ot) | 0) + Math.imul(b11, et3) | 0, e22 = e22 + Math.imul(b11, ot) | 0, h19 = h19 + Math.imul(g11, ut) | 0, n34 = (n34 = n34 + Math.imul(g11, at1) | 0) + Math.imul(c17, ut) | 0, e22 = e22 + Math.imul(c17, at1) | 0, h19 = h19 + Math.imul(p25, mt) | 0, n34 = (n34 = n34 + Math.imul(p25, ft) | 0) + Math.imul(M8, mt) | 0, e22 = e22 + Math.imul(M8, ft) | 0;
        var xt = (a37 + (h19 = h19 + Math.imul(m12, pt) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(m12, Mt) | 0) + Math.imul(f28, pt) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(f28, Mt) | 0) + (n34 >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, h19 = Math.imul(j7, H6), n34 = (n34 = Math.imul(j7, J7)) + Math.imul(K5, H6) | 0, e22 = Math.imul(K5, J7), h19 = h19 + Math.imul(z8, G6) | 0, n34 = (n34 = n34 + Math.imul(z8, Q6) | 0) + Math.imul(E9, G6) | 0, e22 = e22 + Math.imul(E9, Q6) | 0, h19 = h19 + Math.imul(L8, W7) | 0, n34 = (n34 = n34 + Math.imul(L8, X6) | 0) + Math.imul(I9, W7) | 0, e22 = e22 + Math.imul(I9, X6) | 0, h19 = h19 + Math.imul(q7, $7) | 0, n34 = (n34 = n34 + Math.imul(q7, tt4) | 0) + Math.imul(B9, $7) | 0, e22 = e22 + Math.imul(B9, tt4) | 0, h19 = h19 + Math.imul(S6, rt1) | 0, n34 = (n34 = n34 + Math.imul(S6, ht1) | 0) + Math.imul(Z7, rt1) | 0, e22 = e22 + Math.imul(Z7, ht1) | 0, h19 = h19 + Math.imul(k7, et3) | 0, n34 = (n34 = n34 + Math.imul(k7, ot) | 0) + Math.imul(A7, et3) | 0, e22 = e22 + Math.imul(A7, ot) | 0, h19 = h19 + Math.imul(y11, ut) | 0, n34 = (n34 = n34 + Math.imul(y11, at1) | 0) + Math.imul(b11, ut) | 0, e22 = e22 + Math.imul(b11, at1) | 0, h19 = h19 + Math.imul(g11, mt) | 0, n34 = (n34 = n34 + Math.imul(g11, ft) | 0) + Math.imul(c17, mt) | 0, e22 = e22 + Math.imul(c17, ft) | 0;
        var St = (a37 + (h19 = h19 + Math.imul(p25, pt) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(p25, Mt) | 0) + Math.imul(M8, pt) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(M8, Mt) | 0) + (n34 >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, h19 = Math.imul(j7, G6), n34 = (n34 = Math.imul(j7, Q6)) + Math.imul(K5, G6) | 0, e22 = Math.imul(K5, Q6), h19 = h19 + Math.imul(z8, W7) | 0, n34 = (n34 = n34 + Math.imul(z8, X6) | 0) + Math.imul(E9, W7) | 0, e22 = e22 + Math.imul(E9, X6) | 0, h19 = h19 + Math.imul(L8, $7) | 0, n34 = (n34 = n34 + Math.imul(L8, tt4) | 0) + Math.imul(I9, $7) | 0, e22 = e22 + Math.imul(I9, tt4) | 0, h19 = h19 + Math.imul(q7, rt1) | 0, n34 = (n34 = n34 + Math.imul(q7, ht1) | 0) + Math.imul(B9, rt1) | 0, e22 = e22 + Math.imul(B9, ht1) | 0, h19 = h19 + Math.imul(S6, et3) | 0, n34 = (n34 = n34 + Math.imul(S6, ot) | 0) + Math.imul(Z7, et3) | 0, e22 = e22 + Math.imul(Z7, ot) | 0, h19 = h19 + Math.imul(k7, ut) | 0, n34 = (n34 = n34 + Math.imul(k7, at1) | 0) + Math.imul(A7, ut) | 0, e22 = e22 + Math.imul(A7, at1) | 0, h19 = h19 + Math.imul(y11, mt) | 0, n34 = (n34 = n34 + Math.imul(y11, ft) | 0) + Math.imul(b11, mt) | 0, e22 = e22 + Math.imul(b11, ft) | 0;
        var Zt = (a37 + (h19 = h19 + Math.imul(g11, pt) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(g11, Mt) | 0) + Math.imul(c17, pt) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(c17, Mt) | 0) + (n34 >>> 13) | 0) + (Zt >>> 26) | 0, Zt &= 67108863, h19 = Math.imul(j7, W7), n34 = (n34 = Math.imul(j7, X6)) + Math.imul(K5, W7) | 0, e22 = Math.imul(K5, X6), h19 = h19 + Math.imul(z8, $7) | 0, n34 = (n34 = n34 + Math.imul(z8, tt4) | 0) + Math.imul(E9, $7) | 0, e22 = e22 + Math.imul(E9, tt4) | 0, h19 = h19 + Math.imul(L8, rt1) | 0, n34 = (n34 = n34 + Math.imul(L8, ht1) | 0) + Math.imul(I9, rt1) | 0, e22 = e22 + Math.imul(I9, ht1) | 0, h19 = h19 + Math.imul(q7, et3) | 0, n34 = (n34 = n34 + Math.imul(q7, ot) | 0) + Math.imul(B9, et3) | 0, e22 = e22 + Math.imul(B9, ot) | 0, h19 = h19 + Math.imul(S6, ut) | 0, n34 = (n34 = n34 + Math.imul(S6, at1) | 0) + Math.imul(Z7, ut) | 0, e22 = e22 + Math.imul(Z7, at1) | 0, h19 = h19 + Math.imul(k7, mt) | 0, n34 = (n34 = n34 + Math.imul(k7, ft) | 0) + Math.imul(A7, mt) | 0, e22 = e22 + Math.imul(A7, ft) | 0;
        var Rt = (a37 + (h19 = h19 + Math.imul(y11, pt) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(y11, Mt) | 0) + Math.imul(b11, pt) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(b11, Mt) | 0) + (n34 >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, h19 = Math.imul(j7, $7), n34 = (n34 = Math.imul(j7, tt4)) + Math.imul(K5, $7) | 0, e22 = Math.imul(K5, tt4), h19 = h19 + Math.imul(z8, rt1) | 0, n34 = (n34 = n34 + Math.imul(z8, ht1) | 0) + Math.imul(E9, rt1) | 0, e22 = e22 + Math.imul(E9, ht1) | 0, h19 = h19 + Math.imul(L8, et3) | 0, n34 = (n34 = n34 + Math.imul(L8, ot) | 0) + Math.imul(I9, et3) | 0, e22 = e22 + Math.imul(I9, ot) | 0, h19 = h19 + Math.imul(q7, ut) | 0, n34 = (n34 = n34 + Math.imul(q7, at1) | 0) + Math.imul(B9, ut) | 0, e22 = e22 + Math.imul(B9, at1) | 0, h19 = h19 + Math.imul(S6, mt) | 0, n34 = (n34 = n34 + Math.imul(S6, ft) | 0) + Math.imul(Z7, mt) | 0, e22 = e22 + Math.imul(Z7, ft) | 0;
        var qt = (a37 + (h19 = h19 + Math.imul(k7, pt) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(k7, Mt) | 0) + Math.imul(A7, pt) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(A7, Mt) | 0) + (n34 >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, h19 = Math.imul(j7, rt1), n34 = (n34 = Math.imul(j7, ht1)) + Math.imul(K5, rt1) | 0, e22 = Math.imul(K5, ht1), h19 = h19 + Math.imul(z8, et3) | 0, n34 = (n34 = n34 + Math.imul(z8, ot) | 0) + Math.imul(E9, et3) | 0, e22 = e22 + Math.imul(E9, ot) | 0, h19 = h19 + Math.imul(L8, ut) | 0, n34 = (n34 = n34 + Math.imul(L8, at1) | 0) + Math.imul(I9, ut) | 0, e22 = e22 + Math.imul(I9, at1) | 0, h19 = h19 + Math.imul(q7, mt) | 0, n34 = (n34 = n34 + Math.imul(q7, ft) | 0) + Math.imul(B9, mt) | 0, e22 = e22 + Math.imul(B9, ft) | 0;
        var Bt = (a37 + (h19 = h19 + Math.imul(S6, pt) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(S6, Mt) | 0) + Math.imul(Z7, pt) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(Z7, Mt) | 0) + (n34 >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, h19 = Math.imul(j7, et3), n34 = (n34 = Math.imul(j7, ot)) + Math.imul(K5, et3) | 0, e22 = Math.imul(K5, ot), h19 = h19 + Math.imul(z8, ut) | 0, n34 = (n34 = n34 + Math.imul(z8, at1) | 0) + Math.imul(E9, ut) | 0, e22 = e22 + Math.imul(E9, at1) | 0, h19 = h19 + Math.imul(L8, mt) | 0, n34 = (n34 = n34 + Math.imul(L8, ft) | 0) + Math.imul(I9, mt) | 0, e22 = e22 + Math.imul(I9, ft) | 0;
        var Nt = (a37 + (h19 = h19 + Math.imul(q7, pt) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(q7, Mt) | 0) + Math.imul(B9, pt) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(B9, Mt) | 0) + (n34 >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, h19 = Math.imul(j7, ut), n34 = (n34 = Math.imul(j7, at1)) + Math.imul(K5, ut) | 0, e22 = Math.imul(K5, at1), h19 = h19 + Math.imul(z8, mt) | 0, n34 = (n34 = n34 + Math.imul(z8, ft) | 0) + Math.imul(E9, mt) | 0, e22 = e22 + Math.imul(E9, ft) | 0;
        var Lt = (a37 + (h19 = h19 + Math.imul(L8, pt) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(L8, Mt) | 0) + Math.imul(I9, pt) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(I9, Mt) | 0) + (n34 >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, h19 = Math.imul(j7, mt), n34 = (n34 = Math.imul(j7, ft)) + Math.imul(K5, mt) | 0, e22 = Math.imul(K5, ft);
        var It = (a37 + (h19 = h19 + Math.imul(z8, pt) | 0) | 0) + ((8191 & (n34 = (n34 = n34 + Math.imul(z8, Mt) | 0) + Math.imul(E9, pt) | 0)) << 13) | 0;
        a37 = ((e22 = e22 + Math.imul(E9, Mt) | 0) + (n34 >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863;
        var Tt = (a37 + (h19 = Math.imul(j7, pt)) | 0) + ((8191 & (n34 = (n34 = Math.imul(j7, Mt)) + Math.imul(K5, pt) | 0)) << 13) | 0;
        return (a37 = ((e22 = Math.imul(K5, Mt)) + (n34 >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, u28[0] = vt, u28[1] = gt, u28[2] = ct, u28[3] = wt, u28[4] = yt, u28[5] = bt, u28[6] = _t1, u28[7] = kt, u28[8] = At, u28[9] = xt, u28[10] = St, u28[11] = Zt, u28[12] = Rt, u28[13] = qt, u28[14] = Bt, u28[15] = Nt, u28[16] = Lt, u28[17] = It, u28[18] = Tt, 0 !== a37 && (u28[19] = a37, r28.length++), r28);
    };

    function M8(t20, i38, r28) {
        return (new v14).mulp(t20, i38, r28);
    }

    function v14(t20, r28) {
        (this || i$31).x = t20, (this || i$31).y = r28;
    }

    Math.imul || (p25 = d15), o29.prototype.mulTo = function (t20, r28) {
        var h19 = (this || i$31).length + t20.length;
        return 10 === (this || i$31).length && 10 === t20.length ? p25(this || i$31, t20, r28) : h19 < 63 ? d15(this || i$31, t20, r28) : h19 < 1024 ? (function (t21, i38, r29) {
            r29.negative = i38.negative ^ t21.negative, r29.length = t21.length + i38.length;
            for (var h20 = 0, n34 = 0, e22 = 0; e22 < r29.length - 1; e22++) {
                var o32 = n34;
                n34 = 0;
                for (var s24 = 67108863 & h20, u28 = Math.min(e22, i38.length - 1), a37 = Math.max(0, e22 - t21.length + 1); a37 <= u28; a37++) {
                    var l32 = e22 - a37, m12 = (0 | t21.words[l32]) * (0 | i38.words[a37]), f28 = 67108863 & m12;
                    s24 = 67108863 & (f28 = f28 + s24 | 0), n34 += (o32 = (o32 = o32 + (m12 / 67108864 | 0) | 0) + (f28 >>> 26) | 0) >>> 26, o32 &= 67108863;
                }
                r29.words[e22] = s24, h20 = o32, o32 = n34;
            }
            return 0 !== h20 ? r29.words[e22] = h20 : r29.length--, r29.strip();
        })(this || i$31, t20, r28) : M8(this || i$31, t20, r28);
    }, v14.prototype.makeRBT = function (t20) {
        for (var i38 = new Array(t20), r28 = o29.prototype._countBits(t20) - 1, h19 = 0; h19 < t20; h19++) {
            i38[h19] = this.revBin(h19, r28, t20);
        }
        return i38;
    }, v14.prototype.revBin = function (t20, i38, r28) {
        if (0 === t20 || t20 === r28 - 1) {
            return t20;
        }
        for (var h19 = 0, n34 = 0; n34 < i38; n34++) {
            h19 |= (1 & t20) << i38 - n34 - 1, t20 >>= 1;
        }
        return h19;
    }, v14.prototype.permute = function (t20, i38, r28, h19, n34, e22) {
        for (var o33 = 0; o33 < e22; o33++) {
            h19[o33] = i38[t20[o33]], n34[o33] = r28[t20[o33]];
        }
    }, v14.prototype.transform = function (t20, i38, r28, h19, n34, e22) {
        this.permute(e22, t20, i38, r28, h19, n34);
        for (var o33 = 1; o33 < n34; o33 <<= 1) {
            for (var s25 = o33 << 1, u29 = Math.cos(2 * Math.PI / s25), a38 = Math.sin(2 * Math.PI / s25), l33 = 0; l33 < n34; l33 += s25) {
                for (var m13 = u29, f29 = a38, d17 = 0; d17 < o33; d17++) {
                    var p26 = r28[l33 + d17], M9 = h19[l33 + d17], v15 = r28[l33 + d17 + o33],
                            g11 = h19[l33 + d17 + o33],
                            c17 = m13 * v15 - f29 * g11;
                    g11 = m13 * g11 + f29 * v15, v15 = c17, r28[l33 + d17] = p26 + v15, h19[l33 + d17] = M9 + g11, r28[l33 + d17 + o33] = p26 - v15, h19[l33 + d17 + o33] = M9 - g11, d17 !== s25 && (c17 = u29 * m13 - a38 * f29, f29 = u29 * f29 + a38 * m13, m13 = c17);
                }
            }
        }
    }, v14.prototype.guessLen13b = function (t20, i38) {
        var r28 = 1 | Math.max(i38, t20), h19 = 1 & r28, n34 = 0;
        for (r28 = r28 / 2 | 0; r28; r28 >>>= 1) {
            n34++;
        }
        return 1 << n34 + 1 + h19;
    }, v14.prototype.conjugate = function (t20, i38, r28) {
        if (!(r28 <= 1)) {
            for (var h19 = 0; h19 < r28 / 2; h19++) {
                var n34 = t20[h19];
                t20[h19] = t20[r28 - h19 - 1], t20[r28 - h19 - 1] = n34, n34 = i38[h19], i38[h19] = -i38[r28 - h19 - 1], i38[r28 - h19 - 1] = -n34;
            }
        }
    }, v14.prototype.normalize13b = function (t20, i38) {
        for (var r28 = 0, h19 = 0; h19 < i38 / 2; h19++) {
            var n35 = 8192 * Math.round(t20[2 * h19 + 1] / i38) + Math.round(t20[2 * h19] / i38) + r28;
            t20[h19] = 67108863 & n35, r28 = n35 < 67108864 ? 0 : n35 / 67108864 | 0;
        }
        return t20;
    }, v14.prototype.convert13b = function (t20, i38, r28, h19) {
        for (var e22 = 0, o33 = 0; o33 < i38; o33++) {
            e22 += 0 | t20[o33], r28[2 * o33] = 8191 & e22, e22 >>>= 13, r28[2 * o33 + 1] = 8191 & e22, e22 >>>= 13;
        }
        for (o33 = 2 * i38; o33 < h19; ++o33) {
            r28[o33] = 0;
        }
        n33(0 === e22), n33(0 == (-8192 & e22));
    }, v14.prototype.stub = function (t20) {
        for (var i38 = new Array(t20), r28 = 0; r28 < t20; r28++) {
            i38[r28] = 0;
        }
        return i38;
    }, v14.prototype.mulp = function (t20, i38, r28) {
        var h19 = 2 * this.guessLen13b(t20.length, i38.length), n36 = this.makeRBT(h19), e22 = this.stub(h19),
                o33 = new Array(h19), s25 = new Array(h19), u29 = new Array(h19), a38 = new Array(h19),
                l33 = new Array(h19), m13 = new Array(h19), f29 = r28.words;
        f29.length = h19, this.convert13b(t20.words, t20.length, o33, h19), this.convert13b(i38.words, i38.length, a38, h19), this.transform(o33, e22, s25, u29, h19, n36), this.transform(a38, e22, l33, m13, h19, n36);
        for (var d17 = 0; d17 < h19; d17++) {
            var p27 = s25[d17] * l33[d17] - u29[d17] * m13[d17];
            u29[d17] = s25[d17] * m13[d17] + u29[d17] * l33[d17], s25[d17] = p27;
        }
        return this.conjugate(s25, u29, h19), this.transform(s25, u29, f29, e22, h19, n36), this.conjugate(f29, e22, h19), this.normalize13b(f29, h19), r28.negative = t20.negative ^ i38.negative, r28.length = t20.length + i38.length, r28.strip();
    }, o29.prototype.mul = function (t20) {
        var r28 = new o29(null);
        return r28.words = new Array((this || i$31).length + t20.length), this.mulTo(t20, r28);
    }, o29.prototype.mulf = function (t20) {
        var r28 = new o29(null);
        return r28.words = new Array((this || i$31).length + t20.length), M8(this || i$31, t20, r28);
    }, o29.prototype.imul = function (t20) {
        return this.clone().mulTo(t20, this || i$31);
    }, o29.prototype.imuln = function (t20) {
        n33("number" == typeof t20), n33(t20 < 67108864);
        for (var r28 = 0, h19 = 0; h19 < (this || i$31).length; h19++) {
            var e22 = (0 | (this || i$31).words[h19]) * t20, o33 = (67108863 & e22) + (67108863 & r28);
            r28 >>= 26, r28 += e22 / 67108864 | 0, r28 += o33 >>> 26, (this || i$31).words[h19] = 67108863 & o33;
        }
        return 0 !== r28 && ((this || i$31).words[h19] = r28, (this || i$31).length++), this || i$31;
    }, o29.prototype.muln = function (t20) {
        return this.clone().imuln(t20);
    }, o29.prototype.sqr = function () {
        return this.mul(this || i$31);
    }, o29.prototype.isqr = function () {
        return this.imul(this.clone());
    }, o29.prototype.pow = function (t20) {
        var r28 = function (t21) {
            for (var i38 = new Array(t21.bitLength()), r28 = 0; r28 < i38.length; r28++) {
                var h19 = r28 / 26 | 0, n36 = r28 % 26;
                i38[r28] = (t21.words[h19] & 1 << n36) >>> n36;
            }
            return i38;
        }(t20);
        if (0 === r28.length) {
            return new o29(1);
        }
        for (var h20 = this || i$31, n37 = 0; n37 < r28.length && 0 === r28[n37]; n37++, h20 = h20.sqr()) {
            ;
        }
        if ((++n37) < r28.length) {
            for (var e23 = h20.sqr(); n37 < r28.length; n37++, e23 = e23.sqr()) {
                0 !== r28[n37] && (h20 = h20.mul(e23));
            }
        }
        return h20;
    }, o29.prototype.iushln = function (t20) {
        n33("number" == typeof t20 && t20 >= 0);
        var r28, h20 = t20 % 26, e23 = (t20 - h20) / 26, o34 = 67108863 >>> 26 - h20 << 26 - h20;
        if (0 !== h20) {
            var s25 = 0;
            for (r28 = 0; r28 < (this || i$31).length; r28++) {
                var u29 = (this || i$31).words[r28] & o34, a38 = (0 | (this || i$31).words[r28]) - u29 << h20;
                (this || i$31).words[r28] = a38 | s25, s25 = u29 >>> 26 - h20;
            }
            s25 && ((this || i$31).words[r28] = s25, (this || i$31).length++);
        }
        if (0 !== e23) {
            for (r28 = (this || i$31).length - 1; r28 >= 0; r28--) {
                (this || i$31).words[r28 + e23] = (this || i$31).words[r28];
            }
            for (r28 = 0; r28 < e23; r28++) {
                (this || i$31).words[r28] = 0;
            }
            (this || i$31).length += e23;
        }
        return this.strip();
    }, o29.prototype.ishln = function (t20) {
        return n33(0 === (this || i$31).negative), this.iushln(t20);
    }, o29.prototype.iushrn = function (t20, r28, h20) {
        var e23;
        n33("number" == typeof t20 && t20 >= 0), e23 = r28 ? (r28 - r28 % 26) / 26 : 0;
        var o34 = t20 % 26, s26 = Math.min((t20 - o34) / 26, (this || i$31).length),
                u30 = 67108863 ^ 67108863 >>> o34 << o34, a39 = h20;
        if (e23 -= s26, e23 = Math.max(0, e23), a39) {
            for (var l33 = 0; l33 < s26; l33++) {
                a39.words[l33] = (this || i$31).words[l33];
            }
            a39.length = s26;
        }
        if (0 === s26) {
            ;
        } else if ((this || i$31).length > s26) {
            for ((this || i$31).length -= s26, l33 = 0; l33 < (this || i$31).length; l33++) {
                (this || i$31).words[l33] = (this || i$31).words[l33 + s26];
            }
        } else {
            (this || i$31).words[0] = 0, (this || i$31).length = 1;
        }
        var m13 = 0;
        for (l33 = (this || i$31).length - 1; l33 >= 0 && (0 !== m13 || l33 >= e23); l33--) {
            var f29 = 0 | (this || i$31).words[l33];
            (this || i$31).words[l33] = m13 << 26 - o34 | f29 >>> o34, m13 = f29 & u30;
        }
        return a39 && 0 !== m13 && (a39.words[a39.length++] = m13), 0 === (this || i$31).length && ((this || i$31).words[0] = 0, (this || i$31).length = 1), this.strip();
    }, o29.prototype.ishrn = function (t20, r28, h20) {
        return n33(0 === (this || i$31).negative), this.iushrn(t20, r28, h20);
    }, o29.prototype.shln = function (t20) {
        return this.clone().ishln(t20);
    }, o29.prototype.ushln = function (t20) {
        return this.clone().iushln(t20);
    }, o29.prototype.shrn = function (t20) {
        return this.clone().ishrn(t20);
    }, o29.prototype.ushrn = function (t20) {
        return this.clone().iushrn(t20);
    }, o29.prototype.testn = function (t20) {
        n33("number" == typeof t20 && t20 >= 0);
        var r28 = t20 % 26, h20 = (t20 - r28) / 26, e23 = 1 << r28;
        return !((this || i$31).length <= h20) && !!((this || i$31).words[h20] & e23);
    }, o29.prototype.imaskn = function (t20) {
        n33("number" == typeof t20 && t20 >= 0);
        var r28 = t20 % 26, h20 = (t20 - r28) / 26;
        if (n33(0 === (this || i$31).negative, "imaskn works only with positive numbers"), (this || i$31).length <= h20) {
            return this || i$31;
        }
        if (0 !== r28 && h20++, (this || i$31).length = Math.min(h20, (this || i$31).length), 0 !== r28) {
            var e23 = 67108863 ^ 67108863 >>> r28 << r28;
            (this || i$31).words[(this || i$31).length - 1] &= e23;
        }
        return this.strip();
    }, o29.prototype.maskn = function (t20) {
        return this.clone().imaskn(t20);
    }, o29.prototype.iaddn = function (t20) {
        return n33("number" == typeof t20), n33(t20 < 67108864), t20 < 0 ? this.isubn(-t20) : 0 !== (this || i$31).negative ? 1 === (this || i$31).length && (0 | (this || i$31).words[0]) < t20 ? ((this || i$31).words[0] = t20 - (0 | (this || i$31).words[0]), (this || i$31).negative = 0, this || i$31) : ((this || i$31).negative = 0, this.isubn(t20), (this || i$31).negative = 1, this || i$31) : this._iaddn(t20);
    }, o29.prototype._iaddn = function (t20) {
        (this || i$31).words[0] += t20;
        for (var r28 = 0; r28 < (this || i$31).length && (this || i$31).words[r28] >= 67108864; r28++) {
            (this || i$31).words[r28] -= 67108864, r28 === (this || i$31).length - 1 ? (this || i$31).words[r28 + 1] = 1 : (this || i$31).words[r28 + 1]++;
        }
        return (this || i$31).length = Math.max((this || i$31).length, r28 + 1), this || i$31;
    }, o29.prototype.isubn = function (t20) {
        if (n33("number" == typeof t20), n33(t20 < 67108864), t20 < 0) {
            return this.iaddn(-t20);
        }
        if (0 !== (this || i$31).negative) {
            return (this || i$31).negative = 0, this.iaddn(t20), (this || i$31).negative = 1, this || i$31;
        }
        if ((this || i$31).words[0] -= t20, 1 === (this || i$31).length && (this || i$31).words[0] < 0) {
            (this || i$31).words[0] = -(this || i$31).words[0], (this || i$31).negative = 1;
        } else {
            for (var r28 = 0; r28 < (this || i$31).length && (this || i$31).words[r28] < 0; r28++) {
                (this || i$31).words[r28] += 67108864, (this || i$31).words[r28 + 1] -= 1;
            }
        }
        return this.strip();
    }, o29.prototype.addn = function (t20) {
        return this.clone().iaddn(t20);
    }, o29.prototype.subn = function (t20) {
        return this.clone().isubn(t20);
    }, o29.prototype.iabs = function () {
        return (this || i$31).negative = 0, this || i$31;
    }, o29.prototype.abs = function () {
        return this.clone().iabs();
    }, o29.prototype._ishlnsubmul = function (t20, r28, h20) {
        var e24, o34, s26 = t20.length + h20;
        this._expand(s26);
        var u30 = 0;
        for (e24 = 0; e24 < t20.length; e24++) {
            o34 = (0 | (this || i$31).words[e24 + h20]) + u30;
            var a39 = (0 | t20.words[e24]) * r28;
            u30 = ((o34 -= 67108863 & a39) >> 26) - (a39 / 67108864 | 0), (this || i$31).words[e24 + h20] = 67108863 & o34;
        }
        for (; e24 < (this || i$31).length - h20; e24++) {
            u30 = (o34 = (0 | (this || i$31).words[e24 + h20]) + u30) >> 26, (this || i$31).words[e24 + h20] = 67108863 & o34;
        }
        if (0 === u30) {
            return this.strip();
        }
        for (n33(-1 === u30), u30 = 0, e24 = 0; e24 < (this || i$31).length; e24++) {
            u30 = (o34 = -(0 | (this || i$31).words[e24]) + u30) >> 26, (this || i$31).words[e24] = 67108863 & o34;
        }
        return (this || i$31).negative = 1, this.strip();
    }, o29.prototype._wordDiv = function (t20, r28) {
        var h20 = ((this || i$31).length, t20.length), n37 = this.clone(), e24 = t20,
                s26 = 0 | e24.words[e24.length - 1];
        0 !== (h20 = 26 - this._countBits(s26)) && (e24 = e24.ushln(h20), n37.iushln(h20), s26 = 0 | e24.words[e24.length - 1]);
        var u30, a40 = n37.length - e24.length;
        if ("mod" !== r28) {
            (u30 = new o29(null)).length = a40 + 1, u30.words = new Array(u30.length);
            for (var l34 = 0; l34 < u30.length; l34++) {
                u30.words[l34] = 0;
            }
        }
        var m13 = n37.clone()._ishlnsubmul(e24, 1, a40);
        0 === m13.negative && (n37 = m13, u30 && (u30.words[a40] = 1));
        for (var f30 = a40 - 1; f30 >= 0; f30--) {
            var d17 = 67108864 * (0 | n37.words[e24.length + f30]) + (0 | n37.words[e24.length + f30 - 1]);
            for (d17 = Math.min(d17 / s26 | 0, 67108863), n37._ishlnsubmul(e24, d17, f30); 0 !== n37.negative;) {
                d17--, n37.negative = 0, n37._ishlnsubmul(e24, 1, f30), n37.isZero() || (n37.negative ^= 1);
            }
            u30 && (u30.words[f30] = d17);
        }
        return u30 && u30.strip(), n37.strip(), "div" !== r28 && 0 !== h20 && n37.iushrn(h20), {
            div: u30 || null,
            mod: n37
        };
    }, o29.prototype.divmod = function (t20, r28, h20) {
        return n33(!t20.isZero()), this.isZero() ? {
            div: new o29(0),
            mod: new o29(0)
        } : 0 !== (this || i$31).negative && 0 === t20.negative ? (u30 = this.neg().divmod(t20, r28), "mod" !== r28 && (e24 = u30.div.neg()), "div" !== r28 && (s26 = u30.mod.neg(), h20 && 0 !== s26.negative && s26.iadd(t20)), {
            div: e24,
            mod: s26
        }) : 0 === (this || i$31).negative && 0 !== t20.negative ? (u30 = this.divmod(t20.neg(), r28), "mod" !== r28 && (e24 = u30.div.neg()), {
            div: e24,
            mod: u30.mod
        }) : 0 != ((this || i$31).negative & t20.negative) ? (u30 = this.neg().divmod(t20.neg(), r28), "div" !== r28 && (s26 = u30.mod.neg(), h20 && 0 !== s26.negative && s26.isub(t20)), {
            div: u30.div,
            mod: s26
        }) : t20.length > (this || i$31).length || this.cmp(t20) < 0 ? {
            div: new o29(0),
            mod: this || i$31
        } : 1 === t20.length ? "div" === r28 ? {
            div: this.divn(t20.words[0]),
            mod: null
        } : "mod" === r28 ? {
            div: null,
            mod: new o29(this.modn(t20.words[0]))
        } : {
            div: this.divn(t20.words[0]),
            mod: new o29(this.modn(t20.words[0]))
        } : this._wordDiv(t20, r28);
        var e24, s26, u30;
    }, o29.prototype.div = function (t20) {
        return this.divmod(t20, "div", !1).div;
    }, o29.prototype.mod = function (t20) {
        return this.divmod(t20, "mod", !1).mod;
    }, o29.prototype.umod = function (t20) {
        return this.divmod(t20, "mod", !0).mod;
    }, o29.prototype.divRound = function (t20) {
        var i38 = this.divmod(t20);
        if (i38.mod.isZero()) {
            return i38.div;
        }
        var r28 = 0 !== i38.div.negative ? i38.mod.isub(t20) : i38.mod, h20 = t20.ushrn(1), n37 = t20.andln(1),
                e24 = r28.cmp(h20);
        return e24 < 0 || 1 === n37 && 0 === e24 ? i38.div : 0 !== i38.div.negative ? i38.div.isubn(1) : i38.div.iaddn(1);
    }, o29.prototype.modn = function (t20) {
        n33(t20 <= 67108863);
        for (var r28 = (1 << 26) % t20, h20 = 0, e24 = (this || i$31).length - 1; e24 >= 0; e24--) {
            h20 = (r28 * h20 + (0 | (this || i$31).words[e24])) % t20;
        }
        return h20;
    }, o29.prototype.idivn = function (t20) {
        n33(t20 <= 67108863);
        for (var r28 = 0, h20 = (this || i$31).length - 1; h20 >= 0; h20--) {
            var e24 = (0 | (this || i$31).words[h20]) + 67108864 * r28;
            (this || i$31).words[h20] = e24 / t20 | 0, r28 = e24 % t20;
        }
        return this.strip();
    }, o29.prototype.divn = function (t20) {
        return this.clone().idivn(t20);
    }, o29.prototype.egcd = function (t20) {
        n33(0 === t20.negative), n33(!t20.isZero());
        var r28 = this || i$31, h20 = t20.clone();
        r28 = 0 !== r28.negative ? r28.umod(t20) : r28.clone();
        for (var e25 = new o29(1), s26 = new o29(0), u30 = new o29(0), a40 = new o29(1), l35 = 0; r28.isEven() && h20.isEven();) {
            r28.iushrn(1), h20.iushrn(1), ++l35;
        }
        for (var m13 = h20.clone(), f30 = r28.clone(); !r28.isZero();) {
            for (var d18 = 0, p28 = 1; 0 == (r28.words[0] & p28) && d18 < 26; ++d18, p28 <<= 1) {
                ;
            }
            if (d18 > 0) {
                for (r28.iushrn(d18); (d18--) > 0;) {
                    (e25.isOdd() || s26.isOdd()) && (e25.iadd(m13), s26.isub(f30)), e25.iushrn(1), s26.iushrn(1);
                }
            }
            for (var M10 = 0, v16 = 1; 0 == (h20.words[0] & v16) && M10 < 26; ++M10, v16 <<= 1) {
                ;
            }
            if (M10 > 0) {
                for (h20.iushrn(M10); (M10--) > 0;) {
                    (u30.isOdd() || a40.isOdd()) && (u30.iadd(m13), a40.isub(f30)), u30.iushrn(1), a40.iushrn(1);
                }
            }
            r28.cmp(h20) >= 0 ? (r28.isub(h20), e25.isub(u30), s26.isub(a40)) : (h20.isub(r28), u30.isub(e25), a40.isub(s26));
        }
        return {
            a: u30,
            b: a40,
            gcd: h20.iushln(l35)
        };
    }, o29.prototype._invmp = function (t20) {
        n33(0 === t20.negative), n33(!t20.isZero());
        var r28 = this || i$31, h20 = t20.clone();
        r28 = 0 !== r28.negative ? r28.umod(t20) : r28.clone();
        for (var e25, s26 = new o29(1), u30 = new o29(0), a40 = h20.clone(); r28.cmpn(1) > 0 && h20.cmpn(1) > 0;) {
            for (var l35 = 0, m13 = 1; 0 == (r28.words[0] & m13) && l35 < 26; ++l35, m13 <<= 1) {
                ;
            }
            if (l35 > 0) {
                for (r28.iushrn(l35); (l35--) > 0;) {
                    s26.isOdd() && s26.iadd(a40), s26.iushrn(1);
                }
            }
            for (var f30 = 0, d19 = 1; 0 == (h20.words[0] & d19) && f30 < 26; ++f30, d19 <<= 1) {
                ;
            }
            if (f30 > 0) {
                for (h20.iushrn(f30); (f30--) > 0;) {
                    u30.isOdd() && u30.iadd(a40), u30.iushrn(1);
                }
            }
            r28.cmp(h20) >= 0 ? (r28.isub(h20), s26.isub(u30)) : (h20.isub(r28), u30.isub(s26));
        }
        return (e25 = 0 === r28.cmpn(1) ? s26 : u30).cmpn(0) < 0 && e25.iadd(t20), e25;
    }, o29.prototype.gcd = function (t20) {
        if (this.isZero()) {
            return t20.abs();
        }
        if (t20.isZero()) {
            return this.abs();
        }
        var i38 = this.clone(), r28 = t20.clone();
        i38.negative = 0, r28.negative = 0;
        for (var h20 = 0; i38.isEven() && r28.isEven(); h20++) {
            i38.iushrn(1), r28.iushrn(1);
        }
        for (; ;) {
            for (; i38.isEven();) {
                i38.iushrn(1);
            }
            for (; r28.isEven();) {
                r28.iushrn(1);
            }
            var n37 = i38.cmp(r28);
            if (n37 < 0) {
                var e25 = i38;
                i38 = r28, r28 = e25;
            } else if (0 === n37 || 0 === r28.cmpn(1)) {
                break;
            }
            i38.isub(r28);
        }
        return r28.iushln(h20);
    }, o29.prototype.invm = function (t20) {
        return this.egcd(t20).a.umod(t20);
    }, o29.prototype.isEven = function () {
        return 0 == (1 & (this || i$31).words[0]);
    }, o29.prototype.isOdd = function () {
        return 1 == (1 & (this || i$31).words[0]);
    }, o29.prototype.andln = function (t20) {
        return (this || i$31).words[0] & t20;
    }, o29.prototype.bincn = function (t20) {
        n33("number" == typeof t20);
        var r28 = t20 % 26, h20 = (t20 - r28) / 26, e26 = 1 << r28;
        if ((this || i$31).length <= h20) {
            return this._expand(h20 + 1), (this || i$31).words[h20] |= e26, this || i$31;
        }
        for (var o34 = e26, s26 = h20; 0 !== o34 && s26 < (this || i$31).length; s26++) {
            var u30 = 0 | (this || i$31).words[s26];
            o34 = (u30 += o34) >>> 26, u30 &= 67108863, (this || i$31).words[s26] = u30;
        }
        return 0 !== o34 && ((this || i$31).words[s26] = o34, (this || i$31).length++), this || i$31;
    }, o29.prototype.isZero = function () {
        return 1 === (this || i$31).length && 0 === (this || i$31).words[0];
    }, o29.prototype.cmpn = function (t20) {
        var r28, h20 = t20 < 0;
        if (0 !== (this || i$31).negative && !h20) {
            return -1;
        }
        if (0 === (this || i$31).negative && h20) {
            return 1;
        }
        if (this.strip(), (this || i$31).length > 1) {
            r28 = 1;
        } else {
            h20 && (t20 = -t20), n33(t20 <= 67108863, "Number is too big");
            var e26 = 0 | (this || i$31).words[0];
            r28 = e26 === t20 ? 0 : e26 < t20 ? -1 : 1;
        }
        return 0 !== (this || i$31).negative ? 0 | -r28 : r28;
    }, o29.prototype.cmp = function (t20) {
        if (0 !== (this || i$31).negative && 0 === t20.negative) {
            return -1;
        }
        if (0 === (this || i$31).negative && 0 !== t20.negative) {
            return 1;
        }
        var r28 = this.ucmp(t20);
        return 0 !== (this || i$31).negative ? 0 | -r28 : r28;
    }, o29.prototype.ucmp = function (t20) {
        if ((this || i$31).length > t20.length) {
            return 1;
        }
        if ((this || i$31).length < t20.length) {
            return -1;
        }
        for (var r28 = 0, h20 = (this || i$31).length - 1; h20 >= 0; h20--) {
            var n38 = 0 | (this || i$31).words[h20], e27 = 0 | t20.words[h20];
            if (n38 !== e27) {
                n38 < e27 ? r28 = -1 : n38 > e27 && (r28 = 1);
                break;
            }
        }
        return r28;
    }, o29.prototype.gtn = function (t20) {
        return 1 === this.cmpn(t20);
    }, o29.prototype.gt = function (t20) {
        return 1 === this.cmp(t20);
    }, o29.prototype.gten = function (t20) {
        return this.cmpn(t20) >= 0;
    }, o29.prototype.gte = function (t20) {
        return this.cmp(t20) >= 0;
    }, o29.prototype.ltn = function (t20) {
        return -1 === this.cmpn(t20);
    }, o29.prototype.lt = function (t20) {
        return -1 === this.cmp(t20);
    }, o29.prototype.lten = function (t20) {
        return this.cmpn(t20) <= 0;
    }, o29.prototype.lte = function (t20) {
        return this.cmp(t20) <= 0;
    }, o29.prototype.eqn = function (t20) {
        return 0 === this.cmpn(t20);
    }, o29.prototype.eq = function (t20) {
        return 0 === this.cmp(t20);
    }, o29.red = function (t20) {
        return new k7(t20);
    }, o29.prototype.toRed = function (t20) {
        return n33(!(this || i$31).red, "Already a number in reduction context"), n33(0 === (this || i$31).negative, "red works only with positives"), t20.convertTo(this || i$31)._forceRed(t20);
    }, o29.prototype.fromRed = function () {
        return n33((this || i$31).red, "fromRed works only with numbers in reduction context"), (this || i$31).red.convertFrom(this || i$31);
    }, o29.prototype._forceRed = function (t20) {
        return (this || i$31).red = t20, this || i$31;
    }, o29.prototype.forceRed = function (t20) {
        return n33(!(this || i$31).red, "Already a number in reduction context"), this._forceRed(t20);
    }, o29.prototype.redAdd = function (t20) {
        return n33((this || i$31).red, "redAdd works only with red numbers"), (this || i$31).red.add(this || i$31, t20);
    }, o29.prototype.redIAdd = function (t20) {
        return n33((this || i$31).red, "redIAdd works only with red numbers"), (this || i$31).red.iadd(this || i$31, t20);
    }, o29.prototype.redSub = function (t20) {
        return n33((this || i$31).red, "redSub works only with red numbers"), (this || i$31).red.sub(this || i$31, t20);
    }, o29.prototype.redISub = function (t20) {
        return n33((this || i$31).red, "redISub works only with red numbers"), (this || i$31).red.isub(this || i$31, t20);
    }, o29.prototype.redShl = function (t20) {
        return n33((this || i$31).red, "redShl works only with red numbers"), (this || i$31).red.shl(this || i$31, t20);
    }, o29.prototype.redMul = function (t20) {
        return n33((this || i$31).red, "redMul works only with red numbers"), (this || i$31).red._verify2(this || i$31, t20), (this || i$31).red.mul(this || i$31, t20);
    }, o29.prototype.redIMul = function (t20) {
        return n33((this || i$31).red, "redMul works only with red numbers"), (this || i$31).red._verify2(this || i$31, t20), (this || i$31).red.imul(this || i$31, t20);
    }, o29.prototype.redSqr = function () {
        return n33((this || i$31).red, "redSqr works only with red numbers"), (this || i$31).red._verify1(this || i$31), (this || i$31).red.sqr(this || i$31);
    }, o29.prototype.redISqr = function () {
        return n33((this || i$31).red, "redISqr works only with red numbers"), (this || i$31).red._verify1(this || i$31), (this || i$31).red.isqr(this || i$31);
    }, o29.prototype.redSqrt = function () {
        return n33((this || i$31).red, "redSqrt works only with red numbers"), (this || i$31).red._verify1(this || i$31), (this || i$31).red.sqrt(this || i$31);
    }, o29.prototype.redInvm = function () {
        return n33((this || i$31).red, "redInvm works only with red numbers"), (this || i$31).red._verify1(this || i$31), (this || i$31).red.invm(this || i$31);
    }, o29.prototype.redNeg = function () {
        return n33((this || i$31).red, "redNeg works only with red numbers"), (this || i$31).red._verify1(this || i$31), (this || i$31).red.neg(this || i$31);
    }, o29.prototype.redPow = function (t20) {
        return n33((this || i$31).red && !t20.red, "redPow(normalNum)"), (this || i$31).red._verify1(this || i$31), (this || i$31).red.pow(this || i$31, t20);
    };
    var g12 = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };

    function c18(t20, r28) {
        (this || i$31).name = t20, (this || i$31).p = new o29(r28, 16), (this || i$31).n = (this || i$31).p.bitLength(), (this || i$31).k = new o29(1).iushln((this || i$31).n).isub((this || i$31).p), (this || i$31).tmp = this._tmp();
    }

    function w6() {
        c18.call(this || i$31, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }

    function y11() {
        c18.call(this || i$31, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }

    function b11() {
        c18.call(this || i$31, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }

    function _12() {
        c18.call(this || i$31, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }

    function k7(t20) {
        if ("string" == typeof t20) {
            var r28 = o29._prime(t20);
            (this || i$31).m = r28.p, (this || i$31).prime = r28;
        } else {
            n33(t20.gtn(1), "modulus must be greater than 1"), (this || i$31).m = t20, (this || i$31).prime = null;
        }
    }

    function A7(t20) {
        k7.call(this || i$31, t20), (this || i$31).shift = (this || i$31).m.bitLength(), (this || i$31).shift % 26 != 0 && ((this || i$31).shift += 26 - (this || i$31).shift % 26), (this || i$31).r = new o29(1).iushln((this || i$31).shift), (this || i$31).r2 = this.imod((this || i$31).r.sqr()), (this || i$31).rinv = (this || i$31).r._invmp((this || i$31).m), (this || i$31).minv = (this || i$31).rinv.mul((this || i$31).r).isubn(1).div((this || i$31).m), (this || i$31).minv = (this || i$31).minv.umod((this || i$31).r), (this || i$31).minv = (this || i$31).r.sub((this || i$31).minv);
    }

    c18.prototype._tmp = function () {
        var t20 = new o29(null);
        return t20.words = new Array(Math.ceil((this || i$31).n / 13)), t20;
    }, c18.prototype.ireduce = function (t20) {
        var r29, h20 = t20;
        do {
            this.split(h20, (this || i$31).tmp), r29 = (h20 = (h20 = this.imulK(h20)).iadd((this || i$31).tmp)).bitLength();
        } while (r29 > (this || i$31).n)
        var n39 = r29 < (this || i$31).n ? -1 : h20.ucmp((this || i$31).p);
        return 0 === n39 ? (h20.words[0] = 0, h20.length = 1) : n39 > 0 ? h20.isub((this || i$31).p) : h20.strip(), h20;
    }, c18.prototype.split = function (t20, r29) {
        t20.iushrn((this || i$31).n, 0, r29);
    }, c18.prototype.imulK = function (t20) {
        return t20.imul((this || i$31).k);
    }, e20(w6, c18), w6.prototype.split = function (t20, i38) {
        for (var r29 = Math.min(t20.length, 9), h20 = 0; h20 < r29; h20++) {
            i38.words[h20] = t20.words[h20];
        }
        if (i38.length = r29, t20.length <= 9) {
            return t20.words[0] = 0, t20.length = 1, void 0;
        }
        var n39 = t20.words[9];
        for (i38.words[i38.length++] = 4194303 & n39, h20 = 10; h20 < t20.length; h20++) {
            var e28 = 0 | t20.words[h20];
            t20.words[h20 - 10] = (4194303 & e28) << 4 | n39 >>> 22, n39 = e28;
        }
        n39 >>>= 22, t20.words[h20 - 10] = n39, 0 === n39 && t20.length > 10 ? t20.length -= 10 : t20.length -= 9;
    }, w6.prototype.imulK = function (t20) {
        t20.words[t20.length] = 0, t20.words[t20.length + 1] = 0, t20.length += 2;
        for (var i38 = 0, r29 = 0; r29 < t20.length; r29++) {
            var h20 = 0 | t20.words[r29];
            i38 += 977 * h20, t20.words[r29] = 67108863 & i38, i38 = 64 * h20 + (i38 / 67108864 | 0);
        }
        return 0 === t20.words[t20.length - 1] && (t20.length--, 0 === t20.words[t20.length - 1] && t20.length--), t20;
    }, e20(y11, c18), e20(b11, c18), e20(_12, c18), _12.prototype.imulK = function (t20) {
        for (var i38 = 0, r29 = 0; r29 < t20.length; r29++) {
            var h21 = 19 * (0 | t20.words[r29]) + i38, n39 = 67108863 & h21;
            h21 >>>= 26, t20.words[r29] = n39, i38 = h21;
        }
        return 0 !== i38 && (t20.words[t20.length++] = i38), t20;
    }, o29._prime = function (t20) {
        if (g12[t20]) {
            return g12[t20];
        }
        var i38;
        if ("k256" === t20) {
            i38 = new w6;
        } else if ("p224" === t20) {
            i38 = new y11;
        } else if ("p192" === t20) {
            i38 = new b11;
        } else {
            if ("p25519" !== t20) {
                throw new Error("Unknown prime " + t20);
            }
            i38 = new _12;
        }
        return g12[t20] = i38, i38;
    }, k7.prototype._verify1 = function (t20) {
        n33(0 === t20.negative, "red works only with positives"), n33(t20.red, "red works only with red numbers");
    }, k7.prototype._verify2 = function (t20, i38) {
        n33(0 == (t20.negative | i38.negative), "red works only with positives"), n33(t20.red && t20.red === i38.red, "red works only with red numbers");
    }, k7.prototype.imod = function (t20) {
        return (this || i$31).prime ? (this || i$31).prime.ireduce(t20)._forceRed(this || i$31) : t20.umod((this || i$31).m)._forceRed(this || i$31);
    }, k7.prototype.neg = function (t20) {
        return t20.isZero() ? t20.clone() : (this || i$31).m.sub(t20)._forceRed(this || i$31);
    }, k7.prototype.add = function (t20, r29) {
        this._verify2(t20, r29);
        var h22 = t20.add(r29);
        return h22.cmp((this || i$31).m) >= 0 && h22.isub((this || i$31).m), h22._forceRed(this || i$31);
    }, k7.prototype.iadd = function (t20, r29) {
        this._verify2(t20, r29);
        var h22 = t20.iadd(r29);
        return h22.cmp((this || i$31).m) >= 0 && h22.isub((this || i$31).m), h22;
    }, k7.prototype.sub = function (t20, r29) {
        this._verify2(t20, r29);
        var h22 = t20.sub(r29);
        return h22.cmpn(0) < 0 && h22.iadd((this || i$31).m), h22._forceRed(this || i$31);
    }, k7.prototype.isub = function (t20, r29) {
        this._verify2(t20, r29);
        var h22 = t20.isub(r29);
        return h22.cmpn(0) < 0 && h22.iadd((this || i$31).m), h22;
    }, k7.prototype.shl = function (t20, i38) {
        return this._verify1(t20), this.imod(t20.ushln(i38));
    }, k7.prototype.imul = function (t20, i38) {
        return this._verify2(t20, i38), this.imod(t20.imul(i38));
    }, k7.prototype.mul = function (t20, i38) {
        return this._verify2(t20, i38), this.imod(t20.mul(i38));
    }, k7.prototype.isqr = function (t20) {
        return this.imul(t20, t20.clone());
    }, k7.prototype.sqr = function (t20) {
        return this.mul(t20, t20);
    }, k7.prototype.sqrt = function (t20) {
        if (t20.isZero()) {
            return t20.clone();
        }
        var r29 = (this || i$31).m.andln(3);
        if (n33(r29 % 2 == 1), 3 === r29) {
            var h22 = (this || i$31).m.add(new o29(1)).iushrn(2);
            return this.pow(t20, h22);
        }
        for (var e29 = (this || i$31).m.subn(1), s26 = 0; !e29.isZero() && 0 === e29.andln(1);) {
            s26++, e29.iushrn(1);
        }
        n33(!e29.isZero());
        var u31 = new o29(1).toRed(this || i$31), a40 = u31.redNeg(), l36 = (this || i$31).m.subn(1).iushrn(1),
                m14 = (this || i$31).m.bitLength();
        for (m14 = new o29(2 * m14 * m14).toRed(this || i$31); 0 !== this.pow(m14, l36).cmp(a40);) {
            m14.redIAdd(a40);
        }
        for (var f31 = this.pow(m14, e29), d20 = this.pow(t20, e29.addn(1).iushrn(1)), p29 = this.pow(t20, e29), M11 = s26; 0 !== p29.cmp(u31);) {
            for (var v17 = p29, g13 = 0; 0 !== v17.cmp(u31); g13++) {
                v17 = v17.redSqr();
            }
            n33(g13 < M11);
            var c19 = this.pow(f31, new o29(1).iushln(M11 - g13 - 1));
            d20 = d20.redMul(c19), f31 = c19.redSqr(), p29 = p29.redMul(f31), M11 = g13;
        }
        return d20;
    }, k7.prototype.invm = function (t20) {
        var r29 = t20._invmp((this || i$31).m);
        return 0 !== r29.negative ? (r29.negative = 0, this.imod(r29).redNeg()) : this.imod(r29);
    }, k7.prototype.pow = function (t20, r29) {
        if (r29.isZero()) {
            return new o29(1).toRed(this || i$31);
        }
        if (0 === r29.cmpn(1)) {
            return t20.clone();
        }
        var h23 = new Array(16);
        h23[0] = new o29(1).toRed(this || i$31), h23[1] = t20;
        for (var n40 = 2; n40 < h23.length; n40++) {
            h23[n40] = this.mul(h23[n40 - 1], t20);
        }
        var e29 = h23[0], s26 = 0, u31 = 0, a40 = r29.bitLength() % 26;
        for (0 === a40 && (a40 = 26), n40 = r29.length - 1; n40 >= 0; n40--) {
            for (var l36 = r29.words[n40], m14 = a40 - 1; m14 >= 0; m14--) {
                var f31 = l36 >> m14 & 1;
                e29 !== h23[0] && (e29 = this.sqr(e29)), 0 !== f31 || 0 !== s26 ? (s26 <<= 1, s26 |= f31, (4 === ++u31 || 0 === n40 && 0 === m14) && (e29 = this.mul(e29, h23[s26]), u31 = 0, s26 = 0)) : u31 = 0;
            }
            a40 = 26;
        }
        return e29;
    }, k7.prototype.convertTo = function (t20) {
        var r29 = t20.umod((this || i$31).m);
        return r29 === t20 ? r29.clone() : r29;
    }, k7.prototype.convertFrom = function (t20) {
        var i38 = t20.clone();
        return i38.red = null, i38;
    }, o29.mont = function (t20) {
        return new A7(t20);
    }, e20(A7, k7), A7.prototype.convertTo = function (t20) {
        return this.imod(t20.ushln((this || i$31).shift));
    }, A7.prototype.convertFrom = function (t20) {
        var r29 = this.imod(t20.mul((this || i$31).rinv));
        return r29.red = null, r29;
    }, A7.prototype.imul = function (t20, r29) {
        if (t20.isZero() || r29.isZero()) {
            return t20.words[0] = 0, t20.length = 1, t20;
        }
        var h23 = t20.imul(r29),
                n40 = h23.maskn((this || i$31).shift).mul((this || i$31).minv).imaskn((this || i$31).shift).mul((this || i$31).m),
                e29 = h23.isub(n40).iushrn((this || i$31).shift), o34 = e29;
        return e29.cmp((this || i$31).m) >= 0 ? o34 = e29.isub((this || i$31).m) : e29.cmpn(0) < 0 && (o34 = e29.iadd((this || i$31).m)), o34._forceRed(this || i$31);
    }, A7.prototype.mul = function (t20, r29) {
        if (t20.isZero() || r29.isZero()) {
            return new o29(0)._forceRed(this || i$31);
        }
        var h23 = t20.mul(r29),
                n40 = h23.maskn((this || i$31).shift).mul((this || i$31).minv).imaskn((this || i$31).shift).mul((this || i$31).m),
                e29 = h23.isub(n40).iushrn((this || i$31).shift), s26 = e29;
        return e29.cmp((this || i$31).m) >= 0 ? s26 = e29.isub((this || i$31).m) : e29.cmpn(0) < 0 && (s26 = e29.iadd((this || i$31).m)), s26._forceRed(this || i$31);
    }, A7.prototype.invm = function (t20) {
        return this.imod(t20._invmp((this || i$31).m).mul((this || i$31).r2))._forceRed(this || i$31);
    };
}(h$a, r$7);
var n$c = h$a.exports;
var t$52, e$a, r$8 = Object.freeze({}),
        n$d = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;

function o$d(t20) {
    (this || n$d).rand = t20;
}

if ((t$52 = function (t20) {
    return e$a || (e$a = new o$d(null)), e$a.generate(t20);
}).Rand = o$d, o$d.prototype.generate = function (t20) {
    return this._rand(t20);
}, o$d.prototype._rand = function (t20) {
    if ((this || n$d).rand.getBytes) {
        return (this || n$d).rand.getBytes(t20);
    }
    for (var e20 = new Uint8Array(t20), r26 = 0; r26 < e20.length; r26++) {
        e20[r26] = (this || n$d).rand.getByte();
    }
    return e20;
}, "object" == typeof self) {
    self.crypto && self.crypto.getRandomValues ? o$d.prototype._rand = function (t20) {
        var e20 = new Uint8Array(t20);
        return self.crypto.getRandomValues(e20), e20;
    } : self.msCrypto && self.msCrypto.getRandomValues ? o$d.prototype._rand = function (t20) {
        var e20 = new Uint8Array(t20);
        return self.msCrypto.getRandomValues(e20), e20;
    } : "object" == typeof window && (o$d.prototype._rand = function () {
        throw new Error("Not implemented yet");
    });
} else {
    try {
        var a$e = r$8;
        if ("function" != typeof a$e.randomBytes) {
            throw new Error("Not supported");
        }
        o$d.prototype._rand = function (t20) {
            return a$e.randomBytes(t20);
        };
    } catch (t20) {
    }
}
var f$i = t$52;
var n$e, t$61 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, o$e = n$c,
        a$f = f$i;

function d$b(r26) {
    (this || t$61).rand = r26 || new a$f.Rand;
}

n$e = d$b, d$b.create = function (r26) {
    return new d$b(r26);
}, d$b.prototype._randbelow = function (r26) {
    var e20 = r26.bitLength(), n33 = Math.ceil(e20 / 8);
    do {
        var a35 = new o$e((this || t$61).rand.generate(n33));
    } while (a35.cmp(r26) >= 0)
    return a35;
}, d$b.prototype._randrange = function (r26, e20) {
    var n33 = e20.sub(r26);
    return r26.add(this._randbelow(n33));
}, d$b.prototype.test = function (r26, e20, n33) {
    var t20 = r26.bitLength(), a40 = o$e.mont(r26), d15 = new o$e(1).toRed(a40);
    e20 || (e20 = Math.max(1, t20 / 48 | 0));
    for (var i38 = r26.subn(1), f26 = 0; !i38.testn(f26); f26++) {
        ;
    }
    for (var u26 = r26.shrn(f26), p25 = i38.toRed(a40); e20 > 0; e20--) {
        var c18 = this._randrange(new o$e(2), i38);
        n33 && n33(c18);
        var s21 = c18.toRed(a40).redPow(u26);
        if (0 !== s21.cmp(d15) && 0 !== s21.cmp(p25)) {
            for (var m10 = 1; m10 < f26; m10++) {
                if (0 === (s21 = s21.redSqr()).cmp(d15)) {
                    return !1;
                }
                if (0 === s21.cmp(p25)) {
                    break;
                }
            }
            if (m10 === f26) {
                return !1;
            }
        }
    }
    return !0;
}, d$b.prototype.getDivisor = function (r26, e20) {
    var n33 = r26.bitLength(), t20 = o$e.mont(r26), a40 = new o$e(1).toRed(t20);
    e20 || (e20 = Math.max(1, n33 / 48 | 0));
    for (var d15 = r26.subn(1), i38 = 0; !d15.testn(i38); i38++) {
        ;
    }
    for (var f26 = r26.shrn(i38), u26 = d15.toRed(t20); e20 > 0; e20--) {
        var p25 = this._randrange(new o$e(2), d15), c20 = r26.gcd(p25);
        if (0 !== c20.cmpn(1)) {
            return c20;
        }
        var s26 = p25.toRed(t20).redPow(f26);
        if (0 !== s26.cmp(a40) && 0 !== s26.cmp(u26)) {
            for (var m15 = 1; m15 < i38; m15++) {
                if (0 === (s26 = s26.redSqr()).cmp(a40)) {
                    return s26.fromRed().subn(1).gcd(r26);
                }
                if (0 === s26.cmp(u26)) {
                    break;
                }
            }
            if (m15 === i38) {
                return (s26 = s26.redSqr()).fromRed().subn(1).gcd(r26);
            }
        }
    }
    return !1;
};
var i$41 = n$e;
var b$7, d$c = a30;
b$7 = v$9, v$9.simpleSieve = _$9, v$9.fermatTest = g$8;
var r$9 = n$c, t$7 = new r$9(24), n$f = new i$41, i$51 = new r$9(1), o$f = new r$9(2), p$e = new r$9(5),
        s$c = (new r$9(16), new r$9(8), new r$9(10)), m$9 = new r$9(3), u$b = (new r$9(7), new r$9(11)),
        h$b = new r$9(4), w$a = (new r$9(12), null);

function l$c() {
    if (null !== w$a) {
        return w$a;
    }
    var f26 = [];
    f26[0] = 2;
    for (var e20 = 1, c21 = 3; c21 < 1048576; c21 += 2) {
        for (var a40 = Math.ceil(Math.sqrt(c21)), b11 = 0; b11 < e20 && f26[b11] <= a40 && c21 % f26[b11] != 0; b11++) {
            ;
        }
        e20 !== b11 && f26[b11] <= a40 || (f26[e20++] = c21);
    }
    return w$a = f26, f26;
}

function _$9(f26) {
    for (var e20 = l$c(), c21 = 0; c21 < e20.length; c21++) {
        if (0 === f26.modn(e20[c21])) {
            return 0 === f26.cmpn(e20[c21]);
        }
    }
    return !0;
}

function g$8(f26) {
    var e20 = r$9.mont(f26);
    return 0 === o$f.toRed(e20).redPow(f26.subn(1)).fromRed().cmpn(1);
}

function v$9(f26, e20) {
    if (f26 < 16) {
        return new r$9(2 === e20 || 5 === e20 ? [
            140,
            123
        ] : [
            140,
            39
        ]);
    }
    var c21, a41;
    for (e20 = new r$9(e20); ;) {
        for (c21 = new r$9(d$c(Math.ceil(f26 / 8))); c21.bitLength() > f26;) {
            c21.ishrn(1);
        }
        if (c21.isEven() && c21.iadd(i$51), c21.testn(1) || c21.iadd(o$f), e20.cmp(o$f)) {
            if (!e20.cmp(p$e)) {
                for (; c21.mod(s$c).cmp(m$9);) {
                    c21.iadd(h$b);
                }
            }
        } else {
            for (; c21.mod(t$7).cmp(u$b);) {
                c21.iadd(h$b);
            }
        }
        if (_$9(a41 = c21.shrn(1)) && _$9(c21) && g$8(a41) && g$8(c21) && n$f.test(a41) && n$f.test(c21)) {
            return c21;
        }
    }
}

var y$9, P$2 = b$7, B$5 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global,
        K$2 = e$1.Buffer, R$12 = n$c, S$5 = new i$41, x$21 = new R$12(24), C$2 = new R$12(11), D$2 = new R$12(10),
        G$12 = new R$12(3), H$2 = new R$12(7), T$3 = P$2, j$12 = a30;

function E$6(f26, e20) {
    return e20 = e20 || "utf8", K$2.isBuffer(f26) || (f26 = new K$2(f26, e20)), (this || B$5)._pub = new R$12(f26), this || B$5;
}

function L$12(f26, e20) {
    return e20 = e20 || "utf8", K$2.isBuffer(f26) || (f26 = new K$2(f26, e20)), (this || B$5)._priv = new R$12(f26), this || B$5;
}

y$9 = k$7;
var M$4 = {};

function k$7(f26, e20, c21) {
    this.setGenerator(e20), (this || B$5).__prime = new R$12(f26), (this || B$5)._prime = R$12.mont((this || B$5).__prime), (this || B$5)._primeLen = f26.length, (this || B$5)._pub = void 0, (this || B$5)._priv = void 0, (this || B$5)._primeCode = void 0, c21 ? ((this || B$5).setPublicKey = E$6, (this || B$5).setPrivateKey = L$12) : (this || B$5)._primeCode = 8;
}

function A$5(f26, e20) {
    var c21 = new K$2(f26.toArray());
    return e20 ? c21.toString(e20) : c21;
}

Object.defineProperty(k$7.prototype, "verifyError", {
    enumerable: !0,
    get: function () {
        return ("number" != typeof (this || B$5)._primeCode && ((this || B$5)._primeCode = function (f26, e20) {
            var c21 = e20.toString("hex"), a41 = [
                c21,
                f26.toString(16)
            ].join("_");
            if (a41 in M$4) {
                return M$4[a41];
            }
            var b12, d15 = 0;
            if (f26.isEven() || !T$3.simpleSieve || !T$3.fermatTest(f26) || !S$5.test(f26)) {
                return d15 += 1, d15 += "02" === c21 || "05" === c21 ? 8 : 4, M$4[a41] = d15, d15;
            }
            switch (S$5.test(f26.shrn(1)) || (d15 += 2), c21) {
                case "02":
                    f26.mod(x$21).cmp(C$2) && (d15 += 8);
                    break;
                case "05":
                    (b12 = f26.mod(D$2)).cmp(G$12) && b12.cmp(H$2) && (d15 += 8);
                    break;
                default:
                    d15 += 4;
            }
            return M$4[a41] = d15, d15;
        }((this || B$5).__prime, (this || B$5).__gen)), (this || B$5)._primeCode);
    }
}), k$7.prototype.generateKeys = function () {
    return (this || B$5)._priv || ((this || B$5)._priv = new R$12(j$12((this || B$5)._primeLen))), (this || B$5)._pub = (this || B$5)._gen.toRed((this || B$5)._prime).redPow((this || B$5)._priv).fromRed(), this.getPublicKey();
}, k$7.prototype.computeSecret = function (f26) {
    var e20 = (f26 = (f26 = new R$12(f26)).toRed((this || B$5)._prime)).redPow((this || B$5)._priv).fromRed(),
            c21 = new K$2(e20.toArray()), a41 = this.getPrime();
    if (c21.length < a41.length) {
        var b12 = new K$2(a41.length - c21.length);
        b12.fill(0), c21 = K$2.concat([
            b12,
            c21
        ]);
    }
    return c21;
}, k$7.prototype.getPublicKey = function (f26) {
    return A$5((this || B$5)._pub, f26);
}, k$7.prototype.getPrivateKey = function (f26) {
    return A$5((this || B$5)._priv, f26);
}, k$7.prototype.getPrime = function (f26) {
    return A$5((this || B$5).__prime, f26);
}, k$7.prototype.getGenerator = function (f26) {
    return A$5((this || B$5)._gen, f26);
}, k$7.prototype.setGenerator = function (f26, e20) {
    return e20 = e20 || "utf8", K$2.isBuffer(f26) || (f26 = new K$2(f26, e20)), (this || B$5).__gen = f26, (this || B$5)._gen = new R$12(f26), this || B$5;
};
var q$11 = y$9, O$3 = {}, z$3 = e$1.Buffer, F$3 = P$2, I$6 = {
    modp1: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    modp2: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    modp5: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    modp14: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    modp15: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    modp16: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    modp17: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    modp18: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}, J$11 = q$11;
var N$2 = {
    binary: !0,
    hex: !0,
    base64: !0
};
O$3.DiffieHellmanGroup = O$3.createDiffieHellmanGroup = O$3.getDiffieHellman = function (f26) {
    var e20 = new z$3(I$6[f26].prime, "hex"), c21 = new z$3(I$6[f26].gen, "hex");
    return new J$11(e20, c21);
}, O$3.createDiffieHellman = O$3.DiffieHellman = function f20(e20, c21, a41, b13) {
    return z$3.isBuffer(c21) || (void 0) === N$2[c21] ? f20(e20, "binary", c21, a41) : (c21 = c21 || "binary", b13 = b13 || "binary", a41 = a41 || new z$3([
        2
    ]), z$3.isBuffer(a41) || (a41 = new z$3(a41, b13)), "number" == typeof e20 ? new J$11(F$3(e20, a41), a41, !0) : (z$3.isBuffer(e20) || (e20 = new z$3(e20, c21)), new J$11(e20, a41, !0)));
};
var m$a, u$c = e$1.Buffer, n$g = n$c, d$d = a30;

function t$8(e20, o29) {
    var r26 = function (e29) {
                var o34 = i$6(e29);
                return {
                    blinder: o34.toRed(n$g.mont(e29.modulus)).redPow(new n$g(e29.publicExponent)).fromRed(),
                    unblinder: o34.invm(e29.modulus)
                };
            }(o29), m16 = o29.modulus.byteLength(),
            d15 = (n$g.mont(o29.modulus), new n$g(e20).mul(r26.blinder).umod(o29.modulus)),
            t20 = d15.toRed(n$g.mont(o29.prime1)), l30 = d15.toRed(n$g.mont(o29.prime2)), f26 = o29.coefficient,
            p29 = o29.prime1, b13 = o29.prime2, s27 = t20.redPow(o29.exponent1), a41 = l30.redPow(o29.exponent2);
    s27 = s27.fromRed(), a41 = a41.fromRed();
    var w6 = s27.isub(a41).imul(f26).umod(p29);
    return w6.imul(b13), a41.iadd(w6), new u$c(a41.imul(r26.unblinder).umod(o29.modulus).toArray(!1, m16));
}

function i$6(e20) {
    for (var o29 = e20.modulus.byteLength(), r26 = new n$g(d$d(o29)); r26.cmp(e20.modulus) >= 0 || !r26.umod(e20.prime1) || !r26.umod(e20.prime2);) {
        r26 = new n$g(d$d(o29));
    }
    return r26;
}

m$a = t$8, t$8.getr = i$6;
var l$d = m$a;
var r$a = {}, e$b = r$a;

function t$9(r26) {
    return 1 === r26.length ? "0" + r26 : r26;
}

function n$h(r26) {
    for (var e20 = "", n33 = 0; n33 < r26.length; n33++) {
        e20 += t$9(r26[n33].toString(16));
    }
    return e20;
}

e$b.toArray = function (r26, e20) {
    if (Array.isArray(r26)) {
        return r26.slice();
    }
    if (!r26) {
        return [];
    }
    var t20 = [];
    if ("string" != typeof r26) {
        for (var n33 = 0; n33 < r26.length; n33++) {
            t20[n33] = 0 | r26[n33];
        }
        return t20;
    }
    if ("hex" === e20) {
        (r26 = r26.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (r26 = "0" + r26);
        for (n33 = 0; n33 < r26.length; n33 += 2) {
            t20.push(parseInt(r26[n33] + r26[n33 + 1], 16));
        }
    } else {
        for (n33 = 0; n33 < r26.length; n33++) {
            var o29 = r26.charCodeAt(n33), u26 = o29 >> 8, f26 = 255 & o29;
            u26 ? t20.push(u26, f26) : t20.push(f26);
        }
    }
    return t20;
}, e$b.zero2 = t$9, e$b.toHex = n$h, e$b.encode = function (r26, e20) {
    return "hex" === e20 ? n$h(r26) : r26;
};
var n$i = {}, a$g = n$i, i$7 = n$c, o$g = o$7, c$d = r$a;
a$g.assert = o$g, a$g.toArray = c$d.toArray, a$g.zero2 = c$d.zero2, a$g.toHex = c$d.toHex, a$g.encode = c$d.encode, a$g.getNAF = function (r26, t20, e20) {
    var n40 = new Array(Math.max(r26.bitLength(), e20) + 1);
    n40.fill(0);
    for (var a41 = 1 << t20 + 1, i38 = r26.clone(), o34 = 0; o34 < n40.length; o34++) {
        var c21, s27 = i38.andln(a41 - 1);
        i38.isOdd() ? (c21 = s27 > (a41 >> 1) - 1 ? (a41 >> 1) - s27 : s27, i38.isubn(c21)) : c21 = 0, n40[o34] = c21, i38.iushrn(1);
    }
    return n40;
}, a$g.getJSF = function (r26, t20) {
    var e20 = [
        [],
        []
    ];
    r26 = r26.clone(), t20 = t20.clone();
    for (var n40 = 0, a41 = 0; r26.cmpn(-n40) > 0 || t20.cmpn(-a41) > 0;) {
        var i38, o34, c22, s28 = r26.andln(3) + n40 & 3, l30 = t20.andln(3) + a41 & 3;
        if (3 === s28 && (s28 = -1), 3 === l30 && (l30 = -1), 0 == (1 & s28)) {
            i38 = 0;
        } else {
            i38 = 3 !== (c22 = r26.andln(7) + n40 & 7) && 5 !== c22 || 2 !== l30 ? s28 : -s28;
        }
        if (e20[0].push(i38), 0 == (1 & l30)) {
            o34 = 0;
        } else {
            o34 = 3 !== (c22 = t20.andln(7) + a41 & 7) && 5 !== c22 || 2 !== s28 ? l30 : -l30;
        }
        e20[1].push(o34), 2 * n40 === i38 + 1 && (n40 = 1 - n40), 2 * a41 === o34 + 1 && (a41 = 1 - a41), r26.iushrn(1), t20.iushrn(1);
    }
    return e20;
}, a$g.cachedProperty = function (r26, t20, e20) {
    var n40 = "_" + t20;
    r26.prototype[t20] = function () {
        return (void 0) !== this[n40] ? this[n40] : this[n40] = e20.call(this);
    };
}, a$g.parseBytes = function (r26) {
    return "string" == typeof r26 ? a$g.toArray(r26, "hex") : r26;
}, a$g.intFromLE = function (r26) {
    return new i$7(r26, "hex", "le");
};
var s$d, l$e = n$c, u$d = n$i, h$c = u$d.assert;

function p$f(r26, t20) {
    if (r26 instanceof p$f) {
        return r26;
    }
    this._importDER(r26, t20) || (h$c(r26.r && r26.s, "Signature without r or s"), this.r = new l$e(r26.r, 16), this.s = new l$e(r26.s, 16), (void 0) === r26.recoveryParam ? this.recoveryParam = null : this.recoveryParam = r26.recoveryParam);
}

function f$j() {
    this.place = 0;
}

function v$a(r26, t20) {
    var e20 = r26[t20.place++];
    if (!(128 & e20)) {
        return e20;
    }
    for (var n40 = 15 & e20, a41 = 0, i39 = 0, o35 = t20.place; i39 < n40; i39++, o35++) {
        a41 <<= 8, a41 |= r26[o35];
    }
    return t20.place = o35, a41;
}

function m$b(r26) {
    for (var t20 = 0, e20 = r26.length - 1; !r26[t20] && !(128 & r26[t20 + 1]) && t20 < e20;) {
        t20++;
    }
    return 0 === t20 ? r26 : r26.slice(t20);
}

function y$a(r26, t20) {
    if (t20 < 128) {
        return r26.push(t20), void 0;
    }
    var e20 = 1 + (Math.log(t20) / Math.LN2 >>> 3);
    for (r26.push(128 | e20); --e20;) {
        r26.push(t20 >>> (e20 << 3) & 255);
    }
    r26.push(t20);
}

s$d = p$f, p$f.prototype._importDER = function (r26, t20) {
    r26 = u$d.toArray(r26, t20);
    var e20 = new f$j;
    if (48 !== r26[e20.place++]) {
        return !1;
    }
    if (v$a(r26, e20) + e20.place !== r26.length) {
        return !1;
    }
    if (2 !== r26[e20.place++]) {
        return !1;
    }
    var n40 = v$a(r26, e20), a41 = r26.slice(e20.place, n40 + e20.place);
    if (e20.place += n40, 2 !== r26[e20.place++]) {
        return !1;
    }
    var i39 = v$a(r26, e20);
    if (r26.length !== i39 + e20.place) {
        return !1;
    }
    var o35 = r26.slice(e20.place, i39 + e20.place);
    return 0 === a41[0] && 128 & a41[1] && (a41 = a41.slice(1)), 0 === o35[0] && 128 & o35[1] && (o35 = o35.slice(1)), this.r = new l$e(a41), this.s = new l$e(o35), this.recoveryParam = null, !0;
}, p$f.prototype.toDER = function (r26) {
    var t20 = this.r.toArray(), e20 = this.s.toArray();
    for (128 & t20[0] && (t20 = [
        0
    ].concat(t20)), 128 & e20[0] && (e20 = [
        0
    ].concat(e20)), t20 = m$b(t20), e20 = m$b(e20); !(e20[0] || 128 & e20[1]);) {
        e20 = e20.slice(1);
    }
    var n40 = [
        2
    ];
    y$a(n40, t20.length), (n40 = n40.concat(t20)).push(2), y$a(n40, e20.length);
    var a41 = n40.concat(e20), i39 = [
        48
    ];
    return y$a(i39, a41.length), i39 = i39.concat(a41), u$d.encode(i39, r26);
};
var d$e = s$d;
var r$b = {}, i$8 = o$7, e$c = t$2;

function h$d(t20, n40) {
    return 55296 == (64512 & t20.charCodeAt(n40)) && !(n40 < 0 || n40 + 1 >= t20.length) && 56320 == (64512 & t20.charCodeAt(n40 + 1));
}

function o$h(t20) {
    return (t20 >>> 24 | t20 >>> 8 & 65280 | t20 << 8 & 16711680 | (255 & t20) << 24) >>> 0;
}

function u$e(t20) {
    return 1 === t20.length ? "0" + t20 : t20;
}

function s$e(t20) {
    return 7 === t20.length ? "0" + t20 : 6 === t20.length ? "00" + t20 : 5 === t20.length ? "000" + t20 : 4 === t20.length ? "0000" + t20 : 3 === t20.length ? "00000" + t20 : 2 === t20.length ? "000000" + t20 : 1 === t20.length ? "0000000" + t20 : t20;
}

r$b.inherits = e$c, r$b.toArray = function (t20, n40) {
    if (Array.isArray(t20)) {
        return t20.slice();
    }
    if (!t20) {
        return [];
    }
    var r26 = [];
    if ("string" == typeof t20) {
        if (n40) {
            if ("hex" === n40) {
                for ((t20 = t20.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (t20 = "0" + t20), e20 = 0; e20 < t20.length; e20 += 2) {
                    r26.push(parseInt(t20[e20] + t20[e20 + 1], 16));
                }
            }
        } else {
            for (var i39 = 0, e20 = 0; e20 < t20.length; e20++) {
                var o35 = t20.charCodeAt(e20);
                o35 < 128 ? r26[i39++] = o35 : o35 < 2048 ? (r26[i39++] = o35 >> 6 | 192, r26[i39++] = 63 & o35 | 128) : h$d(t20, e20) ? (o35 = 65536 + ((1023 & o35) << 10) + (1023 & t20.charCodeAt(++e20)), r26[i39++] = o35 >> 18 | 240, r26[i39++] = o35 >> 12 & 63 | 128, r26[i39++] = o35 >> 6 & 63 | 128, r26[i39++] = 63 & o35 | 128) : (r26[i39++] = o35 >> 12 | 224, r26[i39++] = o35 >> 6 & 63 | 128, r26[i39++] = 63 & o35 | 128);
            }
        }
    } else {
        for (e20 = 0; e20 < t20.length; e20++) {
            r26[e20] = 0 | t20[e20];
        }
    }
    return r26;
}, r$b.toHex = function (t20) {
    for (var n40 = "", r26 = 0; r26 < t20.length; r26++) {
        n40 += u$e(t20[r26].toString(16));
    }
    return n40;
}, r$b.htonl = o$h, r$b.toHex32 = function (t20, n40) {
    for (var r26 = "", i40 = 0; i40 < t20.length; i40++) {
        var e29 = t20[i40];
        "little" === n40 && (e29 = o$h(e29)), r26 += s$e(e29.toString(16));
    }
    return r26;
}, r$b.zero2 = u$e, r$b.zero8 = s$e, r$b.join32 = function (t20, n40, r26, e30) {
    var h17 = r26 - n40;
    i$8(h17 % 4 == 0);
    for (var o36 = new Array(h17 / 4), u31 = 0, s29 = n40; u31 < o36.length; u31++, s29 += 4) {
        var a41;
        a41 = "big" === e30 ? t20[s29] << 24 | t20[s29 + 1] << 16 | t20[s29 + 2] << 8 | t20[s29 + 3] : t20[s29 + 3] << 24 | t20[s29 + 2] << 16 | t20[s29 + 1] << 8 | t20[s29], o36[u31] = a41 >>> 0;
    }
    return o36;
}, r$b.split32 = function (t20, n40) {
    for (var r26 = new Array(4 * t20.length), i40 = 0, e30 = 0; i40 < t20.length; i40++, e30 += 4) {
        var h17 = t20[i40];
        "big" === n40 ? (r26[e30] = h17 >>> 24, r26[e30 + 1] = h17 >>> 16 & 255, r26[e30 + 2] = h17 >>> 8 & 255, r26[e30 + 3] = 255 & h17) : (r26[e30 + 3] = h17 >>> 24, r26[e30 + 2] = h17 >>> 16 & 255, r26[e30 + 1] = h17 >>> 8 & 255, r26[e30] = 255 & h17);
    }
    return r26;
}, r$b.rotr32 = function (t20, n40) {
    return t20 >>> n40 | t20 << 32 - n40;
}, r$b.rotl32 = function (t20, n40) {
    return t20 << n40 | t20 >>> 32 - n40;
}, r$b.sum32 = function (t20, n40) {
    return t20 + n40 >>> 0;
}, r$b.sum32_3 = function (t20, n40, r26) {
    return t20 + n40 + r26 >>> 0;
}, r$b.sum32_4 = function (t20, n40, r26, i40) {
    return t20 + n40 + r26 + i40 >>> 0;
}, r$b.sum32_5 = function (t20, n40, r26, i40, e30) {
    return t20 + n40 + r26 + i40 + e30 >>> 0;
}, r$b.sum64 = function (t20, n40, r26, i40) {
    var e30 = t20[n40], h23 = i40 + t20[n40 + 1] >>> 0, o36 = (h23 < i40 ? 1 : 0) + r26 + e30;
    t20[n40] = o36 >>> 0, t20[n40 + 1] = h23;
}, r$b.sum64_hi = function (t20, n40, r26, i40) {
    return (n40 + i40 >>> 0 < n40 ? 1 : 0) + t20 + r26 >>> 0;
}, r$b.sum64_lo = function (t20, n40, r26, i40) {
    return n40 + i40 >>> 0;
}, r$b.sum64_4_hi = function (t20, n40, r26, i40, e30, h23, o36, u31) {
    var s29 = 0, a42 = n40;
    return s29 += (a42 = a42 + i40 >>> 0) < n40 ? 1 : 0, s29 += (a42 = a42 + h23 >>> 0) < h23 ? 1 : 0, t20 + r26 + e30 + o36 + (s29 += (a42 = a42 + u31 >>> 0) < u31 ? 1 : 0) >>> 0;
}, r$b.sum64_4_lo = function (t20, n40, r26, i40, e30, h23, o36, u31) {
    return n40 + i40 + h23 + u31 >>> 0;
}, r$b.sum64_5_hi = function (t20, n40, r26, i40, e30, h23, o36, u31, s29, a42) {
    var l37 = 0, g12 = n40;
    return l37 += (g12 = g12 + i40 >>> 0) < n40 ? 1 : 0, l37 += (g12 = g12 + h23 >>> 0) < h23 ? 1 : 0, l37 += (g12 = g12 + u31 >>> 0) < u31 ? 1 : 0, t20 + r26 + e30 + o36 + s29 + (l37 += (g12 = g12 + a42 >>> 0) < a42 ? 1 : 0) >>> 0;
}, r$b.sum64_5_lo = function (t20, n40, r26, i40, e30, h23, o36, u31, s29, a42) {
    return n40 + i40 + h23 + u31 + a42 >>> 0;
}, r$b.rotr64_hi = function (t20, n40, r26) {
    return (n40 << 32 - r26 | t20 >>> r26) >>> 0;
}, r$b.rotr64_lo = function (t20, n40, r26) {
    return (t20 << 32 - r26 | n40 >>> r26) >>> 0;
}, r$b.shr64_hi = function (t20, n40, r26) {
    return t20 >>> r26;
}, r$b.shr64_lo = function (t20, n40, r26) {
    return (t20 << 32 - r26 | n40 >>> r26) >>> 0;
};
var a$h = {}, l$f = r$b, g$9 = o$7;

function c$e() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}

a$h.BlockHash = c$e, c$e.prototype.update = function (t20, n40) {
    if (t20 = l$f.toArray(t20, n40), this.pending ? this.pending = this.pending.concat(t20) : this.pending = t20, this.pendingTotal += t20.length, this.pending.length >= this._delta8) {
        var r26 = (t20 = this.pending).length % this._delta8;
        this.pending = t20.slice(t20.length - r26, t20.length), 0 === this.pending.length && (this.pending = null), t20 = l$f.join32(t20, 0, t20.length - r26, this.endian);
        for (var i40 = 0; i40 < t20.length; i40 += this._delta32) {
            this._update(t20, i40, i40 + this._delta32);
        }
    }
    return this;
}, c$e.prototype.digest = function (t20) {
    return this.update(this._pad()), g$9(null === this.pending), this._digest(t20);
}, c$e.prototype._pad = function () {
    var t20 = this.pendingTotal, n40 = this._delta8, r29 = n40 - (t20 + this.padLength) % n40,
            i41 = new Array(r29 + this.padLength);
    i41[0] = 128;
    for (var e30 = 1; e30 < r29; e30++) {
        i41[e30] = 0;
    }
    if (t20 <<= 3, "big" === this.endian) {
        for (var h23 = 8; h23 < this.padLength; h23++) {
            i41[e30++] = 0;
        }
        i41[e30++] = 0, i41[e30++] = 0, i41[e30++] = 0, i41[e30++] = 0, i41[e30++] = t20 >>> 24 & 255, i41[e30++] = t20 >>> 16 & 255, i41[e30++] = t20 >>> 8 & 255, i41[e30++] = 255 & t20;
    } else {
        for (i41[e30++] = 255 & t20, i41[e30++] = t20 >>> 8 & 255, i41[e30++] = t20 >>> 16 & 255, i41[e30++] = t20 >>> 24 & 255, i41[e30++] = 0, i41[e30++] = 0, i41[e30++] = 0, i41[e30++] = 0, h23 = 8; h23 < this.padLength; h23++) {
            i41[e30++] = 0;
        }
    }
    return i41;
};
var r$c, n$j = r$b, s$f = a$h, o$i = o$7, e$d = n$j.rotr64_hi, u$f = n$j.rotr64_lo, a$i = n$j.shr64_hi,
        c$f = n$j.shr64_lo, f$k = n$j.sum64, v$b = n$j.sum64_hi, _$a = n$j.sum64_lo, l$g = n$j.sum64_4_hi,
        p$g = n$j.sum64_4_lo, m$c = n$j.sum64_5_hi, g$a = n$j.sum64_5_lo, k$8 = s$f.BlockHash, d$f = [
            1116352408,
            3609767458,
            1899447441,
            602891725,
            3049323471,
            3964484399,
            3921009573,
            2173295548,
            961987163,
            4081628472,
            1508970993,
            3053834265,
            2453635748,
            2937671579,
            2870763221,
            3664609560,
            3624381080,
            2734883394,
            310598401,
            1164996542,
            607225278,
            1323610764,
            1426881987,
            3590304994,
            1925078388,
            4068182383,
            2162078206,
            991336113,
            2614888103,
            633803317,
            3248222580,
            3479774868,
            3835390401,
            2666613458,
            4022224774,
            944711139,
            264347078,
            2341262773,
            604807628,
            2007800933,
            770255983,
            1495990901,
            1249150122,
            1856431235,
            1555081692,
            3175218132,
            1996064986,
            2198950837,
            2554220882,
            3999719339,
            2821834349,
            766784016,
            2952996808,
            2566594879,
            3210313671,
            3203337956,
            3336571891,
            1034457026,
            3584528711,
            2466948901,
            113926993,
            3758326383,
            338241895,
            168717936,
            666307205,
            1188179964,
            773529912,
            1546045734,
            1294757372,
            1522805485,
            1396182291,
            2643833823,
            1695183700,
            2343527390,
            1986661051,
            1014477480,
            2177026350,
            1206759142,
            2456956037,
            344077627,
            2730485921,
            1290863460,
            2820302411,
            3158454273,
            3259730800,
            3505952657,
            3345764771,
            106217008,
            3516065817,
            3606008344,
            3600352804,
            1432725776,
            4094571909,
            1467031594,
            275423344,
            851169720,
            430227734,
            3100823752,
            506948616,
            1363258195,
            659060556,
            3750685593,
            883997877,
            3785050280,
            958139571,
            3318307427,
            1322822218,
            3812723403,
            1537002063,
            2003034995,
            1747873779,
            3602036899,
            1955562222,
            1575990012,
            2024104815,
            1125592928,
            2227730452,
            2716904306,
            2361852424,
            442776044,
            2428436474,
            593698344,
            2756734187,
            3733110249,
            3204031479,
            2999351573,
            3329325298,
            3815920427,
            3391569614,
            3928383900,
            3515267271,
            566280711,
            3940187606,
            3454069534,
            4118630271,
            4000239992,
            116418474,
            1914138554,
            174292421,
            2731055270,
            289380356,
            3203993006,
            460393269,
            320620315,
            685471733,
            587496836,
            852142971,
            1086792851,
            1017036298,
            365543100,
            1126000580,
            2618297676,
            1288033470,
            3409855158,
            1501505948,
            4234509866,
            1607167915,
            987167468,
            1816402316,
            1246189591
        ];

function y$b() {
    if (!(this instanceof y$b)) {
        return new y$b;
    }
    k$8.call(this), this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
    ], this.k = d$f, this.W = new Array(160);
}

function b$8(t20, h24, i41, r29, n40) {
    var s29 = t20 & i41 ^ ~t20 & n40;
    return s29 < 0 && (s29 += 4294967296), s29;
}

function x$3(t20, h24, i41, r29, n40, s29) {
    var o36 = h24 & r29 ^ ~h24 & s29;
    return o36 < 0 && (o36 += 4294967296), o36;
}

function B$6(t20, h24, i41, r29, n40) {
    var s29 = t20 & i41 ^ t20 & n40 ^ i41 & n40;
    return s29 < 0 && (s29 += 4294967296), s29;
}

function S$6(t20, h24, i41, r29, n40, s29) {
    var o36 = h24 & r29 ^ h24 & s29 ^ r29 & s29;
    return o36 < 0 && (o36 += 4294967296), o36;
}

function W$12(t20, h24) {
    var i41 = e$d(t20, h24, 28) ^ e$d(h24, t20, 2) ^ e$d(h24, t20, 7);
    return i41 < 0 && (i41 += 4294967296), i41;
}

function w$b(t20, h24) {
    var i41 = u$f(t20, h24, 28) ^ u$f(h24, t20, 2) ^ u$f(h24, t20, 7);
    return i41 < 0 && (i41 += 4294967296), i41;
}

function z$4(t20, h24) {
    var i41 = e$d(t20, h24, 14) ^ e$d(t20, h24, 18) ^ e$d(h24, t20, 9);
    return i41 < 0 && (i41 += 4294967296), i41;
}

function H$3(t20, h24) {
    var i41 = u$f(t20, h24, 14) ^ u$f(t20, h24, 18) ^ u$f(h24, t20, 9);
    return i41 < 0 && (i41 += 4294967296), i41;
}

function j$2(t20, h24) {
    var i41 = e$d(t20, h24, 1) ^ e$d(t20, h24, 8) ^ a$i(t20, h24, 7);
    return i41 < 0 && (i41 += 4294967296), i41;
}

function A$6(t20, h24) {
    var i41 = u$f(t20, h24, 1) ^ u$f(t20, h24, 8) ^ c$f(t20, h24, 7);
    return i41 < 0 && (i41 += 4294967296), i41;
}

function L$2(t20, h24) {
    var i41 = e$d(t20, h24, 19) ^ e$d(h24, t20, 29) ^ a$i(t20, h24, 6);
    return i41 < 0 && (i41 += 4294967296), i41;
}

function q$2(t20, h24) {
    var i41 = u$f(t20, h24, 19) ^ u$f(h24, t20, 29) ^ c$f(t20, h24, 6);
    return i41 < 0 && (i41 += 4294967296), i41;
}

n$j.inherits(y$b, k$8), r$c = y$b, y$b.blockSize = 1024, y$b.outSize = 512, y$b.hmacStrength = 192, y$b.padLength = 128, y$b.prototype._prepareBlock = function (t20, h24) {
    for (var i41 = this.W, r29 = 0; r29 < 32; r29++) {
        i41[r29] = t20[h24 + r29];
    }
    for (; r29 < i41.length; r29 += 2) {
        var n40 = L$2(i41[r29 - 4], i41[r29 - 3]), s29 = q$2(i41[r29 - 4], i41[r29 - 3]), o36 = i41[r29 - 14],
                e30 = i41[r29 - 13], u31 = j$2(i41[r29 - 30], i41[r29 - 29]), a42 = A$6(i41[r29 - 30], i41[r29 - 29]),
                c23 = i41[r29 - 32], f32 = i41[r29 - 31];
        i41[r29] = l$g(n40, s29, o36, e30, u31, a42, c23, f32), i41[r29 + 1] = p$g(n40, s29, o36, e30, u31, a42, c23, f32);
    }
}, y$b.prototype._update = function (t20, h24) {
    this._prepareBlock(t20, h24);
    var i41 = this.W, r29 = this.h[0], n41 = this.h[1], s30 = this.h[2], e31 = this.h[3], u32 = this.h[4],
            a43 = this.h[5], c24 = this.h[6], l37 = this.h[7], p29 = this.h[8], k7 = this.h[9], d15 = this.h[10],
            y11 = this.h[11], j7 = this.h[12], A7 = this.h[13], L8 = this.h[14], q7 = this.h[15];
    o$i(this.k.length === i41.length);
    for (var C7 = 0; C7 < i41.length; C7 += 2) {
        var D8 = L8, E9 = q7, F8 = z$4(p29, k7), G6 = H$3(p29, k7), I9 = b$8(p29, k7, d15, y11, j7),
                J7 = x$3(p29, k7, d15, y11, j7, A7), K5 = this.k[C7], M8 = this.k[C7 + 1], N7 = i41[C7],
                O6 = i41[C7 + 1], P8 = m$c(D8, E9, F8, G6, I9, J7, K5, M8, N7, O6),
                Q6 = g$a(D8, E9, F8, G6, I9, J7, K5, M8, N7, O6);
        D8 = W$12(r29, n41), E9 = w$b(r29, n41), F8 = B$6(r29, n41, s30, e31, u32), G6 = S$6(r29, n41, s30, e31, u32, a43);
        var R7 = v$b(D8, E9, F8, G6), T10 = _$a(D8, E9, F8, G6);
        L8 = j7, q7 = A7, j7 = d15, A7 = y11, d15 = p29, y11 = k7, p29 = v$b(c24, l37, P8, Q6), k7 = _$a(l37, l37, P8, Q6), c24 = u32, l37 = a43, u32 = s30, a43 = e31, s30 = r29, e31 = n41, r29 = v$b(P8, Q6, R7, T10), n41 = _$a(P8, Q6, R7, T10);
    }
    f$k(this.h, 0, r29, n41), f$k(this.h, 2, s30, e31), f$k(this.h, 4, u32, a43), f$k(this.h, 6, c24, l37), f$k(this.h, 8, p29, k7), f$k(this.h, 10, d15, y11), f$k(this.h, 12, j7, A7), f$k(this.h, 14, L8, q7);
}, y$b.prototype._digest = function (t20) {
    return "hex" === t20 ? n$j.toHex32(this.h, "big") : n$j.split32(this.h, "big");
};
var C$3 = r$c;
var s$g = {}, n$k = r$b.rotr32;

function r$d(t20, h24, i41) {
    return t20 & h24 ^ ~t20 & i41;
}

function e$e(t20, h24, i41) {
    return t20 & h24 ^ t20 & i41 ^ h24 & i41;
}

function o$j(t20, h24, i41) {
    return t20 ^ h24 ^ i41;
}

s$g.ft_1 = function (t20, h24, i41, s30) {
    return 0 === t20 ? r$d(h24, i41, s30) : 1 === t20 || 3 === t20 ? o$j(h24, i41, s30) : 2 === t20 ? e$e(h24, i41, s30) : void 0;
}, s$g.ch32 = r$d, s$g.maj32 = e$e, s$g.p32 = o$j, s$g.s0_256 = function (t20) {
    return n$k(t20, 2) ^ n$k(t20, 13) ^ n$k(t20, 22);
}, s$g.s1_256 = function (t20) {
    return n$k(t20, 6) ^ n$k(t20, 11) ^ n$k(t20, 25);
}, s$g.g0_256 = function (t20) {
    return n$k(t20, 7) ^ n$k(t20, 18) ^ t20 >>> 3;
}, s$g.g1_256 = function (t20) {
    return n$k(t20, 17) ^ n$k(t20, 19) ^ t20 >>> 10;
};
var u$g, a$j = r$b, c$g = a$h, f$l = s$g, _$b = o$7, g$b = a$j.sum32, m$d = a$j.sum32_4, p$h = a$j.sum32_5,
        l$h = f$l.ch32, v$c = f$l.maj32, d$g = f$l.s0_256, k$9 = f$l.s1_256, b$9 = f$l.g0_256, j$3 = f$l.g1_256,
        x$4 = c$g.BlockHash, y$c = [
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
        ];

function S$7() {
    if (!(this instanceof S$7)) {
        return new S$7;
    }
    x$4.call(this), this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
    ], this.k = y$c, this.W = new Array(64);
}

a$j.inherits(S$7, x$4), u$g = S$7, S$7.blockSize = 512, S$7.outSize = 256, S$7.hmacStrength = 192, S$7.padLength = 64, S$7.prototype._update = function (t20, h24) {
    for (var i41 = this.W, s30 = 0; s30 < 16; s30++) {
        i41[s30] = t20[h24 + s30];
    }
    for (; s30 < i41.length; s30++) {
        i41[s30] = m$d(j$3(i41[s30 - 2]), i41[s30 - 7], b$9(i41[s30 - 15]), i41[s30 - 16]);
    }
    var n41 = this.h[0], r29 = this.h[1], e31 = this.h[2], o37 = this.h[3], u32 = this.h[4], a43 = this.h[5],
            c24 = this.h[6], f33 = this.h[7];
    for (_$b(this.k.length === i41.length), s30 = 0; s30 < i41.length; s30++) {
        var x8 = p$h(f33, k$9(u32), l$h(u32, a43, c24), this.k[s30], i41[s30]), y11 = g$b(d$g(n41), v$c(n41, r29, e31));
        f33 = c24, c24 = a43, a43 = u32, u32 = g$b(o37, x8), o37 = e31, e31 = r29, r29 = n41, n41 = g$b(x8, y11);
    }
    this.h[0] = g$b(this.h[0], n41), this.h[1] = g$b(this.h[1], r29), this.h[2] = g$b(this.h[2], e31), this.h[3] = g$b(this.h[3], o37), this.h[4] = g$b(this.h[4], u32), this.h[5] = g$b(this.h[5], a43), this.h[6] = g$b(this.h[6], c24), this.h[7] = g$b(this.h[7], f33);
}, S$7.prototype._digest = function (t20) {
    return "hex" === t20 ? a$j.toHex32(this.h, "big") : a$j.split32(this.h, "big");
};
var w$c = u$g;
var r$e, o$k = r$b, a$k = a$h, u$h = s$g, l$i = o$k.rotl32, c$h = o$k.sum32, p$i = o$k.sum32_5, f$m = u$h.ft_1,
        g$c = a$k.BlockHash, d$h = [
            1518500249,
            1859775393,
            2400959708,
            3395469782
        ];

function m$e() {
    if (!(this instanceof m$e)) {
        return new m$e;
    }
    g$c.call(this), this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
    ], this.W = new Array(80);
}

o$k.inherits(m$e, g$c), r$e = m$e, m$e.blockSize = 512, m$e.outSize = 160, m$e.hmacStrength = 80, m$e.padLength = 64, m$e.prototype._update = function (t20, h24) {
    for (var i41 = this.W, s30 = 0; s30 < 16; s30++) {
        i41[s30] = t20[h24 + s30];
    }
    for (; s30 < i41.length; s30++) {
        i41[s30] = l$i(i41[s30 - 3] ^ i41[s30 - 8] ^ i41[s30 - 14] ^ i41[s30 - 16], 1);
    }
    var e31 = this.h[0], n41 = this.h[1], r29 = this.h[2], o37 = this.h[3], a43 = this.h[4];
    for (s30 = 0; s30 < i41.length; s30++) {
        var u32 = ~~(s30 / 20), g12 = p$i(l$i(e31, 5), f$m(u32, n41, r29, o37), a43, i41[s30], d$h[u32]);
        a43 = o37, o37 = r29, r29 = l$i(n41, 30), n41 = e31, e31 = g12;
    }
    this.h[0] = c$h(this.h[0], e31), this.h[1] = c$h(this.h[1], n41), this.h[2] = c$h(this.h[2], r29), this.h[3] = c$h(this.h[3], o37), this.h[4] = c$h(this.h[4], a43);
}, m$e.prototype._digest = function (t20) {
    return "hex" === t20 ? o$k.toHex32(this.h, "big") : o$k.split32(this.h, "big");
};
var S$8, _$c = r$e, b$a = r$b, z$5 = w$c;

function v$d() {
    if (!(this instanceof v$d)) {
        return new v$d;
    }
    z$5.call(this), this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
    ];
}

b$a.inherits(v$d, z$5), S$8 = v$d, v$d.blockSize = 512, v$d.outSize = 224, v$d.hmacStrength = 192, v$d.padLength = 64, v$d.prototype._digest = function (t20) {
    return "hex" === t20 ? b$a.toHex32(this.h.slice(0, 7), "big") : b$a.split32(this.h.slice(0, 7), "big");
};
var k$a, y$d = S$8, H$4 = r$b, w$d = C$3;

function x$5() {
    if (!(this instanceof x$5)) {
        return new x$5;
    }
    w$d.call(this), this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
    ];
}

H$4.inherits(x$5, w$d), k$a = x$5, x$5.blockSize = 1024, x$5.outSize = 384, x$5.hmacStrength = 192, x$5.padLength = 128, x$5.prototype._digest = function (t20) {
    return "hex" === t20 ? H$4.toHex32(this.h.slice(0, 12), "big") : H$4.split32(this.h.slice(0, 12), "big");
};
var L$3 = k$a, j$4 = {};
j$4.sha1 = _$c, j$4.sha224 = y$d, j$4.sha256 = w$c, j$4.sha384 = L$3, j$4.sha512 = C$3;
var A$7 = {}, B$7 = r$b, W$2 = a$h, q$3 = B$7.rotl32, C$4 = B$7.sum32, D$3 = B$7.sum32_3, E$7 = B$7.sum32_4,
        F$4 = W$2.BlockHash;

function G$2() {
    if (!(this instanceof G$2)) {
        return new G$2;
    }
    F$4.call(this), this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
    ], this.endian = "little";
}

function I$7(t20, h24, i41, s30) {
    return t20 <= 15 ? h24 ^ i41 ^ s30 : t20 <= 31 ? h24 & i41 | ~h24 & s30 : t20 <= 47 ? (h24 | ~i41) ^ s30 : t20 <= 63 ? h24 & s30 | i41 & ~s30 : h24 ^ (i41 | ~s30);
}

function J$2(t20) {
    return t20 <= 15 ? 0 : t20 <= 31 ? 1518500249 : t20 <= 47 ? 1859775393 : t20 <= 63 ? 2400959708 : 2840853838;
}

function K$3(t20) {
    return t20 <= 15 ? 1352829926 : t20 <= 31 ? 1548603684 : t20 <= 47 ? 1836072691 : t20 <= 63 ? 2053994217 : 0;
}

B$7.inherits(G$2, F$4), A$7.ripemd160 = G$2, G$2.blockSize = 512, G$2.outSize = 160, G$2.hmacStrength = 192, G$2.padLength = 64, G$2.prototype._update = function (t20, h24) {
    for (var i41 = this.h[0], s30 = this.h[1], e31 = this.h[2], n41 = this.h[3], r29 = this.h[4], o37 = i41, a43 = s30, u33 = e31, l37 = n41, c24 = r29, p29 = 0; p29 < 80; p29++) {
        var f33 = C$4(q$3(E$7(i41, I$7(p29, s30, e31, n41), t20[N$3[p29] + h24], J$2(p29)), P$3[p29]), r29);
        i41 = r29, r29 = n41, n41 = q$3(e31, 10), e31 = s30, s30 = f33, f33 = C$4(q$3(E$7(o37, I$7(79 - p29, a43, u33, l37), t20[O$4[p29] + h24], K$3(p29)), Q$12[p29]), c24), o37 = c24, c24 = l37, l37 = q$3(u33, 10), u33 = a43, a43 = f33;
    }
    f33 = D$3(this.h[1], e31, l37), this.h[1] = D$3(this.h[2], n41, c24), this.h[2] = D$3(this.h[3], r29, o37), this.h[3] = D$3(this.h[4], i41, a43), this.h[4] = D$3(this.h[0], s30, u33), this.h[0] = f33;
}, G$2.prototype._digest = function (t20) {
    return "hex" === t20 ? B$7.toHex32(this.h, "little") : B$7.split32(this.h, "little");
};
var M$5, N$3 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
], O$4 = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
], P$3 = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
], Q$12 = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
], R$2 = r$b, T$4 = o$7;

function U$5(t20, h24, i41) {
    if (!(this instanceof U$5)) {
        return new U$5(t20, h24, i41);
    }
    this.Hash = t20, this.blockSize = t20.blockSize / 8, this.outSize = t20.outSize / 8, this.inner = null, this.outer = null, this._init(R$2.toArray(h24, i41));
}

M$5 = U$5, U$5.prototype._init = function (t20) {
    t20.length > this.blockSize && (t20 = (new this.Hash).update(t20).digest()), T$4(t20.length <= this.blockSize);
    for (var h24 = t20.length; h24 < this.blockSize; h24++) {
        t20.push(0);
    }
    for (h24 = 0; h24 < t20.length; h24++) {
        t20[h24] ^= 54;
    }
    for (this.inner = (new this.Hash).update(t20), h24 = 0; h24 < t20.length; h24++) {
        t20[h24] ^= 106;
    }
    this.outer = (new this.Hash).update(t20);
}, U$5.prototype.update = function (t20, h24) {
    return this.inner.update(t20, h24), this;
}, U$5.prototype.digest = function (t20) {
    return this.outer.update(this.inner.digest()), this.outer.digest(t20);
};
var V$2 = M$5, X$2 = {}, Y$11 = X$2;
Y$11.utils = r$b, Y$11.common = a$h, Y$11.sha = j$4, Y$11.ripemd = A$7, Y$11.hmac = V$2, Y$11.sha1 = Y$11.sha.sha1, Y$11.sha256 = Y$11.sha.sha256, Y$11.sha224 = Y$11.sha.sha224, Y$11.sha384 = Y$11.sha.sha384, Y$11.sha512 = Y$11.sha.sha512, Y$11.ripemd160 = Y$11.ripemd.ripemd160;
var s$h, h$e = X$2, r$f = r$a, n$l = o$7;

function o$l(t20) {
    if (!(this instanceof o$l)) {
        return new o$l(t20);
    }
    this.hash = t20.hash, this.predResist = !!t20.predResist, this.outLen = this.hash.outSize, this.minEntropy = t20.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e31 = r$f.toArray(t20.entropy, t20.entropyEnc || "hex"), i41 = r$f.toArray(t20.nonce, t20.nonceEnc || "hex"),
            s30 = r$f.toArray(t20.pers, t20.persEnc || "hex");
    n$l(e31.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e31, i41, s30);
}

s$h = o$l, o$l.prototype._init = function (t20, e31, i41) {
    var s30 = t20.concat(e31).concat(i41);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var h24 = 0; h24 < this.V.length; h24++) {
        this.K[h24] = 0, this.V[h24] = 1;
    }
    this._update(s30), this._reseed = 1, this.reseedInterval = 281474976710656;
}, o$l.prototype._hmac = function () {
    return new h$e.hmac(this.hash, this.K);
}, o$l.prototype._update = function (t20) {
    var e31 = this._hmac().update(this.V).update([
        0
    ]);
    t20 && (e31 = e31.update(t20)), this.K = e31.digest(), this.V = this._hmac().update(this.V).digest(), t20 && (this.K = this._hmac().update(this.V).update([
        1
    ]).update(t20).digest(), this.V = this._hmac().update(this.V).digest());
}, o$l.prototype.reseed = function (t20, e31, i41, s30) {
    "string" != typeof e31 && (s30 = i41, i41 = e31, e31 = null), t20 = r$f.toArray(t20, e31), i41 = r$f.toArray(i41, s30), n$l(t20.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(t20.concat(i41 || [])), this._reseed = 1;
}, o$l.prototype.generate = function (t20, e31, i41, s30) {
    if (this._reseed > this.reseedInterval) {
        throw new Error("Reseed is required");
    }
    "string" != typeof e31 && (s30 = i41, i41 = e31, e31 = null), i41 && (i41 = r$f.toArray(i41, s30 || "hex"), this._update(i41));
    for (var h24 = []; h24.length < t20;) {
        this.V = this._hmac().update(this.V).digest(), h24 = h24.concat(this.V);
    }
    var n41 = h24.slice(0, t20);
    return this._update(i41), this._reseed++, r$f.encode(n41, e31);
};
var a$l = s$h;
var b$b, i$9 = n$c, n$m = n$i, s$i = n$m.getNAF, o$m = n$m.getJSF, u$i = n$m.assert;

function h$f(e31, f34) {
    this.type = e31, this.p = new i$9(f34.p, 16), this.red = f34.prime ? i$9.red(f34.prime) : i$9.mont(this.p), this.zero = new i$9(0).toRed(this.red), this.one = new i$9(1).toRed(this.red), this.two = new i$9(2).toRed(this.red), this.n = f34.n && new i$9(f34.n, 16), this.g = f34.g && this.pointFromJSON(f34.g, f34.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var d15 = this.n && this.p.div(this.n);
    !d15 || d15.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}

function p$j(e31, f34) {
    this.curve = e31, this.type = f34, this.precomputed = null;
}

b$b = h$f, h$f.prototype.point = function () {
    throw new Error("Not implemented");
}, h$f.prototype.validate = function () {
    throw new Error("Not implemented");
}, h$f.prototype._fixedNafMul = function (e31, f34) {
    u$i(e31.precomputed);
    var d15 = e31._getDoubles(), c24 = s$i(f34, 1, this._bitLength),
            t20 = (1 << d15.step + 1) - (d15.step % 2 == 0 ? 2 : 1);
    t20 /= 3;
    for (var a43 = [], r29 = 0; r29 < c24.length; r29 += d15.step) {
        var b13 = 0;
        for (f34 = r29 + d15.step - 1; f34 >= r29; f34--) {
            b13 = (b13 << 1) + c24[f34];
        }
        a43.push(b13);
    }
    for (var i41 = this.jpoint(null, null, null), n41 = this.jpoint(null, null, null), o37 = t20; o37 > 0; o37--) {
        for (r29 = 0; r29 < a43.length; r29++) {
            (b13 = a43[r29]) === o37 ? n41 = n41.mixedAdd(d15.points[r29]) : b13 === -o37 && (n41 = n41.mixedAdd(d15.points[r29].neg()));
        }
        i41 = i41.add(n41);
    }
    return i41.toP();
}, h$f.prototype._wnafMul = function (e31, f34) {
    var d15 = 4, c24 = e31._getNAFPoints(d15);
    d15 = c24.wnd;
    for (var t20 = c24.points, a43 = s$i(f34, d15, this._bitLength), r29 = this.jpoint(null, null, null), b14 = a43.length - 1; b14 >= 0; b14--) {
        for (f34 = 0; b14 >= 0 && 0 === a43[b14]; b14--) {
            f34++;
        }
        if (b14 >= 0 && f34++, r29 = r29.dblp(f34), b14 < 0) {
            break;
        }
        var i41 = a43[b14];
        u$i(0 !== i41), r29 = "affine" === e31.type ? i41 > 0 ? r29.mixedAdd(t20[i41 - 1 >> 1]) : r29.mixedAdd(t20[-i41 - 1 >> 1].neg()) : i41 > 0 ? r29.add(t20[i41 - 1 >> 1]) : r29.add(t20[-i41 - 1 >> 1].neg());
    }
    return "affine" === e31.type ? r29.toP() : r29;
}, h$f.prototype._wnafMulAdd = function (e31, f34, d15, c24, t20) {
    for (var a43 = this._wnafT1, r29 = this._wnafT2, b14 = this._wnafT3, i42 = 0, n41 = 0; n41 < c24; n41++) {
        var u33 = (x9 = f34[n41])._getNAFPoints(e31);
        a43[n41] = u33.wnd, r29[n41] = u33.points;
    }
    for (n41 = c24 - 1; n41 >= 1; n41 -= 2) {
        var h24 = n41 - 1, p29 = n41;
        if (1 === a43[h24] && 1 === a43[p29]) {
            var l37 = [
                f34[h24],
                null,
                null,
                f34[p29]
            ];
            0 === f34[h24].y.cmp(f34[p29].y) ? (l37[1] = f34[h24].add(f34[p29]), l37[2] = f34[h24].toJ().mixedAdd(f34[p29].neg())) : 0 === f34[h24].y.cmp(f34[p29].y.redNeg()) ? (l37[1] = f34[h24].toJ().mixedAdd(f34[p29]), l37[2] = f34[h24].add(f34[p29].neg())) : (l37[1] = f34[h24].toJ().mixedAdd(f34[p29]), l37[2] = f34[h24].toJ().mixedAdd(f34[p29].neg()));
            var v14 = [
                -3,
                -1,
                -5,
                -7,
                0,
                7,
                5,
                1,
                3
            ], y12 = o$m(d15[h24], d15[p29]);
            i42 = Math.max(y12[0].length, i42), b14[h24] = new Array(i42), b14[p29] = new Array(i42);
            for (var m16 = 0; m16 < i42; m16++) {
                var S6 = 0 | y12[0][m16], g14 = 0 | y12[1][m16];
                b14[h24][m16] = v14[3 * (S6 + 1) + (g14 + 1)], b14[p29][m16] = 0, r29[h24] = l37;
            }
        } else {
            b14[h24] = s$i(d15[h24], a43[h24], this._bitLength), b14[p29] = s$i(d15[p29], a43[p29], this._bitLength), i42 = Math.max(b14[h24].length, i42), i42 = Math.max(b14[p29].length, i42);
        }
    }
    var A7 = this.jpoint(null, null, null), I10 = this._wnafT4;
    for (n41 = i42; n41 >= 0; n41--) {
        for (var w6 = 0; n41 >= 0;) {
            var M11 = !0;
            for (m16 = 0; m16 < c24; m16++) {
                I10[m16] = 0 | b14[m16][n41], 0 !== I10[m16] && (M11 = !1);
            }
            if (!M11) {
                break;
            }
            w6++, n41--;
        }
        if (n41 >= 0 && w6++, A7 = A7.dblp(w6), n41 < 0) {
            break;
        }
        for (m16 = 0; m16 < c24; m16++) {
            var x9, _12 = I10[m16];
            0 !== _12 && (_12 > 0 ? x9 = r29[m16][_12 - 1 >> 1] : _12 < 0 && (x9 = r29[m16][-_12 - 1 >> 1].neg()), A7 = "affine" === x9.type ? A7.mixedAdd(x9) : A7.add(x9));
        }
    }
    for (n41 = 0; n41 < c24; n41++) {
        r29[n41] = null;
    }
    return t20 ? A7 : A7.toP();
}, h$f.BasePoint = p$j, p$j.prototype.eq = function () {
    throw new Error("Not implemented");
}, p$j.prototype.validate = function () {
    return this.curve.validate(this);
}, h$f.prototype.decodePoint = function (e31, f34) {
    e31 = n$m.toArray(e31, f34);
    var d15 = this.p.byteLength();
    if ((4 === e31[0] || 6 === e31[0] || 7 === e31[0]) && e31.length - 1 == 2 * d15) {
        return 6 === e31[0] ? u$i(e31[e31.length - 1] % 2 == 0) : 7 === e31[0] && u$i(e31[e31.length - 1] % 2 == 1), this.point(e31.slice(1, 1 + d15), e31.slice(1 + d15, 1 + 2 * d15));
    }
    if ((2 === e31[0] || 3 === e31[0]) && e31.length - 1 === d15) {
        return this.pointFromX(e31.slice(1, 1 + d15), 3 === e31[0]);
    }
    throw new Error("Unknown point format");
}, p$j.prototype.encodeCompressed = function (e31) {
    return this.encode(e31, !0);
}, p$j.prototype._encode = function (e31) {
    var f34 = this.curve.p.byteLength(), d15 = this.getX().toArray("be", f34);
    return e31 ? [
        this.getY().isEven() ? 2 : 3
    ].concat(d15) : [
        4
    ].concat(d15, this.getY().toArray("be", f34));
}, p$j.prototype.encode = function (e31, f34) {
    return n$m.encode(this._encode(f34), e31);
}, p$j.prototype.precompute = function (e31) {
    if (this.precomputed) {
        return this;
    }
    var f34 = {
        doubles: null,
        naf: null,
        beta: null
    };
    return f34.naf = this._getNAFPoints(8), f34.doubles = this._getDoubles(4, e31), f34.beta = this._getBeta(), this.precomputed = f34, this;
}, p$j.prototype._hasDoubles = function (e31) {
    if (!this.precomputed) {
        return !1;
    }
    var f34 = this.precomputed.doubles;
    return !!f34 && f34.points.length >= Math.ceil((e31.bitLength() + 1) / f34.step);
}, p$j.prototype._getDoubles = function (e31, f34) {
    if (this.precomputed && this.precomputed.doubles) {
        return this.precomputed.doubles;
    }
    for (var d15 = [
        this
    ], c24 = this, t20 = 0; t20 < f34; t20 += e31) {
        for (var a43 = 0; a43 < e31; a43++) {
            c24 = c24.dbl();
        }
        d15.push(c24);
    }
    return {
        step: e31,
        points: d15
    };
}, p$j.prototype._getNAFPoints = function (e31) {
    if (this.precomputed && this.precomputed.naf) {
        return this.precomputed.naf;
    }
    for (var f34 = [
        this
    ], d15 = (1 << e31) - 1, c24 = 1 === d15 ? null : this.dbl(), t20 = 1; t20 < d15; t20++) {
        f34[t20] = f34[t20 - 1].add(c24);
    }
    return {
        wnd: e31,
        points: f34
    };
}, p$j.prototype._getBeta = function () {
    return null;
}, p$j.prototype.dblp = function (e31) {
    for (var f34 = this, d15 = 0; d15 < e31; d15++) {
        f34 = f34.dbl();
    }
    return f34;
};
var l$j, v$e = b$b, y$e = n$c, m$f = t$2, S$9 = v$e, g$d = n$i.assert;

function A$8(e31) {
    S$9.call(this, "short", e31), this.a = new y$e(e31.a, 16).toRed(this.red), this.b = new y$e(e31.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(e31), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}

function I$8(e31, f34, d15, c24) {
    S$9.BasePoint.call(this, e31, "affine"), null === f34 && null === d15 ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new y$e(f34, 16), this.y = new y$e(d15, 16), c24 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}

function w$e(e31, f34, d15, c24) {
    S$9.BasePoint.call(this, e31, "jacobian"), null === f34 && null === d15 && null === c24 ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new y$e(0)) : (this.x = new y$e(f34, 16), this.y = new y$e(d15, 16), this.z = new y$e(c24, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}

m$f(A$8, S$9), l$j = A$8, A$8.prototype._getEndomorphism = function (e31) {
    if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
        var f34, d15;
        if (e31.beta) {
            f34 = new y$e(e31.beta, 16).toRed(this.red);
        } else {
            var c24 = this._getEndoRoots(this.p);
            f34 = (f34 = c24[0].cmp(c24[1]) < 0 ? c24[0] : c24[1]).toRed(this.red);
        }
        if (e31.lambda) {
            d15 = new y$e(e31.lambda, 16);
        } else {
            var t20 = this._getEndoRoots(this.n);
            0 === this.g.mul(t20[0]).x.cmp(this.g.x.redMul(f34)) ? d15 = t20[0] : (d15 = t20[1], g$d(0 === this.g.mul(d15).x.cmp(this.g.x.redMul(f34))));
        }
        return {
            beta: f34,
            lambda: d15,
            basis: e31.basis ? e31.basis.map(function (e32) {
                return {
                    a: new y$e(e32.a, 16),
                    b: new y$e(e32.b, 16)
                };
            }) : this._getEndoBasis(d15)
        };
    }
}, A$8.prototype._getEndoRoots = function (e31) {
    var f35 = e31 === this.p ? this.red : y$e.mont(e31), d20 = new y$e(2).toRed(f35).redInvm(), c25 = d20.redNeg(),
            t21 = new y$e(3).toRed(f35).redNeg().redSqrt().redMul(d20);
    return [
        c25.redAdd(t21).fromRed(),
        c25.redSub(t21).fromRed()
    ];
}, A$8.prototype._getEndoBasis = function (e31) {
    for (var f35, d20, c25, t21, a44, r29, b14, i42, n41, s30 = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), o37 = e31, u34 = this.n.clone(), h25 = new y$e(1), p30 = new y$e(0), l38 = new y$e(0), v18 = new y$e(1), m17 = 0; 0 !== o37.cmpn(0);) {
        var S7 = u34.div(o37);
        i42 = u34.sub(S7.mul(o37)), n41 = l38.sub(S7.mul(h25));
        var g15 = v18.sub(S7.mul(p30));
        if (!c25 && i42.cmp(s30) < 0) {
            f35 = b14.neg(), d20 = h25, c25 = i42.neg(), t21 = n41;
        } else if (c25 && 2 == ++m17) {
            break;
        }
        b14 = i42, u34 = o37, o37 = i42, l38 = h25, h25 = n41, v18 = p30, p30 = g15;
    }
    a44 = i42.neg(), r29 = n41;
    var A7 = c25.sqr().add(t21.sqr());
    return a44.sqr().add(r29.sqr()).cmp(A7) >= 0 && (a44 = f35, r29 = d20), c25.negative && (c25 = c25.neg(), t21 = t21.neg()), a44.negative && (a44 = a44.neg(), r29 = r29.neg()), [
        {
            a: c25,
            b: t21
        },
        {
            a: a44,
            b: r29
        }
    ];
}, A$8.prototype._endoSplit = function (e31) {
    var f35 = this.endo.basis, d20 = f35[0], c25 = f35[1], t21 = c25.b.mul(e31).divRound(this.n),
            a44 = d20.b.neg().mul(e31).divRound(this.n), r29 = t21.mul(d20.a), b14 = a44.mul(c25.a),
            i42 = t21.mul(d20.b), n41 = a44.mul(c25.b);
    return {
        k1: e31.sub(r29).sub(b14),
        k2: i42.add(n41).neg()
    };
}, A$8.prototype.pointFromX = function (e31, f35) {
    (e31 = new y$e(e31, 16)).red || (e31 = e31.toRed(this.red));
    var d20 = e31.redSqr().redMul(e31).redIAdd(e31.redMul(this.a)).redIAdd(this.b), c25 = d20.redSqrt();
    if (0 !== c25.redSqr().redSub(d20).cmp(this.zero)) {
        throw new Error("invalid point");
    }
    var t21 = c25.fromRed().isOdd();
    return (f35 && !t21 || !f35 && t21) && (c25 = c25.redNeg()), this.point(e31, c25);
}, A$8.prototype.validate = function (e31) {
    if (e31.inf) {
        return !0;
    }
    var f35 = e31.x, d20 = e31.y, c25 = this.a.redMul(f35), t21 = f35.redSqr().redMul(f35).redIAdd(c25).redIAdd(this.b);
    return 0 === d20.redSqr().redISub(t21).cmpn(0);
}, A$8.prototype._endoWnafMulAdd = function (e31, f35, d20) {
    for (var c25 = this._endoWnafT1, t21 = this._endoWnafT2, a44 = 0; a44 < e31.length; a44++) {
        var r29 = this._endoSplit(f35[a44]), b14 = e31[a44], i42 = b14._getBeta();
        r29.k1.negative && (r29.k1.ineg(), b14 = b14.neg(!0)), r29.k2.negative && (r29.k2.ineg(), i42 = i42.neg(!0)), c25[2 * a44] = b14, c25[2 * a44 + 1] = i42, t21[2 * a44] = r29.k1, t21[2 * a44 + 1] = r29.k2;
    }
    for (var n41 = this._wnafMulAdd(1, c25, t21, 2 * a44, d20), s30 = 0; s30 < 2 * a44; s30++) {
        c25[s30] = null, t21[s30] = null;
    }
    return n41;
}, m$f(I$8, S$9.BasePoint), A$8.prototype.point = function (e31, f35, d20) {
    return new I$8(this, e31, f35, d20);
}, A$8.prototype.pointFromJSON = function (e31, f35) {
    return I$8.fromJSON(this, e31, f35);
}, I$8.prototype._getBeta = function () {
    if (this.curve.endo) {
        var e31 = this.precomputed;
        if (e31 && e31.beta) {
            return e31.beta;
        }
        var f35 = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e31) {
            var d20 = this.curve, c25 = function (e32) {
                return d20.point(e32.x.redMul(d20.endo.beta), e32.y);
            };
            e31.beta = f35, f35.precomputed = {
                beta: null,
                naf: e31.naf && {
                    wnd: e31.naf.wnd,
                    points: e31.naf.points.map(c25)
                },
                doubles: e31.doubles && {
                    step: e31.doubles.step,
                    points: e31.doubles.points.map(c25)
                }
            };
        }
        return f35;
    }
}, I$8.prototype.toJSON = function () {
    return this.precomputed ? [
        this.x,
        this.y,
        this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        }
    ] : [
        this.x,
        this.y
    ];
}, I$8.fromJSON = function (e32, f36, d21) {
    "string" == typeof f36 && (f36 = JSON.parse(f36));
    var c26 = e32.point(f36[0], f36[1], d21);
    if (!f36[2]) {
        return c26;
    }

    function t21(f37) {
        return e32.point(f37[0], f37[1], d21);
    }

    var a44 = f36[2];
    return c26.precomputed = {
        beta: null,
        doubles: a44.doubles && {
            step: a44.doubles.step,
            points: [
                c26
            ].concat(a44.doubles.points.map(t21))
        },
        naf: a44.naf && {
            wnd: a44.naf.wnd,
            points: [
                c26
            ].concat(a44.naf.points.map(t21))
        }
    }, c26;
}, I$8.prototype.inspect = function () {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
}, I$8.prototype.isInfinity = function () {
    return this.inf;
}, I$8.prototype.add = function (e32) {
    if (this.inf) {
        return e32;
    }
    if (e32.inf) {
        return this;
    }
    if (this.eq(e32)) {
        return this.dbl();
    }
    if (this.neg().eq(e32)) {
        return this.curve.point(null, null);
    }
    if (0 === this.x.cmp(e32.x)) {
        return this.curve.point(null, null);
    }
    var f36 = this.y.redSub(e32.y);
    0 !== f36.cmpn(0) && (f36 = f36.redMul(this.x.redSub(e32.x).redInvm()));
    var d21 = f36.redSqr().redISub(this.x).redISub(e32.x), c26 = f36.redMul(this.x.redSub(d21)).redISub(this.y);
    return this.curve.point(d21, c26);
}, I$8.prototype.dbl = function () {
    if (this.inf) {
        return this;
    }
    var e32 = this.y.redAdd(this.y);
    if (0 === e32.cmpn(0)) {
        return this.curve.point(null, null);
    }
    var f36 = this.curve.a, d21 = this.x.redSqr(), c26 = e32.redInvm(),
            t21 = d21.redAdd(d21).redIAdd(d21).redIAdd(f36).redMul(c26),
            a44 = t21.redSqr().redISub(this.x.redAdd(this.x)), r30 = t21.redMul(this.x.redSub(a44)).redISub(this.y);
    return this.curve.point(a44, r30);
}, I$8.prototype.getX = function () {
    return this.x.fromRed();
}, I$8.prototype.getY = function () {
    return this.y.fromRed();
}, I$8.prototype.mul = function (e32) {
    return e32 = new y$e(e32, 16), this.isInfinity() ? this : this._hasDoubles(e32) ? this.curve._fixedNafMul(this, e32) : this.curve.endo ? this.curve._endoWnafMulAdd([
        this
    ], [
        e32
    ]) : this.curve._wnafMul(this, e32);
}, I$8.prototype.mulAdd = function (e32, f36, d21) {
    var c26 = [
        this,
        f36
    ], t21 = [
        e32,
        d21
    ];
    return this.curve.endo ? this.curve._endoWnafMulAdd(c26, t21) : this.curve._wnafMulAdd(1, c26, t21, 2);
}, I$8.prototype.jmulAdd = function (e32, f36, d21) {
    var c26 = [
        this,
        f36
    ], t21 = [
        e32,
        d21
    ];
    return this.curve.endo ? this.curve._endoWnafMulAdd(c26, t21, !0) : this.curve._wnafMulAdd(1, c26, t21, 2, !0);
}, I$8.prototype.eq = function (e32) {
    return this === e32 || this.inf === e32.inf && (this.inf || 0 === this.x.cmp(e32.x) && 0 === this.y.cmp(e32.y));
}, I$8.prototype.neg = function (e32) {
    if (this.inf) {
        return this;
    }
    var f36 = this.curve.point(this.x, this.y.redNeg());
    if (e32 && this.precomputed) {
        var d21 = this.precomputed, c26 = function (e33) {
            return e33.neg();
        };
        f36.precomputed = {
            naf: d21.naf && {
                wnd: d21.naf.wnd,
                points: d21.naf.points.map(c26)
            },
            doubles: d21.doubles && {
                step: d21.doubles.step,
                points: d21.doubles.points.map(c26)
            }
        };
    }
    return f36;
}, I$8.prototype.toJ = function () {
    return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
}, m$f(w$e, S$9.BasePoint), A$8.prototype.jpoint = function (e32, f36, d22) {
    return new w$e(this, e32, f36, d22);
}, w$e.prototype.toP = function () {
    if (this.isInfinity()) {
        return this.curve.point(null, null);
    }
    var e32 = this.z.redInvm(), f36 = e32.redSqr(), d22 = this.x.redMul(f36), c27 = this.y.redMul(f36).redMul(e32);
    return this.curve.point(d22, c27);
}, w$e.prototype.neg = function () {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
}, w$e.prototype.add = function (e32) {
    if (this.isInfinity()) {
        return e32;
    }
    if (e32.isInfinity()) {
        return this;
    }
    var f36 = e32.z.redSqr(), d22 = this.z.redSqr(), c27 = this.x.redMul(f36), t21 = e32.x.redMul(d22),
            a44 = this.y.redMul(f36.redMul(e32.z)), r30 = e32.y.redMul(d22.redMul(this.z)), b15 = c27.redSub(t21),
            i43 = a44.redSub(r30);
    if (0 === b15.cmpn(0)) {
        return 0 !== i43.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
    }
    var n41 = b15.redSqr(), s30 = n41.redMul(b15), o37 = c27.redMul(n41),
            u34 = i43.redSqr().redIAdd(s30).redISub(o37).redISub(o37),
            h25 = i43.redMul(o37.redISub(u34)).redISub(a44.redMul(s30)), p30 = this.z.redMul(e32.z).redMul(b15);
    return this.curve.jpoint(u34, h25, p30);
}, w$e.prototype.mixedAdd = function (e32) {
    if (this.isInfinity()) {
        return e32.toJ();
    }
    if (e32.isInfinity()) {
        return this;
    }
    var f36 = this.z.redSqr(), d22 = this.x, c27 = e32.x.redMul(f36), t21 = this.y,
            a44 = e32.y.redMul(f36).redMul(this.z), r30 = d22.redSub(c27), b15 = t21.redSub(a44);
    if (0 === r30.cmpn(0)) {
        return 0 !== b15.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
    }
    var i43 = r30.redSqr(), n41 = i43.redMul(r30), s30 = d22.redMul(i43),
            o37 = b15.redSqr().redIAdd(n41).redISub(s30).redISub(s30),
            u34 = b15.redMul(s30.redISub(o37)).redISub(t21.redMul(n41)), h25 = this.z.redMul(r30);
    return this.curve.jpoint(o37, u34, h25);
}, w$e.prototype.dblp = function (e32) {
    if (0 === e32) {
        return this;
    }
    if (this.isInfinity()) {
        return this;
    }
    if (!e32) {
        return this.dbl();
    }
    if (this.curve.zeroA || this.curve.threeA) {
        for (var f36 = this, d22 = 0; d22 < e32; d22++) {
            f36 = f36.dbl();
        }
        return f36;
    }
    var c27 = this.curve.a, t21 = this.curve.tinv, a44 = this.x, r30 = this.y, b15 = this.z,
            i43 = b15.redSqr().redSqr(), n41 = r30.redAdd(r30);
    for (d22 = 0; d22 < e32; d22++) {
        var s30 = a44.redSqr(), o37 = n41.redSqr(), u34 = o37.redSqr(),
                h25 = s30.redAdd(s30).redIAdd(s30).redIAdd(c27.redMul(i43)), p30 = a44.redMul(o37),
                l38 = h25.redSqr().redISub(p30.redAdd(p30)), v18 = p30.redISub(l38), y13 = h25.redMul(v18);
        y13 = y13.redIAdd(y13).redISub(u34);
        var m17 = n41.redMul(b15);
        d22 + 1 < e32 && (i43 = i43.redMul(u34)), a44 = l38, b15 = m17, n41 = y13;
    }
    return this.curve.jpoint(a44, n41.redMul(t21), b15);
}, w$e.prototype.dbl = function () {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
}, w$e.prototype._zeroDbl = function () {
    var e32, f37, d23;
    if (this.zOne) {
        var c27 = this.x.redSqr(), t21 = this.y.redSqr(), a44 = t21.redSqr(),
                r30 = this.x.redAdd(t21).redSqr().redISub(c27).redISub(a44);
        r30 = r30.redIAdd(r30);
        var b15 = c27.redAdd(c27).redIAdd(c27), i43 = b15.redSqr().redISub(r30).redISub(r30), n41 = a44.redIAdd(a44);
        n41 = (n41 = n41.redIAdd(n41)).redIAdd(n41), e32 = i43, f37 = b15.redMul(r30.redISub(i43)).redISub(n41), d23 = this.y.redAdd(this.y);
    } else {
        var s31 = this.x.redSqr(), o38 = this.y.redSqr(), u35 = o38.redSqr(),
                h26 = this.x.redAdd(o38).redSqr().redISub(s31).redISub(u35);
        h26 = h26.redIAdd(h26);
        var p31 = s31.redAdd(s31).redIAdd(s31), l39 = p31.redSqr(), v19 = u35.redIAdd(u35);
        v19 = (v19 = v19.redIAdd(v19)).redIAdd(v19), e32 = l39.redISub(h26).redISub(h26), f37 = p31.redMul(h26.redISub(e32)).redISub(v19), d23 = (d23 = this.y.redMul(this.z)).redIAdd(d23);
    }
    return this.curve.jpoint(e32, f37, d23);
}, w$e.prototype._threeDbl = function () {
    var e32, f37, d23;
    if (this.zOne) {
        var c28 = this.x.redSqr(), t22 = this.y.redSqr(), a45 = t22.redSqr(),
                r31 = this.x.redAdd(t22).redSqr().redISub(c28).redISub(a45);
        r31 = r31.redIAdd(r31);
        var b16 = c28.redAdd(c28).redIAdd(c28).redIAdd(this.curve.a), i44 = b16.redSqr().redISub(r31).redISub(r31);
        e32 = i44;
        var n42 = a45.redIAdd(a45);
        n42 = (n42 = n42.redIAdd(n42)).redIAdd(n42), f37 = b16.redMul(r31.redISub(i44)).redISub(n42), d23 = this.y.redAdd(this.y);
    } else {
        var s32 = this.z.redSqr(), o39 = this.y.redSqr(), u36 = this.x.redMul(o39),
                h27 = this.x.redSub(s32).redMul(this.x.redAdd(s32));
        h27 = h27.redAdd(h27).redIAdd(h27);
        var p32 = u36.redIAdd(u36), l40 = (p32 = p32.redIAdd(p32)).redAdd(p32);
        e32 = h27.redSqr().redISub(l40), d23 = this.y.redAdd(this.z).redSqr().redISub(o39).redISub(s32);
        var v20 = o39.redSqr();
        v20 = (v20 = (v20 = v20.redIAdd(v20)).redIAdd(v20)).redIAdd(v20), f37 = h27.redMul(p32.redISub(e32)).redISub(v20);
    }
    return this.curve.jpoint(e32, f37, d23);
}, w$e.prototype._dbl = function () {
    var e32 = this.curve.a, f37 = this.x, d23 = this.y, c29 = this.z, t23 = c29.redSqr().redSqr(), a46 = f37.redSqr(),
            r32 = d23.redSqr(), b17 = a46.redAdd(a46).redIAdd(a46).redIAdd(e32.redMul(t23)), i45 = f37.redAdd(f37),
            n43 = (i45 = i45.redIAdd(i45)).redMul(r32), s33 = b17.redSqr().redISub(n43.redAdd(n43)),
            o40 = n43.redISub(s33), u37 = r32.redSqr();
    u37 = (u37 = (u37 = u37.redIAdd(u37)).redIAdd(u37)).redIAdd(u37);
    var h28 = b17.redMul(o40).redISub(u37), p33 = d23.redAdd(d23).redMul(c29);
    return this.curve.jpoint(s33, h28, p33);
}, w$e.prototype.trpl = function () {
    if (!this.curve.zeroA) {
        return this.dbl().add(this);
    }
    var e32 = this.x.redSqr(), f37 = this.y.redSqr(), d23 = this.z.redSqr(), c29 = f37.redSqr(),
            t23 = e32.redAdd(e32).redIAdd(e32), a46 = t23.redSqr(),
            r32 = this.x.redAdd(f37).redSqr().redISub(e32).redISub(c29),
            b17 = (r32 = (r32 = (r32 = r32.redIAdd(r32)).redAdd(r32).redIAdd(r32)).redISub(a46)).redSqr(),
            i45 = c29.redIAdd(c29);
    i45 = (i45 = (i45 = i45.redIAdd(i45)).redIAdd(i45)).redIAdd(i45);
    var n43 = t23.redIAdd(r32).redSqr().redISub(a46).redISub(b17).redISub(i45), s33 = f37.redMul(n43);
    s33 = (s33 = s33.redIAdd(s33)).redIAdd(s33);
    var o40 = this.x.redMul(b17).redISub(s33);
    o40 = (o40 = o40.redIAdd(o40)).redIAdd(o40);
    var u37 = this.y.redMul(n43.redMul(i45.redISub(n43)).redISub(r32.redMul(b17)));
    u37 = (u37 = (u37 = u37.redIAdd(u37)).redIAdd(u37)).redIAdd(u37);
    var h28 = this.z.redAdd(r32).redSqr().redISub(d23).redISub(b17);
    return this.curve.jpoint(o40, u37, h28);
}, w$e.prototype.mul = function (e32, f37) {
    return e32 = new y$e(e32, f37), this.curve._wnafMul(this, e32);
}, w$e.prototype.eq = function (e32) {
    if ("affine" === e32.type) {
        return this.eq(e32.toJ());
    }
    if (this === e32) {
        return !0;
    }
    var f37 = this.z.redSqr(), d23 = e32.z.redSqr();
    if (0 !== this.x.redMul(d23).redISub(e32.x.redMul(f37)).cmpn(0)) {
        return !1;
    }
    var c29 = f37.redMul(this.z), t23 = d23.redMul(e32.z);
    return 0 === this.y.redMul(t23).redISub(e32.y.redMul(c29)).cmpn(0);
}, w$e.prototype.eqXToP = function (e32) {
    var f37 = this.z.redSqr(), d23 = e32.toRed(this.curve.red).redMul(f37);
    if (0 === this.x.cmp(d23)) {
        return !0;
    }
    for (var c29 = e32.clone(), t23 = this.curve.redN.redMul(f37); ;) {
        if (c29.iadd(this.curve.n), c29.cmp(this.curve.p) >= 0) {
            return !1;
        }
        if (d23.redIAdd(t23), 0 === this.x.cmp(d23)) {
            return !0;
        }
    }
}, w$e.prototype.inspect = function () {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
}, w$e.prototype.isInfinity = function () {
    return 0 === this.z.cmpn(0);
};
var M$6, x$6 = l$j, _$d = n$c, z$6 = t$2, q$4 = v$e, R$3 = n$i;

function P$4(e32) {
    q$4.call(this, "mont", e32), this.a = new _$d(e32.a, 16).toRed(this.red), this.b = new _$d(e32.b, 16).toRed(this.red), this.i4 = new _$d(4).toRed(this.red).redInvm(), this.two = new _$d(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}

function j$5(e32, f37, d23) {
    q$4.BasePoint.call(this, e32, "projective"), null === f37 && null === d23 ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new _$d(f37, 16), this.z = new _$d(d23, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}

z$6(P$4, q$4), M$6 = P$4, P$4.prototype.validate = function (e32) {
    var f37 = e32.normalize().x, d23 = f37.redSqr(), c29 = d23.redMul(f37).redAdd(d23.redMul(this.a)).redAdd(f37);
    return 0 === c29.redSqrt().redSqr().cmp(c29);
}, z$6(j$5, q$4.BasePoint), P$4.prototype.decodePoint = function (e32, f37) {
    return this.point(R$3.toArray(e32, f37), 1);
}, P$4.prototype.point = function (e32, f37) {
    return new j$5(this, e32, f37);
}, P$4.prototype.pointFromJSON = function (e32) {
    return j$5.fromJSON(this, e32);
}, j$5.prototype.precompute = function () {
}, j$5.prototype._encode = function () {
    return this.getX().toArray("be", this.curve.p.byteLength());
}, j$5.fromJSON = function (e32, f37) {
    return new j$5(e32, f37[0], f37[1] || e32.one);
}, j$5.prototype.inspect = function () {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
}, j$5.prototype.isInfinity = function () {
    return 0 === this.z.cmpn(0);
}, j$5.prototype.dbl = function () {
    var e32 = this.x.redAdd(this.z).redSqr(), f37 = this.x.redSub(this.z).redSqr(), d23 = e32.redSub(f37),
            c29 = e32.redMul(f37), t23 = d23.redMul(f37.redAdd(this.curve.a24.redMul(d23)));
    return this.curve.point(c29, t23);
}, j$5.prototype.add = function () {
    throw new Error("Not supported on Montgomery curve");
}, j$5.prototype.diffAdd = function (e32, f37) {
    var d23 = this.x.redAdd(this.z), c29 = this.x.redSub(this.z), t23 = e32.x.redAdd(e32.z),
            a46 = e32.x.redSub(e32.z).redMul(d23), r32 = t23.redMul(c29), b17 = f37.z.redMul(a46.redAdd(r32).redSqr()),
            i45 = f37.x.redMul(a46.redISub(r32).redSqr());
    return this.curve.point(b17, i45);
}, j$5.prototype.mul = function (e32) {
    for (var f37 = e32.clone(), d23 = this, c29 = this.curve.point(null, null), t23 = []; 0 !== f37.cmpn(0); f37.iushrn(1)) {
        t23.push(f37.andln(1));
    }
    for (var a46 = t23.length - 1; a46 >= 0; a46--) {
        0 === t23[a46] ? (d23 = d23.diffAdd(c29, this), c29 = c29.dbl()) : (c29 = d23.diffAdd(c29, this), d23 = d23.dbl());
    }
    return c29;
}, j$5.prototype.mulAdd = function () {
    throw new Error("Not supported on Montgomery curve");
}, j$5.prototype.jumlAdd = function () {
    throw new Error("Not supported on Montgomery curve");
}, j$5.prototype.eq = function (e32) {
    return 0 === this.getX().cmp(e32.getX());
}, j$5.prototype.normalize = function () {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
}, j$5.prototype.getX = function () {
    return this.normalize(), this.x.fromRed();
};
var N$4, E$8 = M$6, k$b = n$c, O$5 = t$2, L$4 = v$e, B$8 = n$i.assert;

function F$5(e32) {
    this.twisted = 1 != (0 | e32.a), this.mOneA = this.twisted && -1 == (0 | e32.a), this.extended = this.mOneA, L$4.call(this, "edwards", e32), this.a = new k$b(e32.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new k$b(e32.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new k$b(e32.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), B$8(!this.twisted || 0 === this.c.fromRed().cmpn(1)), this.oneC = 1 == (0 | e32.c);
}

function C$5(e32, f37, d23, c29, t23) {
    L$4.BasePoint.call(this, e32, "projective"), null === f37 && null === d23 && null === c29 ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new k$b(f37, 16), this.y = new k$b(d23, 16), this.z = c29 ? new k$b(c29, 16) : this.curve.one, this.t = t23 && new k$b(t23, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}

O$5(F$5, L$4), N$4 = F$5, F$5.prototype._mulA = function (e32) {
    return this.mOneA ? e32.redNeg() : this.a.redMul(e32);
}, F$5.prototype._mulC = function (e32) {
    return this.oneC ? e32 : this.c.redMul(e32);
}, F$5.prototype.jpoint = function (e32, f37, d23, c29) {
    return this.point(e32, f37, d23, c29);
}, F$5.prototype.pointFromX = function (e32, f37) {
    (e32 = new k$b(e32, 16)).red || (e32 = e32.toRed(this.red));
    var d23 = e32.redSqr(), c29 = this.c2.redSub(this.a.redMul(d23)),
            t23 = this.one.redSub(this.c2.redMul(this.d).redMul(d23)), a46 = c29.redMul(t23.redInvm()),
            r32 = a46.redSqrt();
    if (0 !== r32.redSqr().redSub(a46).cmp(this.zero)) {
        throw new Error("invalid point");
    }
    var b17 = r32.fromRed().isOdd();
    return (f37 && !b17 || !f37 && b17) && (r32 = r32.redNeg()), this.point(e32, r32);
}, F$5.prototype.pointFromY = function (e32, f37) {
    (e32 = new k$b(e32, 16)).red || (e32 = e32.toRed(this.red));
    var d23 = e32.redSqr(), c29 = d23.redSub(this.c2), t23 = d23.redMul(this.d).redMul(this.c2).redSub(this.a),
            a46 = c29.redMul(t23.redInvm());
    if (0 === a46.cmp(this.zero)) {
        if (f37) {
            throw new Error("invalid point");
        }
        return this.point(this.zero, e32);
    }
    var r32 = a46.redSqrt();
    if (0 !== r32.redSqr().redSub(a46).cmp(this.zero)) {
        throw new Error("invalid point");
    }
    return r32.fromRed().isOdd() !== f37 && (r32 = r32.redNeg()), this.point(r32, e32);
}, F$5.prototype.validate = function (e32) {
    if (e32.isInfinity()) {
        return !0;
    }
    e32.normalize();
    var f37 = e32.x.redSqr(), d23 = e32.y.redSqr(), c29 = f37.redMul(this.a).redAdd(d23),
            t23 = this.c2.redMul(this.one.redAdd(this.d.redMul(f37).redMul(d23)));
    return 0 === c29.cmp(t23);
}, O$5(C$5, L$4.BasePoint), F$5.prototype.pointFromJSON = function (e32) {
    return C$5.fromJSON(this, e32);
}, F$5.prototype.point = function (e32, f37, d23, c29) {
    return new C$5(this, e32, f37, d23, c29);
}, C$5.fromJSON = function (e32, f37) {
    return new C$5(e32, f37[0], f37[1], f37[2]);
}, C$5.prototype.inspect = function () {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
}, C$5.prototype.isInfinity = function () {
    return 0 === this.x.cmpn(0) && (0 === this.y.cmp(this.z) || this.zOne && 0 === this.y.cmp(this.curve.c));
}, C$5.prototype._extDbl = function () {
    var e32 = this.x.redSqr(), f37 = this.y.redSqr(), d23 = this.z.redSqr();
    d23 = d23.redIAdd(d23);
    var c29 = this.curve._mulA(e32), t23 = this.x.redAdd(this.y).redSqr().redISub(e32).redISub(f37),
            a46 = c29.redAdd(f37), r32 = a46.redSub(d23), b17 = c29.redSub(f37), i45 = t23.redMul(r32),
            n43 = a46.redMul(b17), s33 = t23.redMul(b17), o40 = r32.redMul(a46);
    return this.curve.point(i45, n43, o40, s33);
}, C$5.prototype._projDbl = function () {
    var e32, f37, d23, c29 = this.x.redAdd(this.y).redSqr(), t23 = this.x.redSqr(), a46 = this.y.redSqr();
    if (this.curve.twisted) {
        var r32 = (n43 = this.curve._mulA(t23)).redAdd(a46);
        if (this.zOne) {
            e32 = c29.redSub(t23).redSub(a46).redMul(r32.redSub(this.curve.two)), f37 = r32.redMul(n43.redSub(a46)), d23 = r32.redSqr().redSub(r32).redSub(r32);
        } else {
            var b17 = this.z.redSqr(), i45 = r32.redSub(b17).redISub(b17);
            e32 = c29.redSub(t23).redISub(a46).redMul(i45), f37 = r32.redMul(n43.redSub(a46)), d23 = r32.redMul(i45);
        }
    } else {
        var n43 = t23.redAdd(a46);
        b17 = this.curve._mulC(this.z).redSqr(), i45 = n43.redSub(b17).redSub(b17);
        e32 = this.curve._mulC(c29.redISub(n43)).redMul(i45), f37 = this.curve._mulC(n43).redMul(t23.redISub(a46)), d23 = n43.redMul(i45);
    }
    return this.curve.point(e32, f37, d23);
}, C$5.prototype.dbl = function () {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
}, C$5.prototype._extAdd = function (e32) {
    var f37 = this.y.redSub(this.x).redMul(e32.y.redSub(e32.x)),
            d23 = this.y.redAdd(this.x).redMul(e32.y.redAdd(e32.x)), c29 = this.t.redMul(this.curve.dd).redMul(e32.t),
            t23 = this.z.redMul(e32.z.redAdd(e32.z)), a46 = d23.redSub(f37), r33 = t23.redSub(c29),
            b18 = t23.redAdd(c29), i46 = d23.redAdd(f37), n44 = a46.redMul(r33), s33 = b18.redMul(i46),
            o40 = a46.redMul(i46), u37 = r33.redMul(b18);
    return this.curve.point(n44, s33, u37, o40);
}, C$5.prototype._projAdd = function (e32) {
    var f37, d23, c29 = this.z.redMul(e32.z), t23 = c29.redSqr(), a46 = this.x.redMul(e32.x),
            r33 = this.y.redMul(e32.y), b18 = this.curve.d.redMul(a46).redMul(r33), i46 = t23.redSub(b18),
            n44 = t23.redAdd(b18), s33 = this.x.redAdd(this.y).redMul(e32.x.redAdd(e32.y)).redISub(a46).redISub(r33),
            o40 = c29.redMul(i46).redMul(s33);
    return this.curve.twisted ? (f37 = c29.redMul(n44).redMul(r33.redSub(this.curve._mulA(a46))), d23 = i46.redMul(n44)) : (f37 = c29.redMul(n44).redMul(r33.redSub(a46)), d23 = this.curve._mulC(i46).redMul(n44)), this.curve.point(o40, f37, d23);
}, C$5.prototype.add = function (e32) {
    return this.isInfinity() ? e32 : e32.isInfinity() ? this : this.curve.extended ? this._extAdd(e32) : this._projAdd(e32);
}, C$5.prototype.mul = function (e32) {
    return this._hasDoubles(e32) ? this.curve._fixedNafMul(this, e32) : this.curve._wnafMul(this, e32);
}, C$5.prototype.mulAdd = function (e32, f37, d23) {
    return this.curve._wnafMulAdd(1, [
        this,
        f37
    ], [
        e32,
        d23
    ], 2, !1);
}, C$5.prototype.jmulAdd = function (e32, f37, d23) {
    return this.curve._wnafMulAdd(1, [
        this,
        f37
    ], [
        e32,
        d23
    ], 2, !0);
}, C$5.prototype.normalize = function () {
    if (this.zOne) {
        return this;
    }
    var e32 = this.z.redInvm();
    return this.x = this.x.redMul(e32), this.y = this.y.redMul(e32), this.t && (this.t = this.t.redMul(e32)), this.z = this.curve.one, this.zOne = !0, this;
}, C$5.prototype.neg = function () {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
}, C$5.prototype.getX = function () {
    return this.normalize(), this.x.fromRed();
}, C$5.prototype.getY = function () {
    return this.normalize(), this.y.fromRed();
}, C$5.prototype.eq = function (e32) {
    return this === e32 || 0 === this.getX().cmp(e32.getX()) && 0 === this.getY().cmp(e32.getY());
}, C$5.prototype.eqXToP = function (e32) {
    var f37 = e32.toRed(this.curve.red).redMul(this.z);
    if (0 === this.x.cmp(f37)) {
        return !0;
    }
    for (var d23 = e32.clone(), c29 = this.curve.redN.redMul(this.z); ;) {
        if (d23.iadd(this.curve.n), d23.cmp(this.curve.p) >= 0) {
            return !1;
        }
        if (f37.redIAdd(c29), 0 === this.x.cmp(f37)) {
            return !0;
        }
    }
}, C$5.prototype.toP = C$5.prototype.normalize, C$5.prototype.mixedAdd = C$5.prototype.add;
var T$5 = N$4, J$3 = {}, X$3 = J$3;
X$3.base = v$e, X$3.short = x$6, X$3.mont = E$8, X$3.edwards = T$5;
var D$4, Y$2 = {
    doubles: {
        step: 4,
        points: [
            [
                "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
                "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
            ],
            [
                "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
                "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
            ],
            [
                "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
                "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
            ],
            [
                "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
                "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
            ],
            [
                "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
                "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
            ],
            [
                "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
                "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
            ],
            [
                "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
                "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
            ],
            [
                "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
                "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
            ],
            [
                "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
                "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
            ],
            [
                "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
                "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
            ],
            [
                "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
                "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
            ],
            [
                "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
                "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
            ],
            [
                "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
                "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
            ],
            [
                "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
                "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
            ],
            [
                "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
                "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
            ],
            [
                "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
                "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
            ],
            [
                "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
                "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
            ],
            [
                "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
                "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
            ],
            [
                "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
                "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
            ],
            [
                "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
                "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
            ],
            [
                "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
                "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
            ],
            [
                "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
                "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
            ],
            [
                "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
                "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
            ],
            [
                "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
                "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
            ],
            [
                "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
                "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
            ],
            [
                "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
                "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
            ],
            [
                "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
                "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
            ],
            [
                "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
                "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
            ],
            [
                "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
                "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
            ],
            [
                "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
                "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
            ],
            [
                "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
                "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
            ],
            [
                "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
                "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
            ],
            [
                "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
                "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
            ],
            [
                "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
                "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
            ],
            [
                "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
                "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
            ],
            [
                "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
                "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
            ],
            [
                "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
                "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
            ],
            [
                "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
                "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
            ],
            [
                "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
                "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
            ],
            [
                "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
                "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
            ],
            [
                "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
                "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
            ],
            [
                "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
                "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
            ],
            [
                "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
                "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
            ],
            [
                "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
                "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
            ],
            [
                "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
                "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
            ],
            [
                "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
                "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
            ],
            [
                "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
                "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
            ],
            [
                "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
                "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
            ],
            [
                "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
                "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
            ],
            [
                "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
                "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
            ],
            [
                "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
                "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
            ],
            [
                "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
                "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
            ],
            [
                "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
                "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
            ],
            [
                "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
                "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
            ],
            [
                "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
                "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
            ],
            [
                "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
                "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
            ],
            [
                "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
                "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
            ],
            [
                "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
                "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
            ],
            [
                "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
                "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
            ],
            [
                "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
                "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
            ],
            [
                "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
                "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
            ],
            [
                "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
                "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
            ],
            [
                "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
                "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
            ],
            [
                "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
                "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
            ],
            [
                "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
                "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
            ]
        ]
    },
    naf: {
        wnd: 7,
        points: [
            [
                "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
            ],
            [
                "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
                "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
            ],
            [
                "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
                "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
            ],
            [
                "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
                "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
            ],
            [
                "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
                "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
            ],
            [
                "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
                "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
            ],
            [
                "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
                "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
            ],
            [
                "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
                "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
            ],
            [
                "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
                "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
            ],
            [
                "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
                "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
            ],
            [
                "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
                "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
            ],
            [
                "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
                "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
            ],
            [
                "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
                "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
            ],
            [
                "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
                "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
            ],
            [
                "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
                "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
            ],
            [
                "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
                "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
            ],
            [
                "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
                "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
            ],
            [
                "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
                "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
            ],
            [
                "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
                "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
            ],
            [
                "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
                "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
            ],
            [
                "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
                "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
            ],
            [
                "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
                "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
            ],
            [
                "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
                "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
            ],
            [
                "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
                "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
            ],
            [
                "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
                "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
            ],
            [
                "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
                "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
            ],
            [
                "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
                "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
            ],
            [
                "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
                "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
            ],
            [
                "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
                "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
            ],
            [
                "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
                "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
            ],
            [
                "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
                "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
            ],
            [
                "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
                "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
            ],
            [
                "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
                "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
            ],
            [
                "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
                "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
            ],
            [
                "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
                "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
            ],
            [
                "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
                "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
            ],
            [
                "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
                "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
            ],
            [
                "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
                "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
            ],
            [
                "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
                "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
            ],
            [
                "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
                "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
            ],
            [
                "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
                "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
            ],
            [
                "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
                "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
            ],
            [
                "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
                "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
            ],
            [
                "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
                "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
            ],
            [
                "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
                "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
            ],
            [
                "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
                "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
            ],
            [
                "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
                "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
            ],
            [
                "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
                "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
            ],
            [
                "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
                "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
            ],
            [
                "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
                "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
            ],
            [
                "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
                "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
            ],
            [
                "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
                "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
            ],
            [
                "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
                "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
            ],
            [
                "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
                "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
            ],
            [
                "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
                "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
            ],
            [
                "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
                "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
            ],
            [
                "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
                "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
            ],
            [
                "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
                "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
            ],
            [
                "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
                "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
            ],
            [
                "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
                "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
            ],
            [
                "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
                "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
            ],
            [
                "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
                "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
            ],
            [
                "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
                "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
            ],
            [
                "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
                "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
            ],
            [
                "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
                "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
            ],
            [
                "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
                "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
            ],
            [
                "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
                "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
            ],
            [
                "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
                "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
            ],
            [
                "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
                "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
            ],
            [
                "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
                "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
            ],
            [
                "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
                "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
            ],
            [
                "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
                "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
            ],
            [
                "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
                "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
            ],
            [
                "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
                "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
            ],
            [
                "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
                "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
            ],
            [
                "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
                "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
            ],
            [
                "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
                "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
            ],
            [
                "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
                "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
            ],
            [
                "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
                "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
            ],
            [
                "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
                "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
            ],
            [
                "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
                "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
            ],
            [
                "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
                "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
            ],
            [
                "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
                "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
            ],
            [
                "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
                "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
            ],
            [
                "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
                "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
            ],
            [
                "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
                "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
            ],
            [
                "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
                "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
            ],
            [
                "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
                "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
            ],
            [
                "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
                "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
            ],
            [
                "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
                "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
            ],
            [
                "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
                "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
            ],
            [
                "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
                "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
            ],
            [
                "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
                "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
            ],
            [
                "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
                "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
            ],
            [
                "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
                "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
            ],
            [
                "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
                "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
            ],
            [
                "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
                "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
            ],
            [
                "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
                "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
            ],
            [
                "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
                "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
            ],
            [
                "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
                "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
            ],
            [
                "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
                "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
            ],
            [
                "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
                "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
            ],
            [
                "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
                "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
            ],
            [
                "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
                "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
            ],
            [
                "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
                "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
            ],
            [
                "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
                "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
            ],
            [
                "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
                "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
            ],
            [
                "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
                "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
            ],
            [
                "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
                "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
            ],
            [
                "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
                "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
            ],
            [
                "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
                "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
            ],
            [
                "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
                "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
            ],
            [
                "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
                "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
            ],
            [
                "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
                "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
            ],
            [
                "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
                "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
            ],
            [
                "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
                "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
            ],
            [
                "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
                "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
            ],
            [
                "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
                "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
            ],
            [
                "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
                "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
            ],
            [
                "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
                "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
            ],
            [
                "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
                "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
            ],
            [
                "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
                "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
            ],
            [
                "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
                "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
            ],
            [
                "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
                "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
            ],
            [
                "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
                "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
            ],
            [
                "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
                "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
            ],
            [
                "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
                "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
            ]
        ]
    }
}, W$3 = {}, K$4 = W$3, U$6 = X$2, G$3 = J$3, H$5 = n$i.assert;

function Q$2(e32) {
    "short" === e32.type ? this.curve = new G$3.short(e32) : "edwards" === e32.type ? this.curve = new G$3.edwards(e32) : this.curve = new G$3.mont(e32), this.g = this.curve.g, this.n = this.curve.n, this.hash = e32.hash, H$5(this.g.validate(), "Invalid curve"), H$5(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
}

function V$3(e32, f37) {
    Object.defineProperty(K$4, e32, {
        configurable: !0,
        enumerable: !0,
        get: function () {
            var d23 = new Q$2(f37);
            return (Object.defineProperty(K$4, e32, {
                configurable: !0,
                enumerable: !0,
                value: d23
            }), d23);
        }
    });
}

K$4.PresetCurve = Q$2, V$3("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: U$6.sha256,
    gRed: !1,
    g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
}), V$3("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: U$6.sha256,
    gRed: !1,
    g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
}), V$3("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: U$6.sha256,
    gRed: !1,
    g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
}), V$3("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: U$6.sha384,
    gRed: !1,
    g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
}), V$3("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: U$6.sha512,
    gRed: !1,
    g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
}), V$3("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: U$6.sha256,
    gRed: !1,
    g: [
        "9"
    ]
}), V$3("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: U$6.sha256,
    gRed: !1,
    g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
    ]
});
try {
    D$4 = Y$2;
} catch (e32) {
    D$4 = void 0;
}
V$3("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: U$6.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
        {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
        }
    ],
    gRed: !1,
    g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        D$4
    ]
});
var Z$12, $$11 = n$c, ee3 = n$i.assert;

function fe1(e32, f37) {
    this.ec = e32, this.priv = null, this.pub = null, f37.priv && this._importPrivate(f37.priv, f37.privEnc), f37.pub && this._importPublic(f37.pub, f37.pubEnc);
}

Z$12 = fe1, fe1.fromPublic = function (e32, f37, d23) {
    return f37 instanceof fe1 ? f37 : new fe1(e32, {
        pub: f37,
        pubEnc: d23
    });
}, fe1.fromPrivate = function (e32, f37, d23) {
    return f37 instanceof fe1 ? f37 : new fe1(e32, {
        priv: f37,
        privEnc: d23
    });
}, fe1.prototype.validate = function () {
    var e32 = this.getPublic();
    return e32.isInfinity() ? {
        result: !1,
        reason: "Invalid public key"
    } : e32.validate() ? e32.mul(this.ec.curve.n).isInfinity() ? {
        result: !0,
        reason: null
    } : {
        result: !1,
        reason: "Public key * N != O"
    } : {
        result: !1,
        reason: "Public key is not a point"
    };
}, fe1.prototype.getPublic = function (e32, f37) {
    return "string" == typeof e32 && (f37 = e32, e32 = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), f37 ? this.pub.encode(f37, e32) : this.pub;
}, fe1.prototype.getPrivate = function (e32) {
    return "hex" === e32 ? this.priv.toString(16, 2) : this.priv;
}, fe1.prototype._importPrivate = function (e32, f37) {
    this.priv = new $$11(e32, f37 || 16), this.priv = this.priv.umod(this.ec.curve.n);
}, fe1.prototype._importPublic = function (e32, f37) {
    if (e32.x || e32.y) {
        return "mont" === this.ec.curve.type ? ee3(e32.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || ee3(e32.x && e32.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e32.x, e32.y), void 0;
    }
    this.pub = this.ec.curve.decodePoint(e32, f37);
}, fe1.prototype.derive = function (e32) {
    return e32.mul(this.priv).getX();
}, fe1.prototype.sign = function (e32, f37, d23) {
    return this.ec.sign(e32, this, f37, d23);
}, fe1.prototype.verify = function (e32, f37) {
    return this.ec.verify(e32, f37, this);
}, fe1.prototype.inspect = function () {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var de1, ce1 = Z$12, te1 = n$c, ae1 = a$l, re1 = W$3, be1 = f$i, ie = n$i.assert, ne1 = ce1, se1 = d$e;

function oe1(e32) {
    if (!(this instanceof oe1)) {
        return new oe1(e32);
    }
    "string" == typeof e32 && (ie(re1.hasOwnProperty(e32), "Unknown curve " + e32), e32 = re1[e32]), e32 instanceof re1.PresetCurve && (e32 = {
        curve: e32
    }), this.curve = e32.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e32.curve.g, this.g.precompute(e32.curve.n.bitLength() + 1), this.hash = e32.hash || e32.curve.hash;
}

de1 = oe1, oe1.prototype.keyPair = function (e32) {
    return new ne1(this, e32);
}, oe1.prototype.keyFromPrivate = function (e32, f37) {
    return ne1.fromPrivate(this, e32, f37);
}, oe1.prototype.keyFromPublic = function (e32, f37) {
    return ne1.fromPublic(this, e32, f37);
}, oe1.prototype.genKeyPair = function (e32) {
    e32 || (e32 = {});
    for (var f37 = new ae1({
        hash: this.hash,
        pers: e32.pers,
        persEnc: e32.persEnc || "utf8",
        entropy: e32.entropy || be1(this.hash.hmacStrength),
        entropyEnc: e32.entropy && e32.entropyEnc || "utf8",
        nonce: this.n.toArray()
    }), d23 = this.n.byteLength(), c29 = this.n.sub(new te1(2)); ;) {
        var t23 = new te1(f37.generate(d23));
        if (!(t23.cmp(c29) > 0)) {
            return t23.iaddn(1), this.keyFromPrivate(t23);
        }
    }
}, oe1.prototype._truncateToN = function (e32, f37) {
    var d23 = 8 * e32.byteLength() - this.n.bitLength();
    return d23 > 0 && (e32 = e32.ushrn(d23)), !f37 && e32.cmp(this.n) >= 0 ? e32.sub(this.n) : e32;
}, oe1.prototype.sign = function (e32, f37, d23, c29) {
    "object" == typeof d23 && (c29 = d23, d23 = null), c29 || (c29 = {}), f37 = this.keyFromPrivate(f37, d23), e32 = this._truncateToN(new te1(e32, 16));
    for (var t24 = this.n.byteLength(), a46 = f37.getPrivate().toArray("be", t24), r33 = e32.toArray("be", t24), b18 = new ae1({
        hash: this.hash,
        entropy: a46,
        nonce: r33,
        pers: c29.pers,
        persEnc: c29.persEnc || "utf8"
    }), i46 = this.n.sub(new te1(1)), n44 = 0; ; n44++) {
        var s33 = c29.k ? c29.k(n44) : new te1(b18.generate(this.n.byteLength()));
        if (!((s33 = this._truncateToN(s33, !0)).cmpn(1) <= 0 || s33.cmp(i46) >= 0)) {
            var o40 = this.g.mul(s33);
            if (!o40.isInfinity()) {
                var u37 = o40.getX(), h28 = u37.umod(this.n);
                if (0 !== h28.cmpn(0)) {
                    var p33 = s33.invm(this.n).mul(h28.mul(f37.getPrivate()).iadd(e32));
                    if (0 !== (p33 = p33.umod(this.n)).cmpn(0)) {
                        var l41 = (o40.getY().isOdd() ? 1 : 0) | (0 !== u37.cmp(h28) ? 2 : 0);
                        return c29.canonical && p33.cmp(this.nh) > 0 && (p33 = this.n.sub(p33), l41 ^= 1), new se1({
                            r: h28,
                            s: p33,
                            recoveryParam: l41
                        });
                    }
                }
            }
        }
    }
}, oe1.prototype.verify = function (e32, f37, d23, c29) {
    e32 = this._truncateToN(new te1(e32, 16)), d23 = this.keyFromPublic(d23, c29);
    var t24 = (f37 = new se1(f37, "hex")).r, a46 = f37.s;
    if (t24.cmpn(1) < 0 || t24.cmp(this.n) >= 0) {
        return !1;
    }
    if (a46.cmpn(1) < 0 || a46.cmp(this.n) >= 0) {
        return !1;
    }
    var r33, b18 = a46.invm(this.n), i46 = b18.mul(e32).umod(this.n), n44 = b18.mul(t24).umod(this.n);
    return this.curve._maxwellTrick ? !(r33 = this.g.jmulAdd(i46, d23.getPublic(), n44)).isInfinity() && r33.eqXToP(t24) : !(r33 = this.g.mulAdd(i46, d23.getPublic(), n44)).isInfinity() && 0 === r33.getX().umod(this.n).cmp(t24);
}, oe1.prototype.recoverPubKey = function (e32, f37, d23, c29) {
    ie((3 & d23) === d23, "The recovery param is more than two bits"), f37 = new se1(f37, c29);
    var t24 = this.n, a46 = new te1(e32), r33 = f37.r, b18 = f37.s, i46 = 1 & d23, n44 = d23 >> 1;
    if (r33.cmp(this.curve.p.umod(this.curve.n)) >= 0 && n44) {
        throw new Error("Unable to find sencond key candinate");
    }
    r33 = n44 ? this.curve.pointFromX(r33.add(this.curve.n), i46) : this.curve.pointFromX(r33, i46);
    var s34 = f37.r.invm(t24), o41 = t24.sub(a46).mul(s34).umod(t24), u38 = b18.mul(s34).umod(t24);
    return this.g.mulAdd(o41, r33, u38);
}, oe1.prototype.getKeyRecoveryParam = function (e32, f37, d23, c29) {
    if (null !== (f37 = new se1(f37, c29)).recoveryParam) {
        return f37.recoveryParam;
    }
    for (var t24 = 0; t24 < 4; t24++) {
        var a46;
        try {
            a46 = this.recoverPubKey(e32, f37, t24);
        } catch (e33) {
            continue;
        }
        if (a46.eq(d23)) {
            return t24;
        }
    }
    throw new Error("Unable to find valid recovery factor");
};
var ue1 = de1, he1 = n$i, pe1 = he1.assert, le1 = he1.parseBytes, ve1 = he1.cachedProperty;

function ye1(e32, f37) {
    this.eddsa = e32, this._secret = le1(f37.secret), e32.isPoint(f37.pub) ? this._pub = f37.pub : this._pubBytes = le1(f37.pub);
}

ye1.fromPublic = function (e32, f37) {
    return f37 instanceof ye1 ? f37 : new ye1(e32, {
        pub: f37
    });
}, ye1.fromSecret = function (e32, f37) {
    return f37 instanceof ye1 ? f37 : new ye1(e32, {
        secret: f37
    });
}, ye1.prototype.secret = function () {
    return this._secret;
}, ve1(ye1, "pubBytes", function () {
    return this.eddsa.encodePoint(this.pub());
}), ve1(ye1, "pub", function () {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
}), ve1(ye1, "privBytes", function () {
    var e32 = this.eddsa, f37 = this.hash(), d23 = e32.encodingLength - 1, c29 = f37.slice(0, e32.encodingLength);
    return (c29[0] &= 248, c29[d23] &= 127, c29[d23] |= 64, c29);
}), ve1(ye1, "priv", function () {
    return this.eddsa.decodeInt(this.privBytes());
}), ve1(ye1, "hash", function () {
    return this.eddsa.hash().update(this.secret()).digest();
}), ve1(ye1, "messagePrefix", function () {
    return this.hash().slice(this.eddsa.encodingLength);
}), ye1.prototype.sign = function (e32) {
    return pe1(this._secret, "KeyPair can only verify"), this.eddsa.sign(e32, this);
}, ye1.prototype.verify = function (e32, f37) {
    return this.eddsa.verify(e32, f37, this);
}, ye1.prototype.getSecret = function (e32) {
    return pe1(this._secret, "KeyPair is public only"), he1.encode(this.secret(), e32);
}, ye1.prototype.getPublic = function (e32) {
    return he1.encode(this.pubBytes(), e32);
};
var me1 = ye1, Se1 = n$c, ge1 = n$i, Ae1 = ge1.assert, Ie = ge1.cachedProperty, we1 = ge1.parseBytes;

function Me(e32, f37) {
    this.eddsa = e32, "object" != typeof f37 && (f37 = we1(f37)), Array.isArray(f37) && (f37 = {
        R: f37.slice(0, e32.encodingLength),
        S: f37.slice(e32.encodingLength)
    }), Ae1(f37.R && f37.S, "Signature without R or S"), e32.isPoint(f37.R) && (this._R = f37.R), f37.S instanceof Se1 && (this._S = f37.S), this._Rencoded = Array.isArray(f37.R) ? f37.R : f37.Rencoded, this._Sencoded = Array.isArray(f37.S) ? f37.S : f37.Sencoded;
}

Ie(Me, "S", function () {
    return this.eddsa.decodeInt(this.Sencoded());
}), Ie(Me, "R", function () {
    return this.eddsa.decodePoint(this.Rencoded());
}), Ie(Me, "Rencoded", function () {
    return this.eddsa.encodePoint(this.R());
}), Ie(Me, "Sencoded", function () {
    return this.eddsa.encodeInt(this.S());
}), Me.prototype.toBytes = function () {
    return this.Rencoded().concat(this.Sencoded());
}, Me.prototype.toHex = function () {
    return ge1.encode(this.toBytes(), "hex").toUpperCase();
};
var xe, _e = Me, ze = X$2, qe = W$3, Re = n$i, Pe = Re.assert, je1 = Re.parseBytes, Ne = me1, Ee1 = _e;

function ke1(e32) {
    if (Pe("ed25519" === e32, "only tested with ed25519 so far"), !(this instanceof ke1)) {
        return new ke1(e32);
    }
    e32 = qe[e32].curve;
    this.curve = e32, this.g = e32.g, this.g.precompute(e32.n.bitLength() + 1), this.pointClass = e32.point().constructor, this.encodingLength = Math.ceil(e32.n.bitLength() / 8), this.hash = ze.sha512;
}

xe = ke1, ke1.prototype.sign = function (e32, f37) {
    e32 = je1(e32);
    var d23 = this.keyFromSecret(f37), c29 = this.hashInt(d23.messagePrefix(), e32), t24 = this.g.mul(c29),
            a47 = this.encodePoint(t24), r33 = this.hashInt(a47, d23.pubBytes(), e32).mul(d23.priv()),
            b18 = c29.add(r33).umod(this.curve.n);
    return this.makeSignature({
        R: t24,
        S: b18,
        Rencoded: a47
    });
}, ke1.prototype.verify = function (e32, f37, d23) {
    e32 = je1(e32), f37 = this.makeSignature(f37);
    var c29 = this.keyFromPublic(d23), t24 = this.hashInt(f37.Rencoded(), c29.pubBytes(), e32),
            a47 = this.g.mul(f37.S());
    return f37.R().add(c29.pub().mul(t24)).eq(a47);
}, ke1.prototype.hashInt = function () {
    for (var e32 = this.hash(), f37 = 0; f37 < arguments.length; f37++) {
        e32.update(arguments[f37]);
    }
    return Re.intFromLE(e32.digest()).umod(this.curve.n);
}, ke1.prototype.keyFromPublic = function (e32) {
    return Ne.fromPublic(this, e32);
}, ke1.prototype.keyFromSecret = function (e32) {
    return Ne.fromSecret(this, e32);
}, ke1.prototype.makeSignature = function (e32) {
    return e32 instanceof Ee1 ? e32 : new Ee1(this, e32);
}, ke1.prototype.encodePoint = function (e32) {
    var f37 = e32.getY().toArray("le", this.encodingLength);
    return f37[this.encodingLength - 1] |= e32.getX().isOdd() ? 128 : 0, f37;
}, ke1.prototype.decodePoint = function (e32) {
    var f37 = (e32 = Re.parseBytes(e32)).length - 1, d23 = e32.slice(0, f37).concat(-129 & e32[f37]),
            c29 = 0 != (128 & e32[f37]), t24 = Re.intFromLE(d23);
    return this.curve.pointFromY(t24, c29);
}, ke1.prototype.encodeInt = function (e32) {
    return e32.toArray("le", this.encodingLength);
}, ke1.prototype.decodeInt = function (e32) {
    return Re.intFromLE(e32);
}, ke1.prototype.isPoint = function (e32) {
    return e32 instanceof this.pointClass;
};
var Oe1 = xe, Le = {}, Be1 = Le;
Be1.version = [
    "elliptic",
    "6.5.2",
    "EC cryptography",
    "lib/elliptic.js",
    [
        "lib"
    ],
    {
        jscs: "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
        jshint: "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
        lint: "npm run jscs && npm run jshint",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
    },
    {
        type: "git",
        url: "git@github.com:indutny/elliptic"
    },
    [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
    ],
    "Fedor Indutny <fedor@indutny.com>",
    "MIT",
    {
        url: "https://github.com/indutny/elliptic/issues"
    },
    "https://github.com/indutny/elliptic",
    {
        brfs: "^1.4.3",
        coveralls: "^3.0.8",
        grunt: "^1.0.4",
        "grunt-browserify": "^5.0.0",
        "grunt-cli": "^1.2.0",
        "grunt-contrib-connect": "^1.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^1.0.1",
        "grunt-mocha-istanbul": "^3.0.1",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.2",
        jscs: "^3.0.7",
        jshint: "^2.10.3",
        mocha: "^6.2.2"
    },
    {
        "bn.js": "^4.4.0",
        brorand: "^1.0.1",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.0",
        inherits: "^2.0.1",
        "minimalistic-assert": "^1.0.0",
        "minimalistic-crypto-utils": "^1.0.0"
    }
][1], Be1.utils = n$i, Be1.rand = f$i, Be1.curve = J$3, Be1.curves = W$3, Be1.ec = ue1, Be1.eddsa = Oe1;
var o$n = {}, s$j = !1,
        a$m = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
var u$j = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, c$i = {},
        f$n = t$2;

function l$k(e32) {
    (this || u$j)._reporterState = {
        obj: null,
        path: [],
        options: e32 || {},
        errors: []
    };
}

function h$g(e32, t24) {
    (this || u$j).path = e32, this.rethrow(t24);
}

c$i.Reporter = l$k, l$k.prototype.isError = function (e32) {
    return e32 instanceof h$g;
}, l$k.prototype.save = function () {
    var e32 = (this || u$j)._reporterState;
    return {
        obj: e32.obj,
        pathLen: e32.path.length
    };
}, l$k.prototype.restore = function (e32) {
    var t24 = (this || u$j)._reporterState;
    t24.obj = e32.obj, t24.path = t24.path.slice(0, e32.pathLen);
}, l$k.prototype.enterKey = function (e32) {
    return (this || u$j)._reporterState.path.push(e32);
}, l$k.prototype.exitKey = function (e32) {
    var t24 = (this || u$j)._reporterState;
    t24.path = t24.path.slice(0, e32 - 1);
}, l$k.prototype.leaveKey = function (e32, t24, r33) {
    var n44 = (this || u$j)._reporterState;
    this.exitKey(e32), null !== n44.obj && (n44.obj[t24] = r33);
}, l$k.prototype.path = function () {
    return (this || u$j)._reporterState.path.join("/");
}, l$k.prototype.enterObject = function () {
    var e32 = (this || u$j)._reporterState, t24 = e32.obj;
    return e32.obj = {}, t24;
}, l$k.prototype.leaveObject = function (e32) {
    var t24 = (this || u$j)._reporterState, r33 = t24.obj;
    return t24.obj = e32, r33;
}, l$k.prototype.error = function (e32) {
    var t24, r33 = (this || u$j)._reporterState, n44 = e32 instanceof h$g;
    if (t24 = n44 ? e32 : new h$g(r33.path.map(function (e33) {
        return "[" + JSON.stringify(e33) + "]";
    }).join(""), e32.message || e32, e32.stack), !r33.options.partial) {
        throw t24;
    }
    return n44 || r33.errors.push(t24), t24;
}, l$k.prototype.wrapResult = function (e32) {
    var t24 = (this || u$j)._reporterState;
    return t24.options.partial ? {
        result: this.isError(e32) ? null : e32,
        errors: t24.errors
    } : e32;
}, f$n(h$g, Error), h$g.prototype.rethrow = function (e32) {
    if ((this || u$j).message = e32 + " at: " + ((this || u$j).path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this || u$j, h$g), !(this || u$j).stack) {
        try {
            throw new Error((this || u$j).message);
        } catch (e33) {
            (this || u$j).stack = e33.stack;
        }
    }
    return this || u$j;
};
var p$k = {}, d$i = !1,
        g$e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;

function y$f() {
    if (d$i) {
        return p$k;
    }
    d$i = !0;
    var e32 = t$2, r33 = E$9().Reporter, i46 = e$1.Buffer;

    function o41(e33, t24) {
        if (r33.call(this || g$e, t24), !i46.isBuffer(e33)) {
            return this.error("Input not Buffer"), void 0;
        }
        (this || g$e).base = e33, (this || g$e).offset = 0, (this || g$e).length = e33.length;
    }

    function s34(e33, t24) {
        if (Array.isArray(e33)) {
            (this || g$e).length = 0, (this || g$e).value = e33.map(function (e34) {
                return (e34 instanceof s34 || (e34 = new s34(e34, t24)), (this || g$e).length += e34.length, e34);
            }, this || g$e);
        } else if ("number" == typeof e33) {
            if (!(0 <= e33 && e33 <= 255)) {
                return t24.error("non-byte EncoderBuffer value");
            }
            (this || g$e).value = e33, (this || g$e).length = 1;
        } else if ("string" == typeof e33) {
            (this || g$e).value = e33, (this || g$e).length = i46.byteLength(e33);
        } else {
            if (!i46.isBuffer(e33)) {
                return t24.error("Unsupported type: " + typeof e33);
            }
            (this || g$e).value = e33, (this || g$e).length = e33.length;
        }
    }

    return e32(o41, r33), p$k.DecoderBuffer = o41, o41.prototype.save = function () {
        return {
            offset: (this || g$e).offset,
            reporter: r33.prototype.save.call(this || g$e)
        };
    }, o41.prototype.restore = function (e33) {
        var t24 = new o41((this || g$e).base);
        return t24.offset = e33.offset, t24.length = (this || g$e).offset, (this || g$e).offset = e33.offset, r33.prototype.restore.call(this || g$e, e33.reporter), t24;
    }, o41.prototype.isEmpty = function () {
        return (this || g$e).offset === (this || g$e).length;
    }, o41.prototype.readUInt8 = function (e33) {
        return (this || g$e).offset + 1 <= (this || g$e).length ? (this || g$e).base.readUInt8((this || g$e).offset++, !0) : this.error(e33 || "DecoderBuffer overrun");
    }, o41.prototype.skip = function (e33, t24) {
        if (!((this || g$e).offset + e33 <= (this || g$e).length)) {
            return this.error(t24 || "DecoderBuffer overrun");
        }
        var r34 = new o41((this || g$e).base);
        return r34._reporterState = (this || g$e)._reporterState, r34.offset = (this || g$e).offset, r34.length = (this || g$e).offset + e33, (this || g$e).offset += e33, r34;
    }, o41.prototype.raw = function (e33) {
        return (this || g$e).base.slice(e33 ? e33.offset : (this || g$e).offset, (this || g$e).length);
    }, p$k.EncoderBuffer = s34, s34.prototype.join = function (e33, t24) {
        return e33 || (e33 = new i46((this || g$e).length)), t24 || (t24 = 0), 0 === (this || g$e).length || (Array.isArray((this || g$e).value) ? (this || g$e).value.forEach(function (r34) {
            r34.join(e33, t24), t24 += r34.length;
        }) : ("number" == typeof (this || g$e).value ? e33[t24] = (this || g$e).value : "string" == typeof (this || g$e).value ? e33.write((this || g$e).value, t24) : i46.isBuffer((this || g$e).value) && (this || g$e).value.copy(e33, t24), t24 += (this || g$e).length)), e33;
    }, p$k;
}

var _$e = {}, v$f = !1,
        b$c = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
var m$g = {}, S$a = !1;

function E$9() {
    if (S$a) {
        return m$g;
    }
    S$a = !0;
    var e32 = m$g;
    return e32.Reporter = c$i.Reporter, e32.DecoderBuffer = y$f().DecoderBuffer, e32.EncoderBuffer = y$f().EncoderBuffer, e32.Node = (function () {
        if (v$f) {
            return _$e;
        }
        v$f = !0;
        var e33 = E$9().Reporter, t24 = E$9().EncoderBuffer, r33 = E$9().DecoderBuffer, n44 = o$7, o41 = [
            "seq",
            "seqof",
            "set",
            "setof",
            "objid",
            "bool",
            "gentime",
            "utctime",
            "null_",
            "enum",
            "int",
            "objDesc",
            "bitstr",
            "bmpstr",
            "charstr",
            "genstr",
            "graphstr",
            "ia5str",
            "iso646str",
            "numstr",
            "octstr",
            "printstr",
            "t61str",
            "unistr",
            "utf8str",
            "videostr"
        ], s34 = [
            "key",
            "obj",
            "use",
            "optional",
            "explicit",
            "implicit",
            "def",
            "choice",
            "any",
            "contains"
        ].concat(o41);

        function a47(e34, t25) {
            var r34 = {};
            (this || b$c)._baseState = r34, r34.enc = e34, r34.parent = t25 || null, r34.children = null, r34.tag = null, r34.args = null, r34.reverseArgs = null, r34.choice = null, r34.optional = !1, r34.any = !1, r34.obj = !1, r34.use = null, r34.useDecoder = null, r34.key = null, r34.default = null, r34.explicit = null, r34.implicit = null, r34.contains = null, r34.parent || (r34.children = [], this._wrap());
        }

        _$e = a47;
        var u38 = [
            "enc",
            "parent",
            "children",
            "tag",
            "args",
            "reverseArgs",
            "choice",
            "optional",
            "any",
            "obj",
            "use",
            "alteredUse",
            "key",
            "default",
            "explicit",
            "implicit",
            "contains"
        ];
        return a47.prototype.clone = function () {
            var e34 = (this || b$c)._baseState, t25 = {};
            u38.forEach(function (r34) {
                t25[r34] = e34[r34];
            });
            var r34 = new (this || b$c).constructor(t25.parent);
            return r34._baseState = t25, r34;
        }, a47.prototype._wrap = function () {
            var e34 = (this || b$c)._baseState;
            s34.forEach(function (t25) {
                (this || b$c)[t25] = function () {
                    var r34 = new (this || b$c).constructor(this || b$c);
                    return e34.children.push(r34), r34[t25].apply(r34, arguments);
                };
            }, this || b$c);
        }, a47.prototype._init = function (e34) {
            var t25 = (this || b$c)._baseState;
            n44(null === t25.parent), e34.call(this || b$c), t25.children = t25.children.filter(function (e35) {
                return e35._baseState.parent === (this || b$c);
            }, this || b$c), n44.equal(t25.children.length, 1, "Root node can have only one child");
        }, a47.prototype._useArgs = function (e34) {
            var t25 = (this || b$c)._baseState, r34 = e34.filter(function (e35) {
                return e35 instanceof (this || b$c).constructor;
            }, this || b$c);
            e34 = e34.filter(function (e35) {
                return !(e35 instanceof (this || b$c).constructor);
            }, this || b$c), 0 !== r34.length && (n44(null === t25.children), t25.children = r34, r34.forEach(function (e35) {
                e35._baseState.parent = this || b$c;
            }, this || b$c)), 0 !== e34.length && (n44(null === t25.args), t25.args = e34, t25.reverseArgs = e34.map(function (e35) {
                if ("object" != typeof e35 || e35.constructor !== Object) {
                    return e35;
                }
                var t26 = {};
                return (Object.keys(e35).forEach(function (r35) {
                    r35 == (0 | r35) && (r35 |= 0);
                    var n45 = e35[r35];
                    t26[n45] = r35;
                }), t26);
            }));
        }, [
            "_peekTag",
            "_decodeTag",
            "_use",
            "_decodeStr",
            "_decodeObjid",
            "_decodeTime",
            "_decodeNull",
            "_decodeInt",
            "_decodeBool",
            "_decodeList",
            "_encodeComposite",
            "_encodeStr",
            "_encodeObjid",
            "_encodeTime",
            "_encodeNull",
            "_encodeInt",
            "_encodeBool"
        ].forEach(function (e34) {
            a47.prototype[e34] = function () {
                var t25 = (this || b$c)._baseState;
                throw new Error(e34 + " not implemented for encoding: " + t25.enc);
            };
        }), o41.forEach(function (e34) {
            a47.prototype[e34] = function () {
                var t25 = (this || b$c)._baseState, r34 = Array.prototype.slice.call(arguments);
                return n44(null === t25.tag), t25.tag = e34, this._useArgs(r34), this || b$c;
            };
        }), a47.prototype.use = function (e34) {
            n44(e34);
            var t25 = (this || b$c)._baseState;
            return n44(null === t25.use), t25.use = e34, this || b$c;
        }, a47.prototype.optional = function () {
            return (this || b$c)._baseState.optional = !0, this || b$c;
        }, a47.prototype.def = function (e34) {
            var t25 = (this || b$c)._baseState;
            return n44(null === t25.default), t25.default = e34, t25.optional = !0, this || b$c;
        }, a47.prototype.explicit = function (e34) {
            var t25 = (this || b$c)._baseState;
            return n44(null === t25.explicit && null === t25.implicit), t25.explicit = e34, this || b$c;
        }, a47.prototype.implicit = function (e34) {
            var t25 = (this || b$c)._baseState;
            return n44(null === t25.explicit && null === t25.implicit), t25.implicit = e34, this || b$c;
        }, a47.prototype.obj = function () {
            var e34 = (this || b$c)._baseState, t25 = Array.prototype.slice.call(arguments);
            return e34.obj = !0, 0 !== t25.length && this._useArgs(t25), this || b$c;
        }, a47.prototype.key = function (e34) {
            var t25 = (this || b$c)._baseState;
            return n44(null === t25.key), t25.key = e34, this || b$c;
        }, a47.prototype.any = function () {
            return (this || b$c)._baseState.any = !0, this || b$c;
        }, a47.prototype.choice = function (e34) {
            var t25 = (this || b$c)._baseState;
            return n44(null === t25.choice), t25.choice = e34, this._useArgs(Object.keys(e34).map(function (t26) {
                return e34[t26];
            })), this || b$c;
        }, a47.prototype.contains = function (e34) {
            var t25 = (this || b$c)._baseState;
            return n44(null === t25.use), t25.contains = e34, this || b$c;
        }, a47.prototype._decode = function (e34, t25) {
            var n45 = (this || b$c)._baseState;
            if (null === n45.parent) {
                return e34.wrapResult(n45.children[0]._decode(e34, t25));
            }
            var i46, o42 = n45.default, s35 = !0, a48 = null;
            if (null !== n45.key && (a48 = e34.enterKey(n45.key)), n45.optional) {
                var u39 = null;
                if (null !== n45.explicit ? u39 = n45.explicit : null !== n45.implicit ? u39 = n45.implicit : null !== n45.tag && (u39 = n45.tag), null !== u39 || n45.any) {
                    if (s35 = this._peekTag(e34, u39, n45.any), e34.isError(s35)) {
                        return s35;
                    }
                } else {
                    var c29 = e34.save();
                    try {
                        null === n45.choice ? this._decodeGeneric(n45.tag, e34, t25) : this._decodeChoice(e34, t25), s35 = !0;
                    } catch (e35) {
                        s35 = !1;
                    }
                    e34.restore(c29);
                }
            }
            if (n45.obj && s35 && (i46 = e34.enterObject()), s35) {
                if (null !== n45.explicit) {
                    var f37 = this._decodeTag(e34, n45.explicit);
                    if (e34.isError(f37)) {
                        return f37;
                    }
                    e34 = f37;
                }
                var l42 = e34.offset;
                if (null === n45.use && null === n45.choice) {
                    if (n45.any) {
                        c29 = e34.save();
                    }
                    var h29 = this._decodeTag(e34, null !== n45.implicit ? n45.implicit : n45.tag, n45.any);
                    if (e34.isError(h29)) {
                        return h29;
                    }
                    n45.any ? o42 = e34.raw(c29) : e34 = h29;
                }
                if (t25 && t25.track && null !== n45.tag && t25.track(e34.path(), l42, e34.length, "tagged"), t25 && t25.track && null !== n45.tag && t25.track(e34.path(), e34.offset, e34.length, "content"), o42 = n45.any ? o42 : null === n45.choice ? this._decodeGeneric(n45.tag, e34, t25) : this._decodeChoice(e34, t25), e34.isError(o42)) {
                    return o42;
                }
                if (n45.any || null !== n45.choice || null === n45.children || n45.children.forEach(function (r34) {
                    r34._decode(e34, t25);
                }), n45.contains && ("octstr" === n45.tag || "bitstr" === n45.tag)) {
                    var p34 = new r33(o42);
                    o42 = this._getUse(n45.contains, e34._reporterState.obj)._decode(p34, t25);
                }
            }
            return n45.obj && s35 && (o42 = e34.leaveObject(i46)), null === n45.key || null === o42 && !0 !== s35 ? null !== a48 && e34.exitKey(a48) : e34.leaveKey(a48, n45.key, o42), o42;
        }, a47.prototype._decodeGeneric = function (e34, t25, r34) {
            var n45 = (this || b$c)._baseState;
            return "seq" === e34 || "set" === e34 ? null : "seqof" === e34 || "setof" === e34 ? this._decodeList(t25, e34, n45.args[0], r34) : /str$/.test(e34) ? this._decodeStr(t25, e34, r34) : "objid" === e34 && n45.args ? this._decodeObjid(t25, n45.args[0], n45.args[1], r34) : "objid" === e34 ? this._decodeObjid(t25, null, null, r34) : "gentime" === e34 || "utctime" === e34 ? this._decodeTime(t25, e34, r34) : "null_" === e34 ? this._decodeNull(t25, r34) : "bool" === e34 ? this._decodeBool(t25, r34) : "objDesc" === e34 ? this._decodeStr(t25, e34, r34) : "int" === e34 || "enum" === e34 ? this._decodeInt(t25, n45.args && n45.args[0], r34) : null !== n45.use ? this._getUse(n45.use, t25._reporterState.obj)._decode(t25, r34) : t25.error("unknown tag: " + e34);
        }, a47.prototype._getUse = function (e34, t25) {
            var r34 = (this || b$c)._baseState;
            return r34.useDecoder = this._use(e34, t25), n44(null === r34.useDecoder._baseState.parent), r34.useDecoder = r34.useDecoder._baseState.children[0], r34.implicit !== r34.useDecoder._baseState.implicit && (r34.useDecoder = r34.useDecoder.clone(), r34.useDecoder._baseState.implicit = r34.implicit), r34.useDecoder;
        }, a47.prototype._decodeChoice = function (e34, t25) {
            var r34 = (this || b$c)._baseState, n45 = null, i46 = !1;
            return Object.keys(r34.choice).some(function (o42) {
                var s35 = e34.save(), a48 = r34.choice[o42];
                try {
                    var u40 = a48._decode(e34, t25);
                    if (e34.isError(u40)) {
                        return !1;
                    }
                    n45 = {
                        type: o42,
                        value: u40
                    }, i46 = !0;
                } catch (t26) {
                    return (e34.restore(s35), !1);
                }
                return !0;
            }, this || b$c), i46 ? n45 : e34.error("Choice not matched");
        }, a47.prototype._createEncoderBuffer = function (e34) {
            return new t24(e34, (this || b$c).reporter);
        }, a47.prototype._encode = function (e34, t25, r34) {
            var n45 = (this || b$c)._baseState;
            if (null === n45.default || n45.default !== e34) {
                var i46 = this._encodeValue(e34, t25, r34);
                if ((void 0) !== i46 && !this._skipDefault(i46, t25, r34)) {
                    return i46;
                }
            }
        }, a47.prototype._encodeValue = function (t25, r34, n45) {
            var i47 = (this || b$c)._baseState;
            if (null === i47.parent) {
                return i47.children[0]._encode(t25, r34 || new e33);
            }
            var o42 = null;
            if ((this || b$c).reporter = r34, i47.optional && (void 0) === t25) {
                if (null === i47.default) {
                    return;
                }
                t25 = i47.default;
            }
            var s35 = null, a48 = !1;
            if (i47.any) {
                o42 = this._createEncoderBuffer(t25);
            } else if (i47.choice) {
                o42 = this._encodeChoice(t25, r34);
            } else if (i47.contains) {
                s35 = this._getUse(i47.contains, n45)._encode(t25, r34), a48 = !0;
            } else if (i47.children) {
                s35 = i47.children.map(function (e34) {
                    if ("null_" === e34._baseState.tag) {
                        return e34._encode(null, r34, t25);
                    }
                    if (null === e34._baseState.key) {
                        return r34.error("Child should have a key");
                    }
                    var n46 = r34.enterKey(e34._baseState.key);
                    if ("object" != typeof t25) {
                        return r34.error("Child expected, but input is not object");
                    }
                    var i48 = e34._encode(t25[e34._baseState.key], r34, t25);
                    return (r34.leaveKey(n46), i48);
                }, this || b$c).filter(function (e34) {
                    return e34;
                }), s35 = this._createEncoderBuffer(s35);
            } else if ("seqof" === i47.tag || "setof" === i47.tag) {
                if (!i47.args || 1 !== i47.args.length) {
                    return r34.error("Too many args for : " + i47.tag);
                }
                if (!Array.isArray(t25)) {
                    return r34.error("seqof/setof, but data is not Array");
                }
                var u40 = this.clone();
                u40._baseState.implicit = null, s35 = this._createEncoderBuffer(t25.map(function (e34) {
                    var n46 = (this || b$c)._baseState;
                    return this._getUse(n46.args[0], t25)._encode(e34, r34);
                }, u40));
            } else {
                null !== i47.use ? o42 = this._getUse(i47.use, n45)._encode(t25, r34) : (s35 = this._encodePrimitive(i47.tag, t25), a48 = !0);
            }
            if (!i47.any && null === i47.choice) {
                var c30 = null !== i47.implicit ? i47.implicit : i47.tag,
                        f38 = null === i47.implicit ? "universal" : "context";
                null === c30 ? null === i47.use && r34.error("Tag could be omitted only for .use()") : null === i47.use && (o42 = this._encodeComposite(c30, a48, f38, s35));
            }
            return null !== i47.explicit && (o42 = this._encodeComposite(i47.explicit, !1, "context", o42)), o42;
        }, a47.prototype._encodeChoice = function (e34, t25) {
            var r34 = (this || b$c)._baseState, i47 = r34.choice[e34.type];
            return i47 || n44(!1, e34.type + " not found in " + JSON.stringify(Object.keys(r34.choice))), i47._encode(e34.value, t25);
        }, a47.prototype._encodePrimitive = function (e34, t25) {
            var r34 = (this || b$c)._baseState;
            if (/str$/.test(e34)) {
                return this._encodeStr(t25, e34);
            }
            if ("objid" === e34 && r34.args) {
                return this._encodeObjid(t25, r34.reverseArgs[0], r34.args[1]);
            }
            if ("objid" === e34) {
                return this._encodeObjid(t25, null, null);
            }
            if ("gentime" === e34 || "utctime" === e34) {
                return this._encodeTime(t25, e34);
            }
            if ("null_" === e34) {
                return this._encodeNull();
            }
            if ("int" === e34 || "enum" === e34) {
                return this._encodeInt(t25, r34.args && r34.reverseArgs[0]);
            }
            if ("bool" === e34) {
                return this._encodeBool(t25);
            }
            if ("objDesc" === e34) {
                return this._encodeStr(t25, e34);
            }
            throw new Error("Unsupported tag: " + e34);
        }, a47.prototype._isNumstr = function (e34) {
            return /^[0-9 ]*$/.test(e34);
        }, a47.prototype._isPrintstr = function (e34) {
            return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(e34);
        }, _$e;
    })(), m$g;
}

var j$6 = {}, w$f = !1;
var B$9 = {}, k$c = !1;

function T$6() {
    if (k$c) {
        return B$9;
    }
    k$c = !0;
    var e32 = B$9;
    return e32._reverse = function (e33) {
        var t24 = {};
        return Object.keys(e33).forEach(function (r33) {
            (0 | r33) == r33 && (r33 |= 0);
            var n44 = e33[r33];
            t24[n44] = r33;
        }), t24;
    }, e32.der = (function () {
        if (w$f) {
            return j$6;
        }
        w$f = !0;
        var e33 = T$6();
        return j$6.tagClass = {
            0: "universal",
            1: "application",
            2: "context",
            3: "private"
        }, j$6.tagClassByName = e33._reverse(j$6.tagClass), j$6.tag = {
            0: "end",
            1: "bool",
            2: "int",
            3: "bitstr",
            4: "octstr",
            5: "null_",
            6: "objid",
            7: "objDesc",
            8: "external",
            9: "real",
            10: "enum",
            11: "embed",
            12: "utf8str",
            13: "relativeOid",
            16: "seq",
            17: "set",
            18: "numstr",
            19: "printstr",
            20: "t61str",
            21: "videostr",
            22: "ia5str",
            23: "utctime",
            24: "gentime",
            25: "graphstr",
            26: "iso646str",
            27: "genstr",
            28: "unistr",
            29: "charstr",
            30: "bmpstr"
        }, j$6.tagByName = e33._reverse(j$6.tag), j$6;
    })(), B$9;
}

var D$5 = {}, U$7 = !1,
        N$5 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;

function C$6() {
    if (U$7) {
        return D$5;
    }
    U$7 = !0;
    var e32 = t$2, r33 = Y$3(), n44 = r33.base, i47 = r33.bignum, o41 = r33.constants.der;

    function s34(e33) {
        (this || N$5).enc = "der", (this || N$5).name = e33.name, (this || N$5).entity = e33, (this || N$5).tree = new a47, (this || N$5).tree._init(e33.body);
    }

    function a47(e33) {
        n44.Node.call(this || N$5, "der", e33);
    }

    function u38(e33, t24) {
        var r34 = e33.readUInt8(t24);
        if (e33.isError(r34)) {
            return r34;
        }
        var n45 = o41.tagClass[r34 >> 6], i48 = 0 == (32 & r34);
        if (31 == (31 & r34)) {
            var s35 = r34;
            for (r34 = 0; 128 == (128 & s35);) {
                if (s35 = e33.readUInt8(t24), e33.isError(s35)) {
                    return s35;
                }
                r34 <<= 7, r34 |= 127 & s35;
            }
        } else {
            r34 &= 31;
        }
        return {
            cls: n45,
            primitive: i48,
            tag: r34,
            tagStr: o41.tag[r34]
        };
    }

    function c31(e33, t24, r34) {
        var n45 = e33.readUInt8(r34);
        if (e33.isError(n45)) {
            return n45;
        }
        if (!t24 && 128 === n45) {
            return null;
        }
        if (0 == (128 & n45)) {
            return n45;
        }
        var i48 = 127 & n45;
        if (i48 > 4) {
            return e33.error("length octect is too long");
        }
        n45 = 0;
        for (var o42 = 0; o42 < i48; o42++) {
            n45 <<= 8;
            var s36 = e33.readUInt8(r34);
            if (e33.isError(s36)) {
                return s36;
            }
            n45 |= s36;
        }
        return n45;
    }

    return D$5 = s34, s34.prototype.decode = function (e33, t24) {
        return e33 instanceof n44.DecoderBuffer || (e33 = new n44.DecoderBuffer(e33, t24)), (this || N$5).tree._decode(e33, t24);
    }, e32(a47, n44.Node), a47.prototype._peekTag = function (e33, t24, r34) {
        if (e33.isEmpty()) {
            return !1;
        }
        var n45 = e33.save(), i48 = u38(e33, 'Failed to peek tag: "' + t24 + '"');
        return e33.isError(i48) ? i48 : (e33.restore(n45), i48.tag === t24 || i48.tagStr === t24 || i48.tagStr + "of" === t24 || r34);
    }, a47.prototype._decodeTag = function (e33, t24, r34) {
        var n45 = u38(e33, 'Failed to decode tag of "' + t24 + '"');
        if (e33.isError(n45)) {
            return n45;
        }
        var i48 = c31(e33, n45.primitive, 'Failed to get length of "' + t24 + '"');
        if (e33.isError(i48)) {
            return i48;
        }
        if (!r34 && n45.tag !== t24 && n45.tagStr !== t24 && n45.tagStr + "of" !== t24) {
            return e33.error('Failed to match tag: "' + t24 + '"');
        }
        if (n45.primitive || null !== i48) {
            return e33.skip(i48, 'Failed to match body of: "' + t24 + '"');
        }
        var o42 = e33.save(),
                s37 = this._skipUntilEnd(e33, 'Failed to skip indefinite length body: "' + (this || N$5).tag + '"');
        return e33.isError(s37) ? s37 : (i48 = e33.offset - o42.offset, e33.restore(o42), e33.skip(i48, 'Failed to match body of: "' + t24 + '"'));
    }, a47.prototype._skipUntilEnd = function (e33, t24) {
        for (; ;) {
            var r34 = u38(e33, t24);
            if (e33.isError(r34)) {
                return r34;
            }
            var n45, i48 = c31(e33, r34.primitive, t24);
            if (e33.isError(i48)) {
                return i48;
            }
            if (n45 = r34.primitive || null !== i48 ? e33.skip(i48) : this._skipUntilEnd(e33, t24), e33.isError(n45)) {
                return n45;
            }
            if ("end" === r34.tagStr) {
                break;
            }
        }
    }, a47.prototype._decodeList = function (e33, t24, r35, n46) {
        for (var i49 = []; !e33.isEmpty();) {
            var o42 = this._peekTag(e33, "end");
            if (e33.isError(o42)) {
                return o42;
            }
            var s37 = r35.decode(e33, "der", n46);
            if (e33.isError(s37) && o42) {
                break;
            }
            i49.push(s37);
        }
        return i49;
    }, a47.prototype._decodeStr = function (e33, t24) {
        if ("bitstr" === t24) {
            var r35 = e33.readUInt8();
            return e33.isError(r35) ? r35 : {
                unused: r35,
                data: e33.raw()
            };
        }
        if ("bmpstr" === t24) {
            var n46 = e33.raw();
            if (n46.length % 2 == 1) {
                return e33.error("Decoding of string type: bmpstr length mismatch");
            }
            for (var i49 = "", o43 = 0; o43 < n46.length / 2; o43++) {
                i49 += String.fromCharCode(n46.readUInt16BE(2 * o43));
            }
            return i49;
        }
        if ("numstr" === t24) {
            var s38 = e33.raw().toString("ascii");
            return this._isNumstr(s38) ? s38 : e33.error("Decoding of string type: numstr unsupported characters");
        }
        if ("octstr" === t24) {
            return e33.raw();
        }
        if ("objDesc" === t24) {
            return e33.raw();
        }
        if ("printstr" === t24) {
            var a48 = e33.raw().toString("ascii");
            return this._isPrintstr(a48) ? a48 : e33.error("Decoding of string type: printstr unsupported characters");
        }
        return /str$/.test(t24) ? e33.raw().toString() : e33.error("Decoding of string type: " + t24 + " unsupported");
    }, a47.prototype._decodeObjid = function (e33, t24, r36) {
        for (var n47, i50 = [], o44 = 0; !e33.isEmpty();) {
            var s39 = e33.readUInt8();
            o44 <<= 7, o44 |= 127 & s39, 0 == (128 & s39) && (i50.push(o44), o44 = 0);
        }
        128 & s39 && i50.push(o44);
        var a49 = i50[0] / 40 | 0, u41 = i50[0] % 40;
        if (n47 = r36 ? i50 : [
            a49,
            u41
        ].concat(i50.slice(1)), t24) {
            var c32 = t24[n47.join(" ")];
            (void 0) === c32 && (c32 = t24[n47.join(".")]), (void 0) !== c32 && (n47 = c32);
        }
        return n47;
    }, a47.prototype._decodeTime = function (e33, t24) {
        var r36 = e33.raw().toString();
        if ("gentime" === t24) {
            var n47 = 0 | r36.slice(0, 4), i50 = 0 | r36.slice(4, 6), o44 = 0 | r36.slice(6, 8),
                    s40 = 0 | r36.slice(8, 10), a49 = 0 | r36.slice(10, 12), u41 = 0 | r36.slice(12, 14);
        } else {
            if ("utctime" !== t24) {
                return e33.error("Decoding " + t24 + " time is not supported yet");
            }
            n47 = 0 | r36.slice(0, 2), i50 = 0 | r36.slice(2, 4), o44 = 0 | r36.slice(4, 6), s40 = 0 | r36.slice(6, 8), a49 = 0 | r36.slice(8, 10), u41 = 0 | r36.slice(10, 12);
            n47 = n47 < 70 ? 2000 + n47 : 1900 + n47;
        }
        return Date.UTC(n47, i50 - 1, o44, s40, a49, u41, 0);
    }, a47.prototype._decodeNull = function (e33) {
        return null;
    }, a47.prototype._decodeBool = function (e33) {
        var t24 = e33.readUInt8();
        return e33.isError(t24) ? t24 : 0 !== t24;
    }, a47.prototype._decodeInt = function (e33, t24) {
        var r36 = e33.raw(), n47 = new i47(r36);
        return t24 && (n47 = t24[n47.toString(10)] || n47), n47;
    }, a47.prototype._use = function (e33, t24) {
        return "function" == typeof e33 && (e33 = e33(t24)), e33._getDecoder("der").tree;
    }, D$5;
}

var O$6 = {}, A$9 = !1,
        x$7 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
var I$9 = {}, q$5 = !1;

function P$5() {
    if (q$5) {
        return I$9;
    }
    q$5 = !0;
    var e32 = I$9;
    return e32.der = C$6(), e32.pem = (function () {
        if (A$9) {
            return O$6;
        }
        A$9 = !0;
        var e33 = t$2, r33 = e$1.Buffer, i47 = C$6();

        function o41(e34) {
            i47.call(this || x$7, e34), (this || x$7).enc = "pem";
        }

        return e33(o41, i47), O$6 = o41, o41.prototype.decode = function (e34, t24) {
            for (var n44 = e34.toString().split(/[\r\n]+/g), o44 = t24.label.toUpperCase(), s34 = /^-----(BEGIN|END) ([^-]+)-----$/, a47 = -1, u38 = -1, c31 = 0; c31 < n44.length; c31++) {
                var f39 = n44[c31].match(s34);
                if (null !== f39 && f39[2] === o44) {
                    if (-1 !== a47) {
                        if ("END" !== f39[1]) {
                            break;
                        }
                        u38 = c31;
                        break;
                    }
                    if ("BEGIN" !== f39[1]) {
                        break;
                    }
                    a47 = c31;
                }
            }
            if (-1 === a47 || -1 === u38) {
                throw new Error("PEM section not found for: " + o44);
            }
            var l43 = n44.slice(a47 + 1, u38).join("");
            l43.replace(/[^a-z0-9\+\/=]+/gi, "");
            var h30 = new r33(l43, "base64");
            return i47.prototype.decode.call(this || x$7, h30, t24);
        }, O$6;
    })(), I$9;
}

var F$6 = {}, K$5 = !1,
        R$4 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;

function $$2() {
    if (K$5) {
        return F$6;
    }
    K$5 = !0;
    var e32 = t$2, r33 = e$1.Buffer, i47 = Y$3(), o41 = i47.base, s34 = i47.constants.der;

    function a47(e33) {
        (this || R$4).enc = "der", (this || R$4).name = e33.name, (this || R$4).entity = e33, (this || R$4).tree = new u38, (this || R$4).tree._init(e33.body);
    }

    function u38(e33) {
        o41.Node.call(this || R$4, "der", e33);
    }

    function c31(e33) {
        return e33 < 10 ? "0" + e33 : e33;
    }

    return F$6 = a47, a47.prototype.encode = function (e33, t24) {
        return (this || R$4).tree._encode(e33, t24).join();
    }, e32(u38, o41.Node), u38.prototype._encodeComposite = function (e33, t24, n44, i50) {
        var o44, a49 = function (e34, t25, r36, n47) {
            var i51;
            "seqof" === e34 ? e34 = "seq" : "setof" === e34 && (e34 = "set");
            if (s34.tagByName.hasOwnProperty(e34)) {
                i51 = s34.tagByName[e34];
            } else {
                if ("number" != typeof e34 || (0 | e34) !== e34) {
                    return n47.error("Unknown tag: " + e34);
                }
                i51 = e34;
            }
            if (i51 >= 31) {
                return n47.error("Multi-octet tag encoding unsupported");
            }
            t25 || (i51 |= 32);
            return i51 |= s34.tagClassByName[r36 || "universal"] << 6;
        }(e33, t24, n44, (this || R$4).reporter);
        if (i50.length < 128) {
            return (o44 = new r33(2))[0] = a49, o44[1] = i50.length, this._createEncoderBuffer([
                o44,
                i50
            ]);
        }
        for (var u41 = 1, c33 = i50.length; c33 >= 256; c33 >>= 8) {
            u41++;
        }
        (o44 = new r33(2 + u41))[0] = a49, o44[1] = 128 | u41;
        c33 = 1 + u41;
        for (var f40 = i50.length; f40 > 0; c33--, f40 >>= 8) {
            o44[c33] = 255 & f40;
        }
        return this._createEncoderBuffer([
            o44,
            i50
        ]);
    }, u38.prototype._encodeStr = function (e33, t24) {
        if ("bitstr" === t24) {
            return this._createEncoderBuffer([
                0 | e33.unused,
                e33.data
            ]);
        }
        if ("bmpstr" === t24) {
            for (var n44 = new r33(2 * e33.length), i50 = 0; i50 < e33.length; i50++) {
                n44.writeUInt16BE(e33.charCodeAt(i50), 2 * i50);
            }
            return this._createEncoderBuffer(n44);
        }
        return "numstr" === t24 ? this._isNumstr(e33) ? this._createEncoderBuffer(e33) : (this || R$4).reporter.error("Encoding of string type: numstr supports only digits and space") : "printstr" === t24 ? this._isPrintstr(e33) ? this._createEncoderBuffer(e33) : (this || R$4).reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(t24) || "objDesc" === t24 ? this._createEncoderBuffer(e33) : (this || R$4).reporter.error("Encoding of string type: " + t24 + " unsupported");
    }, u38.prototype._encodeObjid = function (e33, t24, n47) {
        if ("string" == typeof e33) {
            if (!t24) {
                return (this || R$4).reporter.error("string objid given, but no values map found");
            }
            if (!t24.hasOwnProperty(e33)) {
                return (this || R$4).reporter.error("objid not found in values map");
            }
            e33 = t24[e33].split(/[\s\.]+/g);
            for (var i51 = 0; i51 < e33.length; i51++) {
                e33[i51] |= 0;
            }
        } else if (Array.isArray(e33)) {
            e33 = e33.slice();
            for (i51 = 0; i51 < e33.length; i51++) {
                e33[i51] |= 0;
            }
        }
        if (!Array.isArray(e33)) {
            return (this || R$4).reporter.error("objid() should be either array or string, got: " + JSON.stringify(e33));
        }
        if (!n47) {
            if (e33[1] >= 40) {
                return (this || R$4).reporter.error("Second objid identifier OOB");
            }
            e33.splice(0, 2, 40 * e33[0] + e33[1]);
        }
        var o44 = 0;
        for (i51 = 0; i51 < e33.length; i51++) {
            var s40 = e33[i51];
            for (o44++; s40 >= 128; s40 >>= 7) {
                o44++;
            }
        }
        var a49 = new r33(o44), u41 = a49.length - 1;
        for (i51 = e33.length - 1; i51 >= 0; i51--) {
            s40 = e33[i51];
            for (a49[u41--] = 127 & s40; (s40 >>= 7) > 0;) {
                a49[u41--] = 128 | 127 & s40;
            }
        }
        return this._createEncoderBuffer(a49);
    }, u38.prototype._encodeTime = function (e33, t24) {
        var r36, n47 = new Date(e33);
        return "gentime" === t24 ? r36 = [
            c31(n47.getFullYear()),
            c31(n47.getUTCMonth() + 1),
            c31(n47.getUTCDate()),
            c31(n47.getUTCHours()),
            c31(n47.getUTCMinutes()),
            c31(n47.getUTCSeconds()),
            "Z"
        ].join("") : "utctime" === t24 ? r36 = [
            c31(n47.getFullYear() % 100),
            c31(n47.getUTCMonth() + 1),
            c31(n47.getUTCDate()),
            c31(n47.getUTCHours()),
            c31(n47.getUTCMinutes()),
            c31(n47.getUTCSeconds()),
            "Z"
        ].join("") : (this || R$4).reporter.error("Encoding " + t24 + " time is not supported yet"), this._encodeStr(r36, "octstr");
    }, u38.prototype._encodeNull = function () {
        return this._createEncoderBuffer("");
    }, u38.prototype._encodeInt = function (e33, t24) {
        if ("string" == typeof e33) {
            if (!t24) {
                return (this || R$4).reporter.error("String int or enum given, but no values map");
            }
            if (!t24.hasOwnProperty(e33)) {
                return (this || R$4).reporter.error("Values map doesn't contain: " + JSON.stringify(e33));
            }
            e33 = t24[e33];
        }
        if ("number" != typeof e33 && !r33.isBuffer(e33)) {
            var n47 = e33.toArray();
            !e33.sign && 128 & n47[0] && n47.unshift(0), e33 = new r33(n47);
        }
        if (r33.isBuffer(e33)) {
            var i52 = e33.length;
            0 === e33.length && i52++;
            var o44 = new r33(i52);
            return e33.copy(o44), 0 === e33.length && (o44[0] = 0), this._createEncoderBuffer(o44);
        }
        if (e33 < 128) {
            return this._createEncoderBuffer(e33);
        }
        if (e33 < 256) {
            return this._createEncoderBuffer([
                0,
                e33
            ]);
        }
        i52 = 1;
        for (var s41 = e33; s41 >= 256; s41 >>= 8) {
            i52++;
        }
        for (s41 = (o44 = new Array(i52)).length - 1; s41 >= 0; s41--) {
            o44[s41] = 255 & e33, e33 >>= 8;
        }
        return 128 & o44[0] && o44.unshift(0), this._createEncoderBuffer(new r33(o44));
    }, u38.prototype._encodeBool = function (e33) {
        return this._createEncoderBuffer(e33 ? 255 : 0);
    }, u38.prototype._use = function (e33, t24) {
        return "function" == typeof e33 && (e33 = e33(t24)), e33._getEncoder("der").tree;
    }, u38.prototype._skipDefault = function (e33, t24, r36) {
        var n48, i53 = (this || R$4)._baseState;
        if (null === i53.default) {
            return !1;
        }
        var o45 = e33.join();
        if ((void 0) === i53.defaultBuffer && (i53.defaultBuffer = this._encodeValue(i53.default, t24, r36).join()), o45.length !== i53.defaultBuffer.length) {
            return !1;
        }
        for (n48 = 0; n48 < o45.length; n48++) {
            if (o45[n48] !== i53.defaultBuffer[n48]) {
                return !1;
            }
        }
        return !0;
    }, F$6;
}

var G$4 = {}, L$5 = !1,
        M$7 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
var J$4 = {}, V$4 = !1;

function Z$2() {
    if (V$4) {
        return J$4;
    }
    V$4 = !0;
    var e32 = J$4;
    return e32.der = $$2(), e32.pem = (function () {
        if (L$5) {
            return G$4;
        }
        L$5 = !0;
        var e33 = t$2, r33 = $$2();

        function n48(e34) {
            r33.call(this || M$7, e34), (this || M$7).enc = "pem";
        }

        return e33(n48, r33), G$4 = n48, n48.prototype.encode = function (e34, t24) {
            for (var n49 = r33.prototype.encode.call(this || M$7, e34).toString("base64"), i47 = [
                "-----BEGIN " + t24.label + "-----"
            ], o41 = 0; o41 < n49.length; o41 += 64) {
                i47.push(n49.slice(o41, o41 + 64));
            }
            return i47.push("-----END " + t24.label + "-----"), i47.join("\n");
        }, G$4;
    })(), J$4;
}

var z$7 = {}, H$6 = !1;

function Y$3() {
    if (H$6) {
        return z$7;
    }
    H$6 = !0;
    var n48 = z$7;
    return n48.bignum = n$c, n48.define = (function () {
        if (s$j) {
            return o$n;
        }
        s$j = !0;
        var e32 = Y$3(), n49 = t$2;

        function i47(e33, t24) {
            (this || a$m).name = e33, (this || a$m).content = t24, (this || a$m).decoders = {}, (this || a$m).encoders = {};
        }

        return o$n.define = function (e33, t24) {
            return new i47(e33, t24);
        }, i47.prototype._createNamed = function (e33) {
            var t24;
            try {
                t24 = exports1.runInThisContext("(function " + (this || a$m).name + "(entity) {\n  this._initNamed(entity);\n})");
            } catch (e34) {
                t24 = function (e35) {
                    this._initNamed(e35);
                };
            }
            return n49(t24, e33), t24.prototype._initNamed = function (t25) {
                e33.call(this || a$m, t25);
            }, new t24(this || a$m);
        }, i47.prototype._getDecoder = function (t24) {
            return t24 = t24 || "der", (this || a$m).decoders.hasOwnProperty(t24) || ((this || a$m).decoders[t24] = this._createNamed(e32.decoders[t24])), (this || a$m).decoders[t24];
        }, i47.prototype.decode = function (e33, t24, r33) {
            return this._getDecoder(t24).decode(e33, r33);
        }, i47.prototype._getEncoder = function (t24) {
            return t24 = t24 || "der", (this || a$m).encoders.hasOwnProperty(t24) || ((this || a$m).encoders[t24] = this._createNamed(e32.encoders[t24])), (this || a$m).encoders[t24];
        }, i47.prototype.encode = function (e33, t24, r33) {
            return this._getEncoder(t24).encode(e33, r33);
        }, o$n;
    })().define, n48.base = E$9(), n48.constants = T$6(), n48.decoders = P$5(), n48.encoders = Z$2(), z$7;
}

var Q$3 = Y$3();
var e$f = Q$3, t$a = e$f.define("Time", function () {
    this.choice({
        utcTime: this.utctime(),
        generalTime: this.gentime()
    });
}), s$k = e$f.define("AttributeTypeValue", function () {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
}), n$n = e$f.define("AlgorithmIdentifier", function () {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
}), o$o = e$f.define("SubjectPublicKeyInfo", function () {
    this.seq().obj(this.key("algorithm").use(n$n), this.key("subjectPublicKey").bitstr());
}), h$h = e$f.define("RelativeDistinguishedName", function () {
    this.setof(s$k);
}), y$g = e$f.define("RDNSequence", function () {
    this.seqof(h$h);
}), r$g = e$f.define("Name", function () {
    this.choice({
        rdnSequence: this.use(y$g)
    });
}), u$k = e$f.define("Validity", function () {
    this.seq().obj(this.key("notBefore").use(t$a), this.key("notAfter").use(t$a));
}), a$n = e$f.define("Extension", function () {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr());
}), c$j = e$f.define("TBSCertificate", function () {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(n$n), this.key("issuer").use(r$g), this.key("validity").use(u$k), this.key("subject").use(r$g), this.key("subjectPublicKeyInfo").use(o$o), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(a$n).optional());
}), k$d = e$f.define("X509Certificate", function () {
    this.seq().obj(this.key("tbsCertificate").use(c$j), this.key("signatureAlgorithm").use(n$n), this.key("signatureValue").bitstr());
}), f$o = {}, b$d = Q$3;
f$o.certificate = k$d;
var l$l = b$d.define("RSAPrivateKey", function () {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
});
f$o.RSAPrivateKey = l$l;
var d$j = b$d.define("RSAPublicKey", function () {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
});
f$o.RSAPublicKey = d$j;
var p$l = b$d.define("SubjectPublicKeyInfo", function () {
    this.seq().obj(this.key("algorithm").use(j$7), this.key("subjectPublicKey").bitstr());
});
f$o.PublicKey = p$l;
var j$7 = b$d.define("AlgorithmIdentifier", function () {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
}), v$g = b$d.define("PrivateKeyInfo", function () {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(j$7), this.key("subjectPrivateKey").octstr());
});
f$o.PrivateKey = v$g;
var m$h = b$d.define("EncryptedPrivateKeyInfo", function () {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
});
f$o.EncryptedPrivateKey = m$h;
var q$6 = b$d.define("DSAPrivateKey", function () {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
});
f$o.DSAPrivateKey = q$6, f$o.DSAparam = b$d.define("DSAparam", function () {
    this.int();
});
var K$6 = b$d.define("ECPrivateKey", function () {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(P$6), this.key("publicKey").optional().explicit(1).bitstr());
});
f$o.ECPrivateKey = K$6;
var P$6 = b$d.define("ECParameters", function () {
    this.choice({
        namedCurve: this.objid()
    });
});
f$o.signature = b$d.define("signature", function () {
    this.seq().obj(this.key("r").int(), this.key("s").int());
});
var s$l,
        i$a = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m,
        o$p = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m,
        d$k = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m, n$o = a$c,
        p$m = t$32, u$l = u14.Buffer, y$h = f$o, m$i = {
            "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
            "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
            "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
            "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
            "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
            "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
            "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
            "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
            "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
            "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
            "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
            "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
        }, f$p = function (e32, r33) {
            var a47, t24 = e32.toString(), c31 = t24.match(i$a);
            if (c31) {
                var s34 = "aes" + c31[1], y14 = u$l.from(c31[2], "hex"),
                        m18 = u$l.from(c31[3].replace(/[\r\n]/g, ""), "base64"),
                        f40 = n$o(r33, y14.slice(0, 8), parseInt(c31[1], 10)).key, b18 = [],
                        E10 = p$m.createDecipheriv(s34, f40, y14);
                b18.push(E10.update(m18)), b18.push(E10.final()), a47 = u$l.concat(b18);
            } else {
                var h30 = t24.match(d$k);
                a47 = new u$l(h30[2].replace(/[\r\n]/g, ""), "base64");
            }
            return {
                tag: t24.match(o$p)[1],
                data: a47
            };
        }, b$e = t$32, E$a = M$12, h$i = u14.Buffer;

function l$m(e32) {
    var r33;
    "object" != typeof e32 || h$i.isBuffer(e32) || (r33 = e32.passphrase, e32 = e32.key), "string" == typeof e32 && (e32 = h$i.from(e32));
    var a47, t24, c31 = f$p(e32, r33), s41 = c31.tag, i47 = c31.data;
    switch (s41) {
        case "CERTIFICATE":
            t24 = y$h.certificate.decode(i47, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
            switch (t24 || (t24 = y$h.PublicKey.decode(i47, "der")), a47 = t24.algorithm.algorithm.join(".")) {
                case "1.2.840.113549.1.1.1":
                    return y$h.RSAPublicKey.decode(t24.subjectPublicKey.data, "der");
                case "1.2.840.10045.2.1":
                    return t24.subjectPrivateKey = t24.subjectPublicKey, {
                        type: "ec",
                        data: t24
                    };
                case "1.2.840.10040.4.1":
                    return t24.algorithm.params.pub_key = y$h.DSAparam.decode(t24.subjectPublicKey.data, "der"), {
                        type: "dsa",
                        data: t24.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + a47);
            }
        case "ENCRYPTED PRIVATE KEY":
            i47 = (function (e33, r36) {
                var a49 = e33.algorithm.decrypt.kde.kdeparams.salt,
                        t25 = parseInt(e33.algorithm.decrypt.kde.kdeparams.iters.toString(), 10),
                        c33 = m$i[e33.algorithm.decrypt.cipher.algo.join(".")], s42 = e33.algorithm.decrypt.cipher.iv,
                        i53 = e33.subjectPrivateKey, o41 = parseInt(c33.split("-")[1], 10) / 8,
                        d23 = E$a.pbkdf2Sync(r36, a49, t25, o41, "sha1"), n48 = b$e.createDecipheriv(c33, d23, s42),
                        p35 = [];
                return p35.push(n48.update(i53)), p35.push(n48.final()), h$i.concat(p35);
            })(i47 = y$h.EncryptedPrivateKey.decode(i47, "der"), r33);
        case "PRIVATE KEY":
            switch (a47 = (t24 = y$h.PrivateKey.decode(i47, "der")).algorithm.algorithm.join(".")) {
                case "1.2.840.113549.1.1.1":
                    return y$h.RSAPrivateKey.decode(t24.subjectPrivateKey, "der");
                case "1.2.840.10045.2.1":
                    return {
                        curve: t24.algorithm.curve,
                        privateKey: y$h.ECPrivateKey.decode(t24.subjectPrivateKey, "der").privateKey
                    };
                case "1.2.840.10040.4.1":
                    return t24.algorithm.params.priv_key = y$h.DSAparam.decode(t24.subjectPrivateKey, "der"), {
                        type: "dsa",
                        params: t24.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + a47);
            }
        case "RSA PUBLIC KEY":
            return y$h.RSAPublicKey.decode(i47, "der");
        case "RSA PRIVATE KEY":
            return y$h.RSAPrivateKey.decode(i47, "der");
        case "DSA PRIVATE KEY":
            return {
                type: "dsa",
                params: y$h.DSAPrivateKey.decode(i47, "der")
            };
        case "EC PRIVATE KEY":
            return {
                curve: (i47 = y$h.ECPrivateKey.decode(i47, "der")).parameters.value,
                privateKey: i47.privateKey
            };
        default:
            throw new Error("unknown key type " + s41);
    }
}

s$l = l$m, l$m.signature = y$h.signature;
var v$h = s$l;
var p$n = {
    "1.3.132.0.10": "secp256k1",
    "1.3.132.0.33": "p224",
    "1.2.840.10045.3.1.1": "p192",
    "1.2.840.10045.3.1.7": "p256",
    "1.3.132.0.34": "p384",
    "1.3.132.0.35": "p521"
}, d$l = {}, f$q = e$1.Buffer, c$k = w$3, g$f = l$d, w$g = Le.ec, l$n = n$c, m$j = v$h, v$i = p$n;

function y$i(e32, t24, r33, n48) {
    if ((e32 = new f$q(e32.toArray())).length < t24.byteLength()) {
        var a47 = new f$q(t24.byteLength() - e32.length);
        a47.fill(0), e32 = f$q.concat([
            a47,
            e32
        ]);
    }
    var o41 = r33.length, i47 = function (e33, t25) {
        e33 = (e33 = b$f(e33, t25)).mod(t25);
        var r36 = new f$q(e33.toArray());
        if (r36.length < t25.byteLength()) {
            var n49 = new f$q(t25.byteLength() - r36.length);
            n49.fill(0), r36 = f$q.concat([
                n49,
                r36
            ]);
        }
        return r36;
    }(r33, t24), s41 = new f$q(o41);
    s41.fill(1);
    var h31 = new f$q(o41);
    return h31.fill(0), h31 = c$k(n48, h31).update(s41).update(new f$q([
        0
    ])).update(e32).update(i47).digest(), s41 = c$k(n48, h31).update(s41).digest(), {
        k: h31 = c$k(n48, h31).update(s41).update(new f$q([
            1
        ])).update(e32).update(i47).digest(),
        v: s41 = c$k(n48, h31).update(s41).digest()
    };
}

function b$f(e32, t24) {
    var r33 = new l$n(e32), n48 = (e32.length << 3) - t24.bitLength();
    return n48 > 0 && r33.ishrn(n48), r33;
}

function _$f(e32, t24, r33) {
    var n48, a49;
    do {
        for (n48 = new f$q(0); 8 * n48.length < e32.bitLength();) {
            t24.v = c$k(r33, t24.k).update(t24.v).digest(), n48 = f$q.concat([
                n48,
                t24.v
            ]);
        }
        a49 = b$f(n48, e32), t24.k = c$k(r33, t24.k).update(t24.v).update(new f$q([
            0
        ])).digest(), t24.v = c$k(r33, t24.k).update(t24.v).digest();
    } while (-1 !== a49.cmp(e32))
    return a49;
}

function k$e(e32, t24, r33, n48) {
    return e32.toRed(l$n.mont(r33)).redPow(t24).fromRed().mod(n48);
}

(d$l = function (e32, t24, r33, n48, a49) {
    var o41 = m$j(t24);
    if (o41.curve) {
        if ("ecdsa" !== n48 && "ecdsa/rsa" !== n48) {
            throw new Error("wrong private key type");
        }
        return (function (e33, t25) {
            var r36 = v$i[t25.curve.join(".")];
            if (!r36) {
                throw new Error("unknown curve " + t25.curve.join("."));
            }
            var n50 = new w$g(r36).keyFromPrivate(t25.privateKey).sign(e33);
            return new f$q(n50.toDER());
        })(e32, o41);
    }
    if ("dsa" === o41.type) {
        if ("dsa" !== n48) {
            throw new Error("wrong private key type");
        }
        return (function (e33, t25, r36) {
            var n50, a50 = t25.params.priv_key, o45 = t25.params.p, i47 = t25.params.q, s41 = t25.params.g,
                    h31 = new l$n(0), u38 = b$f(e33, i47).mod(i47), p35 = !1, d23 = y$i(a50, i47, e33, r36);
            for (; !1 === p35;) {
                n50 = _$f(i47, d23, r36), h31 = k$e(s41, n50, o45, i47), 0 === (p35 = n50.invm(i47).imul(u38.add(a50.mul(h31))).mod(i47)).cmpn(0) && (p35 = !1, h31 = new l$n(0));
            }
            return (function (e34, t26) {
                e34 = e34.toArray(), t26 = t26.toArray(), 128 & e34[0] && (e34 = [
                    0
                ].concat(e34));
                128 & t26[0] && (t26 = [
                    0
                ].concat(t26));
                var r37 = [
                    48,
                    e34.length + t26.length + 4,
                    2,
                    e34.length
                ];
                return r37 = r37.concat(e34, [
                    2,
                    t26.length
                ], t26), new f$q(r37);
            })(h31, p35);
        })(e32, o41, r33);
    }
    if ("rsa" !== n48 && "ecdsa/rsa" !== n48) {
        throw new Error("wrong private key type");
    }
    e32 = f$q.concat([
        a49,
        e32
    ]);
    for (var i47 = o41.modulus.byteLength(), s41 = [
        0,
        1
    ]; e32.length + s41.length + 1 < i47;) {
        s41.push(255);
    }
    s41.push(0);
    for (var h31 = -1; (++h31) < e32.length;) {
        s41.push(e32[h31]);
    }
    return g$f(s41, o41);
}).getKey = y$i, d$l.makeKey = _$f;
var E$b = d$l, L$6 = e$1.Buffer, R$5 = n$c, j$8 = Le.ec, T$7 = v$h, P$7 = p$n;

function A$a(e32, t24) {
    if (e32.cmpn(0) <= 0) {
        throw new Error("invalid sig");
    }
    if (e32.cmp(t24) >= t24) {
        throw new Error("invalid sig");
    }
}

var K$7 = function (e32, t24, r33, n48, a49) {
            var o41 = T$7(r33);
            if ("ec" === o41.type) {
                if ("ecdsa" !== n48 && "ecdsa/rsa" !== n48) {
                    throw new Error("wrong public key type");
                }
                return function (e33, t25, r36) {
                    var n50 = P$7[r36.data.algorithm.curve.join(".")];
                    if (!n50) {
                        throw new Error("unknown curve " + r36.data.algorithm.curve.join("."));
                    }
                    var a50 = new j$8(n50), o45 = r36.data.subjectPrivateKey.data;
                    return a50.verify(t25, e33, o45);
                }(e32, t24, o41);
            }
            if ("dsa" === o41.type) {
                if ("dsa" !== n48) {
                    throw new Error("wrong public key type");
                }
                return function (e33, t25, r36) {
                    var n50 = r36.data.p, a50 = r36.data.q, o45 = r36.data.g, i47 = r36.data.pub_key,
                            s41 = T$7.signature.decode(e33, "der"), h31 = s41.s, u38 = s41.r;
                    A$a(h31, a50), A$a(u38, a50);
                    var p35 = R$5.mont(n50), d23 = h31.invm(a50);
                    return 0 === o45.toRed(p35).redPow(new R$5(t25).mul(d23).mod(a50)).fromRed().mul(i47.toRed(p35).redPow(u38.mul(d23).mod(a50)).fromRed()).mod(n50).mod(a50).cmp(u38);
                }(e32, t24, o41);
            }
            if ("rsa" !== n48 && "ecdsa/rsa" !== n48) {
                throw new Error("wrong public key type");
            }
            t24 = L$6.concat([
                a49,
                t24
            ]);
            for (var i47 = o41.modulus.byteLength(), s41 = [
                1
            ], h31 = 0; t24.length + s41.length + 2 < i47;) {
                s41.push(255), h31++;
            }
            s41.push(0);
            for (var u38 = -1; (++u38) < t24.length;) {
                s41.push(t24[u38]);
            }
            s41 = new L$6(s41);
            var p35 = R$5.mont(o41.modulus);
            e32 = (e32 = new R$5(e32).toRed(p35)).redPow(new R$5(o41.publicExponent)), e32 = new L$6(e32.fromRed().toArray());
            var d23 = h31 < 8 ? 1 : 0;
            for ((i47 = Math.min(e32.length, s41.length), e32.length !== s41.length && (d23 = 1), u38 = -1); (++u38) < i47;) {
                d23 |= e32[u38] ^ s41[u38];
            }
            return 0 === d23;
        }, W$4 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, x$8 = e$1.Buffer,
        B$a = h$4, S$b = b7, q$7 = t$2, U$8 = E$b, V$5 = K$7, C$7 = s$4;

function D$6(e32) {
    S$b.Writable.call(this || W$4);
    var t24 = C$7[e32];
    if (!t24) {
        throw new Error("Unknown message digest");
    }
    (this || W$4)._hashType = t24.hash, (this || W$4)._hash = B$a(t24.hash), (this || W$4)._tag = t24.id, (this || W$4)._signType = t24.sign;
}

function F$7(e32) {
    S$b.Writable.call(this || W$4);
    var t24 = C$7[e32];
    if (!t24) {
        throw new Error("Unknown message digest");
    }
    (this || W$4)._hash = B$a(t24.hash), (this || W$4)._tag = t24.id, (this || W$4)._signType = t24.sign;
}

function M$8(e32) {
    return new D$6(e32);
}

function O$7(e32) {
    return new F$7(e32);
}

Object.keys(C$7).forEach(function (e32) {
    C$7[e32].id = new x$8(C$7[e32].id, "hex"), C$7[e32.toLowerCase()] = C$7[e32];
}), q$7(D$6, S$b.Writable), D$6.prototype._write = function (e32, t24, r33) {
    (this || W$4)._hash.update(e32), r33();
}, D$6.prototype.update = function (e32, t24) {
    return "string" == typeof e32 && (e32 = new x$8(e32, t24)), (this || W$4)._hash.update(e32), this || W$4;
}, D$6.prototype.sign = function (e32, t24) {
    this.end();
    var r33 = (this || W$4)._hash.digest(),
            n48 = U$8(r33, e32, (this || W$4)._hashType, (this || W$4)._signType, (this || W$4)._tag);
    return t24 ? n48.toString(t24) : n48;
}, q$7(F$7, S$b.Writable), F$7.prototype._write = function (e32, t24, r33) {
    (this || W$4)._hash.update(e32), r33();
}, F$7.prototype.update = function (e32, t24) {
    return "string" == typeof e32 && (e32 = new x$8(e32, t24)), (this || W$4)._hash.update(e32), this || W$4;
}, F$7.prototype.verify = function (e32, t24, r33) {
    "string" == typeof t24 && (t24 = new x$8(t24, r33)), this.end();
    var n48 = (this || W$4)._hash.digest();
    return V$5(t24, n48, e32, (this || W$4)._signType, (this || W$4)._tag);
};
var z$8 = {
    Sign: M$8,
    Verify: O$7,
    createSign: M$8,
    createVerify: O$7
};
var i$b, n$p = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global,
        p$o = e$1.Buffer, s$m = Le, u$m = n$c;
i$b = function (e32) {
    return new c$l(e32);
};
var o$q = {
    secp256k1: {
        name: "secp256k1",
        byteLength: 32
    },
    secp224r1: {
        name: "p224",
        byteLength: 28
    },
    prime256v1: {
        name: "p256",
        byteLength: 32
    },
    prime192v1: {
        name: "p192",
        byteLength: 24
    },
    ed25519: {
        name: "ed25519",
        byteLength: 32
    },
    secp384r1: {
        name: "p384",
        byteLength: 48
    },
    secp521r1: {
        name: "p521",
        byteLength: 66
    }
};

function c$l(e32) {
    (this || n$p).curveType = o$q[e32], (this || n$p).curveType || ((this || n$p).curveType = {
        name: e32
    }), (this || n$p).curve = new s$m.ec((this || n$p).curveType.name), (this || n$p).keys = void 0;
}

function y$j(e32, t24, r33) {
    Array.isArray(e32) || (e32 = e32.toArray());
    var i47 = new p$o(e32);
    if (r33 && i47.length < r33) {
        var n48 = new p$o(r33 - i47.length);
        n48.fill(0), i47 = p$o.concat([
            n48,
            i47
        ]);
    }
    return t24 ? i47.toString(t24) : i47;
}

o$q.p224 = o$q.secp224r1, o$q.p256 = o$q.secp256r1 = o$q.prime256v1, o$q.p192 = o$q.secp192r1 = o$q.prime192v1, o$q.p384 = o$q.secp384r1, o$q.p521 = o$q.secp521r1, c$l.prototype.generateKeys = function (e32, t24) {
    return (this || n$p).keys = (this || n$p).curve.genKeyPair(), this.getPublicKey(e32, t24);
}, c$l.prototype.computeSecret = function (e32, t24, r33) {
    return t24 = t24 || "utf8", p$o.isBuffer(e32) || (e32 = new p$o(e32, t24)), y$j((this || n$p).curve.keyFromPublic(e32).getPublic().mul((this || n$p).keys.getPrivate()).getX(), r33, (this || n$p).curveType.byteLength);
}, c$l.prototype.getPublicKey = function (e32, t24) {
    var r33 = (this || n$p).keys.getPublic("compressed" === t24, !0);
    return "hybrid" === t24 && (r33[r33.length - 1] % 2 ? r33[0] = 7 : r33[0] = 6), y$j(r33, e32);
}, c$l.prototype.getPrivateKey = function (e32) {
    return y$j((this || n$p).keys.getPrivate(), e32);
}, c$l.prototype.setPublicKey = function (e32, t24) {
    return t24 = t24 || "utf8", p$o.isBuffer(e32) || (e32 = new p$o(e32, t24)), (this || n$p).keys._importPublic(e32), this || n$p;
}, c$l.prototype.setPrivateKey = function (e32, t24) {
    t24 = t24 || "utf8", p$o.isBuffer(e32) || (e32 = new p$o(e32, t24));
    var r33 = new u$m(e32);
    return r33 = r33.toString(16), (this || n$p).keys = (this || n$p).curve.genKeyPair(), (this || n$p).keys._importPrivate(r33), this || n$p;
};
var f$r = i$b;
var i$c = h$4, l$o = u14.Buffer;

function f$s(r33) {
    var n50 = l$o.allocUnsafe(4);
    return n50.writeUInt32BE(r33, 0), n50;
}

var u$n = function (r33, n50) {
    for (var e32, t24 = l$o.alloc(0), o41 = 0; t24.length < n50;) {
        e32 = f$s(o41++), t24 = l$o.concat([
            t24,
            i$c("sha1").update(r33).update(e32).digest()
        ]);
    }
    return t24.slice(0, n50);
}, c$m = function (r33, n50) {
    for (var e32 = r33.length, t24 = -1; (++t24) < e32;) {
        r33[t24] ^= n50[t24];
    }
    return r33;
}, p$p = n$c, d$m = u14.Buffer;
var h$j = function (r33, n50) {
    return d$m.from(r33.toRed(p$p.mont(n50.modulus)).redPow(new p$p(n50.publicExponent)).fromRed().toArray());
}, s$n = v$h, g$g = a30, m$k = h$4, w$h = u$n, v$j = c$m, y$k = n$c, E$c = h$j, b$g = l$d, B$b = u14.Buffer;
var x$9 = function (r33, n50, e32) {
    var t24;
    t24 = r33.padding ? r33.padding : e32 ? 1 : 4;
    var o41, a49 = s$n(r33);
    if (4 === t24) {
        o41 = (function (r36, n51) {
            var e33 = r36.modulus.byteLength(), t25 = n51.length, o45 = m$k("sha1").update(B$b.alloc(0)).digest(),
                    a50 = o45.length, i47 = 2 * a50;
            if (t25 > e33 - i47 - 2) {
                throw new Error("message too long");
            }
            var l43 = B$b.alloc(e33 - t25 - i47 - 2), f41 = e33 - a50 - 1, u38 = g$g(a50), c31 = v$j(B$b.concat([
                o45,
                l43,
                B$b.alloc(1, 1),
                n51
            ], f41), w$h(u38, f41)), p35 = v$j(u38, w$h(c31, a50));
            return new y$k(B$b.concat([
                B$b.alloc(1),
                p35,
                c31
            ], e33));
        })(a49, n50);
    } else if (1 === t24) {
        o41 = (function (r36, n51, e33) {
            var t25, o45 = n51.length, a50 = r36.modulus.byteLength();
            if (o45 > a50 - 11) {
                throw new Error("message too long");
            }
            t25 = e33 ? B$b.alloc(a50 - o45 - 3, 255) : (function (r37) {
                var n52, e34 = B$b.allocUnsafe(r37), t26 = 0, o46 = g$g(2 * r37), a51 = 0;
                for (; t26 < r37;) {
                    a51 === o46.length && (o46 = g$g(2 * r37), a51 = 0), (n52 = o46[a51++]) && (e34[t26++] = n52);
                }
                return e34;
            })(a50 - o45 - 3);
            return new y$k(B$b.concat([
                B$b.from([
                    0,
                    e33 ? 1 : 2
                ]),
                t25,
                B$b.alloc(1),
                n51
            ], a50));
        })(a49, n50, e32);
    } else {
        if (3 !== t24) {
            throw new Error("unknown padding");
        }
        if ((o41 = new y$k(n50)).cmp(a49.modulus) >= 0) {
            throw new Error("data too long for modulus");
        }
    }
    return e32 ? b$g(o41, a49) : E$c(o41, a49);
}, L$7 = v$h, k$f = u$n, D$7 = c$m, U$9 = n$c, R$6 = l$d, S$c = h$4, j$9 = h$j, A$b = u14.Buffer;
var I$a = function (r33, n50, e32) {
    var t24;
    t24 = r33.padding ? r33.padding : e32 ? 1 : 4;
    var o41, a49 = L$7(r33), i47 = a49.modulus.byteLength();
    if (n50.length > i47 || new U$9(n50).cmp(a49.modulus) >= 0) {
        throw new Error("decryption error");
    }
    o41 = e32 ? j$9(new U$9(n50), a49) : R$6(n50, a49);
    var l43 = A$b.alloc(i47 - o41.length);
    if ((o41 = A$b.concat([
        l43,
        o41
    ], i47), 4 === t24)) {
        return function (r36, n51) {
            var e33 = r36.modulus.byteLength(), t25 = S$c("sha1").update(A$b.alloc(0)).digest(), o45 = t25.length;
            if (0 !== n51[0]) {
                throw new Error("decryption error");
            }
            var a50 = n51.slice(1, o45 + 1), i53 = n51.slice(o45 + 1), l44 = D$7(a50, k$f(i53, o45)),
                    f41 = D$7(i53, k$f(l44, e33 - o45 - 1));
            if ((function (r37, n52) {
                r37 = A$b.from(r37), n52 = A$b.from(n52);
                var e34 = 0, t26 = r37.length;
                r37.length !== n52.length && (e34++, t26 = Math.min(r37.length, n52.length));
                var o46 = -1;
                for (; (++o46) < t26;) {
                    e34 += r37[o46] ^ n52[o46];
                }
                return e34;
            })(t25, f41.slice(0, o45))) {
                throw new Error("decryption error");
            }
            var u38 = o45;
            for (; 0 === f41[u38];) {
                u38++;
            }
            if (1 !== f41[u38++]) {
                throw new Error("decryption error");
            }
            return f41.slice(u38);
        }(a49, o41);
    }
    if (1 === t24) {
        return function (r36, n51, e33) {
            var t25 = n51.slice(0, 2), o45 = 2, a50 = 0;
            for (; 0 !== n51[o45++];) {
                if (o45 >= n51.length) {
                    a50++;
                    break;
                }
            }
            var i53 = n51.slice(2, o45 - 1);
            ("0002" !== t25.toString("hex") && !e33 || "0001" !== t25.toString("hex") && e33) && a50++;
            i53.length < 8 && a50++;
            if (a50) {
                throw new Error("decryption error");
            }
            return n51.slice(o45);
        }(0, o41, e32);
    }
    if (3 === t24) {
        return o41;
    }
    throw new Error("unknown padding");
}, M$9 = {};
M$9.publicEncrypt = x$9, M$9.privateDecrypt = I$a, M$9.privateEncrypt = function (r33, n50) {
    return M$9.publicEncrypt(r33, n50, !0);
}, M$9.publicDecrypt = function (r33, n50) {
    return M$9.privateDecrypt(r33, n50, !0);
};
var o$r = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, t$b = {},
        f$t = T1;

function i$d() {
    throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
}

var u$o = u14, a$o = a30, s$o = u$o.Buffer, l$p = u$o.kMaxLength, m$l = o$r.crypto || o$r.msCrypto,
        p$q = Math.pow(2, 32) - 1;

function y$l(r33, e32) {
    if ("number" != typeof r33 || r33 != r33) {
        throw new TypeError("offset must be a number");
    }
    if (r33 > p$q || r33 < 0) {
        throw new TypeError("offset must be a uint32");
    }
    if (r33 > l$p || r33 > e32) {
        throw new RangeError("offset out of range");
    }
}

function b$h(r33, e32, n50) {
    if ("number" != typeof r33 || r33 != r33) {
        throw new TypeError("size must be a number");
    }
    if (r33 > p$q || r33 < 0) {
        throw new TypeError("size must be a uint32");
    }
    if (r33 + e32 > n50 || r33 > l$p) {
        throw new RangeError("buffer too small");
    }
}

function w$i(r33, e32, n50, o41) {
    if (f$t.browser) {
        var t24 = r33.buffer, i47 = new Uint8Array(t24, e32, n50);
        return m$l.getRandomValues(i47), o41 ? (f$t.nextTick(function () {
            o41(null, r33);
        }), void 0) : r33;
    }
    return o41 ? (a$o(n50, function (n51, t25) {
        if (n51) {
            return o41(n51);
        }
        t25.copy(r33, e32), o41(null, r33);
    }), void 0) : (a$o(n50).copy(r33, e32), r33);
}

m$l && m$l.getRandomValues || !f$t.browser ? (t$b.randomFill = function (r33, e32, n50, t25) {
    if (!(s$o.isBuffer(r33) || r33 instanceof o$r.Uint8Array)) {
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    }
    if ("function" == typeof e32) {
        t25 = e32, e32 = 0, n50 = r33.length;
    } else if ("function" == typeof n50) {
        t25 = n50, n50 = r33.length - e32;
    } else if ("function" != typeof t25) {
        throw new TypeError('"cb" argument must be a function');
    }
    return y$l(e32, r33.length), b$h(n50, e32, r33.length), w$i(r33, e32, n50, t25);
}, t$b.randomFillSync = function (r33, e32, n50) {
    (void 0) === e32 && (e32 = 0);
    if (!(s$o.isBuffer(r33) || r33 instanceof o$r.Uint8Array)) {
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    }
    y$l(e32, r33.length), (void 0) === n50 && (n50 = r33.length - e32);
    return b$h(n50, e32, r33.length), w$i(r33, e32, n50);
}) : (t$b.randomFill = i$d, t$b.randomFillSync = i$d);
var l$q = {};
l$q.randomBytes = l$q.rng = l$q.pseudoRandomBytes = l$q.prng = a30, l$q.createHash = l$q.Hash = h$4, l$q.createHmac = l$q.Hmac = w$3;
var D$8 = s$4, s$p = Object.keys(D$8), _$g = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
].concat(s$p);
l$q.getHashes = function () {
    return _$g;
};
var h$k = M$12;
l$q.pbkdf2 = h$k.pbkdf2, l$q.pbkdf2Sync = h$k.pbkdf2Sync;
var y$m = p$d;
l$q.Cipher = y$m.Cipher, l$q.createCipher = y$m.createCipher, l$q.Cipheriv = y$m.Cipheriv, l$q.createCipheriv = y$m.createCipheriv, l$q.Decipher = y$m.Decipher, l$q.createDecipher = y$m.createDecipher, l$q.Decipheriv = y$m.Decipheriv, l$q.createDecipheriv = y$m.createDecipheriv, l$q.getCiphers = y$m.getCiphers, l$q.listCiphers = y$m.listCiphers;
var E$d = O$3;
l$q.DiffieHellmanGroup = E$d.DiffieHellmanGroup, l$q.createDiffieHellmanGroup = E$d.createDiffieHellmanGroup, l$q.getDiffieHellman = E$d.getDiffieHellman, l$q.createDiffieHellman = E$d.createDiffieHellman, l$q.DiffieHellman = E$d.DiffieHellman;
var S$d = z$8;
l$q.createSign = S$d.createSign, l$q.Sign = S$d.Sign, l$q.createVerify = S$d.createVerify, l$q.Verify = S$d.Verify, l$q.createECDH = f$r;
var C$8 = M$9;
l$q.publicEncrypt = C$8.publicEncrypt, l$q.privateEncrypt = C$8.privateEncrypt, l$q.publicDecrypt = C$8.publicDecrypt, l$q.privateDecrypt = C$8.privateDecrypt;
var N$6 = t$b;
l$q.randomFill = N$6.randomFill, l$q.randomFillSync = N$6.randomFillSync, l$q.createCredentials = function () {
    throw new Error([
        "sorry, createCredentials is not implemented yet",
        "we accept pull requests",
        "https://github.com/crypto-browserify/crypto-browserify"
    ].join("\n"));
}, l$q.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
};

function unimplemented() {
    throw new Error("Node.js net module is not supported by jspm core" + ("undefined" != typeof Deno ? ". Deno support here is tracking in https://github.com/jspm/jspm-core/issues/4, +1's are appreciated!" : " in the browser"));
}

var net = {
    _createServerHandle: unimplemented,
    _normalizeArgs: unimplemented,
    _setSimultaneousAccepts: unimplemented,
    connect: unimplemented,
    createConnection: unimplemented,
    createServer: unimplemented,
    isIP: unimplemented,
    isIPv4: unimplemented,
    isIPv6: unimplemented,
    Server: unimplemented,
    Socket: unimplemented,
    Stream: unimplemented
};

function unimplemented1() {
    throw new Error("Node.js tls module is not supported by jspm core" + ("undefined" != typeof Deno ? ". Deno support here is tracking in https://github.com/jspm/jspm-core/issues/4, +1's are appreciated!" : " in the browser"));
}

var tls = {
    CLIENT_RENEG_LIMIT: null,
    CLIENT_RENEG_WINDOW: null,
    DEFAULT_CIPHERS: null,
    DEFAULT_ECDH_CURVE: null,
    DEFAULT_MIN_VERSION: null,
    DEFAULT_MAX_VERSION: null,
    getCiphers: unimplemented1,
    rootCertificates: null,
    convertALPNProtocols: unimplemented1,
    checkServerIdentity: unimplemented1,
    parseCertString: unimplemented1,
    createSecureContext: unimplemented1,
    SecureContext: unimplemented1,
    TLSSocket: unimplemented1,
    Server: unimplemented1,
    createServer: unimplemented1,
    connect: unimplemented1,
    createSecurePair: unimplemented1
};
var exports2 = {};
var process = T1;
const {assign} = Object;
const LEVELS = {
    NOTHING: 0,
    ERROR: 1,
    WARN: 2,
    INFO: 4,
    DEBUG: 5
};
const createLevel = (label, level, currentLevel, namespace, logFunction) => (message, extra = {}) => {
            if (level > currentLevel()) {
                return;
            }
            logFunction({
                namespace,
                level,
                label,
                log: assign({
                    timestamp: new Date().toISOString(),
                    logger: "kafkajs",
                    message
                }, extra)
            });
        }
;
const evaluateLogLevel = (logLevel) => {
    const envLogLevel = (process.env.KAFKAJS_LOG_LEVEL || "").toUpperCase();
    return LEVELS[envLogLevel] == null ? logLevel : LEVELS[envLogLevel];
};
const createLogger = ({level = LEVELS.INFO, logCreator} = {}) => {
    let logLevel = evaluateLogLevel(level);
    const logFunction = logCreator(logLevel);
    const createNamespace = (namespace, logLevel1 = null) => {
        const namespaceLogLevel = evaluateLogLevel(logLevel1);
        return createLogFunctions(namespace, namespaceLogLevel);
    };
    const createLogFunctions = (namespace, namespaceLogLevel = null) => {
        const currentLogLevel = () => namespaceLogLevel == null ? logLevel : namespaceLogLevel
        ;
        const logger = {
            info: createLevel("INFO", LEVELS.INFO, currentLogLevel, namespace, logFunction),
            error: createLevel("ERROR", LEVELS.ERROR, currentLogLevel, namespace, logFunction),
            warn: createLevel("WARN", LEVELS.WARN, currentLogLevel, namespace, logFunction),
            debug: createLevel("DEBUG", LEVELS.DEBUG, currentLogLevel, namespace, logFunction)
        };
        return assign(logger, {
            namespace: createNamespace,
            setLogLevel: (newLevel) => {
                logLevel = newLevel;
            }
        });
    };
    return createLogFunctions();
};
exports2 = {
    LEVELS,
    createLogger
};
var _loggers = exports2;
var exports$11 = {};
let id = 0;
const nextId = () => {
    if (id === Number.MAX_VALUE) {
        id = 0;
    }
    return id++;
};

class InstrumentationEvent {
    constructor(type, payload1) {
        this.id = nextId();
        this.type = type;
        this.timestamp = Date.now();
        this.payload = payload1;
    }
}

exports$11 = InstrumentationEvent;
var _event = exports$11;
var _package = {
    "name": "kafkajs",
    "version": "1.15.0",
    "description": "A modern Apache Kafka client for node.js",
    "author": "Tulio Ornelas <ornelas.tulio@gmail.com>",
    "main": "index.js",
    "types": "types/index.d.ts",
    "license": "MIT",
    "keywords": [
        "kafka",
        "sasl",
        "scram"
    ],
    "engines": {
        "node": ">=10.13.0"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/tulios/kafkajs.git"
    },
    "bugs": {
        "url": "https://github.com/tulios/kafkajs/issues"
    },
    "homepage": "https://kafka.js.org",
    "scripts": {
        "jest": "export KAFKA_VERSION=${KAFKA_VERSION:='2.4'} && NODE_ENV=test echo \"KAFKA_VERSION: ${KAFKA_VERSION}\" && KAFKAJS_DEBUG_PROTOCOL_BUFFERS=1 jest",
        "test:local": "yarn jest --detectOpenHandles",
        "test:debug": "NODE_ENV=test KAFKAJS_DEBUG_PROTOCOL_BUFFERS=1 node --inspect-brk $(yarn bin 2>/dev/null)/jest --detectOpenHandles --runInBand --watch",
        "test:local:watch": "yarn test:local --watch",
        "test": "yarn lint && JEST_JUNIT_OUTPUT_NAME=test-report.xml ./scripts/testWithKafka.sh 'yarn jest --ci --maxWorkers=4 --no-watchman --forceExit'",
        "lint": "find . -path ./node_modules -prune -o -path ./coverage -prune -o -path ./website -prune -o -name '*.js' -print0 | xargs -0 eslint",
        "format": "find . -path ./node_modules -prune -o -path ./coverage -prune -o -path ./website -prune -o -name '*.js' -print0 | xargs -0 prettier --write",
        "precommit": "lint-staged",
        "test:group:broker": "yarn jest --forceExit --testPathPattern 'src/broker/.*'",
        "test:group:admin": "yarn jest --forceExit --testPathPattern 'src/admin/.*'",
        "test:group:producer": "yarn jest --forceExit --testPathPattern 'src/producer/.*'",
        "test:group:consumer": "yarn jest --forceExit --testPathPattern 'src/consumer/.*.spec.js'",
        "test:group:others": "yarn jest --forceExit --testPathPattern 'src/(?!(broker|admin|producer|consumer)/).*'",
        "test:group:oauthbearer": "OAUTHBEARER_ENABLED=1 yarn jest --forceExit src/producer/index.spec.js src/broker/__tests__/connect.spec.js src/consumer/__tests__/connection.spec.js src/broker/__tests__/disconnect.spec.js src/admin/__tests__/connection.spec.js",
        "test:group:broker:ci": "JEST_JUNIT_OUTPUT_NAME=test-report.xml ./scripts/testWithKafka.sh \"yarn test:group:broker --ci --maxWorkers=4 --no-watchman\"",
        "test:group:admin:ci": "JEST_JUNIT_OUTPUT_NAME=test-report.xml ./scripts/testWithKafka.sh \"yarn test:group:admin --ci --maxWorkers=4 --no-watchman\"",
        "test:group:producer:ci": "JEST_JUNIT_OUTPUT_NAME=test-report.xml ./scripts/testWithKafka.sh \"yarn test:group:producer --ci --maxWorkers=4 --no-watchman\"",
        "test:group:consumer:ci": "JEST_JUNIT_OUTPUT_NAME=test-report.xml ./scripts/testWithKafka.sh \"yarn test:group:consumer --ci --maxWorkers=4 --no-watchman\"",
        "test:group:others:ci": "JEST_JUNIT_OUTPUT_NAME=test-report.xml ./scripts/testWithKafka.sh \"yarn test:group:others --ci --maxWorkers=4 --no-watchman\"",
        "test:group:oauthbearer:ci": "JEST_JUNIT_OUTPUT_NAME=test-report.xml COMPOSE_FILE='docker-compose.2_4_oauthbearer.yml' ./scripts/testWithKafka.sh \"yarn test:group:oauthbearer --ci --maxWorkers=4 --no-watchman\"",
        "test:types": "tsc -p types/"
    },
    "devDependencies": {
        "@types/node": "^12.0.8",
        "@typescript-eslint/typescript-estree": "^1.10.2",
        "eslint": "^6.8.0",
        "eslint-config-prettier": "^6.0.0",
        "eslint-config-standard": "^13.0.1",
        "eslint-plugin-import": "^2.18.2",
        "eslint-plugin-node": "^11.0.0",
        "eslint-plugin-prettier": "^3.1.0",
        "eslint-plugin-promise": "^4.2.1",
        "eslint-plugin-standard": "^4.0.0",
        "execa": "^2.0.3",
        "glob": "^7.1.4",
        "husky": "^3.0.1",
        "ip": "^1.1.5",
        "jest": "^25.1.0",
        "jest-circus": "^25.1.0",
        "jest-extended": "^0.11.2",
        "jest-junit": "^10.0.0",
        "jsonwebtoken": "^8.5.1",
        "lint-staged": "^9.2.0",
        "mockdate": "^2.0.5",
        "prettier": "^1.18.2",
        "semver": "^6.2.0",
        "typescript": "^3.8.3",
        "uuid": "^3.3.2"
    },
    "dependencies": {},
    "lint-staged": {
        "*.js": [
            "prettier --write",
            "git add"
        ]
    }
};
var exports$21 = {};
const pkgJson = _package;

class KafkaJSError extends Error {
    constructor(e32, {retriable = true} = {}) {
        super(e32);
        Error.captureStackTrace(this, this.constructor);
        this.message = e32.message || e32;
        this.name = "KafkaJSError";
        this.retriable = retriable;
        this.helpUrl = e32.helpUrl;
    }
}

class KafkaJSNonRetriableError extends KafkaJSError {
    constructor(e33) {
        super(e33, {
            retriable: false
        });
        this.name = "KafkaJSNonRetriableError";
    }
}

class KafkaJSProtocolError extends KafkaJSError {
    constructor(e34, {retriable: retriable1 = e34.retriable} = {}) {
        super(e34, {
            retriable: retriable1
        });
        this.type = e34.type;
        this.code = e34.code;
        this.name = "KafkaJSProtocolError";
    }
}

class KafkaJSOffsetOutOfRange extends KafkaJSProtocolError {
    constructor(e35, {topic: topic3, partition: partition2}) {
        super(e35);
        this.topic = topic3;
        this.partition = partition2;
        this.name = "KafkaJSOffsetOutOfRange";
    }
}

class KafkaJSMemberIdRequired extends KafkaJSProtocolError {
    constructor(e36, {memberId: memberId1}) {
        super(e36);
        this.memberId = memberId1;
        this.name = "KafkaJSMemberIdRequired";
    }
}

class KafkaJSNumberOfRetriesExceeded extends KafkaJSNonRetriableError {
    constructor(e37, {retryCount, retryTime}) {
        super(e37);
        this.stack = `${this.name}\n  Caused by: ${e37.stack}`;
        this.originalError = e37;
        this.retryCount = retryCount;
        this.retryTime = retryTime;
        this.name = "KafkaJSNumberOfRetriesExceeded";
    }
}

class KafkaJSConnectionError extends KafkaJSError {
    constructor(e38, {broker: broker3, code} = {}) {
        super(e38);
        this.broker = broker3;
        this.code = code;
        this.name = "KafkaJSConnectionError";
    }
}

class KafkaJSConnectionClosedError extends KafkaJSConnectionError {
    constructor(e39, {host: host1, port: port1} = {}) {
        super(e39, {
            broker: `${host1}:${port1}`
        });
        this.host = host1;
        this.port = port1;
        this.name = "KafkaJSConnectionClosedError";
    }
}

class KafkaJSRequestTimeoutError extends KafkaJSError {
    constructor(e40, {broker: broker1, correlationId: correlationId1, createdAt, sentAt, pendingDuration} = {}) {
        super(e40);
        this.broker = broker1;
        this.correlationId = correlationId1;
        this.createdAt = createdAt;
        this.sentAt = sentAt;
        this.pendingDuration = pendingDuration;
        this.name = "KafkaJSRequestTimeoutError";
    }
}

class KafkaJSMetadataNotLoaded extends KafkaJSError {
    constructor() {
        super(...arguments);
        this.name = "KafkaJSMetadataNotLoaded";
    }
}

class KafkaJSTopicMetadataNotLoaded extends KafkaJSMetadataNotLoaded {
    constructor(e41, {topic: topic1} = {}) {
        super(e41);
        this.topic = topic1;
        this.name = "KafkaJSTopicMetadataNotLoaded";
    }
}

class KafkaJSStaleTopicMetadataAssignment extends KafkaJSError {
    constructor(e42, {topic: topic2, unknownPartitions} = {}) {
        super(e42);
        this.topic = topic2;
        this.unknownPartitions = unknownPartitions;
        this.name = "KafkaJSStaleTopicMetadataAssignment";
    }
}

class KafkaJSDeleteGroupsError extends KafkaJSError {
    constructor(e43, groups = []) {
        super(e43);
        this.groups = groups;
        this.name = "KafkaJSDeleteGroupsError";
    }
}

class KafkaJSServerDoesNotSupportApiKey extends KafkaJSNonRetriableError {
    constructor(e44, {apiKey, apiName} = {}) {
        super(e44);
        this.apiKey = apiKey;
        this.apiName = apiName;
        this.name = "KafkaJSServerDoesNotSupportApiKey";
    }
}

class KafkaJSBrokerNotFound extends KafkaJSError {
    constructor() {
        super(...arguments);
        this.name = "KafkaJSBrokerNotFound";
    }
}

class KafkaJSPartialMessageError extends KafkaJSNonRetriableError {
    constructor() {
        super(...arguments);
        this.name = "KafkaJSPartialMessageError";
    }
}

class KafkaJSSASLAuthenticationError extends KafkaJSNonRetriableError {
    constructor() {
        super(...arguments);
        this.name = "KafkaJSSASLAuthenticationError";
    }
}

class KafkaJSGroupCoordinatorNotFound extends KafkaJSNonRetriableError {
    constructor() {
        super(...arguments);
        this.name = "KafkaJSGroupCoordinatorNotFound";
    }
}

class KafkaJSNotImplemented extends KafkaJSNonRetriableError {
    constructor() {
        super(...arguments);
        this.name = "KafkaJSNotImplemented";
    }
}

class KafkaJSTimeout extends KafkaJSNonRetriableError {
    constructor() {
        super(...arguments);
        this.name = "KafkaJSTimeout";
    }
}

class KafkaJSLockTimeout extends KafkaJSTimeout {
    constructor() {
        super(...arguments);
        this.name = "KafkaJSLockTimeout";
    }
}

class KafkaJSUnsupportedMagicByteInMessageSet extends KafkaJSNonRetriableError {
    constructor() {
        super(...arguments);
        this.name = "KafkaJSUnsupportedMagicByteInMessageSet";
    }
}

class KafkaJSDeleteTopicRecordsError extends KafkaJSError {
    constructor({partitions: partitions1}) {
        const retriable2 = partitions1.filter(({error}) => error != null
        ).every(({error}) => error.retriable === true
        );
        super("Error while deleting records", {
            retriable: retriable2
        });
        this.name = "KafkaJSDeleteTopicRecordsError";
        this.partitions = partitions1;
    }
}

const issueUrl = pkgJson.bugs.url;

class KafkaJSInvariantViolation extends KafkaJSNonRetriableError {
    constructor(e45) {
        const message = e45.message || e45;
        super(`Invariant violated: ${message}. This is likely a bug and should be reported.`);
        this.name = "KafkaJSInvariantViolation";
        const issueTitle = encodeURIComponent(`Invariant violation: ${message}`);
        this.helpUrl = `${issueUrl}/new?assignees=&labels=bug&template=bug_report.md&title=${issueTitle}`;
    }
}

exports$21 = {
    KafkaJSError,
    KafkaJSNonRetriableError,
    KafkaJSPartialMessageError,
    KafkaJSBrokerNotFound,
    KafkaJSProtocolError,
    KafkaJSConnectionError,
    KafkaJSConnectionClosedError,
    KafkaJSRequestTimeoutError,
    KafkaJSSASLAuthenticationError,
    KafkaJSNumberOfRetriesExceeded,
    KafkaJSOffsetOutOfRange,
    KafkaJSMemberIdRequired,
    KafkaJSGroupCoordinatorNotFound,
    KafkaJSNotImplemented,
    KafkaJSMetadataNotLoaded,
    KafkaJSTopicMetadataNotLoaded,
    KafkaJSStaleTopicMetadataAssignment,
    KafkaJSDeleteGroupsError,
    KafkaJSTimeout,
    KafkaJSLockTimeout,
    KafkaJSServerDoesNotSupportApiKey,
    KafkaJSUnsupportedMagicByteInMessageSet,
    KafkaJSDeleteTopicRecordsError,
    KafkaJSInvariantViolation
};
var _errors = exports$21;
var exports$31 = {};
const EventEmitter = y1;
const InstrumentationEvent$1 = _event;
const {KafkaJSError: KafkaJSError$1} = _errors;
exports$31 = class InstrumentationEventEmitter {
    constructor() {
        this.emitter = new EventEmitter();
    }

    emit(eventName, payload) {
        if (!eventName) {
            throw new KafkaJSError$1("Invalid event name", {
                retriable: false
            });
        }
        if (this.emitter.listenerCount(eventName) > 0) {
            const event = new InstrumentationEvent$1(eventName, payload);
            this.emitter.emit(eventName, event);
        }
    }

    addListener(eventName, listener) {
        this.emitter.addListener(eventName, listener);
        return () => this.emitter.removeListener(eventName, listener)
                ;
    }
};
var _emitter = exports$31;
var exports$4 = {};
const {LEVELS: logLevel2} = _loggers;
exports$4 = () => ({namespace, level, label, log}) => {
    const prefix = namespace ? `[${namespace}] ` : "";
    const message1 = JSON.stringify(Object.assign({
        level: label
    }, log, {
        message: `${prefix}${log.message}`
    }));
    switch (level) {
        case logLevel2.INFO:
            return console.info(message1);
        case logLevel2.ERROR:
            return console.error(message1);
        case logLevel2.WARN:
            return console.warn(message1);
        case logLevel2.DEBUG:
            return console.log(message1);
    }
}
;
var _console = exports$4;
var exports$5 = {};
const {format} = X;
const {KafkaJSLockTimeout: KafkaJSLockTimeout$1} = _errors;
const PRIVATE = {
    LOCKED: Symbol("private:Lock:locked"),
    TIMEOUT: Symbol("private:Lock:timeout"),
    WAITING: Symbol("private:Lock:waiting"),
    TIMEOUT_ERROR_MESSAGE: Symbol("private:Lock:timeoutErrorMessage")
};
const TIMEOUT_MESSAGE = "Timeout while acquiring lock (%d waiting locks)";
exports$5 = class Lock {
    constructor({timeout: timeout1, description = null} = {}) {
        if (typeof timeout1 !== "number") {
            throw new TypeError(`'timeout' is not a number, received '${typeof timeout1}'`);
        }
        this[PRIVATE.LOCKED] = false;
        this[PRIVATE.TIMEOUT] = timeout1;
        this[PRIVATE.WAITING] = new Set();
        this[PRIVATE.TIMEOUT_ERROR_MESSAGE] = () => {
            const timeoutMessage = format(TIMEOUT_MESSAGE, this[PRIVATE.WAITING].size);
            return description ? `${timeoutMessage}: "${description}"` : timeoutMessage;
        };
    }

    async acquire() {
        return new Promise((resolve, reject) => {
            if (!this[PRIVATE.LOCKED]) {
                this[PRIVATE.LOCKED] = true;
                return resolve();
            }
            let timeoutId = null;
            const tryToAcquire = async () => {
                if (!this[PRIVATE.LOCKED]) {
                    this[PRIVATE.LOCKED] = true;
                    clearTimeout(timeoutId);
                    this[PRIVATE.WAITING].delete(tryToAcquire);
                    return resolve();
                }
            };
            this[PRIVATE.WAITING].add(tryToAcquire);
            timeoutId = setTimeout(() => {
                const error = new KafkaJSLockTimeout$1(this[PRIVATE.TIMEOUT_ERROR_MESSAGE]());
                this[PRIVATE.WAITING].delete(tryToAcquire);
                reject(error);
            }, this[PRIVATE.TIMEOUT]);
        });
    }

    async release() {
        this[PRIVATE.LOCKED] = false;
        const waitingLock = this[PRIVATE.WAITING].values().next().value;
        if (waitingLock) {
            return waitingLock();
        }
    }
};
var _lock = exports$5;
var exports$6 = {};
const {promisify} = X;
const gzip = promisify(Z$11.gzip);
const unzip = promisify(Z$11.unzip);
exports$6 = {
    async compress(encoder) {
        return await gzip(encoder.buffer);
    },
    async decompress(buffer) {
        return await unzip(buffer);
    }
};
var _gzip = exports$6;
var exports$7 = {};
const {KafkaJSNotImplemented: KafkaJSNotImplemented$1} = _errors;
const COMPRESSION_CODEC_MASK = 7;
const Types = {
    None: 0,
    GZIP: 1,
    Snappy: 2,
    LZ4: 3,
    ZSTD: 4
};
const Codecs = {
    [Types.GZIP]: () => _gzip
    ,
    [Types.Snappy]: () => {
        throw new KafkaJSNotImplemented$1("Snappy compression not implemented");
    },
    [Types.LZ4]: () => {
        throw new KafkaJSNotImplemented$1("LZ4 compression not implemented");
    },
    [Types.ZSTD]: () => {
        throw new KafkaJSNotImplemented$1("ZSTD compression not implemented");
    }
};
const lookupCodec = (type1) => Codecs[type1] ? Codecs[type1]() : null
;
const lookupCodecByAttributes = (attributes) => {
    const codec = Codecs[attributes & 7];
    return codec ? codec() : null;
};
exports$7 = {
    Types,
    Codecs,
    lookupCodec,
    lookupCodecByAttributes,
    COMPRESSION_CODEC_MASK
};
var _compression = exports$7;
var exports$8 = {};
exports$8 = {
    Produce: 0,
    Fetch: 1,
    ListOffsets: 2,
    Metadata: 3,
    LeaderAndIsr: 4,
    StopReplica: 5,
    UpdateMetadata: 6,
    ControlledShutdown: 7,
    OffsetCommit: 8,
    OffsetFetch: 9,
    GroupCoordinator: 10,
    JoinGroup: 11,
    Heartbeat: 12,
    LeaveGroup: 13,
    SyncGroup: 14,
    DescribeGroups: 15,
    ListGroups: 16,
    SaslHandshake: 17,
    ApiVersions: 18,
    CreateTopics: 19,
    DeleteTopics: 20,
    DeleteRecords: 21,
    InitProducerId: 22,
    OffsetForLeaderEpoch: 23,
    AddPartitionsToTxn: 24,
    AddOffsetsToTxn: 25,
    EndTxn: 26,
    WriteTxnMarkers: 27,
    TxnOffsetCommit: 28,
    DescribeAcls: 29,
    CreateAcls: 30,
    DeleteAcls: 31,
    DescribeConfigs: 32,
    AlterConfigs: 33,
    AlterReplicaLogDirs: 34,
    DescribeLogDirs: 35,
    SaslAuthenticate: 36,
    CreatePartitions: 37,
    CreateDelegationToken: 38,
    RenewDelegationToken: 39,
    ExpireDelegationToken: 40,
    DescribeDelegationToken: 41,
    DeleteGroups: 42,
    ElectPreferredLeaders: 43
};
var _apiKeys = exports$8;
var exports$9 = {};
var CRC_TABLE = new Int32Array([
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
]);
exports$9 = (encoder) => {
    const {buffer: buffer2} = encoder;
    const l43 = buffer2.length;
    let crc = -1;
    for (let n50 = 0; n50 < l43; n50++) {
        crc = CRC_TABLE[(crc ^ buffer2[n50]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
};
var _crc = exports$9;
var exports$a = {};
const Encoder1 = _encoder;
const crc32 = _crc;
const {Types: Compression, COMPRESSION_CODEC_MASK: COMPRESSION_CODEC_MASK$1} = _compression;
exports$a = ({compression = Compression.None, key, value: value2}) => {
    const content = new Encoder1().writeInt8(0).writeInt8(compression & COMPRESSION_CODEC_MASK$1).writeBytes(key).writeBytes(value2);
    const crc = crc32(content);
    return new Encoder1().writeInt32(crc).writeEncoder(content);
};
var _v = exports$a;
var exports$b = {};
const Encoder$1 = _encoder;
const crc32$1 = _crc;
const {Types: Compression$1, COMPRESSION_CODEC_MASK: COMPRESSION_CODEC_MASK$2} = _compression;
exports$b = ({compression = Compression$1.None, timestamp = Date.now(), key, value: value2}) => {
    const content = new Encoder$1().writeInt8(1).writeInt8(compression & COMPRESSION_CODEC_MASK$2).writeInt64(timestamp).writeBytes(key).writeBytes(value2);
    const crc = crc32$1(content);
    return new Encoder$1().writeInt32(crc).writeEncoder(content);
};
var _v2 = exports$b;
var exports$c = {};
const versions = {
    0: _v,
    1: _v2
};
exports$c = ({version = 0}) => versions[version]
;
var _message = exports$c;
var exports$d = {};
const Encoder$2 = _encoder;
const MessageProtocol = _message;
const {Types: Types$1} = _compression;
exports$d = ({messageVersion = 0, compression, entries}) => {
    const isCompressed = compression !== Types$1.None;
    const Message = MessageProtocol({
        version: messageVersion
    });
    const encoder = new Encoder$2();
    entries.forEach((entry, i53) => {
        const message1 = Message(entry);
        encoder.writeInt64(isCompressed ? i53 : -1);
        encoder.writeInt32(message1.size());
        encoder.writeEncoder(message1);
    });
    return encoder;
};
var _messageSet = exports$d;
var exports$e = {};
const Encoder$3 = _encoder;
const {Produce: apiKey1} = _apiKeys;
const MessageSet = _messageSet;
exports$e = ({acks, timeout: timeout1, topicData}) => ({
    apiKey: apiKey1,
    apiVersion: 0,
    apiName: "Produce",
    expectResponse: () => acks !== 0
    ,
    encode: async () => {
        return new Encoder$3().writeInt16(acks).writeInt32(timeout1).writeArray(topicData.map(encodeTopic));
    }
})
;
const encodeTopic = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartitions));
};
const encodePartitions = ({partition: partition1, messages}) => {
    const messageSet = MessageSet({
        messageVersion: 0,
        entries: messages
    });
    return new _encoder().writeInt32(partition1).writeInt32(messageSet.size()).writeEncoder(messageSet);
};
var _request = exports$e;
var exports$f = {};
const BASE_URL = "https://kafka.js.org";
exports$f = (path, hash) => `${BASE_URL}/${path}${hash ? "#" + hash : ""}`
;
var _websiteUrl = exports$f;
var exports$g = {};
const {KafkaJSProtocolError: KafkaJSProtocolError$1} = _errors;
const websiteUrl = _websiteUrl;
const errorCodes = [
    {
        type: "UNKNOWN",
        code: -1,
        retriable: false,
        message: "The server experienced an unexpected error when processing the request"
    },
    {
        type: "OFFSET_OUT_OF_RANGE",
        code: 1,
        retriable: false,
        message: "The requested offset is not within the range of offsets maintained by the server"
    },
    {
        type: "CORRUPT_MESSAGE",
        code: 2,
        retriable: true,
        message: "This message has failed its CRC checksum, exceeds the valid size, or is otherwise corrupt"
    },
    {
        type: "UNKNOWN_TOPIC_OR_PARTITION",
        code: 3,
        retriable: true,
        message: "This server does not host this topic-partition"
    },
    {
        type: "INVALID_FETCH_SIZE",
        code: 4,
        retriable: false,
        message: "The requested fetch size is invalid"
    },
    {
        type: "LEADER_NOT_AVAILABLE",
        code: 5,
        retriable: true,
        message: "There is no leader for this topic-partition as we are in the middle of a leadership election"
    },
    {
        type: "NOT_LEADER_FOR_PARTITION",
        code: 6,
        retriable: true,
        message: "This server is not the leader for that topic-partition"
    },
    {
        type: "REQUEST_TIMED_OUT",
        code: 7,
        retriable: true,
        message: "The request timed out"
    },
    {
        type: "BROKER_NOT_AVAILABLE",
        code: 8,
        retriable: false,
        message: "The broker is not available"
    },
    {
        type: "REPLICA_NOT_AVAILABLE",
        code: 9,
        retriable: false,
        message: "The replica is not available for the requested topic-partition"
    },
    {
        type: "MESSAGE_TOO_LARGE",
        code: 10,
        retriable: false,
        message: "The request included a message larger than the max message size the server will accept"
    },
    {
        type: "STALE_CONTROLLER_EPOCH",
        code: 11,
        retriable: false,
        message: "The controller moved to another broker"
    },
    {
        type: "OFFSET_METADATA_TOO_LARGE",
        code: 12,
        retriable: false,
        message: "The metadata field of the offset request was too large"
    },
    {
        type: "NETWORK_EXCEPTION",
        code: 13,
        retriable: true,
        message: "The server disconnected before a response was received"
    },
    {
        type: "GROUP_LOAD_IN_PROGRESS",
        code: 14,
        retriable: true,
        message: "The coordinator is loading and hence can't process requests for this group"
    },
    {
        type: "GROUP_COORDINATOR_NOT_AVAILABLE",
        code: 15,
        retriable: true,
        message: "The group coordinator is not available"
    },
    {
        type: "NOT_COORDINATOR_FOR_GROUP",
        code: 16,
        retriable: true,
        message: "This is not the correct coordinator for this group"
    },
    {
        type: "INVALID_TOPIC_EXCEPTION",
        code: 17,
        retriable: false,
        message: "The request attempted to perform an operation on an invalid topic"
    },
    {
        type: "RECORD_LIST_TOO_LARGE",
        code: 18,
        retriable: false,
        message: "The request included message batch larger than the configured segment size on the server"
    },
    {
        type: "NOT_ENOUGH_REPLICAS",
        code: 19,
        retriable: true,
        message: "Messages are rejected since there are fewer in-sync replicas than required"
    },
    {
        type: "NOT_ENOUGH_REPLICAS_AFTER_APPEND",
        code: 20,
        retriable: true,
        message: "Messages are written to the log, but to fewer in-sync replicas than required"
    },
    {
        type: "INVALID_REQUIRED_ACKS",
        code: 21,
        retriable: false,
        message: "Produce request specified an invalid value for required acks"
    },
    {
        type: "ILLEGAL_GENERATION",
        code: 22,
        retriable: false,
        message: "Specified group generation id is not valid"
    },
    {
        type: "INCONSISTENT_GROUP_PROTOCOL",
        code: 23,
        retriable: false,
        message: "The group member's supported protocols are incompatible with those of existing members"
    },
    {
        type: "INVALID_GROUP_ID",
        code: 24,
        retriable: false,
        message: "The configured groupId is invalid"
    },
    {
        type: "UNKNOWN_MEMBER_ID",
        code: 25,
        retriable: false,
        message: "The coordinator is not aware of this member"
    },
    {
        type: "INVALID_SESSION_TIMEOUT",
        code: 26,
        retriable: false,
        message: "The session timeout is not within the range allowed by the broker (as configured by group.min.session.timeout.ms and group.max.session.timeout.ms)"
    },
    {
        type: "REBALANCE_IN_PROGRESS",
        code: 27,
        retriable: false,
        message: "The group is rebalancing, so a rejoin is needed",
        helpUrl: websiteUrl("docs/faq", "what-does-it-mean-to-get-rebalance-in-progress-errors")
    },
    {
        type: "INVALID_COMMIT_OFFSET_SIZE",
        code: 28,
        retriable: false,
        message: "The committing offset data size is not valid"
    },
    {
        type: "TOPIC_AUTHORIZATION_FAILED",
        code: 29,
        retriable: false,
        message: "Not authorized to access topics: [Topic authorization failed]"
    },
    {
        type: "GROUP_AUTHORIZATION_FAILED",
        code: 30,
        retriable: false,
        message: "Not authorized to access group: Group authorization failed"
    },
    {
        type: "CLUSTER_AUTHORIZATION_FAILED",
        code: 31,
        retriable: false,
        message: "Cluster authorization failed"
    },
    {
        type: "INVALID_TIMESTAMP",
        code: 32,
        retriable: false,
        message: "The timestamp of the message is out of acceptable range"
    },
    {
        type: "UNSUPPORTED_SASL_MECHANISM",
        code: 33,
        retriable: false,
        message: "The broker does not support the requested SASL mechanism"
    },
    {
        type: "ILLEGAL_SASL_STATE",
        code: 34,
        retriable: false,
        message: "Request is not valid given the current SASL state"
    },
    {
        type: "UNSUPPORTED_VERSION",
        code: 35,
        retriable: false,
        message: "The version of API is not supported"
    },
    {
        type: "TOPIC_ALREADY_EXISTS",
        code: 36,
        retriable: false,
        message: "Topic with this name already exists"
    },
    {
        type: "INVALID_PARTITIONS",
        code: 37,
        retriable: false,
        message: "Number of partitions is invalid"
    },
    {
        type: "INVALID_REPLICATION_FACTOR",
        code: 38,
        retriable: false,
        message: "Replication-factor is invalid"
    },
    {
        type: "INVALID_REPLICA_ASSIGNMENT",
        code: 39,
        retriable: false,
        message: "Replica assignment is invalid"
    },
    {
        type: "INVALID_CONFIG",
        code: 40,
        retriable: false,
        message: "Configuration is invalid"
    },
    {
        type: "NOT_CONTROLLER",
        code: 41,
        retriable: true,
        message: "This is not the correct controller for this cluster"
    },
    {
        type: "INVALID_REQUEST",
        code: 42,
        retriable: false,
        message: "This most likely occurs because of a request being malformed by the client library or the message was sen't to an incompatible broker. See the broker logs for more details"
    },
    {
        type: "UNSUPPORTED_FOR_MESSAGE_FORMAT",
        code: 43,
        retriable: false,
        message: "The message format version on the broker does not support the request"
    },
    {
        type: "POLICY_VIOLATION",
        code: 44,
        retriable: false,
        message: "Request parameters do not satisfy the configured policy"
    },
    {
        type: "OUT_OF_ORDER_SEQUENCE_NUMBER",
        code: 45,
        retriable: false,
        message: "The broker received an out of order sequence number"
    },
    {
        type: "DUPLICATE_SEQUENCE_NUMBER",
        code: 46,
        retriable: false,
        message: "The broker received a duplicate sequence number"
    },
    {
        type: "INVALID_PRODUCER_EPOCH",
        code: 47,
        retriable: false,
        message: "Producer attempted an operation with an old epoch. Either there is a newer producer with the same transactionalId, or the producer's transaction has been expired by the broker"
    },
    {
        type: "INVALID_TXN_STATE",
        code: 48,
        retriable: false,
        message: "The producer attempted a transactional operation in an invalid state"
    },
    {
        type: "INVALID_PRODUCER_ID_MAPPING",
        code: 49,
        retriable: false,
        message: "The producer attempted to use a producer id which is not currently assigned to its transactional id"
    },
    {
        type: "INVALID_TRANSACTION_TIMEOUT",
        code: 50,
        retriable: false,
        message: "The transaction timeout is larger than the maximum value allowed by the broker (as configured by max.transaction.timeout.ms)"
    },
    {
        type: "CONCURRENT_TRANSACTIONS",
        code: 51,
        retriable: true,
        message: "The producer attempted to update a transaction while another concurrent operation on the same transaction was ongoing"
    },
    {
        type: "TRANSACTION_COORDINATOR_FENCED",
        code: 52,
        retriable: false,
        message: "Indicates that the transaction coordinator sending a WriteTxnMarker is no longer the current coordinator for a given producer"
    },
    {
        type: "TRANSACTIONAL_ID_AUTHORIZATION_FAILED",
        code: 53,
        retriable: false,
        message: "Transactional Id authorization failed"
    },
    {
        type: "SECURITY_DISABLED",
        code: 54,
        retriable: false,
        message: "Security features are disabled"
    },
    {
        type: "OPERATION_NOT_ATTEMPTED",
        code: 55,
        retriable: false,
        message: "The broker did not attempt to execute this operation. This may happen for batched RPCs where some operations in the batch failed, causing the broker to respond without trying the rest"
    },
    {
        type: "KAFKA_STORAGE_ERROR",
        code: 56,
        retriable: true,
        message: "Disk error when trying to access log file on the disk"
    },
    {
        type: "LOG_DIR_NOT_FOUND",
        code: 57,
        retriable: false,
        message: "The user-specified log directory is not found in the broker config"
    },
    {
        type: "SASL_AUTHENTICATION_FAILED",
        code: 58,
        retriable: false,
        message: "SASL Authentication failed",
        helpUrl: websiteUrl("docs/configuration", "sasl")
    },
    {
        type: "UNKNOWN_PRODUCER_ID",
        code: 59,
        retriable: false,
        message: "This exception is raised by the broker if it could not locate the producer metadata associated with the producerId in question. This could happen if, for instance, the producer's records were deleted because their retention time had elapsed. Once the last records of the producerId are removed, the producer's metadata is removed from the broker, and future appends by the producer will return this exception"
    },
    {
        type: "REASSIGNMENT_IN_PROGRESS",
        code: 60,
        retriable: false,
        message: "A partition reassignment is in progress"
    },
    {
        type: "DELEGATION_TOKEN_AUTH_DISABLED",
        code: 61,
        retriable: false,
        message: "Delegation Token feature is not enabled"
    },
    {
        type: "DELEGATION_TOKEN_NOT_FOUND",
        code: 62,
        retriable: false,
        message: "Delegation Token is not found on server"
    },
    {
        type: "DELEGATION_TOKEN_OWNER_MISMATCH",
        code: 63,
        retriable: false,
        message: "Specified Principal is not valid Owner/Renewer"
    },
    {
        type: "DELEGATION_TOKEN_REQUEST_NOT_ALLOWED",
        code: 64,
        retriable: false,
        message: "Delegation Token requests are not allowed on PLAINTEXT/1-way SSL channels and on delegation token authenticated channels"
    },
    {
        type: "DELEGATION_TOKEN_AUTHORIZATION_FAILED",
        code: 65,
        retriable: false,
        message: "Delegation Token authorization failed"
    },
    {
        type: "DELEGATION_TOKEN_EXPIRED",
        code: 66,
        retriable: false,
        message: "Delegation Token is expired"
    },
    {
        type: "INVALID_PRINCIPAL_TYPE",
        code: 67,
        retriable: false,
        message: "Supplied principalType is not supported"
    },
    {
        type: "NON_EMPTY_GROUP",
        code: 68,
        retriable: false,
        message: "The group is not empty"
    },
    {
        type: "GROUP_ID_NOT_FOUND",
        code: 69,
        retriable: false,
        message: "The group id was not found"
    },
    {
        type: "FETCH_SESSION_ID_NOT_FOUND",
        code: 70,
        retriable: true,
        message: "The fetch session ID was not found"
    },
    {
        type: "INVALID_FETCH_SESSION_EPOCH",
        code: 71,
        retriable: true,
        message: "The fetch session epoch is invalid"
    },
    {
        type: "LISTENER_NOT_FOUND",
        code: 72,
        retriable: true,
        message: "There is no listener on the leader broker that matches the listener on which metadata request was processed"
    },
    {
        type: "TOPIC_DELETION_DISABLED",
        code: 73,
        retriable: false,
        message: "Topic deletion is disabled"
    },
    {
        type: "FENCED_LEADER_EPOCH",
        code: 74,
        retriable: true,
        message: "The leader epoch in the request is older than the epoch on the broker"
    },
    {
        type: "UNKNOWN_LEADER_EPOCH",
        code: 75,
        retriable: true,
        message: "The leader epoch in the request is newer than the epoch on the broker"
    },
    {
        type: "UNSUPPORTED_COMPRESSION_TYPE",
        code: 76,
        retriable: false,
        message: "The requesting client does not support the compression type of given partition"
    },
    {
        type: "STALE_BROKER_EPOCH",
        code: 77,
        retriable: false,
        message: "Broker epoch has changed"
    },
    {
        type: "OFFSET_NOT_AVAILABLE",
        code: 78,
        retriable: true,
        message: "The leader high watermark has not caught up from a recent leader election so the offsets cannot be guaranteed to be monotonically increasing"
    },
    {
        type: "MEMBER_ID_REQUIRED",
        code: 79,
        retriable: false,
        message: "The group member needs to have a valid member id before actually entering a consumer group"
    },
    {
        type: "PREFERRED_LEADER_NOT_AVAILABLE",
        code: 80,
        retriable: true,
        message: "The preferred leader was not available"
    },
    {
        type: "GROUP_MAX_SIZE_REACHED",
        code: 81,
        retriable: false,
        message: "The consumer group has reached its max size. It already has the configured maximum number of members"
    },
    {
        type: "FENCED_INSTANCE_ID",
        code: 82,
        retriable: false,
        message: "The broker rejected this static consumer since another consumer with the same group instance id has registered with a different member id"
    },
    {
        type: "ELIGIBLE_LEADERS_NOT_AVAILABLE",
        code: 83,
        retriable: true,
        message: "Eligible topic partition leaders are not available"
    },
    {
        type: "ELECTION_NOT_NEEDED",
        code: 84,
        retriable: true,
        message: "Leader election not needed for topic partition"
    },
    {
        type: "NO_REASSIGNMENT_IN_PROGRESS",
        code: 85,
        retriable: false,
        message: "No partition reassignment is in progress"
    },
    {
        type: "GROUP_SUBSCRIBED_TO_TOPIC",
        code: 86,
        retriable: false,
        message: "Deleting offsets of a topic is forbidden while the consumer group is actively subscribed to it"
    },
    {
        type: "INVALID_RECORD",
        code: 87,
        retriable: false,
        message: "This record has failed the validation on broker and hence be rejected"
    },
    {
        type: "UNSTABLE_OFFSET_COMMIT",
        code: 88,
        retriable: true,
        message: "There are unstable offsets that need to be cleared"
    }
];
const unknownErrorCode = (errorCode) => ({
            type: "KAFKAJS_UNKNOWN_ERROR_CODE",
            code: -99,
            retriable: false,
            message: `Unknown error code ${errorCode}`
        })
;
const failure = (code1) => code1 !== 0
;
const createErrorFromCode = (code1) => {
    return new KafkaJSProtocolError$1(errorCodes.find((e46) => e46.code === code1
    ) || unknownErrorCode(code1));
};
const failIfVersionNotSupported = (code1) => {
    if (code1 === 35) {
        throw createErrorFromCode(35);
    }
};
const staleMetadata = (e46) => [
            "UNKNOWN_TOPIC_OR_PARTITION",
            "LEADER_NOT_AVAILABLE",
            "NOT_LEADER_FOR_PARTITION"
        ].includes(e46.type)
;
exports$g = {
    failure,
    errorCodes,
    createErrorFromCode,
    failIfVersionNotSupported,
    staleMetadata
};
var _error = exports$g;
var exports$h = {};

function flatten(arrays) {
    return [].concat.apply([], arrays);
}

exports$h = flatten;
var _flatten = exports$h;
var exports$i = {};
const {failure: failure$1, createErrorFromCode: createErrorFromCode$1} = _error;
const flatten$1 = _flatten;
const partition1 = (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            offset: decoder.readInt64().toString()
        })
;
const decode = async (rawData) => {
    const decoder = new _decoder(rawData);
    const topics = decoder.readArray((decoder1) => ({
                topicName: decoder1.readString(),
                partitions: decoder1.readArray(partition1)
            })
    );
    return {
        topics
    };
};
const parse = async (data) => {
    const partitionsWithError = data.topics.map((topic3) => {
        return topic3.partitions.filter((partition2) => failure$1(partition2.errorCode)
        );
    });
    const errors = flatten$1(partitionsWithError);
    if (errors.length > 0) {
        const {errorCode} = errors[0];
        throw createErrorFromCode$1(errorCode);
    }
    return data;
};
exports$i = {
    decode,
    parse
};
var _response = exports$i;
var exports$j = {};
const requestV0 = _request;
exports$j = ({acks, timeout: timeout1, topicData}) => {
    return Object.assign(requestV0({
        acks,
        timeout: timeout1,
        topicData
    }), {
        apiVersion: 1
    });
};
var _request2 = exports$j;
var exports$k = {};
const {parse: parseV0} = _response;
const partition$1 = (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            offset: decoder.readInt64().toString()
        })
;
const decode$1 = async (rawData) => {
    const decoder = new _decoder(rawData);
    const topics = decoder.readArray((decoder1) => ({
                topicName: decoder1.readString(),
                partitions: decoder1.readArray(partition$1)
            })
    );
    const throttleTime = decoder.readInt32();
    return {
        topics,
        throttleTime
    };
};
exports$k = {
    decode: decode$1,
    parse: parseV0
};
var _response2 = exports$k;
var exports$l = {};
const Encoder$4 = _encoder;
const {Produce: apiKey$1} = _apiKeys;
const MessageSet$1 = _messageSet;
const {Types: Types$2, lookupCodec: lookupCodec$1} = _compression;
exports$l = ({acks, timeout: timeout1, compression = Types$2.None, topicData}) => ({
    apiKey: apiKey$1,
    apiVersion: 2,
    apiName: "Produce",
    expectResponse: () => acks !== 0
    ,
    encode: async () => {
        const encodeTopic1 = topicEncoder(compression);
        const encodedTopicData = [];
        for (const data of topicData) {
            encodedTopicData.push(await encodeTopic1(data));
        }
        return new Encoder$4().writeInt16(acks).writeInt32(timeout1).writeArray(encodedTopicData);
    }
})
;
const topicEncoder = (compression) => {
    const encodePartitions1 = partitionsEncoder(compression);
    return async ({topic: topic3, partitions: partitions1}) => {
        const encodedPartitions = [];
        for (const data of partitions1) {
            encodedPartitions.push(await encodePartitions1(data));
        }
        return new _encoder().writeString(topic3).writeArray(encodedPartitions);
    };
};
const partitionsEncoder = (compression) => async ({partition: partition2, messages}) => {
            const messageSet = MessageSet$1({
                messageVersion: 1,
                compression,
                entries: messages
            });
            if (compression === Types$2.None) {
                return new _encoder().writeInt32(partition2).writeInt32(messageSet.size()).writeEncoder(messageSet);
            }
            const timestamp = messages[0].timestamp || Date.now();
            const codec = lookupCodec$1(compression);
            const compressedValue = await codec.compress(messageSet);
            const compressedMessageSet = MessageSet$1({
                messageVersion: 1,
                entries: [
                    {
                        compression,
                        timestamp,
                        value: compressedValue
                    }
                ]
            });
            return new _encoder().writeInt32(partition2).writeInt32(compressedMessageSet.size()).writeEncoder(compressedMessageSet);
        }
;
var _request3 = exports$l;
var exports$m = {};
const {parse: parseV0$1} = _response;
const partition$2 = (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            offset: decoder.readInt64().toString(),
            timestamp: decoder.readInt64().toString()
        })
;
const decode$2 = async (rawData) => {
    const decoder = new _decoder(rawData);
    const topics = decoder.readArray((decoder1) => ({
                topicName: decoder1.readString(),
                partitions: decoder1.readArray(partition$2)
            })
    );
    const throttleTime = decoder.readInt32();
    return {
        topics,
        throttleTime
    };
};
exports$m = {
    decode: decode$2,
    parse: parseV0$1
};
var _response3 = exports$m;
var exports$n = {};
const Encoder$5 = _encoder;
exports$n = ({key, value: value2}) => {
    return new Encoder$5().writeVarIntString(key).writeVarIntBytes(value2);
};
var _v$1 = exports$n;
var exports$o = {};
var Buffer1 = e$1.Buffer;
const Encoder$6 = _encoder;
const Header = _v$1;
exports$o = ({
    offsetDelta = 0, timestampDelta = 0, key, value: value2, headers = {}
}) => {
    const headersArray = Object.keys(headers).map((headerKey) => ({
                key: headerKey,
                value: headers[headerKey]
            })
    );
    const sizeOfBody = 1 + Encoder$6.sizeOfVarLong(timestampDelta) + Encoder$6.sizeOfVarInt(offsetDelta) + Encoder$6.sizeOfVarIntBytes(key) + Encoder$6.sizeOfVarIntBytes(value2) + sizeOfHeaders(headersArray);
    return new Encoder$6().writeVarInt(sizeOfBody).writeInt8(0).writeVarLong(timestampDelta).writeVarInt(offsetDelta).writeVarIntBytes(key).writeVarIntBytes(value2).writeVarIntArray(headersArray.map(Header));
};
const sizeOfHeaders = (headersArray) => {
    let size = _encoder.sizeOfVarInt(headersArray.length);
    for (const header of headersArray) {
        const keySize = Buffer1.byteLength(header.key);
        const valueSize = Buffer1.byteLength(header.value);
        size += Encoder$6.sizeOfVarInt(keySize) + keySize;
        if (header.value === null) {
            size += Encoder$6.sizeOfVarInt(-1);
        } else {
            size += Encoder$6.sizeOfVarInt(valueSize) + valueSize;
        }
    }
    return size;
};
var _v$2 = exports$o;
var exports$p = {};
const crc32C = (buffer2) => {
    let crc = 0 ^ -1;
    for (let i53 = 0; i53 < buffer2.length; i53++) {
        crc = T11[(crc ^ buffer2[i53]) & 255] ^ crc >>> 8;
    }
    return (crc ^ -1) >>> 0;
};
exports$p = crc32C;
var T11 = new Int32Array([
    0,
    4067132163,
    3778769143,
    324072436,
    3348797215,
    904991772,
    648144872,
    3570033899,
    2329499855,
    2024987596,
    1809983544,
    2575936315,
    1296289744,
    3207089363,
    2893594407,
    1578318884,
    274646895,
    3795141740,
    4049975192,
    51262619,
    3619967088,
    632279923,
    922689671,
    3298075524,
    2592579488,
    1760304291,
    2075979607,
    2312596564,
    1562183871,
    2943781820,
    3156637768,
    1313733451,
    549293790,
    3537243613,
    3246849577,
    871202090,
    3878099393,
    357341890,
    102525238,
    4101499445,
    2858735121,
    1477399826,
    1264559846,
    3107202533,
    1845379342,
    2677391885,
    2361733625,
    2125378298,
    820201905,
    3263744690,
    3520608582,
    598981189,
    4151959214,
    85089709,
    373468761,
    3827903834,
    3124367742,
    1213305469,
    1526817161,
    2842354314,
    2107672161,
    2412447074,
    2627466902,
    1861252501,
    1098587580,
    3004210879,
    2688576843,
    1378610760,
    2262928035,
    1955203488,
    1742404180,
    2511436119,
    3416409459,
    969524848,
    714683780,
    3639785095,
    205050476,
    4266873199,
    3976438427,
    526918040,
    1361435347,
    2739821008,
    2954799652,
    1114974503,
    2529119692,
    1691668175,
    2005155131,
    2247081528,
    3690758684,
    697762079,
    986182379,
    3366744552,
    476452099,
    3993867776,
    4250756596,
    255256311,
    1640403810,
    2477592673,
    2164122517,
    1922457750,
    2791048317,
    1412925310,
    1197962378,
    3037525897,
    3944729517,
    427051182,
    170179418,
    4165941337,
    746937522,
    3740196785,
    3451792453,
    1070968646,
    1905808397,
    2213795598,
    2426610938,
    1657317369,
    3053634322,
    1147748369,
    1463399397,
    2773627110,
    4215344322,
    153784257,
    444234805,
    3893493558,
    1021025245,
    3467647198,
    3722505002,
    797665321,
    2197175160,
    1889384571,
    1674398607,
    2443626636,
    1164749927,
    3070701412,
    2757221520,
    1446797203,
    137323447,
    4198817972,
    3910406976,
    461344835,
    3484808360,
    1037989803,
    781091935,
    3705997148,
    2460548119,
    1623424788,
    1939049696,
    2180517859,
    1429367560,
    2807687179,
    3020495871,
    1180866812,
    410100952,
    3927582683,
    4182430767,
    186734380,
    3756733383,
    763408580,
    1053836080,
    3434856499,
    2722870694,
    1344288421,
    1131464017,
    2971354706,
    1708204729,
    2545590714,
    2229949006,
    1988219213,
    680717673,
    3673779818,
    3383336350,
    1002577565,
    4010310262,
    493091189,
    238226049,
    4233660802,
    2987750089,
    1082061258,
    1395524158,
    2705686845,
    1972364758,
    2279892693,
    2494862625,
    1725896226,
    952904198,
    3399985413,
    3656866545,
    731699698,
    4283874585,
    222117402,
    510512622,
    3959836397,
    3280807620,
    837199303,
    582374963,
    3504198960,
    68661723,
    4135334616,
    3844915500,
    390545967,
    1230274059,
    3141532936,
    2825850620,
    1510247935,
    2395924756,
    2091215383,
    1878366691,
    2644384480,
    3553878443,
    565732008,
    854102364,
    3229815391,
    340358836,
    3861050807,
    4117890627,
    119113024,
    1493875044,
    2875275879,
    3090270611,
    1247431312,
    2660249211,
    1828433272,
    2141937292,
    2378227087,
    3811616794,
    291187481,
    34330861,
    4032846830,
    615137029,
    3603020806,
    3314634738,
    939183345,
    1776939221,
    2609017814,
    2295496738,
    2058945313,
    2926798794,
    1545135305,
    1330124605,
    3173225534,
    4084100981,
    17165430,
    307568514,
    3762199681,
    888469610,
    3332340585,
    3587147933,
    665062302,
    2042050490,
    2346497209,
    2559330125,
    1793573966,
    3190661285,
    1279665062,
    1595330642,
    2910671697
]);
var _crc32C = exports$p;
var exports$q = {};
const crc32C$1 = _crc32C;
const unsigned = (value2) => Uint32Array.from([
            value2
        ])[0]
;
exports$q = (buffer2) => unsigned(crc32C$1(buffer2))
;
var _crc32C$1 = exports$q;
var exports$r = {};
const crc32C$2 = _crc32C$1;
const {
    Types: Compression$2,
    lookupCodec: lookupCodec$2,
    COMPRESSION_CODEC_MASK: COMPRESSION_CODEC_MASK$3
} = _compression;
const MAGIC_BYTE = 2;
const RecordBatch = async ({
    compression = Compression$2.None,
    firstOffset = _long.fromInt(0),
    firstTimestamp = Date.now(),
    maxTimestamp = Date.now(),
    partitionLeaderEpoch = 0,
    lastOffsetDelta = 0,
    transactional = false,
    producerId = _long.fromValue(-1),
    producerEpoch = 0,
    firstSequence = 0,
    records = []
}) => {
    const COMPRESSION_CODEC = compression & COMPRESSION_CODEC_MASK$3;
    const IN_TRANSACTION = transactional ? 16 : 0;
    const attributes = COMPRESSION_CODEC | 0 | IN_TRANSACTION;
    const batchBody = new _encoder().writeInt16(attributes).writeInt32(lastOffsetDelta).writeInt64(firstTimestamp).writeInt64(maxTimestamp).writeInt64(producerId).writeInt16(producerEpoch).writeInt32(firstSequence);
    if (compression === Compression$2.None) {
        if (records.every((v21) => typeof v21 === typeof records[0]
        )) {
            batchBody.writeArray(records, typeof records[0]);
        } else {
            batchBody.writeArray(records);
        }
    } else {
        const compressedRecords = await compressRecords(compression, records);
        batchBody.writeInt32(records.length).writeBuffer(compressedRecords);
    }
    const batch = new _encoder().writeInt32(partitionLeaderEpoch).writeInt8(2).writeUInt32(crc32C$2(batchBody.buffer)).writeEncoder(batchBody);
    return new _encoder().writeInt64(firstOffset).writeBytes(batch.buffer);
};
const compressRecords = async (compression, records) => {
    const codec = lookupCodec$2(compression);
    const recordsEncoder = new _encoder();
    recordsEncoder.writeEncoderArray(records);
    return codec.compress(recordsEncoder);
};
exports$r = {
    RecordBatch,
    MAGIC_BYTE
};
var _v$3 = exports$r;
var exports$s = {};
const Long$11 = _long;
const Encoder$8 = _encoder;
const {Produce: apiKey$2} = _apiKeys;
const {Types: Types$3} = _compression;
const Record = _v$2;
const {RecordBatch: RecordBatch$1} = _v$3;
exports$s = ({
    acks,
    timeout: timeout1,
    transactionalId = null,
    producerId = Long$11.fromInt(-1),
    producerEpoch = 0,
    compression = Types$3.None,
    topicData
}) => ({
    apiKey: apiKey$2,
    apiVersion: 3,
    apiName: "Produce",
    expectResponse: () => acks !== 0
    ,
    encode: async () => {
        const encodeTopic1 = topicEncoder$1(compression);
        const encodedTopicData = [];
        for (const data of topicData) {
            encodedTopicData.push(await encodeTopic1({
                ...data,
                transactionalId,
                producerId,
                producerEpoch
            }));
        }
        return new Encoder$8().writeString(transactionalId).writeInt16(acks).writeInt32(timeout1).writeArray(encodedTopicData);
    }
})
;
const topicEncoder$1 = (compression) => async ({
            topic: topic3,
            partitions: partitions1,
            transactionalId,
            producerId,
            producerEpoch
        }) => {
            const encodePartitions1 = partitionsEncoder$1(compression);
            const encodedPartitions = [];
            for (const data of partitions1) {
                encodedPartitions.push(await encodePartitions1({
                    ...data,
                    transactionalId,
                    producerId,
                    producerEpoch
                }));
            }
            return new _encoder().writeString(topic3).writeArray(encodedPartitions);
        }
;
const partitionsEncoder$1 = (compression) => async ({
            partition: partition2,
            messages,
            transactionalId,
            firstSequence,
            producerId,
            producerEpoch
        }) => {
            const dateNow = Date.now();
            const messageTimestamps = messages.map((m19) => m19.timestamp
            ).filter((timestamp) => timestamp != null
            ).sort();
            const timestamps = messageTimestamps.length === 0 ? [
                dateNow
            ] : messageTimestamps;
            const firstTimestamp = timestamps[0];
            const maxTimestamp = timestamps[timestamps.length - 1];
            const records = messages.map((message1, i53) => Record({
                        ...message1,
                        offsetDelta: i53,
                        timestampDelta: (message1.timestamp || dateNow) - firstTimestamp
                    })
            );
            const recordBatch = await RecordBatch$1({
                compression,
                records,
                firstTimestamp,
                maxTimestamp,
                producerId,
                producerEpoch,
                firstSequence,
                transactional: !!transactionalId,
                lastOffsetDelta: records.length - 1
            });
            return new _encoder().writeInt32(partition2).writeInt32(recordBatch.size()).writeEncoder(recordBatch);
        }
;
var _request4 = exports$s;
var exports$t = {};
const {failure: failure$2, createErrorFromCode: createErrorFromCode$2} = _error;
const flatten$2 = _flatten;
const partition$3 = (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            baseOffset: decoder.readInt64().toString(),
            logAppendTime: decoder.readInt64().toString()
        })
;
const decode$3 = async (rawData) => {
    const decoder = new _decoder(rawData);
    const topics = decoder.readArray((decoder1) => ({
                topicName: decoder1.readString(),
                partitions: decoder1.readArray(partition$3)
            })
    );
    const throttleTime = decoder.readInt32();
    return {
        topics,
        throttleTime
    };
};
const parse$1 = async (data) => {
    const partitionsWithError = data.topics.map((response) => {
        return response.partitions.filter((partition2) => failure$2(partition2.errorCode)
        );
    });
    const errors = flatten$2(partitionsWithError);
    if (errors.length > 0) {
        const {errorCode} = errors[0];
        throw createErrorFromCode$2(errorCode);
    }
    return data;
};
exports$t = {
    decode: decode$3,
    parse: parse$1
};
var _response4 = exports$t;
var exports$u = {};
const requestV3 = _request4;
exports$u = ({
    acks,
    timeout: timeout1,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
}) => Object.assign(requestV3({
    acks,
    timeout: timeout1,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
}), {
    apiVersion: 4
})
;
var _request5 = exports$u;
var exports$v = {};
const {decode: decode$4, parse: parse$2} = _response4;
exports$v = {
    decode: decode$4,
    parse: parse$2
};
var _response5 = exports$v;
var exports$w = {};
const requestV3$1 = _request4;
exports$w = ({
    acks,
    timeout: timeout1,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
}) => Object.assign(requestV3$1({
    acks,
    timeout: timeout1,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
}), {
    apiVersion: 5
})
;
var _request6 = exports$w;
var exports$x = {};
const {parse: parseV3} = _response4;
const partition$4 = (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            baseOffset: decoder.readInt64().toString(),
            logAppendTime: decoder.readInt64().toString(),
            logStartOffset: decoder.readInt64().toString()
        })
;
const decode$5 = async (rawData) => {
    const decoder = new _decoder(rawData);
    const topics = decoder.readArray((decoder1) => ({
                topicName: decoder1.readString(),
                partitions: decoder1.readArray(partition$4)
            })
    );
    const throttleTime = decoder.readInt32();
    return {
        topics,
        throttleTime
    };
};
exports$x = {
    decode: decode$5,
    parse: parseV3
};
var _response6 = exports$x;
var exports$y = {};
const requestV5 = _request6;
exports$y = ({
    acks,
    timeout: timeout1,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
}) => Object.assign(requestV5({
    acks,
    timeout: timeout1,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
}), {
    apiVersion: 6
})
;
var _request7 = exports$y;
var exports$z = {};
const {parse: parse$3, decode: decodeV5} = _response6;
const decode$6 = async (rawData) => {
    const decoded = await decodeV5(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$z = {
    decode: decode$6,
    parse: parse$3
};
var _response7 = exports$z;
var exports$A = {};
const requestV6 = _request7;
exports$A = ({
    acks,
    timeout: timeout1,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
}) => Object.assign(requestV6({
    acks,
    timeout: timeout1,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
}), {
    apiVersion: 7
})
;
var _request8 = exports$A;
var exports$B = {};
const {decode: decode$7, parse: parse$4} = _response7;
exports$B = {
    decode: decode$7,
    parse: parse$4
};
var _response8 = exports$B;
var exports$C = {};
const versions$1 = {
    0: ({acks, timeout: timeout1, topicData}) => {
        const request = _request;
        const response = _response;
        return {
            request: request({
                acks,
                timeout: timeout1,
                topicData
            }),
            response
        };
    },
    1: ({acks, timeout: timeout1, topicData}) => {
        const request = _request2;
        const response = _response2;
        return {
            request: request({
                acks,
                timeout: timeout1,
                topicData
            }),
            response
        };
    },
    2: ({acks, timeout: timeout1, topicData, compression}) => {
        const request = _request3;
        const response = _response3;
        return {
            request: request({
                acks,
                timeout: timeout1,
                compression,
                topicData
            }),
            response
        };
    },
    3: ({acks, timeout: timeout1, compression, topicData, transactionalId, producerId, producerEpoch}) => {
        const request = _request4;
        const response = _response4;
        return {
            request: request({
                acks,
                timeout: timeout1,
                compression,
                topicData,
                transactionalId,
                producerId,
                producerEpoch
            }),
            response
        };
    },
    4: ({acks, timeout: timeout1, compression, topicData, transactionalId, producerId, producerEpoch}) => {
        const request = _request5;
        const response = _response5;
        return {
            request: request({
                acks,
                timeout: timeout1,
                compression,
                topicData,
                transactionalId,
                producerId,
                producerEpoch
            }),
            response
        };
    },
    5: ({acks, timeout: timeout1, compression, topicData, transactionalId, producerId, producerEpoch}) => {
        const request = _request6;
        const response = _response6;
        return {
            request: request({
                acks,
                timeout: timeout1,
                compression,
                topicData,
                transactionalId,
                producerId,
                producerEpoch
            }),
            response
        };
    },
    6: ({acks, timeout: timeout1, compression, topicData, transactionalId, producerId, producerEpoch}) => {
        const request = _request7;
        const response = _response7;
        return {
            request: request({
                acks,
                timeout: timeout1,
                compression,
                topicData,
                transactionalId,
                producerId,
                producerEpoch
            }),
            response
        };
    },
    7: ({acks, timeout: timeout1, compression, topicData, transactionalId, producerId, producerEpoch}) => {
        const request = _request8;
        const response = _response8;
        return {
            request: request({
                acks,
                timeout: timeout1,
                compression,
                topicData,
                transactionalId,
                producerId,
                producerEpoch
            }),
            response
        };
    }
};
exports$C = {
    versions: Object.keys(versions$1),
    protocol: ({version}) => versions$1[version]
};
var _produce = exports$C;
var exports$D = {};
exports$D = {
    READ_UNCOMMITTED: 0,
    READ_COMMITTED: 1
};
var _isolationLevel = exports$D;
var exports$E = {};
const Encoder$9 = _encoder;
const {Fetch: apiKey$3} = _apiKeys;
exports$E = ({replicaId, maxWaitTime, minBytes, topics}) => ({
    apiKey: apiKey$3,
    apiVersion: 0,
    apiName: "Fetch",
    encode: async () => {
        return new Encoder$9().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeArray(topics.map(encodeTopic$1));
    }
})
;
const encodeTopic$1 = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition));
};
const encodePartition = ({partition: partition2, fetchOffset, maxBytes}) => {
    return new _encoder().writeInt32(partition2).writeInt64(fetchOffset).writeInt32(maxBytes);
};
var _request$1 = exports$E;
var exports$F = {};
exports$F = (decoder) => ({
    attributes: decoder.readInt8(),
    key: decoder.readBytes(),
    value: decoder.readBytes()
})
;
var _decoder1 = exports$F;
var exports$G = {};
exports$G = (decoder) => ({
    attributes: decoder.readInt8(),
    timestamp: decoder.readInt64().toString(),
    key: decoder.readBytes(),
    value: decoder.readBytes()
})
;
var _decoder2 = exports$G;
var exports$H = {};
var Buffer$11 = e$1.Buffer;
const {
    KafkaJSPartialMessageError: KafkaJSPartialMessageError$1,
    KafkaJSUnsupportedMagicByteInMessageSet: KafkaJSUnsupportedMagicByteInMessageSet$1
} = _errors;
const V0Decoder = _decoder1;
const V1Decoder = _decoder2;
const decodeMessage = (decoder, magicByte) => {
    switch (magicByte) {
        case 0:
            return V0Decoder(decoder);
        case 1:
            return V1Decoder(decoder);
        default:
            throw new KafkaJSUnsupportedMagicByteInMessageSet$1(`Unsupported MessageSet message version, magic byte: ${magicByte}`);
    }
};
exports$H = (offset, size, decoder) => {
    const remainingBytes = Buffer$11.byteLength(decoder.slice(size).buffer);
    if (remainingBytes < size) {
        throw new KafkaJSPartialMessageError$1(`Tried to decode a partial message: remainingBytes(${remainingBytes}) < messageSize(${size})`);
    }
    const crc = decoder.readInt32();
    const magicByte = decoder.readInt8();
    const message1 = decodeMessage(decoder, magicByte);
    return Object.assign({
        offset,
        size,
        crc,
        magicByte
    }, message1);
};
var _decoder2$1 = exports$H;
var exports$I = {};
const Long$21 = _long;
const Decoder$5 = _decoder;
const MessageDecoder = _decoder2$1;
const {lookupCodecByAttributes: lookupCodecByAttributes$1} = _compression;
const {KafkaJSPartialMessageError: KafkaJSPartialMessageError$2} = _errors;
exports$I = async (primaryDecoder, size = null) => {
    const messages = [];
    const messageSetSize = size || primaryDecoder.readInt32();
    const messageSetDecoder = primaryDecoder.slice(messageSetSize);
    while (messageSetDecoder.offset < messageSetSize) {
        try {
            const message1 = EntryDecoder(messageSetDecoder);
            const codec = lookupCodecByAttributes$1(message1.attributes);
            if (codec) {
                const buffer2 = await codec.decompress(message1.value);
                messages.push(...EntriesDecoder(new Decoder$5(buffer2), message1));
            } else {
                messages.push(message1);
            }
        } catch (e46) {
            if (e46.name === "KafkaJSPartialMessageError") {
                break;
            }
            if (e46.name === "KafkaJSUnsupportedMagicByteInMessageSet") {
                break;
            }
            throw e46;
        }
    }
    primaryDecoder.forward(messageSetSize);
    return messages;
};
const EntriesDecoder = (decoder, compressedMessage) => {
    const messages = [];
    while (decoder.offset < decoder.buffer.length) {
        messages.push(EntryDecoder(decoder));
    }
    if (compressedMessage.magicByte > 0 && compressedMessage.offset >= 0) {
        const compressedOffset = _long.fromValue(compressedMessage.offset);
        const lastMessageOffset = _long.fromValue(messages[messages.length - 1].offset);
        const baseOffset = compressedOffset - lastMessageOffset;
        for (const message1 of messages) {
            message1.offset = Long$21.fromValue(message1.offset).add(baseOffset).toString();
        }
    }
    return messages;
};
const EntryDecoder = (decoder) => {
    if (!decoder.canReadInt64()) {
        throw new KafkaJSPartialMessageError$2(`Tried to decode a partial message: There isn't enough bytes to read the offset`);
    }
    const offset = decoder.readInt64().toString();
    if (!decoder.canReadInt32()) {
        throw new KafkaJSPartialMessageError$2(`Tried to decode a partial message: There isn't enough bytes to read the message size`);
    }
    const size = decoder.readInt32();
    return MessageDecoder(offset, size, decoder);
};
var _decoder2$2 = exports$I;
var exports$J = {};
const {KafkaJSOffsetOutOfRange: KafkaJSOffsetOutOfRange$1} = _errors;
const {failure: failure$3, createErrorFromCode: createErrorFromCode$3, errorCodes: errorCodes$1} = _error;
const flatten$3 = _flatten;
const MessageSetDecoder = _decoder2$2;
const decodePartition = async (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            highWatermark: decoder.readInt64().toString(),
            messages: await MessageSetDecoder(decoder)
        })
;
const decodeResponse = async (decoder) => ({
            topicName: decoder.readString(),
            partitions: await decoder.readArrayAsync(decodePartition)
        })
;
const decode$8 = async (rawData) => {
    const decoder = new _decoder(rawData);
    const responses = await decoder.readArrayAsync(decodeResponse);
    return {
        responses
    };
};
const {code: OFFSET_OUT_OF_RANGE_ERROR_CODE} = errorCodes$1.find((e46) => e46.type === "OFFSET_OUT_OF_RANGE"
);
const parse$5 = async (data) => {
    const partitionsWithError = data.responses.map(({topicName, partitions: partitions1}) => {
        return partitions1.filter((partition2) => failure$3(partition2.errorCode)
        ).map((partition2) => Object.assign({}, partition2, {
                    topic: topicName
                })
        );
    });
    const errors = flatten$3(partitionsWithError);
    if (errors.length > 0) {
        const {errorCode, topic: topic3, partition: partition2} = errors[0];
        if (errorCode === OFFSET_OUT_OF_RANGE_ERROR_CODE) {
            throw new KafkaJSOffsetOutOfRange$1(createErrorFromCode$3(errorCode), {
                topic: topic3,
                partition: partition2
            });
        }
        throw createErrorFromCode$3(errorCode);
    }
    return data;
};
exports$J = {
    decode: decode$8,
    parse: parse$5
};
var _response$1 = exports$J;
var exports$K = {};
const requestV0$1 = _request$1;
exports$K = ({replicaId, maxWaitTime, minBytes, topics}) => {
    return Object.assign(requestV0$1({
        replicaId,
        maxWaitTime,
        minBytes,
        topics
    }), {
        apiVersion: 1
    });
};
var _request2$1 = exports$K;
var exports$L = {};
const {parse: parseV0$2} = _response$1;
const MessageSetDecoder$1 = _decoder2$2;
const decodePartition$1 = async (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            highWatermark: decoder.readInt64().toString(),
            messages: await MessageSetDecoder$1(decoder)
        })
;
const decodeResponse$1 = async (decoder) => ({
            topicName: decoder.readString(),
            partitions: await decoder.readArrayAsync(decodePartition$1)
        })
;
const decode$9 = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const responses = await decoder.readArrayAsync(decodeResponse$1);
    return {
        throttleTime,
        responses
    };
};
exports$L = {
    decode: decode$9,
    parse: parseV0$2
};
var _response2$1 = exports$L;
var exports$M = {};
const requestV0$2 = _request$1;
exports$M = ({replicaId, maxWaitTime, minBytes, topics}) => {
    return Object.assign(requestV0$2({
        replicaId,
        maxWaitTime,
        minBytes,
        topics
    }), {
        apiVersion: 2
    });
};
var _request3$1 = exports$M;
var exports$N = {};
const {decode: decode$a, parse: parse$6} = _response2$1;
exports$N = {
    decode: decode$a,
    parse: parse$6
};
var _response3$1 = exports$N;
var exports$O = {};
const Encoder$a = _encoder;
const {Fetch: apiKey$4} = _apiKeys;
exports$O = ({replicaId, maxWaitTime, minBytes, maxBytes, topics}) => ({
    apiKey: apiKey$4,
    apiVersion: 3,
    apiName: "Fetch",
    encode: async () => {
        return new Encoder$a().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeInt32(maxBytes).writeArray(topics.map(encodeTopic$2));
    }
})
;
const encodeTopic$2 = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$1));
};
const encodePartition$1 = ({partition: partition2, fetchOffset, maxBytes}) => {
    return new _encoder().writeInt32(partition2).writeInt64(fetchOffset).writeInt32(maxBytes);
};
var _request4$1 = exports$O;
var exports$P = {};
const {decode: decode$b, parse: parse$7} = _response2$1;
exports$P = {
    decode: decode$b,
    parse: parse$7
};
var _response4$1 = exports$P;
var exports$Q = {};
const Encoder$b = _encoder;
const {Fetch: apiKey$5} = _apiKeys;
const ISOLATION_LEVEL = _isolationLevel;
exports$Q = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL.READ_COMMITTED
}) => ({
    apiKey: apiKey$5,
    apiVersion: 4,
    apiName: "Fetch",
    encode: async () => {
        return new Encoder$b().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeInt32(maxBytes).writeInt8(isolationLevel).writeArray(topics.map(encodeTopic$3));
    }
})
;
const encodeTopic$3 = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$2));
};
const encodePartition$2 = ({partition: partition2, fetchOffset, maxBytes}) => {
    return new _encoder().writeInt32(partition2).writeInt64(fetchOffset).writeInt32(maxBytes);
};
var _request5$1 = exports$Q;
var exports$R = {};
exports$R = (decoder) => ({
    key: decoder.readVarIntString(),
    value: decoder.readVarIntBytes()
})
;
var _decoder$1 = exports$R;
var exports$S = {};
exports$S = {
    NO_TIMESTAMP: -1,
    CREATE_TIME: 0,
    LOG_APPEND_TIME: 1
};
var _timestampTypes = exports$S;
var exports$T = {};
const Long$3 = _long;
const HeaderDecoder = _decoder$1;
const TimestampTypes = _timestampTypes;
exports$T = (decoder, batchContext = {}) => {
    const {firstOffset, firstTimestamp, magicByte, isControlBatch = false, timestampType, maxTimestamp} = batchContext;
    const attributes = decoder.readInt8();
    const timestampDelta = decoder.readVarLong();
    const timestamp = timestampType === TimestampTypes.LOG_APPEND_TIME && maxTimestamp ? maxTimestamp : Long$3.fromValue(firstTimestamp).add(timestampDelta).toString();
    const offsetDelta = decoder.readVarInt();
    const offset = Long$3.fromValue(firstOffset).add(offsetDelta).toString();
    const key = decoder.readVarIntBytes();
    const value2 = decoder.readVarIntBytes();
    const headers = decoder.readVarIntArray(HeaderDecoder).reduce((obj, {key: key1, value: value3}) => ({
                ...obj,
                [key1]: value3
            })
            , {});
    return {
        magicByte,
        attributes,
        timestamp,
        offset,
        key,
        value: value2,
        headers,
        isControlRecord: isControlBatch,
        batchContext
    };
};
var _decoder2$3 = exports$T;
var exports$U = {};
var Buffer$21 = e$1.Buffer;
const {KafkaJSPartialMessageError: KafkaJSPartialMessageError$3} = _errors;
const {lookupCodecByAttributes: lookupCodecByAttributes$2} = _compression;
const RecordDecoder = _decoder2$3;
const TimestampTypes$1 = _timestampTypes;
const TIMESTAMP_TYPE_FLAG_MASK = 8;
const TRANSACTIONAL_FLAG_MASK = 16;
const CONTROL_FLAG_MASK = 32;
exports$U = async (fetchDecoder) => {
    const firstOffset = fetchDecoder.readInt64().toString();
    const length = fetchDecoder.readInt32();
    const decoder = fetchDecoder.slice(length);
    fetchDecoder.forward(length);
    const remainingBytes = Buffer$21.byteLength(decoder.buffer);
    if (remainingBytes < length) {
        throw new KafkaJSPartialMessageError$3(`Tried to decode a partial record batch: remainingBytes(${remainingBytes}) < recordBatchLength(${length})`);
    }
    const partitionLeaderEpoch = decoder.readInt32();
    const magicByte = decoder.readInt8();
    const crc = decoder.readInt32();
    const attributes = decoder.readInt16();
    const lastOffsetDelta = decoder.readInt32();
    const firstTimestamp = decoder.readInt64().toString();
    const maxTimestamp = decoder.readInt64().toString();
    const producerId = decoder.readInt64().toString();
    const producerEpoch = decoder.readInt16();
    const firstSequence = decoder.readInt32();
    const inTransaction = (attributes & TRANSACTIONAL_FLAG_MASK) > 0;
    const isControlBatch = (attributes & CONTROL_FLAG_MASK) > 0;
    const timestampType = (attributes & TIMESTAMP_TYPE_FLAG_MASK) > 0 ? TimestampTypes$1.LOG_APPEND_TIME : TimestampTypes$1.CREATE_TIME;
    const codec = lookupCodecByAttributes$2(attributes);
    const recordContext = {
        firstOffset,
        firstTimestamp,
        partitionLeaderEpoch,
        inTransaction,
        isControlBatch,
        lastOffsetDelta,
        producerId,
        producerEpoch,
        firstSequence,
        maxTimestamp,
        timestampType
    };
    const records = await decodeRecords(codec, decoder, {
        ...recordContext,
        magicByte
    });
    return {
        ...recordContext,
        records
    };
};
const decodeRecords = async (codec, recordsDecoder, recordContext) => {
    if (!codec) {
        return recordsDecoder.readArray((decoder) => decodeRecord(decoder, recordContext)
        );
    }
    const length = recordsDecoder.readInt32();
    if (length <= 0) {
        return [];
    }
    const compressedRecordsBuffer = recordsDecoder.readAll();
    const decompressedRecordBuffer = await codec.decompress(compressedRecordsBuffer);
    const decompressedRecordDecoder = new _decoder(decompressedRecordBuffer);
    const records = new Array(length);
    for (let i53 = 0; i53 < length; i53++) {
        records[i53] = decodeRecord(decompressedRecordDecoder, recordContext);
    }
    return records;
};
const decodeRecord = (decoder, recordContext) => {
    const recordBuffer = decoder.readVarIntBytes();
    return RecordDecoder(new _decoder(recordBuffer), recordContext);
};
var _decoder3 = exports$U;
var exports$V = {};
const MessageSetDecoder$2 = _decoder2$2;
const RecordBatchDecoder = _decoder3;
const {MAGIC_BYTE: MAGIC_BYTE$1} = _v$3;
const decodeMessages = async (decoder) => {
    const messagesSize = decoder.readInt32();
    if (messagesSize <= 0 || !decoder.canReadBytes(messagesSize)) {
        return [];
    }
    const messagesBuffer = decoder.readBytes(messagesSize);
    const messagesDecoder = new _decoder(messagesBuffer);
    const magicByte = messagesBuffer.slice(16).readInt8(0);
    if (magicByte === MAGIC_BYTE$1) {
        let records = [];
        while (messagesDecoder.canReadBytes(49)) {
            try {
                const recordBatch = await RecordBatchDecoder(messagesDecoder);
                records = [
                    ...records,
                    ...recordBatch.records
                ];
            } catch (e46) {
                if (e46.name === "KafkaJSPartialMessageError") {
                    break;
                }
                throw e46;
            }
        }
        return records;
    }
    return MessageSetDecoder$2(messagesDecoder, messagesSize);
};
exports$V = decodeMessages;
var _decodeMessages = exports$V;
var exports$W = {};
const {parse: parseV1} = _response2$1;
const decodeMessages$1 = _decodeMessages;
const decodeAbortedTransactions = (decoder) => ({
            producerId: decoder.readInt64().toString(),
            firstOffset: decoder.readInt64().toString()
        })
;
const decodePartition$2 = async (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            highWatermark: decoder.readInt64().toString(),
            lastStableOffset: decoder.readInt64().toString(),
            abortedTransactions: decoder.readArray(decodeAbortedTransactions),
            messages: await decodeMessages$1(decoder)
        })
;
const decodeResponse$2 = async (decoder) => ({
            topicName: decoder.readString(),
            partitions: await decoder.readArrayAsync(decodePartition$2)
        })
;
const decode$c = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const responses = await decoder.readArrayAsync(decodeResponse$2);
    return {
        throttleTime,
        responses
    };
};
exports$W = {
    decode: decode$c,
    parse: parseV1
};
var _response5$1 = exports$W;
var exports$X = {};
const Encoder$c = _encoder;
const {Fetch: apiKey$6} = _apiKeys;
const ISOLATION_LEVEL$1 = _isolationLevel;
exports$X = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL$1.READ_COMMITTED
}) => ({
    apiKey: apiKey$6,
    apiVersion: 5,
    apiName: "Fetch",
    encode: async () => {
        return new Encoder$c().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeInt32(maxBytes).writeInt8(isolationLevel).writeArray(topics.map(encodeTopic$4));
    }
})
;
const encodeTopic$4 = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$3));
};
const encodePartition$3 = ({partition: partition2, fetchOffset, logStartOffset = -1, maxBytes}) => {
    return new _encoder().writeInt32(partition2).writeInt64(fetchOffset).writeInt64(logStartOffset).writeInt32(maxBytes);
};
var _request6$1 = exports$X;
var exports$Y = {};
const {parse: parseV1$1} = _response2$1;
const decodeMessages$2 = _decodeMessages;
const decodeAbortedTransactions$1 = (decoder) => ({
            producerId: decoder.readInt64().toString(),
            firstOffset: decoder.readInt64().toString()
        })
;
const decodePartition$3 = async (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            highWatermark: decoder.readInt64().toString(),
            lastStableOffset: decoder.readInt64().toString(),
            lastStartOffset: decoder.readInt64().toString(),
            abortedTransactions: decoder.readArray(decodeAbortedTransactions$1),
            messages: await decodeMessages$2(decoder)
        })
;
const decodeResponse$3 = async (decoder) => ({
            topicName: decoder.readString(),
            partitions: await decoder.readArrayAsync(decodePartition$3)
        })
;
const decode$d = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const responses = await decoder.readArrayAsync(decodeResponse$3);
    return {
        throttleTime,
        responses
    };
};
exports$Y = {
    decode: decode$d,
    parse: parseV1$1
};
var _response6$1 = exports$Y;
var exports$Z = {};
const ISOLATION_LEVEL$2 = _isolationLevel;
const requestV5$1 = _request6$1;
exports$Z = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL$2.READ_COMMITTED
}) => Object.assign(requestV5$1({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel
}), {
    apiVersion: 6
})
;
var _request7$1 = exports$Z;
var exports$_ = {};
const {decode: decode$e, parse: parse$8} = _response6$1;
exports$_ = {
    decode: decode$e,
    parse: parse$8
};
var _response7$1 = exports$_;
var exports$$ = {};
const Encoder$d = _encoder;
const {Fetch: apiKey$7} = _apiKeys;
const ISOLATION_LEVEL$3 = _isolationLevel;
exports$$ = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL$3.READ_COMMITTED,
    sessionId = 0,
    sessionEpoch = -1,
    forgottenTopics = []
}) => ({
    apiKey: apiKey$7,
    apiVersion: 7,
    apiName: "Fetch",
    encode: async () => {
        return new Encoder$d().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeInt32(maxBytes).writeInt8(isolationLevel).writeInt32(sessionId).writeInt32(sessionEpoch).writeArray(topics.map(encodeTopic$5)).writeArray(forgottenTopics.map(encodeForgottenTopics));
    }
})
;
const encodeForgottenTopics = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1);
};
const encodeTopic$5 = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$4));
};
const encodePartition$4 = ({partition: partition2, fetchOffset, logStartOffset = -1, maxBytes}) => {
    return new _encoder().writeInt32(partition2).writeInt64(fetchOffset).writeInt64(logStartOffset).writeInt32(maxBytes);
};
var _request8$1 = exports$$;
var exports$10 = {};
const {parse: parseV1$2} = _response2$1;
const decodeMessages$3 = _decodeMessages;
const decodeAbortedTransactions$2 = (decoder) => ({
            producerId: decoder.readInt64().toString(),
            firstOffset: decoder.readInt64().toString()
        })
;
const decodePartition$4 = async (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            highWatermark: decoder.readInt64().toString(),
            lastStableOffset: decoder.readInt64().toString(),
            lastStartOffset: decoder.readInt64().toString(),
            abortedTransactions: decoder.readArray(decodeAbortedTransactions$2),
            messages: await decodeMessages$3(decoder)
        })
;
const decodeResponse$4 = async (decoder) => ({
            topicName: decoder.readString(),
            partitions: await decoder.readArrayAsync(decodePartition$4)
        })
;
const decode$f = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const sessionId = decoder.readInt32();
    const responses = await decoder.readArrayAsync(decodeResponse$4);
    return {
        throttleTime,
        errorCode,
        sessionId,
        responses
    };
};
exports$10 = {
    decode: decode$f,
    parse: parseV1$2
};
var _response8$1 = exports$10;
var exports$111 = {};
const ISOLATION_LEVEL$4 = _isolationLevel;
const requestV7 = _request8$1;
exports$111 = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL$4.READ_COMMITTED,
    sessionId = 0,
    sessionEpoch = -1,
    forgottenTopics = []
}) => Object.assign(requestV7({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel,
    sessionId,
    sessionEpoch,
    forgottenTopics
}), {
    apiVersion: 8
})
;
var _request9 = exports$111;
var exports$12 = {};
const {parse: parseV1$3} = _response2$1;
const decodeMessages$4 = _decodeMessages;
const decodeAbortedTransactions$3 = (decoder) => ({
            producerId: decoder.readInt64().toString(),
            firstOffset: decoder.readInt64().toString()
        })
;
const decodePartition$5 = async (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            highWatermark: decoder.readInt64().toString(),
            lastStableOffset: decoder.readInt64().toString(),
            lastStartOffset: decoder.readInt64().toString(),
            abortedTransactions: decoder.readArray(decodeAbortedTransactions$3),
            messages: await decodeMessages$4(decoder)
        })
;
const decodeResponse$5 = async (decoder) => ({
            topicName: decoder.readString(),
            partitions: await decoder.readArrayAsync(decodePartition$5)
        })
;
const decode$g = async (rawData) => {
    const decoder = new _decoder(rawData);
    const clientSideThrottleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const sessionId = decoder.readInt32();
    const responses = await decoder.readArrayAsync(decodeResponse$5);
    return {
        throttleTime: 0,
        clientSideThrottleTime,
        errorCode,
        sessionId,
        responses
    };
};
exports$12 = {
    decode: decode$g,
    parse: parseV1$3
};
var _response9 = exports$12;
var exports$13 = {};
const Encoder$e = _encoder;
const {Fetch: apiKey$8} = _apiKeys;
const ISOLATION_LEVEL$5 = _isolationLevel;
exports$13 = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL$5.READ_COMMITTED,
    sessionId = 0,
    sessionEpoch = -1,
    forgottenTopics = []
}) => ({
    apiKey: apiKey$8,
    apiVersion: 9,
    apiName: "Fetch",
    encode: async () => {
        return new Encoder$e().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeInt32(maxBytes).writeInt8(isolationLevel).writeInt32(sessionId).writeInt32(sessionEpoch).writeArray(topics.map(encodeTopic$6)).writeArray(forgottenTopics.map(encodeForgottenTopics$1));
    }
})
;
const encodeForgottenTopics$1 = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1);
};
const encodeTopic$6 = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$5));
};
const encodePartition$5 = ({
    partition: partition2,
    currentLeaderEpoch = -1,
    fetchOffset,
    logStartOffset = -1,
    maxBytes
}) => {
    return new _encoder().writeInt32(partition2).writeInt32(currentLeaderEpoch).writeInt64(fetchOffset).writeInt64(logStartOffset).writeInt32(maxBytes);
};
var _request10 = exports$13;
var exports$14 = {};
const {decode: decode$h, parse: parse$9} = _response9;
exports$14 = {
    decode: decode$h,
    parse: parse$9
};
var _response10 = exports$14;
var exports$15 = {};
const ISOLATION_LEVEL$6 = _isolationLevel;
const requestV9 = _request10;
exports$15 = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL$6.READ_COMMITTED,
    sessionId = 0,
    sessionEpoch = -1,
    forgottenTopics = []
}) => Object.assign(requestV9({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel,
    sessionId,
    sessionEpoch,
    forgottenTopics
}), {
    apiVersion: 10
})
;
var _request11 = exports$15;
var exports$16 = {};
const {decode: decode$i, parse: parse$a} = _response10;
exports$16 = {
    decode: decode$i,
    parse: parse$a
};
var _response11 = exports$16;
var exports$17 = {};
const Encoder$f = _encoder;
const {Fetch: apiKey$9} = _apiKeys;
const ISOLATION_LEVEL$7 = _isolationLevel;
exports$17 = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    rackId = "",
    isolationLevel = ISOLATION_LEVEL$7.READ_COMMITTED,
    sessionId = 0,
    sessionEpoch = -1,
    forgottenTopics = []
}) => ({
    apiKey: apiKey$9,
    apiVersion: 11,
    apiName: "Fetch",
    encode: async () => {
        return new Encoder$f().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeInt32(maxBytes).writeInt8(isolationLevel).writeInt32(sessionId).writeInt32(sessionEpoch).writeArray(topics.map(encodeTopic$7)).writeArray(forgottenTopics.map(encodeForgottenTopics$2)).writeString(rackId);
    }
})
;
const encodeForgottenTopics$2 = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1);
};
const encodeTopic$7 = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$6));
};
const encodePartition$6 = ({
    partition: partition2,
    currentLeaderEpoch = -1,
    fetchOffset,
    logStartOffset = -1,
    maxBytes
}) => {
    return new _encoder().writeInt32(partition2).writeInt32(currentLeaderEpoch).writeInt64(fetchOffset).writeInt64(logStartOffset).writeInt32(maxBytes);
};
var _request12 = exports$17;
var exports$18 = {};
const {parse: parseV1$4} = _response2$1;
const decodeMessages$5 = _decodeMessages;
const decodeAbortedTransactions$4 = (decoder) => ({
            producerId: decoder.readInt64().toString(),
            firstOffset: decoder.readInt64().toString()
        })
;
const decodePartition$6 = async (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            highWatermark: decoder.readInt64().toString(),
            lastStableOffset: decoder.readInt64().toString(),
            lastStartOffset: decoder.readInt64().toString(),
            abortedTransactions: decoder.readArray(decodeAbortedTransactions$4),
            preferredReadReplica: decoder.readInt32(),
            messages: await decodeMessages$5(decoder)
        })
;
const decodeResponse$6 = async (decoder) => ({
            topicName: decoder.readString(),
            partitions: await decoder.readArrayAsync(decodePartition$6)
        })
;
const decode$j = async (rawData) => {
    const decoder = new _decoder(rawData);
    const clientSideThrottleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const sessionId = decoder.readInt32();
    const responses = await decoder.readArrayAsync(decodeResponse$6);
    return {
        throttleTime: 0,
        clientSideThrottleTime,
        errorCode,
        sessionId,
        responses
    };
};
exports$18 = {
    decode: decode$j,
    parse: parseV1$4
};
var _response12 = exports$18;
var exports$19 = {};
const ISOLATION_LEVEL$8 = _isolationLevel;
const REPLICA_ID = -1;
const requestTimeout4 = (timeout1) => Number.isSafeInteger(timeout1 + 100) ? timeout1 + 100 : timeout1
;
const versions$2 = {
    0: ({replicaId = REPLICA_ID, maxWaitTime, minBytes, topics}) => {
        const request = _request$1;
        const response = _response$1;
        return {
            request: request({
                replicaId,
                maxWaitTime,
                minBytes,
                topics
            }),
            response,
            requestTimeout: requestTimeout4(maxWaitTime)
        };
    },
    1: ({replicaId = REPLICA_ID, maxWaitTime, minBytes, topics}) => {
        const request = _request2$1;
        const response = _response2$1;
        return {
            request: request({
                replicaId,
                maxWaitTime,
                minBytes,
                topics
            }),
            response,
            requestTimeout: requestTimeout4(maxWaitTime)
        };
    },
    2: ({replicaId = REPLICA_ID, maxWaitTime, minBytes, topics}) => {
        const request = _request3$1;
        const response = _response3$1;
        return {
            request: request({
                replicaId,
                maxWaitTime,
                minBytes,
                topics
            }),
            response,
            requestTimeout: requestTimeout4(maxWaitTime)
        };
    },
    3: ({replicaId = REPLICA_ID, maxWaitTime, minBytes, maxBytes, topics}) => {
        const request = _request4$1;
        const response = _response4$1;
        return {
            request: request({
                replicaId,
                maxWaitTime,
                minBytes,
                maxBytes,
                topics
            }),
            response,
            requestTimeout: requestTimeout4(maxWaitTime)
        };
    },
    4: ({
        replicaId = REPLICA_ID,
        isolationLevel = ISOLATION_LEVEL$8.READ_COMMITTED,
        maxWaitTime,
        minBytes,
        maxBytes,
        topics
    }) => {
        const request = _request5$1;
        const response = _response5$1;
        return {
            request: request({
                replicaId,
                isolationLevel,
                maxWaitTime,
                minBytes,
                maxBytes,
                topics
            }),
            response,
            requestTimeout: requestTimeout4(maxWaitTime)
        };
    },
    5: ({
        replicaId = REPLICA_ID,
        isolationLevel = ISOLATION_LEVEL$8.READ_COMMITTED,
        maxWaitTime,
        minBytes,
        maxBytes,
        topics
    }) => {
        const request = _request6$1;
        const response = _response6$1;
        return {
            request: request({
                replicaId,
                isolationLevel,
                maxWaitTime,
                minBytes,
                maxBytes,
                topics
            }),
            response,
            requestTimeout: requestTimeout4(maxWaitTime)
        };
    },
    6: ({
        replicaId = REPLICA_ID,
        isolationLevel = ISOLATION_LEVEL$8.READ_COMMITTED,
        maxWaitTime,
        minBytes,
        maxBytes,
        topics
    }) => {
        const request = _request7$1;
        const response = _response7$1;
        return {
            request: request({
                replicaId,
                isolationLevel,
                maxWaitTime,
                minBytes,
                maxBytes,
                topics
            }),
            response,
            requestTimeout: requestTimeout4(maxWaitTime)
        };
    },
    7: ({
        replicaId = REPLICA_ID,
        isolationLevel = ISOLATION_LEVEL$8.READ_COMMITTED,
        sessionId = 0,
        sessionEpoch = -1,
        forgottenTopics = [],
        maxWaitTime,
        minBytes,
        maxBytes,
        topics
    }) => {
        const request = _request8$1;
        const response = _response8$1;
        return {
            request: request({
                replicaId,
                isolationLevel,
                sessionId,
                sessionEpoch,
                forgottenTopics,
                maxWaitTime,
                minBytes,
                maxBytes,
                topics
            }),
            response,
            requestTimeout: requestTimeout4(maxWaitTime)
        };
    },
    8: ({
        replicaId = REPLICA_ID,
        isolationLevel = ISOLATION_LEVEL$8.READ_COMMITTED,
        sessionId = 0,
        sessionEpoch = -1,
        forgottenTopics = [],
        maxWaitTime,
        minBytes,
        maxBytes,
        topics
    }) => {
        const request = _request9;
        const response = _response9;
        return {
            request: request({
                replicaId,
                isolationLevel,
                sessionId,
                sessionEpoch,
                forgottenTopics,
                maxWaitTime,
                minBytes,
                maxBytes,
                topics
            }),
            response,
            requestTimeout: requestTimeout4(maxWaitTime)
        };
    },
    9: ({
        replicaId = REPLICA_ID,
        isolationLevel = ISOLATION_LEVEL$8.READ_COMMITTED,
        sessionId = 0,
        sessionEpoch = -1,
        forgottenTopics = [],
        maxWaitTime,
        minBytes,
        maxBytes,
        topics
    }) => {
        const request = _request10;
        const response = _response10;
        return {
            request: request({
                replicaId,
                isolationLevel,
                sessionId,
                sessionEpoch,
                forgottenTopics,
                maxWaitTime,
                minBytes,
                maxBytes,
                topics
            }),
            response,
            requestTimeout: requestTimeout4(maxWaitTime)
        };
    },
    10: ({
        replicaId = REPLICA_ID,
        isolationLevel = ISOLATION_LEVEL$8.READ_COMMITTED,
        sessionId = 0,
        sessionEpoch = -1,
        forgottenTopics = [],
        maxWaitTime,
        minBytes,
        maxBytes,
        topics
    }) => {
        const request = _request11;
        const response = _response11;
        return {
            request: request({
                replicaId,
                isolationLevel,
                sessionId,
                sessionEpoch,
                forgottenTopics,
                maxWaitTime,
                minBytes,
                maxBytes,
                topics
            }),
            response,
            requestTimeout: requestTimeout4(maxWaitTime)
        };
    },
    11: ({
        replicaId = REPLICA_ID,
        isolationLevel = ISOLATION_LEVEL$8.READ_COMMITTED,
        sessionId = 0,
        sessionEpoch = -1,
        forgottenTopics = [],
        maxWaitTime,
        minBytes,
        maxBytes,
        topics,
        rackId
    }) => {
        const request = _request12;
        const response = _response12;
        return {
            request: request({
                replicaId,
                isolationLevel,
                sessionId,
                sessionEpoch,
                forgottenTopics,
                maxWaitTime,
                minBytes,
                maxBytes,
                topics,
                rackId
            }),
            response,
            requestTimeout: requestTimeout4(maxWaitTime)
        };
    }
};
exports$19 = {
    versions: Object.keys(versions$2),
    protocol: ({version}) => versions$2[version]
};
var _fetch = exports$19;
var exports$1a = {};
const Encoder$g = _encoder;
const {ListOffsets: apiKey$a} = _apiKeys;
exports$1a = ({replicaId, topics}) => ({
    apiKey: apiKey$a,
    apiVersion: 0,
    apiName: "ListOffsets",
    encode: async () => {
        return new Encoder$g().writeInt32(replicaId).writeArray(topics.map(encodeTopic$8));
    }
})
;
const encodeTopic$8 = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$7));
};
const encodePartition$7 = ({partition: partition2, timestamp = -1, maxNumOffsets = 1}) => {
    return new _encoder().writeInt32(partition2).writeInt64(timestamp).writeInt32(maxNumOffsets);
};
var _request$2 = exports$1a;
var exports$1b = {};
const {failure: failure$4, createErrorFromCode: createErrorFromCode$4} = _error;
const flatten$4 = _flatten;
const decode$k = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        responses: decoder.readArray(decodeResponses)
    };
};
const decodeResponses = (decoder) => ({
            topic: decoder.readString(),
            partitions: decoder.readArray(decodePartitions)
        })
;
const decodePartitions = (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            offsets: decoder.readArray(decodeOffsets)
        })
;
const decodeOffsets = (decoder) => decoder.readInt64().toString()
;
const parse$b = async (data) => {
    const partitionsWithError = data.responses.map((response) => response.partitions.filter((partition2) => failure$4(partition2.errorCode)
            )
    );
    const partitionWithError = flatten$4(partitionsWithError)[0];
    if (partitionWithError) {
        throw createErrorFromCode$4(partitionWithError.errorCode);
    }
    return data;
};
exports$1b = {
    decode: decode$k,
    parse: parse$b
};
var _response$2 = exports$1b;
var exports$1c = {};
const Encoder$h = _encoder;
const {ListOffsets: apiKey$b} = _apiKeys;
exports$1c = ({replicaId, topics}) => ({
    apiKey: apiKey$b,
    apiVersion: 1,
    apiName: "ListOffsets",
    encode: async () => {
        return new Encoder$h().writeInt32(replicaId).writeArray(topics.map(encodeTopic$9));
    }
})
;
const encodeTopic$9 = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$8));
};
const encodePartition$8 = ({partition: partition2, timestamp = -1}) => {
    return new _encoder().writeInt32(partition2).writeInt64(timestamp);
};
var _request2$2 = exports$1c;
var exports$1d = {};
const {failure: failure$5, createErrorFromCode: createErrorFromCode$5} = _error;
const flatten$5 = _flatten;
const decode$l = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        responses: decoder.readArray(decodeResponses$1)
    };
};
const decodeResponses$1 = (decoder) => ({
            topic: decoder.readString(),
            partitions: decoder.readArray(decodePartitions$1)
        })
;
const decodePartitions$1 = (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            timestamp: decoder.readInt64().toString(),
            offset: decoder.readInt64().toString()
        })
;
const parse$c = async (data) => {
    const partitionsWithError = data.responses.map((response) => response.partitions.filter((partition2) => failure$5(partition2.errorCode)
            )
    );
    const partitionWithError = flatten$5(partitionsWithError)[0];
    if (partitionWithError) {
        throw createErrorFromCode$5(partitionWithError.errorCode);
    }
    return data;
};
exports$1d = {
    decode: decode$l,
    parse: parse$c
};
var _response2$2 = exports$1d;
var exports$1e = {};
const Encoder$i = _encoder;
const {ListOffsets: apiKey$c} = _apiKeys;
exports$1e = ({replicaId, isolationLevel, topics}) => ({
    apiKey: apiKey$c,
    apiVersion: 2,
    apiName: "ListOffsets",
    encode: async () => {
        return new Encoder$i().writeInt32(replicaId).writeInt8(isolationLevel).writeArray(topics.map(encodeTopic$a));
    }
})
;
const encodeTopic$a = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$9));
};
const encodePartition$9 = ({partition: partition2, timestamp = -1}) => {
    return new _encoder().writeInt32(partition2).writeInt64(timestamp);
};
var _request3$2 = exports$1e;
var exports$1f = {};
const {failure: failure$6, createErrorFromCode: createErrorFromCode$6} = _error;
const flatten$6 = _flatten;
const decode$m = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        throttleTime: decoder.readInt32(),
        responses: decoder.readArray(decodeResponses$2)
    };
};
const decodeResponses$2 = (decoder) => ({
            topic: decoder.readString(),
            partitions: decoder.readArray(decodePartitions$2)
        })
;
const decodePartitions$2 = (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16(),
            timestamp: decoder.readInt64().toString(),
            offset: decoder.readInt64().toString()
        })
;
const parse$d = async (data) => {
    const partitionsWithError = data.responses.map((response) => response.partitions.filter((partition2) => failure$6(partition2.errorCode)
            )
    );
    const partitionWithError = flatten$6(partitionsWithError)[0];
    if (partitionWithError) {
        throw createErrorFromCode$6(partitionWithError.errorCode);
    }
    return data;
};
exports$1f = {
    decode: decode$m,
    parse: parse$d
};
var _response3$2 = exports$1f;
var exports$1g = {};
const requestV2 = _request3$2;
exports$1g = ({replicaId, isolationLevel, topics}) => Object.assign(requestV2({
    replicaId,
    isolationLevel,
    topics
}), {
    apiVersion: 3
})
;
var _request4$2 = exports$1g;
var exports$1h = {};
const {parse: parse$e, decode: decodeV2} = _response3$2;
const decode$n = async (rawData) => {
    const decoded = await decodeV2(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$1h = {
    decode: decode$n,
    parse: parse$e
};
var _response4$2 = exports$1h;
var exports$1i = {};
const ISOLATION_LEVEL$9 = _isolationLevel;
const REPLICA_ID$1 = -1;
const versions$3 = {
    0: ({replicaId = REPLICA_ID$1, topics}) => {
        const request = _request$2;
        const response = _response$2;
        return {
            request: request({
                replicaId,
                topics
            }),
            response
        };
    },
    1: ({replicaId = REPLICA_ID$1, topics}) => {
        const request = _request2$2;
        const response = _response2$2;
        return {
            request: request({
                replicaId,
                topics
            }),
            response
        };
    },
    2: ({replicaId = REPLICA_ID$1, isolationLevel = ISOLATION_LEVEL$9.READ_COMMITTED, topics}) => {
        const request = _request3$2;
        const response = _response3$2;
        return {
            request: request({
                replicaId,
                isolationLevel,
                topics
            }),
            response
        };
    },
    3: ({replicaId = REPLICA_ID$1, isolationLevel = ISOLATION_LEVEL$9.READ_COMMITTED, topics}) => {
        const request = _request4$2;
        const response = _response4$2;
        return {
            request: request({
                replicaId,
                isolationLevel,
                topics
            }),
            response
        };
    }
};
exports$1i = {
    versions: Object.keys(versions$3),
    protocol: ({version}) => versions$3[version]
};
var _listOffsets = exports$1i;
var exports$1j = {};
const Encoder$j = _encoder;
const {Metadata: apiKey$d} = _apiKeys;
exports$1j = ({topics}) => ({
    apiKey: apiKey$d,
    apiVersion: 0,
    apiName: "Metadata",
    encode: async () => {
        return new Encoder$j().writeArray(topics);
    }
})
;
var _request$3 = exports$1j;
var exports$1k = {};
const {failure: failure$7, createErrorFromCode: createErrorFromCode$7} = _error;
const flatten$7 = _flatten;
const broker2 = (decoder) => ({
            nodeId: decoder.readInt32(),
            host: decoder.readString(),
            port: decoder.readInt32()
        })
;
const topicMetadata = (decoder) => ({
            topicErrorCode: decoder.readInt16(),
            topic: decoder.readString(),
            partitionMetadata: decoder.readArray(partitionMetadata)
        })
;
const partitionMetadata = (decoder) => ({
            partitionErrorCode: decoder.readInt16(),
            partitionId: decoder.readInt32(),
            leader: decoder.readInt32(),
            replicas: decoder.readArray((d23) => d23.readInt32()
            ),
            isr: decoder.readArray((d23) => d23.readInt32()
            )
        })
;
const decode$o = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        brokers: decoder.readArray(broker2),
        topicMetadata: decoder.readArray(topicMetadata)
    };
};
const parse$f = async (data) => {
    const topicsWithErrors = data.topicMetadata.filter((topic3) => failure$7(topic3.topicErrorCode)
    );
    if (topicsWithErrors.length > 0) {
        const {topicErrorCode} = topicsWithErrors[0];
        throw createErrorFromCode$7(topicErrorCode);
    }
    const partitionsWithErrors = data.topicMetadata.map((topic3) => {
        return topic3.partitionMetadata.filter((partition2) => failure$7(partition2.partitionErrorCode)
        );
    });
    const errors = flatten$7(partitionsWithErrors);
    if (errors.length > 0) {
        const {partitionErrorCode} = errors[0];
        throw createErrorFromCode$7(partitionErrorCode);
    }
    return data;
};
exports$1k = {
    decode: decode$o,
    parse: parse$f
};
var _response$3 = exports$1k;
var exports$1l = {};
const requestV0$3 = _request$3;
exports$1l = ({topics}) => Object.assign(requestV0$3({
    topics
}), {
    apiVersion: 1
})
;
var _request2$3 = exports$1l;
var exports$1m = {};
const {parse: parseV0$3} = _response$3;
const broker$1 = (decoder) => ({
            nodeId: decoder.readInt32(),
            host: decoder.readString(),
            port: decoder.readInt32(),
            rack: decoder.readString()
        })
;
const topicMetadata$1 = (decoder) => ({
            topicErrorCode: decoder.readInt16(),
            topic: decoder.readString(),
            isInternal: decoder.readBoolean(),
            partitionMetadata: decoder.readArray(partitionMetadata$1)
        })
;
const partitionMetadata$1 = (decoder) => ({
            partitionErrorCode: decoder.readInt16(),
            partitionId: decoder.readInt32(),
            leader: decoder.readInt32(),
            replicas: decoder.readArray((d23) => d23.readInt32()
            ),
            isr: decoder.readArray((d23) => d23.readInt32()
            )
        })
;
const decode$p = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        brokers: decoder.readArray(broker$1),
        controllerId: decoder.readInt32(),
        topicMetadata: decoder.readArray(topicMetadata$1)
    };
};
exports$1m = {
    decode: decode$p,
    parse: parseV0$3
};
var _response2$3 = exports$1m;
var exports$1n = {};
const requestV0$4 = _request$3;
exports$1n = ({topics}) => Object.assign(requestV0$4({
    topics
}), {
    apiVersion: 2
})
;
var _request3$3 = exports$1n;
var exports$1o = {};
const {parse: parseV0$4} = _response$3;
const broker$2 = (decoder) => ({
            nodeId: decoder.readInt32(),
            host: decoder.readString(),
            port: decoder.readInt32(),
            rack: decoder.readString()
        })
;
const topicMetadata$2 = (decoder) => ({
            topicErrorCode: decoder.readInt16(),
            topic: decoder.readString(),
            isInternal: decoder.readBoolean(),
            partitionMetadata: decoder.readArray(partitionMetadata$2)
        })
;
const partitionMetadata$2 = (decoder) => ({
            partitionErrorCode: decoder.readInt16(),
            partitionId: decoder.readInt32(),
            leader: decoder.readInt32(),
            replicas: decoder.readArray((d23) => d23.readInt32()
            ),
            isr: decoder.readArray((d23) => d23.readInt32()
            )
        })
;
const decode$q = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        brokers: decoder.readArray(broker$2),
        clusterId: decoder.readString(),
        controllerId: decoder.readInt32(),
        topicMetadata: decoder.readArray(topicMetadata$2)
    };
};
exports$1o = {
    decode: decode$q,
    parse: parseV0$4
};
var _response3$3 = exports$1o;
var exports$1p = {};
const requestV0$5 = _request$3;
exports$1p = ({topics}) => Object.assign(requestV0$5({
    topics
}), {
    apiVersion: 3
})
;
var _request4$3 = exports$1p;
var exports$1q = {};
const {parse: parseV0$5} = _response$3;
const broker$3 = (decoder) => ({
            nodeId: decoder.readInt32(),
            host: decoder.readString(),
            port: decoder.readInt32(),
            rack: decoder.readString()
        })
;
const topicMetadata$3 = (decoder) => ({
            topicErrorCode: decoder.readInt16(),
            topic: decoder.readString(),
            isInternal: decoder.readBoolean(),
            partitionMetadata: decoder.readArray(partitionMetadata$3)
        })
;
const partitionMetadata$3 = (decoder) => ({
            partitionErrorCode: decoder.readInt16(),
            partitionId: decoder.readInt32(),
            leader: decoder.readInt32(),
            replicas: decoder.readArray((d23) => d23.readInt32()
            ),
            isr: decoder.readArray((d23) => d23.readInt32()
            )
        })
;
const decode$r = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        throttleTime: decoder.readInt32(),
        brokers: decoder.readArray(broker$3),
        clusterId: decoder.readString(),
        controllerId: decoder.readInt32(),
        topicMetadata: decoder.readArray(topicMetadata$3)
    };
};
exports$1q = {
    decode: decode$r,
    parse: parseV0$5
};
var _response4$3 = exports$1q;
var exports$1r = {};
const Encoder$k = _encoder;
const {Metadata: apiKey$e} = _apiKeys;
exports$1r = ({topics, allowAutoTopicCreation = true}) => ({
    apiKey: apiKey$e,
    apiVersion: 4,
    apiName: "Metadata",
    encode: async () => {
        return new Encoder$k().writeNullableArray(topics).writeBoolean(allowAutoTopicCreation);
    }
})
;
var _request5$2 = exports$1r;
var exports$1s = {};
const {parse: parseV3$1, decode: decodeV3} = _response4$3;
exports$1s = {
    parse: parseV3$1,
    decode: decodeV3
};
var _response5$2 = exports$1s;
var exports$1t = {};
const requestV4 = _request5$2;
exports$1t = ({topics, allowAutoTopicCreation = true}) => Object.assign(requestV4({
    topics,
    allowAutoTopicCreation
}), {
    apiVersion: 5
})
;
var _request6$2 = exports$1t;
var exports$1u = {};
const {parse: parseV0$6} = _response$3;
const broker$4 = (decoder) => ({
            nodeId: decoder.readInt32(),
            host: decoder.readString(),
            port: decoder.readInt32(),
            rack: decoder.readString()
        })
;
const topicMetadata$4 = (decoder) => ({
            topicErrorCode: decoder.readInt16(),
            topic: decoder.readString(),
            isInternal: decoder.readBoolean(),
            partitionMetadata: decoder.readArray(partitionMetadata$4)
        })
;
const partitionMetadata$4 = (decoder) => ({
            partitionErrorCode: decoder.readInt16(),
            partitionId: decoder.readInt32(),
            leader: decoder.readInt32(),
            replicas: decoder.readArray((d23) => d23.readInt32()
            ),
            isr: decoder.readArray((d23) => d23.readInt32()
            ),
            offlineReplicas: decoder.readArray((d23) => d23.readInt32()
            )
        })
;
const decode$s = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        throttleTime: decoder.readInt32(),
        brokers: decoder.readArray(broker$4),
        clusterId: decoder.readString(),
        controllerId: decoder.readInt32(),
        topicMetadata: decoder.readArray(topicMetadata$4)
    };
};
exports$1u = {
    decode: decode$s,
    parse: parseV0$6
};
var _response6$2 = exports$1u;
var exports$1v = {};
const requestV5$2 = _request6$2;
exports$1v = ({topics, allowAutoTopicCreation = true}) => Object.assign(requestV5$2({
    topics,
    allowAutoTopicCreation
}), {
    apiVersion: 6
})
;
var _request7$2 = exports$1v;
var exports$1w = {};
const {parse: parse$g, decode: decodeV1} = _response6$2;
const decode$t = async (rawData) => {
    const decoded = await decodeV1(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$1w = {
    decode: decode$t,
    parse: parse$g
};
var _response7$2 = exports$1w;
var exports$1x = {};
const versions$4 = {
    0: ({topics}) => {
        const request = _request$3;
        const response = _response$3;
        return {
            request: request({
                topics
            }),
            response
        };
    },
    1: ({topics}) => {
        const request = _request2$3;
        const response = _response2$3;
        return {
            request: request({
                topics
            }),
            response
        };
    },
    2: ({topics}) => {
        const request = _request3$3;
        const response = _response3$3;
        return {
            request: request({
                topics
            }),
            response
        };
    },
    3: ({topics}) => {
        const request = _request4$3;
        const response = _response4$3;
        return {
            request: request({
                topics
            }),
            response
        };
    },
    4: ({topics, allowAutoTopicCreation}) => {
        const request = _request5$2;
        const response = _response5$2;
        return {
            request: request({
                topics,
                allowAutoTopicCreation
            }),
            response
        };
    },
    5: ({topics, allowAutoTopicCreation}) => {
        const request = _request6$2;
        const response = _response6$2;
        return {
            request: request({
                topics,
                allowAutoTopicCreation
            }),
            response
        };
    },
    6: ({topics, allowAutoTopicCreation}) => {
        const request = _request7$2;
        const response = _response7$2;
        return {
            request: request({
                topics,
                allowAutoTopicCreation
            }),
            response
        };
    }
};
exports$1x = {
    versions: Object.keys(versions$4),
    protocol: ({version}) => versions$4[version]
};
var _metadata = exports$1x;
var exports$1y = {};
const Encoder$l = _encoder;
const {OffsetCommit: apiKey$f} = _apiKeys;
exports$1y = ({groupId, topics}) => ({
    apiKey: apiKey$f,
    apiVersion: 0,
    apiName: "OffsetCommit",
    encode: async () => {
        return new Encoder$l().writeString(groupId).writeArray(topics.map(encodeTopic$b));
    }
})
;
const encodeTopic$b = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$a));
};
const encodePartition$a = ({partition: partition2, offset, metadata = null}) => {
    return new _encoder().writeInt32(partition2).writeInt64(offset).writeString(metadata);
};
var _request$4 = exports$1y;
var exports$1z = {};
const {failure: failure$8, createErrorFromCode: createErrorFromCode$8} = _error;
const flatten$8 = _flatten;
const decode$u = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        responses: decoder.readArray(decodeResponses$3)
    };
};
const decodeResponses$3 = (decoder) => ({
            topic: decoder.readString(),
            partitions: decoder.readArray(decodePartitions$3)
        })
;
const decodePartitions$3 = (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16()
        })
;
const parse$h = async (data) => {
    const partitionsWithError = data.responses.map((response) => response.partitions.filter((partition2) => failure$8(partition2.errorCode)
            )
    );
    const partitionWithError = flatten$8(partitionsWithError)[0];
    if (partitionWithError) {
        throw createErrorFromCode$8(partitionWithError.errorCode);
    }
    return data;
};
exports$1z = {
    decode: decode$u,
    parse: parse$h
};
var _response$4 = exports$1z;
var exports$1A = {};
const Encoder$m = _encoder;
const {OffsetCommit: apiKey$g} = _apiKeys;
exports$1A = ({groupId, groupGenerationId, memberId: memberId1, topics}) => ({
    apiKey: apiKey$g,
    apiVersion: 1,
    apiName: "OffsetCommit",
    encode: async () => {
        return new Encoder$m().writeString(groupId).writeInt32(groupGenerationId).writeString(memberId1).writeArray(topics.map(encodeTopic$c));
    }
})
;
const encodeTopic$c = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$b));
};
const encodePartition$b = ({partition: partition2, offset, timestamp = Date.now(), metadata = null}) => {
    return new _encoder().writeInt32(partition2).writeInt64(offset).writeInt64(timestamp).writeString(metadata);
};
var _request2$4 = exports$1A;
var exports$1B = {};
const {parse: parse$i, decode: decode$v} = _response$4;
exports$1B = {
    decode: decode$v,
    parse: parse$i
};
var _response2$4 = exports$1B;
var exports$1C = {};
const Encoder$n = _encoder;
const {OffsetCommit: apiKey$h} = _apiKeys;
exports$1C = ({groupId, groupGenerationId, memberId: memberId1, retentionTime, topics}) => ({
    apiKey: apiKey$h,
    apiVersion: 2,
    apiName: "OffsetCommit",
    encode: async () => {
        return new Encoder$n().writeString(groupId).writeInt32(groupGenerationId).writeString(memberId1).writeInt64(retentionTime).writeArray(topics.map(encodeTopic$d));
    }
})
;
const encodeTopic$d = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$c));
};
const encodePartition$c = ({partition: partition2, offset, metadata = null}) => {
    return new _encoder().writeInt32(partition2).writeInt64(offset).writeString(metadata);
};
var _request3$4 = exports$1C;
var exports$1D = {};
const {parse: parse$j, decode: decode$w} = _response$4;
exports$1D = {
    decode: decode$w,
    parse: parse$j
};
var _response3$4 = exports$1D;
var exports$1E = {};
const requestV2$1 = _request3$4;
exports$1E = ({groupId, groupGenerationId, memberId: memberId1, retentionTime, topics}) => Object.assign(requestV2$1({
    groupId,
    groupGenerationId,
    memberId: memberId1,
    retentionTime,
    topics
}), {
    apiVersion: 3
})
;
var _request4$4 = exports$1E;
var exports$1F = {};
const {parse: parseV0$7} = _response$4;
const decode$x = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        throttleTime: decoder.readInt32(),
        responses: decoder.readArray(decodeResponses$4)
    };
};
const decodeResponses$4 = (decoder) => ({
            topic: decoder.readString(),
            partitions: decoder.readArray(decodePartitions$4)
        })
;
const decodePartitions$4 = (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16()
        })
;
exports$1F = {
    decode: decode$x,
    parse: parseV0$7
};
var _response4$4 = exports$1F;
var exports$1G = {};
const requestV3$2 = _request4$4;
exports$1G = ({groupId, groupGenerationId, memberId: memberId1, retentionTime, topics}) => Object.assign(requestV3$2({
    groupId,
    groupGenerationId,
    memberId: memberId1,
    retentionTime,
    topics
}), {
    apiVersion: 4
})
;
var _request5$3 = exports$1G;
var exports$1H = {};
const {parse: parse$k, decode: decodeV3$1} = _response4$4;
const decode$y = async (rawData) => {
    const decoded = await decodeV3$1(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$1H = {
    decode: decode$y,
    parse: parse$k
};
var _response5$3 = exports$1H;
var exports$1I = {};
const Encoder$o = _encoder;
const {OffsetCommit: apiKey$i} = _apiKeys;
exports$1I = ({groupId, groupGenerationId, memberId: memberId1, topics}) => ({
    apiKey: apiKey$i,
    apiVersion: 5,
    apiName: "OffsetCommit",
    encode: async () => {
        return new Encoder$o().writeString(groupId).writeInt32(groupGenerationId).writeString(memberId1).writeArray(topics.map(encodeTopic$e));
    }
})
;
const encodeTopic$e = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$d));
};
const encodePartition$d = ({partition: partition2, offset, metadata = null}) => {
    return new _encoder().writeInt32(partition2).writeInt64(offset).writeString(metadata);
};
var _request6$3 = exports$1I;
var exports$1J = {};
const {parse: parse$l, decode: decode$z} = _response5$3;
exports$1J = {
    decode: decode$z,
    parse: parse$l
};
var _response6$3 = exports$1J;
var exports$1K = {};
const RETENTION_TIME = -1;
const versions$5 = {
    0: ({groupId, topics}) => {
        const request = _request$4;
        const response = _response$4;
        return {
            request: request({
                groupId,
                topics
            }),
            response
        };
    },
    1: ({groupId, groupGenerationId, memberId: memberId1, topics}) => {
        const request = _request2$4;
        const response = _response2$4;
        return {
            request: request({
                groupId,
                groupGenerationId,
                memberId: memberId1,
                topics
            }),
            response
        };
    },
    2: ({groupId, groupGenerationId, memberId: memberId1, retentionTime = RETENTION_TIME, topics}) => {
        const request = _request3$4;
        const response = _response3$4;
        return {
            request: request({
                groupId,
                groupGenerationId,
                memberId: memberId1,
                retentionTime,
                topics
            }),
            response
        };
    },
    3: ({groupId, groupGenerationId, memberId: memberId1, retentionTime = RETENTION_TIME, topics}) => {
        const request = _request4$4;
        const response = _response4$4;
        return {
            request: request({
                groupId,
                groupGenerationId,
                memberId: memberId1,
                retentionTime,
                topics
            }),
            response
        };
    },
    4: ({groupId, groupGenerationId, memberId: memberId1, retentionTime = RETENTION_TIME, topics}) => {
        const request = _request5$3;
        const response = _response5$3;
        return {
            request: request({
                groupId,
                groupGenerationId,
                memberId: memberId1,
                retentionTime,
                topics
            }),
            response
        };
    },
    5: ({groupId, groupGenerationId, memberId: memberId1, topics}) => {
        const request = _request6$3;
        const response = _response6$3;
        return {
            request: request({
                groupId,
                groupGenerationId,
                memberId: memberId1,
                topics
            }),
            response
        };
    }
};
exports$1K = {
    versions: Object.keys(versions$5),
    protocol: ({version}) => versions$5[version]
};
var _offsetCommit = exports$1K;
var exports$1L = {};
const Encoder$p = _encoder;
const {OffsetFetch: apiKey$j} = _apiKeys;
exports$1L = ({groupId, topics}) => ({
    apiKey: apiKey$j,
    apiVersion: 1,
    apiName: "OffsetFetch",
    encode: async () => {
        return new Encoder$p().writeString(groupId).writeArray(topics.map(encodeTopic$f));
    }
})
;
const encodeTopic$f = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$e));
};
const encodePartition$e = ({partition: partition2}) => {
    return new _encoder().writeInt32(partition2);
};
var _request$5 = exports$1L;
var exports$1M = {};
const {failure: failure$9, createErrorFromCode: createErrorFromCode$9} = _error;
const flatten$9 = _flatten;
const decode$A = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        responses: decoder.readArray(decodeResponses$5)
    };
};
const decodeResponses$5 = (decoder) => ({
            topic: decoder.readString(),
            partitions: decoder.readArray(decodePartitions$5)
        })
;
const decodePartitions$5 = (decoder) => ({
            partition: decoder.readInt32(),
            offset: decoder.readInt64().toString(),
            metadata: decoder.readString(),
            errorCode: decoder.readInt16()
        })
;
const parse$m = async (data) => {
    const partitionsWithError = data.responses.map((response) => response.partitions.filter((partition2) => failure$9(partition2.errorCode)
            )
    );
    const partitionWithError = flatten$9(partitionsWithError)[0];
    if (partitionWithError) {
        throw createErrorFromCode$9(partitionWithError.errorCode);
    }
    return data;
};
exports$1M = {
    decode: decode$A,
    parse: parse$m
};
var _response$5 = exports$1M;
var exports$1N = {};
const requestV1 = _request$5;
exports$1N = ({groupId, topics}) => Object.assign(requestV1({
    groupId,
    topics
}), {
    apiVersion: 2
})
;
var _request2$5 = exports$1N;
var exports$1O = {};
const {failure: failure$a, createErrorFromCode: createErrorFromCode$a} = _error;
const flatten$a = _flatten;
const decode$B = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        responses: decoder.readArray(decodeResponses$6),
        errorCode: decoder.readInt16()
    };
};
const decodeResponses$6 = (decoder) => ({
            topic: decoder.readString(),
            partitions: decoder.readArray(decodePartitions$6)
        })
;
const decodePartitions$6 = (decoder) => ({
            partition: decoder.readInt32(),
            offset: decoder.readInt64().toString(),
            metadata: decoder.readString(),
            errorCode: decoder.readInt16()
        })
;
const parse$n = async (data) => {
    if (failure$a(data.errorCode)) {
        throw createErrorFromCode$a(data.errorCode);
    }
    const partitionsWithError = data.responses.map((response) => response.partitions.filter((partition2) => failure$a(partition2.errorCode)
            )
    );
    const partitionWithError = flatten$a(partitionsWithError)[0];
    if (partitionWithError) {
        throw createErrorFromCode$a(partitionWithError.errorCode);
    }
    return data;
};
exports$1O = {
    decode: decode$B,
    parse: parse$n
};
var _response2$5 = exports$1O;
var exports$1P = {};
const Encoder$q = _encoder;
const {OffsetFetch: apiKey$k} = _apiKeys;
exports$1P = ({groupId, topics}) => ({
    apiKey: apiKey$k,
    apiVersion: 3,
    apiName: "OffsetFetch",
    encode: async () => {
        return new Encoder$q().writeString(groupId).writeNullableArray(topics.map(encodeTopic$g));
    }
})
;
const encodeTopic$g = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$f));
};
const encodePartition$f = ({partition: partition2}) => {
    return new _encoder().writeInt32(partition2);
};
var _request3$5 = exports$1P;
var exports$1Q = {};
const {parse: parseV2} = _response2$5;
const decode$C = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        throttleTime: decoder.readInt32(),
        responses: decoder.readArray(decodeResponses$7),
        errorCode: decoder.readInt16()
    };
};
const decodeResponses$7 = (decoder) => ({
            topic: decoder.readString(),
            partitions: decoder.readArray(decodePartitions$7)
        })
;
const decodePartitions$7 = (decoder) => ({
            partition: decoder.readInt32(),
            offset: decoder.readInt64().toString(),
            metadata: decoder.readString(),
            errorCode: decoder.readInt16()
        })
;
exports$1Q = {
    decode: decode$C,
    parse: parseV2
};
var _response3$5 = exports$1Q;
var exports$1R = {};
const requestV3$3 = _request3$5;
exports$1R = ({groupId, topics}) => Object.assign(requestV3$3({
    groupId,
    topics
}), {
    apiVersion: 4
})
;
var _request4$5 = exports$1R;
var exports$1S = {};
const {parse: parse$o, decode: decodeV3$2} = _response3$5;
const decode$D = async (rawData) => {
    const decoded = await decodeV3$2(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$1S = {
    decode: decode$D,
    parse: parse$o
};
var _response4$5 = exports$1S;
var exports$1T = {};
const versions$6 = {
    1: ({groupId, topics}) => {
        const request = _request$5;
        const response = _response$5;
        return {
            request: request({
                groupId,
                topics
            }),
            response
        };
    },
    2: ({groupId, topics}) => {
        const request = _request2$5;
        const response = _response2$5;
        return {
            request: request({
                groupId,
                topics
            }),
            response
        };
    },
    3: ({groupId, topics}) => {
        const request = _request3$5;
        const response = _response3$5;
        return {
            request: request({
                groupId,
                topics
            }),
            response
        };
    },
    4: ({groupId, topics}) => {
        const request = _request4$5;
        const response = _response4$5;
        return {
            request: request({
                groupId,
                topics
            }),
            response
        };
    }
};
exports$1T = {
    versions: Object.keys(versions$6),
    protocol: ({version}) => versions$6[version]
};
var _offsetFetch = exports$1T;
var exports$1U = {};
exports$1U = {
    GROUP: 0,
    TRANSACTION: 1
};
var _coordinatorTypes = exports$1U;
var exports$1V = {};
const Encoder$r = _encoder;
const {GroupCoordinator: apiKey$l} = _apiKeys;
exports$1V = ({groupId}) => ({
    apiKey: apiKey$l,
    apiVersion: 0,
    apiName: "GroupCoordinator",
    encode: async () => {
        return new Encoder$r().writeString(groupId);
    }
})
;
var _request$6 = exports$1V;
var exports$1W = {};
const {
    failure: failure$b,
    createErrorFromCode: createErrorFromCode$b,
    failIfVersionNotSupported: failIfVersionNotSupported$1
} = _error;
const decode$E = async (rawData) => {
    const decoder = new _decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$1(errorCode);
    const coordinator = {
        nodeId: decoder.readInt32(),
        host: decoder.readString(),
        port: decoder.readInt32()
    };
    return {
        errorCode,
        coordinator
    };
};
const parse$p = async (data) => {
    if (failure$b(data.errorCode)) {
        throw createErrorFromCode$b(data.errorCode);
    }
    return data;
};
exports$1W = {
    decode: decode$E,
    parse: parse$p
};
var _response$6 = exports$1W;
var exports$1X = {};
const Encoder$s = _encoder;
const {GroupCoordinator: apiKey$m} = _apiKeys;
exports$1X = ({coordinatorKey, coordinatorType}) => ({
    apiKey: apiKey$m,
    apiVersion: 1,
    apiName: "GroupCoordinator",
    encode: async () => {
        return new Encoder$s().writeString(coordinatorKey).writeInt8(coordinatorType);
    }
})
;
var _request2$6 = exports$1X;
var exports$1Y = {};
const {
    failure: failure$c,
    createErrorFromCode: createErrorFromCode$c,
    failIfVersionNotSupported: failIfVersionNotSupported$2
} = _error;
const decode$F = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$2(errorCode);
    const errorMessage = decoder.readString();
    const coordinator = {
        nodeId: decoder.readInt32(),
        host: decoder.readString(),
        port: decoder.readInt32()
    };
    return {
        throttleTime,
        errorCode,
        errorMessage,
        coordinator
    };
};
const parse$q = async (data) => {
    if (failure$c(data.errorCode)) {
        throw createErrorFromCode$c(data.errorCode);
    }
    return data;
};
exports$1Y = {
    decode: decode$F,
    parse: parse$q
};
var _response2$6 = exports$1Y;
var exports$1Z = {};
const requestV1$1 = _request2$6;
exports$1Z = ({coordinatorKey, coordinatorType}) => Object.assign(requestV1$1({
    coordinatorKey,
    coordinatorType
}), {
    apiVersion: 2
})
;
var _request3$6 = exports$1Z;
var exports$1_ = {};
const {parse: parse$r, decode: decodeV1$1} = _response2$6;
const decode$G = async (rawData) => {
    const decoded = await decodeV1$1(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$1_ = {
    decode: decode$G,
    parse: parse$r
};
var _response3$6 = exports$1_;
var exports$1$ = {};
const COORDINATOR_TYPES = _coordinatorTypes;
const versions$7 = {
    0: ({groupId}) => {
        const request = _request$6;
        const response = _response$6;
        return {
            request: request({
                groupId
            }),
            response
        };
    },
    1: ({groupId, coordinatorType = COORDINATOR_TYPES.GROUP}) => {
        const request = _request2$6;
        const response = _response2$6;
        return {
            request: request({
                coordinatorKey: groupId,
                coordinatorType
            }),
            response
        };
    },
    2: ({groupId, coordinatorType = COORDINATOR_TYPES.GROUP}) => {
        const request = _request3$6;
        const response = _response3$6;
        return {
            request: request({
                coordinatorKey: groupId,
                coordinatorType
            }),
            response
        };
    }
};
exports$1$ = {
    versions: Object.keys(versions$7),
    protocol: ({version}) => versions$7[version]
};
var _findCoordinator = exports$1$;
var exports$20 = {};
var Buffer$3 = e$1.Buffer;
const Encoder$t = _encoder;
const {JoinGroup: apiKey$n} = _apiKeys;
exports$20 = ({groupId, sessionTimeout, memberId: memberId1, protocolType, groupProtocols}) => ({
    apiKey: apiKey$n,
    apiVersion: 0,
    apiName: "JoinGroup",
    encode: async () => {
        return new Encoder$t().writeString(groupId).writeInt32(sessionTimeout).writeString(memberId1).writeString(protocolType).writeArray(groupProtocols.map(encodeGroupProtocols));
    }
})
;
const encodeGroupProtocols = ({name, metadata = Buffer$3.alloc(0)}) => {
    return new _encoder().writeString(name).writeBytes(metadata);
};
var _request$7 = exports$20;
var exports$211 = {};
const {
    failure: failure$d,
    createErrorFromCode: createErrorFromCode$d,
    failIfVersionNotSupported: failIfVersionNotSupported$3
} = _error;
const decode$H = async (rawData) => {
    const decoder = new _decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$3(errorCode);
    return {
        errorCode,
        generationId: decoder.readInt32(),
        groupProtocol: decoder.readString(),
        leaderId: decoder.readString(),
        memberId: decoder.readString(),
        members: decoder.readArray((decoder1) => ({
                    memberId: decoder1.readString(),
                    memberMetadata: decoder1.readBytes()
                })
        )
    };
};
const parse$s = async (data) => {
    if (failure$d(data.errorCode)) {
        throw createErrorFromCode$d(data.errorCode);
    }
    return data;
};
exports$211 = {
    decode: decode$H,
    parse: parse$s
};
var _response$7 = exports$211;
var exports$22 = {};
var Buffer$4 = e$1.Buffer;
const Encoder$u = _encoder;
const {JoinGroup: apiKey$o} = _apiKeys;
exports$22 = ({groupId, sessionTimeout, rebalanceTimeout, memberId: memberId1, protocolType, groupProtocols}) => ({
    apiKey: apiKey$o,
    apiVersion: 1,
    apiName: "JoinGroup",
    encode: async () => {
        return new Encoder$u().writeString(groupId).writeInt32(sessionTimeout).writeInt32(rebalanceTimeout).writeString(memberId1).writeString(protocolType).writeArray(groupProtocols.map(encodeGroupProtocols$1));
    }
})
;
const encodeGroupProtocols$1 = ({name, metadata = Buffer$4.alloc(0)}) => {
    return new _encoder().writeString(name).writeBytes(metadata);
};
var _request2$7 = exports$22;
var exports$23 = {};
const {parse: parse$t, decode: decode$I} = _response$7;
exports$23 = {
    decode: decode$I,
    parse: parse$t
};
var _response2$7 = exports$23;
var exports$24 = {};
const requestV1$2 = _request2$7;
exports$24 = ({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId: memberId1,
    protocolType,
    groupProtocols
}) => Object.assign(requestV1$2({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId: memberId1,
    protocolType,
    groupProtocols
}), {
    apiVersion: 2
})
;
var _request3$7 = exports$24;
var exports$25 = {};
const {failIfVersionNotSupported: failIfVersionNotSupported$4} = _error;
const {parse: parseV0$8} = _response$7;
const decode$J = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$4(errorCode);
    return {
        throttleTime,
        errorCode,
        generationId: decoder.readInt32(),
        groupProtocol: decoder.readString(),
        leaderId: decoder.readString(),
        memberId: decoder.readString(),
        members: decoder.readArray((decoder1) => ({
                    memberId: decoder1.readString(),
                    memberMetadata: decoder1.readBytes()
                })
        )
    };
};
exports$25 = {
    decode: decode$J,
    parse: parseV0$8
};
var _response3$7 = exports$25;
var exports$26 = {};
const requestV2$2 = _request3$7;
exports$26 = ({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId: memberId1,
    protocolType,
    groupProtocols
}) => Object.assign(requestV2$2({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId: memberId1,
    protocolType,
    groupProtocols
}), {
    apiVersion: 3
})
;
var _request4$6 = exports$26;
var exports$27 = {};
const {parse: parse$u, decode: decodeV2$1} = _response3$7;
const decode$K = async (rawData) => {
    const decoded = await decodeV2$1(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$27 = {
    decode: decode$K,
    parse: parse$u
};
var _response4$6 = exports$27;
var exports$28 = {};
const requestV3$4 = _request4$6;
exports$28 = ({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId: memberId1,
    protocolType,
    groupProtocols
}) => Object.assign(requestV3$4({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId: memberId1,
    protocolType,
    groupProtocols
}), {
    apiVersion: 4
})
;
var _request5$4 = exports$28;
var exports$29 = {};
const {decode: decode$L} = _response4$6;
const {KafkaJSMemberIdRequired: KafkaJSMemberIdRequired$1} = _errors;
const {failure: failure$e, createErrorFromCode: createErrorFromCode$e, errorCodes: errorCodes$2} = _error;
const {code: MEMBER_ID_REQUIRED_ERROR_CODE} = errorCodes$2.find((e46) => e46.type === "MEMBER_ID_REQUIRED"
);
const parse$v = async (data) => {
    if (failure$e(data.errorCode)) {
        if (data.errorCode === MEMBER_ID_REQUIRED_ERROR_CODE) {
            throw new KafkaJSMemberIdRequired$1(createErrorFromCode$e(data.errorCode), {
                memberId: data.memberId
            });
        }
        throw createErrorFromCode$e(data.errorCode);
    }
    return data;
};
exports$29 = {
    decode: decode$L,
    parse: parse$v
};
var _response5$4 = exports$29;
var exports$2a = {};
var Buffer$5 = e$1.Buffer;
const Encoder$v = _encoder;
const {JoinGroup: apiKey$p} = _apiKeys;
exports$2a = ({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId: memberId1,
    groupInstanceId = null,
    protocolType,
    groupProtocols
}) => ({
    apiKey: apiKey$p,
    apiVersion: 5,
    apiName: "JoinGroup",
    encode: async () => {
        return new Encoder$v().writeString(groupId).writeInt32(sessionTimeout).writeInt32(rebalanceTimeout).writeString(memberId1).writeString(groupInstanceId).writeString(protocolType).writeArray(groupProtocols.map(encodeGroupProtocols$2));
    }
})
;
const encodeGroupProtocols$2 = ({name, metadata = Buffer$5.alloc(0)}) => {
    return new _encoder().writeString(name).writeBytes(metadata);
};
var _request6$4 = exports$2a;
var exports$2b = {};
const {KafkaJSMemberIdRequired: KafkaJSMemberIdRequired$2} = _errors;
const {
    failure: failure$f,
    createErrorFromCode: createErrorFromCode$f,
    errorCodes: errorCodes$3,
    failIfVersionNotSupported: failIfVersionNotSupported$5
} = _error;
const {code: MEMBER_ID_REQUIRED_ERROR_CODE$1} = errorCodes$3.find((e46) => e46.type === "MEMBER_ID_REQUIRED"
);
const parse$w = async (data) => {
    if (failure$f(data.errorCode)) {
        if (data.errorCode === MEMBER_ID_REQUIRED_ERROR_CODE$1) {
            throw new KafkaJSMemberIdRequired$2(createErrorFromCode$f(data.errorCode), {
                memberId: data.memberId
            });
        }
        throw createErrorFromCode$f(data.errorCode);
    }
    return data;
};
const decode$M = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$5(errorCode);
    return {
        throttleTime: 0,
        clientSideThrottleTime: throttleTime,
        errorCode,
        generationId: decoder.readInt32(),
        groupProtocol: decoder.readString(),
        leaderId: decoder.readString(),
        memberId: decoder.readString(),
        members: decoder.readArray((decoder1) => ({
                    memberId: decoder1.readString(),
                    groupInstanceId: decoder1.readString(),
                    memberMetadata: decoder1.readBytes()
                })
        )
    };
};
exports$2b = {
    decode: decode$M,
    parse: parse$w
};
var _response6$4 = exports$2b;
var exports$2c = {};
const requestTimeout$1 = ({rebalanceTimeout, sessionTimeout}) => {
    const timeout1 = rebalanceTimeout || sessionTimeout;
    return Number.isSafeInteger(timeout1 + 5000) ? timeout1 + 5000 : timeout1;
};
const logResponseError1 = (memberId1) => memberId1 != null && memberId1 !== ""
;
const versions$8 = {
    0: ({groupId, sessionTimeout, memberId: memberId1, protocolType, groupProtocols}) => {
        const request = _request$7;
        const response = _response$7;
        return {
            request: request({
                groupId,
                sessionTimeout,
                memberId: memberId1,
                protocolType,
                groupProtocols
            }),
            response,
            requestTimeout: requestTimeout$1({
                rebalanceTimeout: null,
                sessionTimeout
            })
        };
    },
    1: ({groupId, sessionTimeout, rebalanceTimeout, memberId: memberId1, protocolType, groupProtocols}) => {
        const request = _request2$7;
        const response = _response2$7;
        return {
            request: request({
                groupId,
                sessionTimeout,
                rebalanceTimeout,
                memberId: memberId1,
                protocolType,
                groupProtocols
            }),
            response,
            requestTimeout: requestTimeout$1({
                rebalanceTimeout,
                sessionTimeout
            })
        };
    },
    2: ({groupId, sessionTimeout, rebalanceTimeout, memberId: memberId1, protocolType, groupProtocols}) => {
        const request = _request3$7;
        const response = _response3$7;
        return {
            request: request({
                groupId,
                sessionTimeout,
                rebalanceTimeout,
                memberId: memberId1,
                protocolType,
                groupProtocols
            }),
            response,
            requestTimeout: requestTimeout$1({
                rebalanceTimeout,
                sessionTimeout
            })
        };
    },
    3: ({groupId, sessionTimeout, rebalanceTimeout, memberId: memberId1, protocolType, groupProtocols}) => {
        const request = _request4$6;
        const response = _response4$6;
        return {
            request: request({
                groupId,
                sessionTimeout,
                rebalanceTimeout,
                memberId: memberId1,
                protocolType,
                groupProtocols
            }),
            response,
            requestTimeout: requestTimeout$1({
                rebalanceTimeout,
                sessionTimeout
            })
        };
    },
    4: ({groupId, sessionTimeout, rebalanceTimeout, memberId: memberId1, protocolType, groupProtocols}) => {
        const request = _request5$4;
        const response = _response5$4;
        return {
            request: request({
                groupId,
                sessionTimeout,
                rebalanceTimeout,
                memberId: memberId1,
                protocolType,
                groupProtocols
            }),
            response,
            requestTimeout: requestTimeout$1({
                rebalanceTimeout,
                sessionTimeout
            }),
            logResponseError: logResponseError1(memberId1)
        };
    },
    5: ({
        groupId,
        sessionTimeout,
        rebalanceTimeout,
        memberId: memberId1,
        groupInstanceId,
        protocolType,
        groupProtocols
    }) => {
        const request = _request6$4;
        const response = _response6$4;
        return {
            request: request({
                groupId,
                sessionTimeout,
                rebalanceTimeout,
                memberId: memberId1,
                groupInstanceId,
                protocolType,
                groupProtocols
            }),
            response,
            requestTimeout: requestTimeout$1({
                rebalanceTimeout,
                sessionTimeout
            }),
            logResponseError: logResponseError1(memberId1)
        };
    }
};
exports$2c = {
    versions: Object.keys(versions$8),
    protocol: ({version}) => versions$8[version]
};
var _joinGroup = exports$2c;
var exports$2d = {};
const Encoder$w = _encoder;
const {Heartbeat: apiKey$q} = _apiKeys;
exports$2d = ({groupId, groupGenerationId, memberId: memberId1}) => ({
    apiKey: apiKey$q,
    apiVersion: 0,
    apiName: "Heartbeat",
    encode: async () => {
        return new Encoder$w().writeString(groupId).writeInt32(groupGenerationId).writeString(memberId1);
    }
})
;
var _request$8 = exports$2d;
var exports$2e = {};
const {
    failure: failure$g,
    createErrorFromCode: createErrorFromCode$g,
    failIfVersionNotSupported: failIfVersionNotSupported$6
} = _error;
const decode$N = async (rawData) => {
    const decoder = new _decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$6(errorCode);
    return {
        errorCode
    };
};
const parse$x = async (data) => {
    if (failure$g(data.errorCode)) {
        throw createErrorFromCode$g(data.errorCode);
    }
    return data;
};
exports$2e = {
    decode: decode$N,
    parse: parse$x
};
var _response$8 = exports$2e;
var exports$2f = {};
const requestV0$6 = _request$8;
exports$2f = ({groupId, groupGenerationId, memberId: memberId1}) => Object.assign(requestV0$6({
    groupId,
    groupGenerationId,
    memberId: memberId1
}), {
    apiVersion: 1
})
;
var _request2$8 = exports$2f;
var exports$2g = {};
const {failIfVersionNotSupported: failIfVersionNotSupported$7} = _error;
const {parse: parseV0$9} = _response$8;
const decode$O = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$7(errorCode);
    return {
        throttleTime,
        errorCode
    };
};
exports$2g = {
    decode: decode$O,
    parse: parseV0$9
};
var _response2$8 = exports$2g;
var exports$2h = {};
const requestV1$3 = _request2$8;
exports$2h = ({groupId, groupGenerationId, memberId: memberId1}) => Object.assign(requestV1$3({
    groupId,
    groupGenerationId,
    memberId: memberId1
}), {
    apiVersion: 2
})
;
var _request3$8 = exports$2h;
var exports$2i = {};
const {parse: parse$y, decode: decodeV1$2} = _response2$8;
const decode$P = async (rawData) => {
    const decoded = await decodeV1$2(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$2i = {
    decode: decode$P,
    parse: parse$y
};
var _response3$8 = exports$2i;
var exports$2j = {};
const Encoder$x = _encoder;
const {Heartbeat: apiKey$r} = _apiKeys;
exports$2j = ({groupId, groupGenerationId, memberId: memberId1, groupInstanceId}) => ({
    apiKey: apiKey$r,
    apiVersion: 3,
    apiName: "Heartbeat",
    encode: async () => {
        return new Encoder$x().writeString(groupId).writeInt32(groupGenerationId).writeString(memberId1).writeString(groupInstanceId);
    }
})
;
var _request4$7 = exports$2j;
var exports$2k = {};
const {parse: parse$z, decode: decode$Q} = _response3$8;
exports$2k = {
    decode: decode$Q,
    parse: parse$z
};
var _response4$7 = exports$2k;
var exports$2l = {};
const versions$9 = {
    0: ({groupId, groupGenerationId, memberId: memberId1}) => {
        const request = _request$8;
        const response = _response$8;
        return {
            request: request({
                groupId,
                groupGenerationId,
                memberId: memberId1
            }),
            response
        };
    },
    1: ({groupId, groupGenerationId, memberId: memberId1}) => {
        const request = _request2$8;
        const response = _response2$8;
        return {
            request: request({
                groupId,
                groupGenerationId,
                memberId: memberId1
            }),
            response
        };
    },
    2: ({groupId, groupGenerationId, memberId: memberId1}) => {
        const request = _request3$8;
        const response = _response3$8;
        return {
            request: request({
                groupId,
                groupGenerationId,
                memberId: memberId1
            }),
            response
        };
    },
    3: ({groupId, groupGenerationId, memberId: memberId1, groupInstanceId}) => {
        const request = _request4$7;
        const response = _response4$7;
        return {
            request: request({
                groupId,
                groupGenerationId,
                memberId: memberId1,
                groupInstanceId
            }),
            response
        };
    }
};
exports$2l = {
    versions: Object.keys(versions$9),
    protocol: ({version}) => versions$9[version]
};
var _heartbeat = exports$2l;
var exports$2m = {};
const Encoder$y = _encoder;
const {LeaveGroup: apiKey$s} = _apiKeys;
exports$2m = ({groupId, memberId: memberId1}) => ({
    apiKey: apiKey$s,
    apiVersion: 0,
    apiName: "LeaveGroup",
    encode: async () => {
        return new Encoder$y().writeString(groupId).writeString(memberId1);
    }
})
;
var _request$9 = exports$2m;
var exports$2n = {};
const {
    failure: failure$h,
    createErrorFromCode: createErrorFromCode$h,
    failIfVersionNotSupported: failIfVersionNotSupported$8
} = _error;
const decode$R = async (rawData) => {
    const decoder = new _decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$8(errorCode);
    return {
        errorCode
    };
};
const parse$A = async (data) => {
    if (failure$h(data.errorCode)) {
        throw createErrorFromCode$h(data.errorCode);
    }
    return data;
};
exports$2n = {
    decode: decode$R,
    parse: parse$A
};
var _response$9 = exports$2n;
var exports$2o = {};
const requestV0$7 = _request$9;
exports$2o = ({groupId, memberId: memberId1}) => Object.assign(requestV0$7({
    groupId,
    memberId: memberId1
}), {
    apiVersion: 1
})
;
var _request2$9 = exports$2o;
var exports$2p = {};
const {failIfVersionNotSupported: failIfVersionNotSupported$9} = _error;
const {parse: parseV0$a} = _response$9;
const decode$S = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$9(errorCode);
    return {
        throttleTime,
        errorCode
    };
};
exports$2p = {
    decode: decode$S,
    parse: parseV0$a
};
var _response2$9 = exports$2p;
var exports$2q = {};
const requestV1$4 = _request2$9;
exports$2q = ({groupId, memberId: memberId1}) => Object.assign(requestV1$4({
    groupId,
    memberId: memberId1
}), {
    apiVersion: 2
})
;
var _request3$9 = exports$2q;
var exports$2r = {};
const {parse: parse$B, decode: decodeV1$3} = _response2$9;
const decode$T = async (rawData) => {
    const decoded = await decodeV1$3(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$2r = {
    decode: decode$T,
    parse: parse$B
};
var _response3$9 = exports$2r;
var exports$2s = {};
const Encoder$z = _encoder;
const {LeaveGroup: apiKey$t} = _apiKeys;
exports$2s = ({groupId, members}) => ({
    apiKey: apiKey$t,
    apiVersion: 3,
    apiName: "LeaveGroup",
    encode: async () => {
        return new Encoder$z().writeString(groupId).writeArray(members.map((member) => encodeMember(member)
        ));
    }
})
;
const encodeMember = ({memberId: memberId1, groupInstanceId = null}) => {
    return new _encoder().writeString(memberId1).writeString(groupInstanceId);
};
var _request4$8 = exports$2s;
var exports$2t = {};
const {
    failIfVersionNotSupported: failIfVersionNotSupported$a,
    failure: failure$i,
    createErrorFromCode: createErrorFromCode$i
} = _error;
const {parse: parseV2$1} = _response3$9;
const decode$U = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const members = decoder.readArray(decodeMembers);
    failIfVersionNotSupported$a(errorCode);
    return {
        throttleTime: 0,
        clientSideThrottleTime: throttleTime,
        errorCode,
        members
    };
};
const decodeMembers = (decoder) => ({
            memberId: decoder.readString(),
            groupInstanceId: decoder.readString(),
            errorCode: decoder.readInt16()
        })
;
const parse$C = async (data) => {
    const parsed = parseV2$1(data);
    const memberWithError = data.members.find((member) => failure$i(member.errorCode)
    );
    if (memberWithError) {
        throw createErrorFromCode$i(memberWithError.errorCode);
    }
    return parsed;
};
exports$2t = {
    decode: decode$U,
    parse: parse$C
};
var _response4$8 = exports$2t;
var exports$2u = {};
const versions$a = {
    0: ({groupId, memberId: memberId1}) => {
        const request = _request$9;
        const response = _response$9;
        return {
            request: request({
                groupId,
                memberId: memberId1
            }),
            response
        };
    },
    1: ({groupId, memberId: memberId1}) => {
        const request = _request2$9;
        const response = _response2$9;
        return {
            request: request({
                groupId,
                memberId: memberId1
            }),
            response
        };
    },
    2: ({groupId, memberId: memberId1}) => {
        const request = _request3$9;
        const response = _response3$9;
        return {
            request: request({
                groupId,
                memberId: memberId1
            }),
            response
        };
    },
    3: ({groupId, memberId: memberId1, groupInstanceId}) => {
        const request = _request4$8;
        const response = _response4$8;
        return {
            request: request({
                groupId,
                members: [
                    {
                        memberId: memberId1,
                        groupInstanceId
                    }
                ]
            }),
            response
        };
    }
};
exports$2u = {
    versions: Object.keys(versions$a),
    protocol: ({version}) => versions$a[version]
};
var _leaveGroup = exports$2u;
var exports$2v = {};
const Encoder$A = _encoder;
const {SyncGroup: apiKey$u} = _apiKeys;
exports$2v = ({groupId, generationId, memberId: memberId1, groupAssignment}) => ({
    apiKey: apiKey$u,
    apiVersion: 0,
    apiName: "SyncGroup",
    encode: async () => {
        return new Encoder$A().writeString(groupId).writeInt32(generationId).writeString(memberId1).writeArray(groupAssignment.map(encodeGroupAssignment));
    }
})
;
const encodeGroupAssignment = ({memberId: memberId1, memberAssignment}) => {
    return new _encoder().writeString(memberId1).writeBytes(memberAssignment);
};
var _request$a = exports$2v;
var exports$2w = {};
const {
    failure: failure$j,
    createErrorFromCode: createErrorFromCode$j,
    failIfVersionNotSupported: failIfVersionNotSupported$b
} = _error;
const decode$V = async (rawData) => {
    const decoder = new _decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$b(errorCode);
    return {
        errorCode,
        memberAssignment: decoder.readBytes()
    };
};
const parse$D = async (data) => {
    if (failure$j(data.errorCode)) {
        throw createErrorFromCode$j(data.errorCode);
    }
    return data;
};
exports$2w = {
    decode: decode$V,
    parse: parse$D
};
var _response$a = exports$2w;
var exports$2x = {};
const requestV0$8 = _request$a;
exports$2x = ({groupId, generationId, memberId: memberId1, groupAssignment}) => Object.assign(requestV0$8({
    groupId,
    generationId,
    memberId: memberId1,
    groupAssignment
}), {
    apiVersion: 1
})
;
var _request2$a = exports$2x;
var exports$2y = {};
const {failIfVersionNotSupported: failIfVersionNotSupported$c} = _error;
const {parse: parseV0$b} = _response$a;
const decode$W = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$c(errorCode);
    return {
        throttleTime,
        errorCode,
        memberAssignment: decoder.readBytes()
    };
};
exports$2y = {
    decode: decode$W,
    parse: parseV0$b
};
var _response2$a = exports$2y;
var exports$2z = {};
const requestV1$5 = _request2$a;
exports$2z = ({groupId, generationId, memberId: memberId1, groupAssignment}) => Object.assign(requestV1$5({
    groupId,
    generationId,
    memberId: memberId1,
    groupAssignment
}), {
    apiVersion: 2
})
;
var _request3$a = exports$2z;
var exports$2A = {};
const {parse: parse$E, decode: decodeV1$4} = _response2$a;
const decode$X = async (rawData) => {
    const decoded = await decodeV1$4(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$2A = {
    decode: decode$X,
    parse: parse$E
};
var _response3$a = exports$2A;
var exports$2B = {};
const Encoder$B = _encoder;
const {SyncGroup: apiKey$v} = _apiKeys;
exports$2B = ({groupId, generationId, memberId: memberId1, groupInstanceId = null, groupAssignment}) => ({
    apiKey: apiKey$v,
    apiVersion: 3,
    apiName: "SyncGroup",
    encode: async () => {
        return new Encoder$B().writeString(groupId).writeInt32(generationId).writeString(memberId1).writeString(groupInstanceId).writeArray(groupAssignment.map(encodeGroupAssignment$1));
    }
})
;
const encodeGroupAssignment$1 = ({memberId: memberId1, memberAssignment}) => {
    return new _encoder().writeString(memberId1).writeBytes(memberAssignment);
};
var _request4$9 = exports$2B;
var exports$2C = {};
const {decode: decode$Y, parse: parse$F} = _response3$a;
exports$2C = {
    decode: decode$Y,
    parse: parse$F
};
var _response4$9 = exports$2C;
var exports$2D = {};
const versions$b = {
    0: ({groupId, generationId, memberId: memberId1, groupAssignment}) => {
        const request = _request$a;
        const response = _response$a;
        return {
            request: request({
                groupId,
                generationId,
                memberId: memberId1,
                groupAssignment
            }),
            response
        };
    },
    1: ({groupId, generationId, memberId: memberId1, groupAssignment}) => {
        const request = _request2$a;
        const response = _response2$a;
        return {
            request: request({
                groupId,
                generationId,
                memberId: memberId1,
                groupAssignment
            }),
            response
        };
    },
    2: ({groupId, generationId, memberId: memberId1, groupAssignment}) => {
        const request = _request3$a;
        const response = _response3$a;
        return {
            request: request({
                groupId,
                generationId,
                memberId: memberId1,
                groupAssignment
            }),
            response
        };
    },
    3: ({groupId, generationId, memberId: memberId1, groupInstanceId, groupAssignment}) => {
        const request = _request4$9;
        const response = _response4$9;
        return {
            request: request({
                groupId,
                generationId,
                memberId: memberId1,
                groupInstanceId,
                groupAssignment
            }),
            response
        };
    }
};
exports$2D = {
    versions: Object.keys(versions$b),
    protocol: ({version}) => versions$b[version]
};
var _syncGroup = exports$2D;
var exports$2E = {};
const Encoder$C = _encoder;
const {DescribeGroups: apiKey$w} = _apiKeys;
exports$2E = ({groupIds}) => ({
    apiKey: apiKey$w,
    apiVersion: 0,
    apiName: "DescribeGroups",
    encode: async () => {
        return new Encoder$C().writeArray(groupIds);
    }
})
;
var _request$b = exports$2E;
var exports$2F = {};
const {failure: failure$k, createErrorFromCode: createErrorFromCode$k} = _error;
const decoderMember = (decoder) => ({
            memberId: decoder.readString(),
            clientId: decoder.readString(),
            clientHost: decoder.readString(),
            memberMetadata: decoder.readBytes(),
            memberAssignment: decoder.readBytes()
        })
;
const decodeGroup = (decoder) => ({
            errorCode: decoder.readInt16(),
            groupId: decoder.readString(),
            state: decoder.readString(),
            protocolType: decoder.readString(),
            protocol: decoder.readString(),
            members: decoder.readArray(decoderMember)
        })
;
const decode$Z = async (rawData) => {
    const decoder = new _decoder(rawData);
    const groups1 = decoder.readArray(decodeGroup);
    return {
        groups: groups1
    };
};
const parse$G = async (data) => {
    const groupsWithError = data.groups.filter(({errorCode}) => failure$k(errorCode)
    );
    if (groupsWithError.length > 0) {
        throw createErrorFromCode$k(groupsWithError[0].errorCode);
    }
    return data;
};
exports$2F = {
    decode: decode$Z,
    parse: parse$G
};
var _response$b = exports$2F;
var exports$2G = {};
const requestV0$9 = _request$b;
exports$2G = ({groupIds}) => Object.assign(requestV0$9({
    groupIds
}), {
    apiVersion: 1
})
;
var _request2$b = exports$2G;
var exports$2H = {};
const {parse: parseV0$c} = _response$b;
const decoderMember$1 = (decoder) => ({
            memberId: decoder.readString(),
            clientId: decoder.readString(),
            clientHost: decoder.readString(),
            memberMetadata: decoder.readBytes(),
            memberAssignment: decoder.readBytes()
        })
;
const decodeGroup$1 = (decoder) => ({
            errorCode: decoder.readInt16(),
            groupId: decoder.readString(),
            state: decoder.readString(),
            protocolType: decoder.readString(),
            protocol: decoder.readString(),
            members: decoder.readArray(decoderMember$1)
        })
;
const decode$_ = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const groups1 = decoder.readArray(decodeGroup$1);
    return {
        throttleTime,
        groups: groups1
    };
};
exports$2H = {
    decode: decode$_,
    parse: parseV0$c
};
var _response2$b = exports$2H;
var exports$2I = {};
const requestV1$6 = _request2$b;
exports$2I = ({groupIds}) => Object.assign(requestV1$6({
    groupIds
}), {
    apiVersion: 2
})
;
var _request3$b = exports$2I;
var exports$2J = {};
const {parse: parse$H, decode: decodeV1$5} = _response2$b;
const decode$$ = async (rawData) => {
    const decoded = await decodeV1$5(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$2J = {
    decode: decode$$,
    parse: parse$H
};
var _response3$b = exports$2J;
var exports$2K = {};
const versions$c = {
    0: ({groupIds}) => {
        const request = _request$b;
        const response = _response$b;
        return {
            request: request({
                groupIds
            }),
            response
        };
    },
    1: ({groupIds}) => {
        const request = _request2$b;
        const response = _response2$b;
        return {
            request: request({
                groupIds
            }),
            response
        };
    },
    2: ({groupIds}) => {
        const request = _request3$b;
        const response = _response3$b;
        return {
            request: request({
                groupIds
            }),
            response
        };
    }
};
exports$2K = {
    versions: Object.keys(versions$c),
    protocol: ({version}) => versions$c[version]
};
var _describeGroups = exports$2K;
var exports$2L = {};
const Encoder$D = _encoder;
const {ListGroups: apiKey$x} = _apiKeys;
exports$2L = () => ({
    apiKey: apiKey$x,
    apiVersion: 0,
    apiName: "ListGroups",
    encode: async () => {
        return new Encoder$D();
    }
})
;
var _request$c = exports$2L;
var exports$2M = {};
const {failure: failure$l, createErrorFromCode: createErrorFromCode$l} = _error;
const decodeGroup$2 = (decoder) => ({
            groupId: decoder.readString(),
            protocolType: decoder.readString()
        })
;
const decode$10 = async (rawData) => {
    const decoder = new _decoder(rawData);
    const errorCode = decoder.readInt16();
    const groups1 = decoder.readArray(decodeGroup$2);
    return {
        errorCode,
        groups: groups1
    };
};
const parse$I = async (data) => {
    if (failure$l(data.errorCode)) {
        throw createErrorFromCode$l(data.errorCode);
    }
    return data;
};
exports$2M = {
    decodeGroup: decodeGroup$2,
    decode: decode$10,
    parse: parse$I
};
var _response$c = exports$2M;
var exports$2N = {};
const requestV0$a = _request$c;
exports$2N = () => Object.assign(requestV0$a(), {
    apiVersion: 1
})
;
var _request2$c = exports$2N;
var exports$2O = {};
const responseV0 = _response$c;
const decode$11 = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const groups1 = decoder.readArray(responseV0.decodeGroup);
    return {
        throttleTime,
        errorCode,
        groups: groups1
    };
};
exports$2O = {
    decode: decode$11,
    parse: responseV0.parse
};
var _response2$c = exports$2O;
var exports$2P = {};
const requestV1$7 = _request2$c;
exports$2P = () => Object.assign(requestV1$7(), {
    apiVersion: 2
})
;
var _request3$c = exports$2P;
var exports$2Q = {};
const {parse: parse$J, decode: decodeV1$6} = _response2$c;
const decode$12 = async (rawData) => {
    const decoded = await decodeV1$6(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$2Q = {
    decode: decode$12,
    parse: parse$J
};
var _response3$c = exports$2Q;
var exports$2R = {};
const versions$d = {
    0: () => {
        const request = _request$c;
        const response = _response$c;
        return {
            request: request(),
            response
        };
    },
    1: () => {
        const request = _request2$c;
        const response = _response2$c;
        return {
            request: request(),
            response
        };
    },
    2: () => {
        const request = _request3$c;
        const response = _response3$c;
        return {
            request: request(),
            response
        };
    }
};
exports$2R = {
    versions: Object.keys(versions$d),
    protocol: ({version}) => versions$d[version]
};
var _listGroups = exports$2R;
var exports$2S = {};
const Encoder$E = _encoder;
const {SaslHandshake: apiKey$y} = _apiKeys;
exports$2S = ({mechanism}) => ({
    apiKey: apiKey$y,
    apiVersion: 0,
    apiName: "SaslHandshake",
    encode: async () => new Encoder$E().writeString(mechanism)
})
;
var _request$d = exports$2S;
var exports$2T = {};
const {
    failure: failure$m,
    createErrorFromCode: createErrorFromCode$m,
    failIfVersionNotSupported: failIfVersionNotSupported$d
} = _error;
const decode$13 = async (rawData) => {
    const decoder = new _decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$d(errorCode);
    return {
        errorCode,
        enabledMechanisms: decoder.readArray((decoder1) => decoder1.readString()
        )
    };
};
const parse$K = async (data) => {
    if (failure$m(data.errorCode)) {
        throw createErrorFromCode$m(data.errorCode);
    }
    return data;
};
exports$2T = {
    decode: decode$13,
    parse: parse$K
};
var _response$d = exports$2T;
var exports$2U = {};
const requestV0$b = _request$d;
exports$2U = ({mechanism}) => ({
    ...requestV0$b({
        mechanism
    }),
    apiVersion: 1
})
;
var _request2$d = exports$2U;
var exports$2V = {};
const {decode: decodeV0, parse: parseV0$d} = _response$d;
exports$2V = {
    decode: decodeV0,
    parse: parseV0$d
};
var _response2$d = exports$2V;
var exports$2W = {};
const versions$e = {
    0: ({mechanism}) => {
        const request = _request$d;
        const response = _response$d;
        return {
            request: request({
                mechanism
            }),
            response
        };
    },
    1: ({mechanism}) => {
        const request = _request2$d;
        const response = _response2$d;
        return {
            request: request({
                mechanism
            }),
            response
        };
    }
};
exports$2W = {
    versions: Object.keys(versions$e),
    protocol: ({version}) => versions$e[version]
};
var _saslHandshake = exports$2W;
var exports$2X = {};
const Encoder$F = _encoder;
const {ApiVersions: apiKey$z} = _apiKeys;
exports$2X = () => ({
    apiKey: apiKey$z,
    apiVersion: 0,
    apiName: "ApiVersions",
    encode: async () => new Encoder$F()
})
;
var _request$e = exports$2X;
var exports$2Y = {};
const {
    failure: failure$n,
    createErrorFromCode: createErrorFromCode$n,
    failIfVersionNotSupported: failIfVersionNotSupported$e
} = _error;
const apiVersion = (decoder) => ({
            apiKey: decoder.readInt16(),
            minVersion: decoder.readInt16(),
            maxVersion: decoder.readInt16()
        })
;
const decode$14 = async (rawData) => {
    const decoder = new _decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$e(errorCode);
    return {
        errorCode,
        apiVersions: decoder.readArray(apiVersion)
    };
};
const parse$L = async (data) => {
    if (failure$n(data.errorCode)) {
        throw createErrorFromCode$n(data.errorCode);
    }
    return data;
};
exports$2Y = {
    decode: decode$14,
    parse: parse$L
};
var _response$e = exports$2Y;
var exports$2Z = {};
const requestV0$c = _request$e;
exports$2Z = () => ({
    ...requestV0$c(),
    apiVersion: 1
})
;
var _request2$e = exports$2Z;
var exports$2_ = {};
const {failIfVersionNotSupported: failIfVersionNotSupported$f} = _error;
const {parse: parseV0$e} = _response$e;
const apiVersion$1 = (decoder) => ({
            apiKey: decoder.readInt16(),
            minVersion: decoder.readInt16(),
            maxVersion: decoder.readInt16()
        })
;
const decode$15 = async (rawData) => {
    const decoder = new _decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$f(errorCode);
    const apiVersions = decoder.readArray(apiVersion$1);
    const throttleTime = decoder.canReadInt32() ? decoder.readInt32() : 0;
    return {
        errorCode,
        apiVersions,
        throttleTime
    };
};
exports$2_ = {
    decode: decode$15,
    parse: parseV0$e
};
var _response2$e = exports$2_;
var exports$2$ = {};
const requestV0$d = _request$e;
exports$2$ = () => ({
    ...requestV0$d(),
    apiVersion: 2
})
;
var _request3$d = exports$2$;
var exports$30 = {};
const {parse: parse$M, decode: decodeV1$7} = _response2$e;
const decode$16 = async (rawData) => {
    const decoded = await decodeV1$7(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$30 = {
    decode: decode$16,
    parse: parse$M
};
var _response3$d = exports$30;
var exports$311 = {};
const versions$f = {
    0: () => {
        const request = _request$e;
        const response = _response$e;
        return {
            request: request(),
            response,
            logResponseError: true
        };
    },
    1: () => {
        const request = _request2$e;
        const response = _response2$e;
        return {
            request: request(),
            response,
            logResponseError: false
        };
    },
    2: () => {
        const request = _request3$d;
        const response = _response3$d;
        return {
            request: request(),
            response,
            logResponseError: false
        };
    }
};
exports$311 = {
    versions: Object.keys(versions$f),
    protocol: ({version}) => versions$f[version]
};
var _apiVersions = exports$311;
var exports$32 = {};
const Encoder$G = _encoder;
const {CreateTopics: apiKey$A} = _apiKeys;
exports$32 = ({topics, timeout: timeout1 = 5000}) => ({
    apiKey: apiKey$A,
    apiVersion: 0,
    apiName: "CreateTopics",
    encode: async () => {
        return new Encoder$G().writeArray(topics.map(encodeTopics)).writeInt32(timeout1);
    }
})
;
const encodeTopics = ({
    topic: topic3,
    numPartitions = 1,
    replicationFactor = 1,
    replicaAssignment = [],
    configEntries = []
}) => {
    return new _encoder().writeString(topic3).writeInt32(numPartitions).writeInt16(replicationFactor).writeArray(replicaAssignment.map(encodeReplicaAssignment)).writeArray(configEntries.map(encodeConfigEntries));
};
const encodeReplicaAssignment = ({partition: partition2, replicas}) => {
    return new _encoder().writeInt32(partition2).writeArray(replicas);
};
const encodeConfigEntries = ({name, value: value2}) => {
    return new _encoder().writeString(name).writeString(value2);
};
var _request$f = exports$32;
var exports$33 = {};
const {failure: failure$o, createErrorFromCode: createErrorFromCode$o} = _error;
const topicNameComparator = (a49, b19) => a49.topic.localeCompare(b19.topic)
;
const topicErrors = (decoder) => ({
            topic: decoder.readString(),
            errorCode: decoder.readInt16()
        })
;
const decode$17 = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        topicErrors: decoder.readArray(topicErrors).sort(topicNameComparator)
    };
};
const parse$N = async (data) => {
    const topicsWithError = data.topicErrors.filter(({errorCode}) => failure$o(errorCode)
    );
    if (topicsWithError.length > 0) {
        throw createErrorFromCode$o(topicsWithError[0].errorCode);
    }
    return data;
};
exports$33 = {
    decode: decode$17,
    parse: parse$N
};
var _response$f = exports$33;
var exports$34 = {};
const Encoder$H = _encoder;
const {CreateTopics: apiKey$B} = _apiKeys;
exports$34 = ({topics, validateOnly = false, timeout: timeout1 = 5000}) => ({
    apiKey: apiKey$B,
    apiVersion: 1,
    apiName: "CreateTopics",
    encode: async () => {
        return new Encoder$H().writeArray(topics.map(encodeTopics$1)).writeInt32(timeout1).writeBoolean(validateOnly);
    }
})
;
const encodeTopics$1 = ({
    topic: topic3,
    numPartitions = 1,
    replicationFactor = 1,
    replicaAssignment = [],
    configEntries = []
}) => {
    return new _encoder().writeString(topic3).writeInt32(numPartitions).writeInt16(replicationFactor).writeArray(replicaAssignment.map(encodeReplicaAssignment$1)).writeArray(configEntries.map(encodeConfigEntries$1));
};
const encodeReplicaAssignment$1 = ({partition: partition2, replicas}) => {
    return new _encoder().writeInt32(partition2).writeArray(replicas);
};
const encodeConfigEntries$1 = ({name, value: value2}) => {
    return new _encoder().writeString(name).writeString(value2);
};
var _request2$f = exports$34;
var exports$35 = {};
const {failure: failure$p, createErrorFromCode: createErrorFromCode$p} = _error;
const topicNameComparator$1 = (a49, b19) => a49.topic.localeCompare(b19.topic)
;
const topicErrors$1 = (decoder) => ({
            topic: decoder.readString(),
            errorCode: decoder.readInt16(),
            errorMessage: decoder.readString()
        })
;
const decode$18 = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        topicErrors: decoder.readArray(topicErrors$1).sort(topicNameComparator$1)
    };
};
const parse$O = async (data) => {
    const topicsWithError = data.topicErrors.filter(({errorCode}) => failure$p(errorCode)
    );
    if (topicsWithError.length > 0) {
        throw createErrorFromCode$p(topicsWithError[0].errorCode);
    }
    return data;
};
exports$35 = {
    decode: decode$18,
    parse: parse$O
};
var _response2$f = exports$35;
var exports$36 = {};
const requestV1$8 = _request2$f;
exports$36 = ({topics, validateOnly, timeout: timeout1}) => Object.assign(requestV1$8({
    topics,
    validateOnly,
    timeout: timeout1
}), {
    apiVersion: 2
})
;
var _request3$e = exports$36;
var exports$37 = {};
const {parse: parseV1$5} = _response2$f;
const topicNameComparator$2 = (a49, b19) => a49.topic.localeCompare(b19.topic)
;
const topicErrors$2 = (decoder) => ({
            topic: decoder.readString(),
            errorCode: decoder.readInt16(),
            errorMessage: decoder.readString()
        })
;
const decode$19 = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        throttleTime: decoder.readInt32(),
        topicErrors: decoder.readArray(topicErrors$2).sort(topicNameComparator$2)
    };
};
exports$37 = {
    decode: decode$19,
    parse: parseV1$5
};
var _response3$e = exports$37;
var exports$38 = {};
const requestV2$3 = _request3$e;
exports$38 = ({topics, validateOnly, timeout: timeout1}) => Object.assign(requestV2$3({
    topics,
    validateOnly,
    timeout: timeout1
}), {
    apiVersion: 3
})
;
var _request4$a = exports$38;
var exports$39 = {};
const {parse: parse$P, decode: decodeV2$2} = _response3$e;
const decode$1a = async (rawData) => {
    const decoded = await decodeV2$2(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$39 = {
    decode: decode$1a,
    parse: parse$P
};
var _response4$a = exports$39;
var exports$3a = {};
const versions$g = {
    0: ({topics, timeout: timeout1}) => {
        const request = _request$f;
        const response = _response$f;
        return {
            request: request({
                topics,
                timeout: timeout1
            }),
            response
        };
    },
    1: ({topics, validateOnly, timeout: timeout1}) => {
        const request = _request2$f;
        const response = _response2$f;
        return {
            request: request({
                topics,
                validateOnly,
                timeout: timeout1
            }),
            response
        };
    },
    2: ({topics, validateOnly, timeout: timeout1}) => {
        const request = _request3$e;
        const response = _response3$e;
        return {
            request: request({
                topics,
                validateOnly,
                timeout: timeout1
            }),
            response
        };
    },
    3: ({topics, validateOnly, timeout: timeout1}) => {
        const request = _request4$a;
        const response = _response4$a;
        return {
            request: request({
                topics,
                validateOnly,
                timeout: timeout1
            }),
            response
        };
    }
};
exports$3a = {
    versions: Object.keys(versions$g),
    protocol: ({version}) => versions$g[version]
};
var _createTopics = exports$3a;
var exports$3b = {};
const Encoder$I = _encoder;
const {DeleteTopics: apiKey$C} = _apiKeys;
exports$3b = ({topics, timeout: timeout1 = 5000}) => ({
    apiKey: apiKey$C,
    apiVersion: 0,
    apiName: "DeleteTopics",
    encode: async () => {
        return new Encoder$I().writeArray(topics).writeInt32(timeout1);
    }
})
;
var _request$g = exports$3b;
var exports$3c = {};
const {failure: failure$q, createErrorFromCode: createErrorFromCode$q} = _error;
const topicNameComparator$3 = (a49, b19) => a49.topic.localeCompare(b19.topic)
;
const topicErrors$3 = (decoder) => ({
            topic: decoder.readString(),
            errorCode: decoder.readInt16()
        })
;
const decode$1b = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        topicErrors: decoder.readArray(topicErrors$3).sort(topicNameComparator$3)
    };
};
const parse$Q = async (data) => {
    const topicsWithError = data.topicErrors.filter(({errorCode}) => failure$q(errorCode)
    );
    if (topicsWithError.length > 0) {
        throw createErrorFromCode$q(topicsWithError[0].errorCode);
    }
    return data;
};
exports$3c = {
    decode: decode$1b,
    parse: parse$Q
};
var _response$g = exports$3c;
var exports$3d = {};
const requestV0$e = _request$g;
exports$3d = ({topics, timeout: timeout1}) => Object.assign(requestV0$e({
    topics,
    timeout: timeout1
}), {
    apiVersion: 1
})
;
var _request2$g = exports$3d;
var exports$3e = {};
const {parse: parseV0$f} = _response$g;
const topicNameComparator$4 = (a49, b19) => a49.topic.localeCompare(b19.topic)
;
const topicErrors$4 = (decoder) => ({
            topic: decoder.readString(),
            errorCode: decoder.readInt16()
        })
;
const decode$1c = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    return {
        throttleTime: 0,
        clientSideThrottleTime: throttleTime,
        topicErrors: decoder.readArray(topicErrors$4).sort(topicNameComparator$4)
    };
};
exports$3e = {
    decode: decode$1c,
    parse: parseV0$f
};
var _response2$g = exports$3e;
var exports$3f = {};
const versions$h = {
    0: ({topics, timeout: timeout1}) => {
        const request = _request$g;
        const response = _response$g;
        return {
            request: request({
                topics,
                timeout: timeout1
            }),
            response
        };
    },
    1: ({topics, timeout: timeout1}) => {
        const request = _request2$g;
        const response = _response2$g;
        return {
            request: request({
                topics,
                timeout: timeout1
            }),
            response
        };
    }
};
exports$3f = {
    versions: Object.keys(versions$h),
    protocol: ({version}) => versions$h[version]
};
var _deleteTopics = exports$3f;
var exports$3g = {};
const Encoder$J = _encoder;
const {DeleteRecords: apiKey$D} = _apiKeys;
exports$3g = ({topics, timeout: timeout1 = 5000}) => ({
    apiKey: apiKey$D,
    apiVersion: 0,
    apiName: "DeleteRecords",
    encode: async () => {
        return new Encoder$J().writeArray(topics.map(({topic: topic3, partitions: partitions1}) => {
            return new Encoder$J().writeString(topic3).writeArray(partitions1.map(({partition: partition2, offset}) => {
                return new Encoder$J().writeInt32(partition2).writeInt64(offset);
            }));
        })).writeInt32(timeout1);
    }
})
;
var _request$h = exports$3g;
var exports$3h = {};
const {KafkaJSDeleteTopicRecordsError: KafkaJSDeleteTopicRecordsError$1} = _errors;
const {failure: failure$r, createErrorFromCode: createErrorFromCode$r} = _error;
const topicNameComparator$5 = (a49, b19) => a49.topic.localeCompare(b19.topic)
;
const decode$1d = async (rawData) => {
    const decoder = new _decoder(rawData);
    return {
        throttleTime: decoder.readInt32(),
        topics: decoder.readArray((decoder1) => ({
                    topic: decoder1.readString(),
                    partitions: decoder1.readArray((decoder2) => ({
                                partition: decoder2.readInt32(),
                                lowWatermark: decoder2.readInt64(),
                                errorCode: decoder2.readInt16()
                            })
                    )
                })
        ).sort(topicNameComparator$5)
    };
};
const parse$R = (requestTopics) => async (data) => {
            const topicsWithErrors = data.topics.map(({partitions: partitions1}) => ({
                        partitionsWithErrors: partitions1.filter(({errorCode}) => failure$r(errorCode)
                        )
                    })
            ).filter(({partitionsWithErrors}) => partitionsWithErrors.length
            );
            if (topicsWithErrors.length > 0) {
                const [{topic: topic3}] = data.topics;
                const [{partitions: requestPartitions}] = requestTopics;
                const [{partitionsWithErrors}] = topicsWithErrors;
                throw new KafkaJSDeleteTopicRecordsError$1({
                    topic: topic3,
                    partitions: partitionsWithErrors.map(({partition: partition2, errorCode}) => ({
                                partition: partition2,
                                error: createErrorFromCode$r(errorCode),
                                offset: requestPartitions.find((p35) => p35.partition === partition2
                                ).offset
                            })
                    )
                });
            }
            return data;
        }
;
exports$3h = ({topics}) => ({
    decode: decode$1d,
    parse: parse$R(topics)
})
;
var _response$h = exports$3h;
var exports$3i = {};
const requestV0$f = _request$h;
exports$3i = ({topics, timeout: timeout1}) => Object.assign(requestV0$f({
    topics,
    timeout: timeout1
}), {
    apiVersion: 1
})
;
var _request2$h = exports$3i;
var exports$3j = {};
const responseV0$1 = _response$h;
exports$3j = ({topics}) => {
    const {parse: parse1, decode: decodeV01} = responseV0$1({
        topics
    });
    const decode1 = async (rawData) => {
        const decoded = await decodeV01(rawData);
        return {
            ...decoded,
            throttleTime: 0,
            clientSideThrottleTime: decoded.throttleTime
        };
    };
    return {
        decode: decode1,
        parse: parse1
    };
};
var _response2$h = exports$3j;
var exports$3k = {};
const versions$i = {
    0: ({topics, timeout: timeout1}) => {
        const request = _request$h;
        const response = _response$h;
        return {
            request: request({
                topics,
                timeout: timeout1
            }),
            response: response({
                topics
            })
        };
    },
    1: ({topics, timeout: timeout1}) => {
        const request = _request2$h;
        const response = _response2$h;
        return {
            request: request({
                topics,
                timeout: timeout1
            }),
            response: response({
                topics
            })
        };
    }
};
exports$3k = {
    versions: Object.keys(versions$i),
    protocol: ({version}) => versions$i[version]
};
var _deleteRecords = exports$3k;
var exports$3l = {};
const Encoder$K = _encoder;
const {InitProducerId: apiKey$E} = _apiKeys;
exports$3l = ({transactionalId, transactionTimeout}) => ({
    apiKey: apiKey$E,
    apiVersion: 0,
    apiName: "InitProducerId",
    encode: async () => {
        return new Encoder$K().writeString(transactionalId).writeInt32(transactionTimeout);
    }
})
;
var _request$i = exports$3l;
var exports$3m = {};
const {
    failure: failure$s,
    createErrorFromCode: createErrorFromCode$s,
    failIfVersionNotSupported: failIfVersionNotSupported$g
} = _error;
const decode$1e = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$g(errorCode);
    return {
        throttleTime,
        errorCode,
        producerId: decoder.readInt64().toString(),
        producerEpoch: decoder.readInt16()
    };
};
const parse$S = async (data) => {
    if (failure$s(data.errorCode)) {
        throw createErrorFromCode$s(data.errorCode);
    }
    return data;
};
exports$3m = {
    decode: decode$1e,
    parse: parse$S
};
var _response$i = exports$3m;
var exports$3n = {};
const requestV0$g = _request$i;
exports$3n = ({transactionalId, transactionTimeout}) => Object.assign(requestV0$g({
    transactionalId,
    transactionTimeout
}), {
    apiVersion: 1
})
;
var _request2$i = exports$3n;
var exports$3o = {};
const {parse: parse$T, decode: decodeV0$1} = _response$i;
const decode$1f = async (rawData) => {
    const decoded = await decodeV0$1(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$3o = {
    decode: decode$1f,
    parse: parse$T
};
var _response2$i = exports$3o;
var exports$3p = {};
const versions$j = {
    0: ({transactionalId, transactionTimeout = 5000}) => {
        const request = _request$i;
        const response = _response$i;
        return {
            request: request({
                transactionalId,
                transactionTimeout
            }),
            response
        };
    },
    1: ({transactionalId, transactionTimeout = 5000}) => {
        const request = _request2$i;
        const response = _response2$i;
        return {
            request: request({
                transactionalId,
                transactionTimeout
            }),
            response
        };
    }
};
exports$3p = {
    versions: Object.keys(versions$j),
    protocol: ({version}) => versions$j[version]
};
var _initProducerId = exports$3p;
var exports$3q = {};
const Encoder$L = _encoder;
const {AddPartitionsToTxn: apiKey$F} = _apiKeys;
exports$3q = ({transactionalId, producerId, producerEpoch, topics}) => ({
    apiKey: apiKey$F,
    apiVersion: 0,
    apiName: "AddPartitionsToTxn",
    encode: async () => {
        return new Encoder$L().writeString(transactionalId).writeInt64(producerId).writeInt16(producerEpoch).writeArray(topics.map(encodeTopic$h));
    }
})
;
const encodeTopic$h = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$g));
};
const encodePartition$g = (partition2) => {
    return new _encoder().writeInt32(partition2);
};
var _request$j = exports$3q;
var exports$3r = {};
const {failure: failure$t, createErrorFromCode: createErrorFromCode$t} = _error;
const decode$1g = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errors = await decoder.readArrayAsync(decodeError);
    return {
        throttleTime,
        errors
    };
};
const decodeError = async (decoder) => ({
            topic: decoder.readString(),
            partitionErrors: await decoder.readArrayAsync(decodePartitionError)
        })
;
const decodePartitionError = (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16()
        })
;
const parse$U = async (data) => {
    const topicsWithErrors = data.errors.map(({partitionErrors}) => ({
                partitionsWithErrors: partitionErrors.filter(({errorCode}) => failure$t(errorCode)
                )
            })
    ).filter(({partitionsWithErrors}) => partitionsWithErrors.length
    );
    if (topicsWithErrors.length > 0) {
        throw createErrorFromCode$t(topicsWithErrors[0].partitionsWithErrors[0].errorCode);
    }
    return data;
};
exports$3r = {
    decode: decode$1g,
    parse: parse$U
};
var _response$j = exports$3r;
var exports$3s = {};
const requestV0$h = _request$j;
exports$3s = ({transactionalId, producerId, producerEpoch, topics}) => Object.assign(requestV0$h({
    transactionalId,
    producerId,
    producerEpoch,
    topics
}), {
    apiVersion: 1
})
;
var _request2$j = exports$3s;
var exports$3t = {};
const {parse: parse$V, decode: decodeV0$2} = _response$j;
const decode$1h = async (rawData) => {
    const decoded = await decodeV0$2(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$3t = {
    decode: decode$1h,
    parse: parse$V
};
var _response2$j = exports$3t;
var exports$3u = {};
const versions$k = {
    0: ({transactionalId, producerId, producerEpoch, topics}) => {
        const request = _request$j;
        const response = _response$j;
        return {
            request: request({
                transactionalId,
                producerId,
                producerEpoch,
                topics
            }),
            response
        };
    },
    1: ({transactionalId, producerId, producerEpoch, topics}) => {
        const request = _request2$j;
        const response = _response2$j;
        return {
            request: request({
                transactionalId,
                producerId,
                producerEpoch,
                topics
            }),
            response
        };
    }
};
exports$3u = {
    versions: Object.keys(versions$k),
    protocol: ({version}) => versions$k[version]
};
var _addPartitionsToTxn = exports$3u;
var exports$3v = {};
const Encoder$M = _encoder;
const {AddOffsetsToTxn: apiKey$G} = _apiKeys;
exports$3v = ({transactionalId, producerId, producerEpoch, groupId}) => ({
    apiKey: apiKey$G,
    apiVersion: 0,
    apiName: "AddOffsetsToTxn",
    encode: async () => {
        return new Encoder$M().writeString(transactionalId).writeInt64(producerId).writeInt16(producerEpoch).writeString(groupId);
    }
})
;
var _request$k = exports$3v;
var exports$3w = {};
const {
    failure: failure$u,
    createErrorFromCode: createErrorFromCode$u,
    failIfVersionNotSupported: failIfVersionNotSupported$h
} = _error;
const decode$1i = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$h(errorCode);
    return {
        throttleTime,
        errorCode
    };
};
const parse$W = async (data) => {
    if (failure$u(data.errorCode)) {
        throw createErrorFromCode$u(data.errorCode);
    }
    return data;
};
exports$3w = {
    decode: decode$1i,
    parse: parse$W
};
var _response$k = exports$3w;
var exports$3x = {};
const requestV0$i = _request$k;
exports$3x = ({transactionalId, producerId, producerEpoch, groupId}) => Object.assign(requestV0$i({
    transactionalId,
    producerId,
    producerEpoch,
    groupId
}), {
    apiVersion: 1
})
;
var _request2$k = exports$3x;
var exports$3y = {};
const {parse: parse$X, decode: decodeV0$3} = _response$k;
const decode$1j = async (rawData) => {
    const decoded = await decodeV0$3(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$3y = {
    decode: decode$1j,
    parse: parse$X
};
var _response2$k = exports$3y;
var exports$3z = {};
const versions$l = {
    0: ({transactionalId, producerId, producerEpoch, groupId}) => {
        const request = _request$k;
        const response = _response$k;
        return {
            request: request({
                transactionalId,
                producerId,
                producerEpoch,
                groupId
            }),
            response
        };
    },
    1: ({transactionalId, producerId, producerEpoch, groupId}) => {
        const request = _request2$k;
        const response = _response2$k;
        return {
            request: request({
                transactionalId,
                producerId,
                producerEpoch,
                groupId
            }),
            response
        };
    }
};
exports$3z = {
    versions: Object.keys(versions$l),
    protocol: ({version}) => versions$l[version]
};
var _addOffsetsToTxn = exports$3z;
var exports$3A = {};
const Encoder$N = _encoder;
const {EndTxn: apiKey$H} = _apiKeys;
exports$3A = ({transactionalId, producerId, producerEpoch, transactionResult}) => ({
    apiKey: apiKey$H,
    apiVersion: 0,
    apiName: "EndTxn",
    encode: async () => {
        return new Encoder$N().writeString(transactionalId).writeInt64(producerId).writeInt16(producerEpoch).writeBoolean(transactionResult);
    }
})
;
var _request$l = exports$3A;
var exports$3B = {};
const {
    failure: failure$v,
    createErrorFromCode: createErrorFromCode$v,
    failIfVersionNotSupported: failIfVersionNotSupported$i
} = _error;
const decode$1k = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$i(errorCode);
    return {
        throttleTime,
        errorCode
    };
};
const parse$Y = async (data) => {
    if (failure$v(data.errorCode)) {
        throw createErrorFromCode$v(data.errorCode);
    }
    return data;
};
exports$3B = {
    decode: decode$1k,
    parse: parse$Y
};
var _response$l = exports$3B;
var exports$3C = {};
const requestV0$j = _request$l;
exports$3C = ({transactionalId, producerId, producerEpoch, transactionResult}) => Object.assign(requestV0$j({
    transactionalId,
    producerId,
    producerEpoch,
    transactionResult
}), {
    apiVersion: 1
})
;
var _request2$l = exports$3C;
var exports$3D = {};
const {parse: parse$Z, decode: decodeV0$4} = _response$l;
const decode$1l = async (rawData) => {
    const decoded = await decodeV0$4(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$3D = {
    decode: decode$1l,
    parse: parse$Z
};
var _response2$l = exports$3D;
var exports$3E = {};
const versions$m = {
    0: ({transactionalId, producerId, producerEpoch, transactionResult}) => {
        const request = _request$l;
        const response = _response$l;
        return {
            request: request({
                transactionalId,
                producerId,
                producerEpoch,
                transactionResult
            }),
            response
        };
    },
    1: ({transactionalId, producerId, producerEpoch, transactionResult}) => {
        const request = _request2$l;
        const response = _response2$l;
        return {
            request: request({
                transactionalId,
                producerId,
                producerEpoch,
                transactionResult
            }),
            response
        };
    }
};
exports$3E = {
    versions: Object.keys(versions$m),
    protocol: ({version}) => versions$m[version]
};
var _endTxn = exports$3E;
var exports$3F = {};
const Encoder$O = _encoder;
const {TxnOffsetCommit: apiKey$I} = _apiKeys;
exports$3F = ({transactionalId, groupId, producerId, producerEpoch, topics}) => ({
    apiKey: apiKey$I,
    apiVersion: 0,
    apiName: "TxnOffsetCommit",
    encode: async () => {
        return new Encoder$O().writeString(transactionalId).writeString(groupId).writeInt64(producerId).writeInt16(producerEpoch).writeArray(topics.map(encodeTopic$i));
    }
})
;
const encodeTopic$i = ({topic: topic3, partitions: partitions1}) => {
    return new _encoder().writeString(topic3).writeArray(partitions1.map(encodePartition$h));
};
const encodePartition$h = ({partition: partition2, offset, metadata}) => {
    return new _encoder().writeInt32(partition2).writeInt64(offset).writeString(metadata);
};
var _request$m = exports$3F;
var exports$3G = {};
const {failure: failure$w, createErrorFromCode: createErrorFromCode$w} = _error;
const decode$1m = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const topics = await decoder.readArrayAsync(decodeTopic);
    return {
        throttleTime,
        topics
    };
};
const decodeTopic = async (decoder) => ({
            topic: decoder.readString(),
            partitions: await decoder.readArrayAsync(decodePartition$7)
        })
;
const decodePartition$7 = (decoder) => ({
            partition: decoder.readInt32(),
            errorCode: decoder.readInt16()
        })
;
const parse$_ = async (data) => {
    const topicsWithErrors = data.topics.map(({partitions: partitions1}) => ({
                partitionsWithErrors: partitions1.filter(({errorCode}) => failure$w(errorCode)
                )
            })
    ).filter(({partitionsWithErrors}) => partitionsWithErrors.length
    );
    if (topicsWithErrors.length > 0) {
        throw createErrorFromCode$w(topicsWithErrors[0].partitionsWithErrors[0].errorCode);
    }
    return data;
};
exports$3G = {
    decode: decode$1m,
    parse: parse$_
};
var _response$m = exports$3G;
var exports$3H = {};
const requestV0$k = _request$m;
exports$3H = ({transactionalId, groupId, producerId, producerEpoch, topics}) => Object.assign(requestV0$k({
    transactionalId,
    groupId,
    producerId,
    producerEpoch,
    topics
}), {
    apiVersion: 1
})
;
var _request2$m = exports$3H;
var exports$3I = {};
const {parse: parse$$, decode: decodeV1$8} = _response$m;
const decode$1n = async (rawData) => {
    const decoded = await decodeV1$8(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$3I = {
    decode: decode$1n,
    parse: parse$$
};
var _response2$m = exports$3I;
var exports$3J = {};
const versions$n = {
    0: ({transactionalId, groupId, producerId, producerEpoch, topics}) => {
        const request = _request$m;
        const response = _response$m;
        return {
            request: request({
                transactionalId,
                groupId,
                producerId,
                producerEpoch,
                topics
            }),
            response
        };
    },
    1: ({transactionalId, groupId, producerId, producerEpoch, topics}) => {
        const request = _request2$m;
        const response = _response2$m;
        return {
            request: request({
                transactionalId,
                groupId,
                producerId,
                producerEpoch,
                topics
            }),
            response
        };
    }
};
exports$3J = {
    versions: Object.keys(versions$n),
    protocol: ({version}) => versions$n[version]
};
var _txnOffsetCommit = exports$3J;
var exports$3K = {};
const Encoder$P = _encoder;
const {DescribeAcls: apiKey$J} = _apiKeys;
exports$3K = ({resourceType, resourceName, principal, host: host1, operation, permissionType}) => ({
    apiKey: apiKey$J,
    apiVersion: 0,
    apiName: "DescribeAcls",
    encode: async () => {
        return new Encoder$P().writeInt8(resourceType).writeString(resourceName).writeString(principal).writeString(host1).writeInt8(operation).writeInt8(permissionType);
    }
})
;
var _request$n = exports$3K;
var exports$3L = {};
const {failure: failure$x, createErrorFromCode: createErrorFromCode$x} = _error;
const decodeAcls = (decoder) => ({
            principal: decoder.readString(),
            host: decoder.readString(),
            operation: decoder.readInt8(),
            permissionType: decoder.readInt8()
        })
;
const decodeResources = (decoder) => ({
            resourceType: decoder.readInt8(),
            resourceName: decoder.readString(),
            acls: decoder.readArray(decodeAcls)
        })
;
const decode$1o = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const errorMessage = decoder.readString();
    const resources = decoder.readArray(decodeResources);
    return {
        throttleTime,
        errorCode,
        errorMessage,
        resources
    };
};
const parse$10 = async (data) => {
    if (failure$x(data.errorCode)) {
        throw createErrorFromCode$x(data.errorCode);
    }
    return data;
};
exports$3L = {
    decode: decode$1o,
    parse: parse$10
};
var _response$n = exports$3L;
var exports$3M = {};
const Encoder$Q = _encoder;
const {DescribeAcls: apiKey$K} = _apiKeys;
exports$3M = ({
    resourceType,
    resourceName,
    resourcePatternType,
    principal,
    host: host1,
    operation,
    permissionType
}) => ({
    apiKey: apiKey$K,
    apiVersion: 1,
    apiName: "DescribeAcls",
    encode: async () => {
        return new Encoder$Q().writeInt8(resourceType).writeString(resourceName).writeInt8(resourcePatternType).writeString(principal).writeString(host1).writeInt8(operation).writeInt8(permissionType);
    }
})
;
var _request2$n = exports$3M;
var exports$3N = {};
const {parse: parse$11} = _response$n;
const decodeAcls$1 = (decoder) => ({
            principal: decoder.readString(),
            host: decoder.readString(),
            operation: decoder.readInt8(),
            permissionType: decoder.readInt8()
        })
;
const decodeResources$1 = (decoder) => ({
            resourceType: decoder.readInt8(),
            resourceName: decoder.readString(),
            resourcePatternType: decoder.readInt8(),
            acls: decoder.readArray(decodeAcls$1)
        })
;
const decode$1p = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const errorMessage = decoder.readString();
    const resources = decoder.readArray(decodeResources$1);
    return {
        throttleTime: 0,
        clientSideThrottleTime: throttleTime,
        errorCode,
        errorMessage,
        resources
    };
};
exports$3N = {
    decode: decode$1p,
    parse: parse$11
};
var _response2$n = exports$3N;
var exports$3O = {};
const versions$o = {
    0: ({resourceType, resourceName, principal, host: host1, operation, permissionType}) => {
        const request = _request$n;
        const response = _response$n;
        return {
            request: request({
                resourceType,
                resourceName,
                principal,
                host: host1,
                operation,
                permissionType
            }),
            response
        };
    },
    1: ({resourceType, resourceName, resourcePatternType, principal, host: host1, operation, permissionType}) => {
        const request = _request2$n;
        const response = _response2$n;
        return {
            request: request({
                resourceType,
                resourceName,
                resourcePatternType,
                principal,
                host: host1,
                operation,
                permissionType
            }),
            response
        };
    }
};
exports$3O = {
    versions: Object.keys(versions$o),
    protocol: ({version}) => versions$o[version]
};
var _describeAcls = exports$3O;
var exports$3P = {};
const Encoder$R = _encoder;
const {CreateAcls: apiKey$L} = _apiKeys;
const encodeCreations = ({resourceType, resourceName, principal, host: host1, operation, permissionType}) => {
    return new _encoder().writeInt8(resourceType).writeString(resourceName).writeString(principal).writeString(host1).writeInt8(operation).writeInt8(permissionType);
};
exports$3P = ({creations}) => ({
    apiKey: apiKey$L,
    apiVersion: 0,
    apiName: "CreateAcls",
    encode: async () => {
        return new Encoder$R().writeArray(creations.map(encodeCreations));
    }
})
;
var _request$o = exports$3P;
var exports$3Q = {};
const {failure: failure$y, createErrorFromCode: createErrorFromCode$y} = _error;
const decodeCreationResponse = (decoder) => ({
            errorCode: decoder.readInt16(),
            errorMessage: decoder.readString()
        })
;
const decode$1q = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const creationResponses = decoder.readArray(decodeCreationResponse);
    return {
        throttleTime,
        creationResponses
    };
};
const parse$12 = async (data) => {
    const creationResponsesWithError = data.creationResponses.filter(({errorCode}) => failure$y(errorCode)
    );
    if (creationResponsesWithError.length > 0) {
        throw createErrorFromCode$y(creationResponsesWithError[0].errorCode);
    }
    return data;
};
exports$3Q = {
    decode: decode$1q,
    parse: parse$12
};
var _response$o = exports$3Q;
var exports$3R = {};
const Encoder$S = _encoder;
const {CreateAcls: apiKey$M} = _apiKeys;
const encodeCreations$1 = ({
    resourceType,
    resourceName,
    resourcePatternType,
    principal,
    host: host1,
    operation,
    permissionType
}) => {
    return new _encoder().writeInt8(resourceType).writeString(resourceName).writeInt8(resourcePatternType).writeString(principal).writeString(host1).writeInt8(operation).writeInt8(permissionType);
};
exports$3R = ({creations}) => ({
    apiKey: apiKey$M,
    apiVersion: 1,
    apiName: "CreateAcls",
    encode: async () => {
        return new Encoder$S().writeArray(creations.map(encodeCreations$1));
    }
})
;
var _request2$o = exports$3R;
var exports$3S = {};
const {parse: parse$13, decode: decodeV0$5} = _response$o;
const decode$1r = async (rawData) => {
    const decoded = await decodeV0$5(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$3S = {
    decode: decode$1r,
    parse: parse$13
};
var _response2$o = exports$3S;
var exports$3T = {};
const versions$p = {
    0: ({creations}) => {
        const request = _request$o;
        const response = _response$o;
        return {
            request: request({
                creations
            }),
            response
        };
    },
    1: ({creations}) => {
        const request = _request2$o;
        const response = _response2$o;
        return {
            request: request({
                creations
            }),
            response
        };
    }
};
exports$3T = {
    versions: Object.keys(versions$p),
    protocol: ({version}) => versions$p[version]
};
var _createAcls = exports$3T;
var exports$3U = {};
const Encoder$T = _encoder;
const {DeleteAcls: apiKey$N} = _apiKeys;
const encodeFilters = ({resourceType, resourceName, principal, host: host1, operation, permissionType}) => {
    return new _encoder().writeInt8(resourceType).writeString(resourceName).writeString(principal).writeString(host1).writeInt8(operation).writeInt8(permissionType);
};
exports$3U = ({filters}) => ({
    apiKey: apiKey$N,
    apiVersion: 0,
    apiName: "DeleteAcls",
    encode: async () => {
        return new Encoder$T().writeArray(filters.map(encodeFilters));
    }
})
;
var _request$p = exports$3U;
var exports$3V = {};
const {failure: failure$z, createErrorFromCode: createErrorFromCode$z} = _error;
const decodeMatchingAcls = (decoder) => ({
            errorCode: decoder.readInt16(),
            errorMessage: decoder.readString(),
            resourceType: decoder.readInt8(),
            resourceName: decoder.readString(),
            principal: decoder.readString(),
            host: decoder.readString(),
            operation: decoder.readInt8(),
            permissionType: decoder.readInt8()
        })
;
const decodeFilterResponse = (decoder) => ({
            errorCode: decoder.readInt16(),
            errorMessage: decoder.readString(),
            matchingAcls: decoder.readArray(decodeMatchingAcls)
        })
;
const decode$1s = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const filterResponses = decoder.readArray(decodeFilterResponse);
    return {
        throttleTime,
        filterResponses
    };
};
const parse$14 = async (data) => {
    const filterResponsesWithError = data.filterResponses.filter(({errorCode}) => failure$z(errorCode)
    );
    if (filterResponsesWithError.length > 0) {
        throw createErrorFromCode$z(filterResponsesWithError[0].errorCode);
    }
    for (const filterResponse of data.filterResponses) {
        const matchingAcls = filterResponse.matchingAcls;
        const matchingAclsWithError = matchingAcls.filter(({errorCode}) => failure$z(errorCode)
        );
        if (matchingAclsWithError.length > 0) {
            throw createErrorFromCode$z(matchingAclsWithError[0].errorCode);
        }
    }
    return data;
};
exports$3V = {
    decodeMatchingAcls,
    decodeFilterResponse,
    decode: decode$1s,
    parse: parse$14
};
var _response$p = exports$3V;
var exports$3W = {};
const Encoder$U = _encoder;
const {DeleteAcls: apiKey$O} = _apiKeys;
const encodeFilters$1 = ({
    resourceType,
    resourceName,
    resourcePatternType,
    principal,
    host: host1,
    operation,
    permissionType
}) => {
    return new _encoder().writeInt8(resourceType).writeString(resourceName).writeInt8(resourcePatternType).writeString(principal).writeString(host1).writeInt8(operation).writeInt8(permissionType);
};
exports$3W = ({filters}) => ({
    apiKey: apiKey$O,
    apiVersion: 1,
    apiName: "DeleteAcls",
    encode: async () => {
        return new Encoder$U().writeArray(filters.map(encodeFilters$1));
    }
})
;
var _request2$p = exports$3W;
var exports$3X = {};
const {parse: parseV0$g} = _response$p;
const decodeMatchingAcls$1 = (decoder) => ({
            errorCode: decoder.readInt16(),
            errorMessage: decoder.readString(),
            resourceType: decoder.readInt8(),
            resourceName: decoder.readString(),
            resourcePatternType: decoder.readInt8(),
            principal: decoder.readString(),
            host: decoder.readString(),
            operation: decoder.readInt8(),
            permissionType: decoder.readInt8()
        })
;
const decodeFilterResponse$1 = (decoder) => ({
            errorCode: decoder.readInt16(),
            errorMessage: decoder.readString(),
            matchingAcls: decoder.readArray(decodeMatchingAcls$1)
        })
;
const decode$1t = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const filterResponses = decoder.readArray(decodeFilterResponse$1);
    return {
        throttleTime: 0,
        clientSideThrottleTime: throttleTime,
        filterResponses
    };
};
exports$3X = {
    decode: decode$1t,
    parse: parseV0$g
};
var _response2$p = exports$3X;
var exports$3Y = {};
const versions$q = {
    0: ({filters}) => {
        const request = _request$p;
        const response = _response$p;
        return {
            request: request({
                filters
            }),
            response
        };
    },
    1: ({filters}) => {
        const request = _request2$p;
        const response = _response2$p;
        return {
            request: request({
                filters
            }),
            response
        };
    }
};
exports$3Y = {
    versions: Object.keys(versions$q),
    protocol: ({version}) => versions$q[version]
};
var _deleteAcls = exports$3Y;
var exports$3Z = {};
const Encoder$V = _encoder;
const {DescribeConfigs: apiKey$P} = _apiKeys;
exports$3Z = ({resources}) => ({
    apiKey: apiKey$P,
    apiVersion: 0,
    apiName: "DescribeConfigs",
    encode: async () => {
        return new Encoder$V().writeArray(resources.map(encodeResource));
    }
})
;
const encodeResource = ({type: type1, name, configNames = []}) => {
    return new _encoder().writeInt8(type1).writeString(name).writeNullableArray(configNames);
};
var _request$q = exports$3Z;
var exports$3_ = {};
const {failure: failure$A, createErrorFromCode: createErrorFromCode$A} = _error;
const decodeConfigEntries = (decoder) => ({
            configName: decoder.readString(),
            configValue: decoder.readString(),
            readOnly: decoder.readBoolean(),
            isDefault: decoder.readBoolean(),
            isSensitive: decoder.readBoolean()
        })
;
const decodeResources$2 = (decoder) => ({
            errorCode: decoder.readInt16(),
            errorMessage: decoder.readString(),
            resourceType: decoder.readInt8(),
            resourceName: decoder.readString(),
            configEntries: decoder.readArray(decodeConfigEntries)
        })
;
const decode$1u = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const resources = decoder.readArray(decodeResources$2);
    return {
        throttleTime,
        resources
    };
};
const parse$15 = async (data) => {
    const resourcesWithError = data.resources.filter(({errorCode}) => failure$A(errorCode)
    );
    if (resourcesWithError.length > 0) {
        throw createErrorFromCode$A(resourcesWithError[0].errorCode);
    }
    return data;
};
exports$3_ = {
    decode: decode$1u,
    parse: parse$15
};
var _response$q = exports$3_;
var exports$3$ = {};
const Encoder$W = _encoder;
const {DescribeConfigs: apiKey$Q} = _apiKeys;
exports$3$ = ({resources, includeSynonyms = false}) => ({
    apiKey: apiKey$Q,
    apiVersion: 1,
    apiName: "DescribeConfigs",
    encode: async () => {
        return new Encoder$W().writeArray(resources.map(encodeResource$1)).writeBoolean(includeSynonyms);
    }
})
;
const encodeResource$1 = ({type: type1, name, configNames = []}) => {
    return new _encoder().writeInt8(type1).writeString(name).writeNullableArray(configNames);
};
var _request2$q = exports$3$;
var exports$40 = {};
const {parse: parseV0$h} = _response$q;
const decodeSynonyms = (decoder) => ({
            configName: decoder.readString(),
            configValue: decoder.readString(),
            configSource: decoder.readInt8()
        })
;
const decodeConfigEntries$1 = (decoder) => ({
            configName: decoder.readString(),
            configValue: decoder.readString(),
            readOnly: decoder.readBoolean(),
            isDefault: decoder.readBoolean(),
            isSensitive: decoder.readBoolean(),
            configSynonyms: decoder.readArray(decodeSynonyms)
        })
;
const decodeResources$3 = (decoder) => ({
            errorCode: decoder.readInt16(),
            errorMessage: decoder.readString(),
            resourceType: decoder.readInt8(),
            resourceName: decoder.readString(),
            configEntries: decoder.readArray(decodeConfigEntries$1)
        })
;
const decode$1v = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const resources = decoder.readArray(decodeResources$3);
    return {
        throttleTime,
        resources
    };
};
exports$40 = {
    decode: decode$1v,
    parse: parseV0$h
};
var _response2$q = exports$40;
var exports$41 = {};
const requestV1$9 = _request2$q;
exports$41 = ({resources, includeSynonyms}) => Object.assign(requestV1$9({
    resources,
    includeSynonyms
}), {
    apiVersion: 2
})
;
var _request3$f = exports$41;
var exports$42 = {};
const {parse: parse$16, decode: decodeV1$9} = _response2$q;
const decode$1w = async (rawData) => {
    const decoded = await decodeV1$9(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$42 = {
    decode: decode$1w,
    parse: parse$16
};
var _response3$f = exports$42;
var exports$43 = {};
const versions$r = {
    0: ({resources}) => {
        const request = _request$q;
        const response = _response$q;
        return {
            request: request({
                resources
            }),
            response
        };
    },
    1: ({resources, includeSynonyms}) => {
        const request = _request2$q;
        const response = _response2$q;
        return {
            request: request({
                resources,
                includeSynonyms
            }),
            response
        };
    },
    2: ({resources, includeSynonyms}) => {
        const request = _request3$f;
        const response = _response3$f;
        return {
            request: request({
                resources,
                includeSynonyms
            }),
            response
        };
    }
};
exports$43 = {
    versions: Object.keys(versions$r),
    protocol: ({version}) => versions$r[version]
};
var _describeConfigs = exports$43;
var exports$44 = {};
const Encoder$X = _encoder;
const {AlterConfigs: apiKey$R} = _apiKeys;
exports$44 = ({resources, validateOnly = false}) => ({
    apiKey: apiKey$R,
    apiVersion: 0,
    apiName: "AlterConfigs",
    encode: async () => {
        return new Encoder$X().writeArray(resources.map(encodeResource$2)).writeBoolean(validateOnly);
    }
})
;
const encodeResource$2 = ({type: type1, name, configEntries}) => {
    return new _encoder().writeInt8(type1).writeString(name).writeArray(configEntries.map(encodeConfigEntries$2));
};
const encodeConfigEntries$2 = ({name, value: value2}) => {
    return new _encoder().writeString(name).writeString(value2);
};
var _request$r = exports$44;
var exports$45 = {};
const {failure: failure$B, createErrorFromCode: createErrorFromCode$B} = _error;
const decodeResources$4 = (decoder) => ({
            errorCode: decoder.readInt16(),
            errorMessage: decoder.readString(),
            resourceType: decoder.readInt8(),
            resourceName: decoder.readString()
        })
;
const decode$1x = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    const resources = decoder.readArray(decodeResources$4);
    return {
        throttleTime,
        resources
    };
};
const parse$17 = async (data) => {
    const resourcesWithError = data.resources.filter(({errorCode}) => failure$B(errorCode)
    );
    if (resourcesWithError.length > 0) {
        throw createErrorFromCode$B(resourcesWithError[0].errorCode);
    }
    return data;
};
exports$45 = {
    decode: decode$1x,
    parse: parse$17
};
var _response$r = exports$45;
var exports$46 = {};
const requestV0$l = _request$r;
exports$46 = ({resources, validateOnly}) => Object.assign(requestV0$l({
    resources,
    validateOnly
}), {
    apiVersion: 1
})
;
var _request2$r = exports$46;
var exports$47 = {};
const {parse: parse$18, decode: decodeV0$6} = _response$r;
const decode$1y = async (rawData) => {
    const decoded = await decodeV0$6(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$47 = {
    decode: decode$1y,
    parse: parse$18
};
var _response2$r = exports$47;
var exports$48 = {};
const versions$s = {
    0: ({resources, validateOnly}) => {
        const request = _request$r;
        const response = _response$r;
        return {
            request: request({
                resources,
                validateOnly
            }),
            response
        };
    },
    1: ({resources, validateOnly}) => {
        const request = _request2$r;
        const response = _response2$r;
        return {
            request: request({
                resources,
                validateOnly
            }),
            response
        };
    }
};
exports$48 = {
    versions: Object.keys(versions$s),
    protocol: ({version}) => versions$s[version]
};
var _alterConfigs = exports$48;
var exports$49 = {};
const Encoder$Y = _encoder;
const {SaslAuthenticate: apiKey$S} = _apiKeys;
exports$49 = ({authBytes}) => ({
    apiKey: apiKey$S,
    apiVersion: 0,
    apiName: "SaslAuthenticate",
    encode: async () => {
        return new Encoder$Y().writeBuffer(authBytes);
    }
})
;
var _request$s = exports$49;
var exports$4a = {};
const {
    failure: failure$C,
    createErrorFromCode: createErrorFromCode$C,
    failIfVersionNotSupported: failIfVersionNotSupported$j,
    errorCodes: errorCodes$4
} = _error;
const {KafkaJSProtocolError: KafkaJSProtocolError$2} = _errors;
const protocolAuthError = errorCodes$4.find((e46) => e46.code === 58
);
const decode$1z = async (rawData) => {
    const decoder = new _decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$j(errorCode);
    const errorMessage = decoder.readString();
    const authBytesEncoder = new _encoder().writeBytes(decoder.readBytes());
    const authBytes = authBytesEncoder.buffer;
    return {
        errorCode,
        errorMessage,
        authBytes
    };
};
const parse$19 = async (data) => {
    if (data.errorCode === 58 && data.errorMessage) {
        throw new KafkaJSProtocolError$2({
            ...protocolAuthError,
            message: data.errorMessage
        });
    }
    if (failure$C(data.errorCode)) {
        throw createErrorFromCode$C(data.errorCode);
    }
    return data;
};
exports$4a = {
    decode: decode$1z,
    parse: parse$19
};
var _response$s = exports$4a;
var exports$4b = {};
const requestV0$m = _request$s;
exports$4b = ({authBytes}) => Object.assign(requestV0$m({
    authBytes
}), {
    apiVersion: 1
})
;
var _request2$s = exports$4b;
var exports$4c = {};
const {parse: parseV0$i} = _response$s;
const {failIfVersionNotSupported: failIfVersionNotSupported$k} = _error;
const decode$1A = async (rawData) => {
    const decoder = new _decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported$k(errorCode);
    const errorMessage = decoder.readString();
    const authBytesEncoder = new _encoder().writeBytes(decoder.readBytes());
    const authBytes = authBytesEncoder.buffer;
    const sessionLifetimeMs = decoder.readInt64().toString();
    return {
        errorCode,
        errorMessage,
        authBytes,
        sessionLifetimeMs
    };
};
exports$4c = {
    decode: decode$1A,
    parse: parseV0$i
};
var _response2$s = exports$4c;
var exports$4d = {};
const versions$t = {
    0: ({authBytes}) => {
        const request = _request$s;
        const response = _response$s;
        return {
            request: request({
                authBytes
            }),
            response
        };
    },
    1: ({authBytes}) => {
        const request = _request2$s;
        const response = _response2$s;
        return {
            request: request({
                authBytes
            }),
            response
        };
    }
};
exports$4d = {
    versions: Object.keys(versions$t),
    protocol: ({version}) => versions$t[version]
};
var _saslAuthenticate = exports$4d;
var exports$4e = {};
const Encoder$$ = _encoder;
const {CreatePartitions: apiKey$T} = _apiKeys;
exports$4e = ({topicPartitions, validateOnly = false, timeout: timeout1 = 5000}) => ({
    apiKey: apiKey$T,
    apiVersion: 0,
    apiName: "CreatePartitions",
    encode: async () => {
        return new Encoder$$().writeArray(topicPartitions.map(encodeTopicPartitions)).writeInt32(timeout1).writeBoolean(validateOnly);
    }
})
;
const encodeTopicPartitions = ({topic: topic3, count, assignments = []}) => {
    return new _encoder().writeString(topic3).writeInt32(count).writeNullableArray(assignments.map(encodeAssignments));
};
const encodeAssignments = (brokerIds) => {
    return new _encoder().writeNullableArray(brokerIds);
};
var _request$t = exports$4e;
var exports$4f = {};
const {failure: failure$D, createErrorFromCode: createErrorFromCode$D} = _error;
const topicNameComparator$6 = (a49, b19) => a49.topic.localeCompare(b19.topic)
;
const topicErrors$5 = (decoder) => ({
            topic: decoder.readString(),
            errorCode: decoder.readInt16(),
            errorMessage: decoder.readString()
        })
;
const decode$1B = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTime = decoder.readInt32();
    return {
        throttleTime,
        topicErrors: decoder.readArray(topicErrors$5).sort(topicNameComparator$6)
    };
};
const parse$1a = async (data) => {
    const topicsWithError = data.topicErrors.filter(({errorCode}) => failure$D(errorCode)
    );
    if (topicsWithError.length > 0) {
        throw createErrorFromCode$D(topicsWithError[0].errorCode);
    }
    return data;
};
exports$4f = {
    decode: decode$1B,
    parse: parse$1a
};
var _response$t = exports$4f;
var exports$4g = {};
const requestV0$n = _request$t;
exports$4g = ({topicPartitions, validateOnly, timeout: timeout1}) => Object.assign(requestV0$n({
    topicPartitions,
    validateOnly,
    timeout: timeout1
}), {
    apiVersion: 1
})
;
var _request2$t = exports$4g;
var exports$4h = {};
const {parse: parse$1b, decode: decodeV0$7} = _response$t;
const decode$1C = async (rawData) => {
    const decoded = await decodeV0$7(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$4h = {
    decode: decode$1C,
    parse: parse$1b
};
var _response2$t = exports$4h;
var exports$4i = {};
const versions$u = {
    0: ({topicPartitions, timeout: timeout1, validateOnly}) => {
        const request = _request$t;
        const response = _response$t;
        return {
            request: request({
                topicPartitions,
                timeout: timeout1,
                validateOnly
            }),
            response
        };
    },
    1: ({topicPartitions, validateOnly, timeout: timeout1}) => {
        const request = _request2$t;
        const response = _response2$t;
        return {
            request: request({
                topicPartitions,
                validateOnly,
                timeout: timeout1
            }),
            response
        };
    }
};
exports$4i = {
    versions: Object.keys(versions$u),
    protocol: ({version}) => versions$u[version]
};
var _createPartitions = exports$4i;
var exports$4j = {};
const Encoder$10 = _encoder;
const {DeleteGroups: apiKey$U} = _apiKeys;
exports$4j = (groupIds) => ({
    apiKey: apiKey$U,
    apiVersion: 0,
    apiName: "DeleteGroups",
    encode: async () => {
        return new Encoder$10().writeArray(groupIds.map(encodeGroups));
    }
})
;
const encodeGroups = (group) => {
    return new _encoder().writeString(group);
};
var _request$u = exports$4j;
var exports$4k = {};
const {failure: failure$E, createErrorFromCode: createErrorFromCode$E} = _error;
const decodeGroup$3 = (decoder) => ({
            groupId: decoder.readString(),
            errorCode: decoder.readInt16()
        })
;
const decode$1D = async (rawData) => {
    const decoder = new _decoder(rawData);
    const throttleTimeMs = decoder.readInt32();
    const results = decoder.readArray(decodeGroup$3);
    for (const result of results) {
        if (failure$E(result.errorCode)) {
            result.error = createErrorFromCode$E(result.errorCode);
        }
    }
    return {
        throttleTimeMs,
        results
    };
};
const parse$1c = async (data) => {
    return data;
};
exports$4k = {
    decode: decode$1D,
    parse: parse$1c
};
var _response$u = exports$4k;
var exports$4l = {};
const requestV0$o = _request$u;
exports$4l = (groupIds) => Object.assign(requestV0$o(groupIds), {
    apiVersion: 1
})
;
var _request2$u = exports$4l;
var exports$4m = {};
const {parse: parse$1d, decode: decodeV0$8} = _response$u;
const decode$1E = async (rawData) => {
    const decoded = await decodeV0$8(rawData);
    return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
    };
};
exports$4m = {
    decode: decode$1E,
    parse: parse$1d
};
var _response2$u = exports$4m;
var exports$4n = {};
const versions$v = {
    0: (groupIds) => {
        const request = _request$u;
        const response = _response$u;
        return {
            request: request(groupIds),
            response
        };
    },
    1: (groupIds) => {
        const request = _request2$u;
        const response = _response2$u;
        return {
            request: request(groupIds),
            response
        };
    }
};
exports$4n = {
    versions: Object.keys(versions$v),
    protocol: ({version}) => versions$v[version]
};
var _deleteGroups = exports$4n;
var _global1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
var exports$4o = {};
const apiKeys = _apiKeys;
const {KafkaJSServerDoesNotSupportApiKey: KafkaJSServerDoesNotSupportApiKey$1} = _errors;
const requests = {
    Produce: _produce,
    Fetch: _fetch,
    ListOffsets: _listOffsets,
    Metadata: _metadata,
    LeaderAndIsr: {},
    StopReplica: {},
    UpdateMetadata: {},
    ControlledShutdown: {},
    OffsetCommit: _offsetCommit,
    OffsetFetch: _offsetFetch,
    GroupCoordinator: _findCoordinator,
    JoinGroup: _joinGroup,
    Heartbeat: _heartbeat,
    LeaveGroup: _leaveGroup,
    SyncGroup: _syncGroup,
    DescribeGroups: _describeGroups,
    ListGroups: _listGroups,
    SaslHandshake: _saslHandshake,
    ApiVersions: _apiVersions,
    CreateTopics: _createTopics,
    DeleteTopics: _deleteTopics,
    DeleteRecords: _deleteRecords,
    InitProducerId: _initProducerId,
    OffsetForLeaderEpoch: {},
    AddPartitionsToTxn: _addPartitionsToTxn,
    AddOffsetsToTxn: _addOffsetsToTxn,
    EndTxn: _endTxn,
    WriteTxnMarkers: {},
    TxnOffsetCommit: _txnOffsetCommit,
    DescribeAcls: _describeAcls,
    CreateAcls: _createAcls,
    DeleteAcls: _deleteAcls,
    DescribeConfigs: _describeConfigs,
    AlterConfigs: _alterConfigs,
    AlterReplicaLogDirs: {},
    DescribeLogDirs: {},
    SaslAuthenticate: _saslAuthenticate,
    CreatePartitions: _createPartitions,
    CreateDelegationToken: {},
    RenewDelegationToken: {},
    ExpireDelegationToken: {},
    DescribeDelegationToken: {},
    DeleteGroups: _deleteGroups
};
const names = Object.keys(apiKeys);
const keys = Object.values(apiKeys);
const findApiName = (apiKey2) => names[keys.indexOf(apiKey2)]
;
const lookup = (versions1) => (apiKey2, definition) => {
            const version = versions1[apiKey2];
            const availableVersions = definition.versions.map(Number);
            const bestImplementedVersion = Math.max.apply(undefined || _global1, availableVersions);
            if (!version || version.maxVersion == null) {
                throw new KafkaJSServerDoesNotSupportApiKey$1(`The Kafka server does not support the requested API version`, {
                    apiKey: apiKey2,
                    apiName: findApiName(apiKey2)
                });
            }
            const bestSupportedVersion = Math.min(bestImplementedVersion, version.maxVersion);
            return definition.protocol({
                version: bestSupportedVersion
            });
        }
;
exports$4o = {
    requests,
    lookup
};
var _requests = exports$4o;
var exports$4p = {};
const Encoder$11 = _encoder;
const US_ASCII_NULL_CHAR = "\0";
exports$4p = ({authorizationIdentity = null, username, password}) => ({
    encode: async () => {
        return new Encoder$11().writeBytes([
            authorizationIdentity,
            username,
            password
        ].join(US_ASCII_NULL_CHAR));
    }
})
;
var _request$v = exports$4p;
var exports$4q = {};
exports$4q = {
    decode: async () => true
    ,
    parse: async () => true
};
var _response$v = exports$4q;
var exports$4r = {};
exports$4r = {
    request: _request$v,
    response: _response$v
};
var _plain = exports$4r;
var exports$4s = {};
const plain = _plain;
const {KafkaJSSASLAuthenticationError: KafkaJSSASLAuthenticationError$1} = _errors;
exports$4s = class PlainAuthenticator {
    constructor(connection, logger, saslAuthenticate) {
        this.connection = connection;
        this.logger = logger.namespace("SASLPlainAuthenticator");
        this.saslAuthenticate = saslAuthenticate;
    }

    async authenticate() {
        const {sasl} = this.connection;
        if (sasl.username == null || sasl.password == null) {
            throw new KafkaJSSASLAuthenticationError$1("SASL Plain: Invalid username or password");
        }
        const request = plain.request(sasl);
        const response = plain.response;
        const {host: host1, port: port1} = this.connection;
        const broker3 = `${host1}:${port1}`;
        try {
            this.logger.debug("Authenticate with SASL PLAIN", {
                broker: broker3
            });
            await this.saslAuthenticate({
                request,
                response
            });
            this.logger.debug("SASL PLAIN authentication successful", {
                broker: broker3
            });
        } catch (e46) {
            const error = new KafkaJSSASLAuthenticationError$1(`SASL PLAIN authentication failed: ${e46.message}`);
            this.logger.error(error.message, {
                broker: broker3
            });
            throw error;
        }
    }
};
var _plain$1 = exports$4s;
var exports$4t = {};
const Encoder$12 = _encoder;
exports$4t = ({clientFirstMessage}) => ({
    encode: async () => new Encoder$12().writeBytes(clientFirstMessage)
})
;
var _request$w = exports$4t;
var exports$4u = {};
const Decoder$16 = _decoder;
const ENTRY_REGEX = /^([rsiev])=(.*)$/;
exports$4u = {
    decode: async (rawData) => {
        return new Decoder$16(rawData).readBytes();
    },
    parse: async (data) => {
        const processed = data.toString().split(",").map((str) => {
            const [_13, key, value2] = str.match(ENTRY_REGEX);
            return [
                key,
                value2
            ];
        }).reduce((obj, entry) => ({
                    ...obj,
                    [entry[0]]: entry[1]
                })
                , {});
        return {
            original: data.toString(),
            ...processed
        };
    }
};
var _response2$v = exports$4u;
var exports$4v = {};
const Encoder$13 = _encoder;
exports$4v = ({finalMessage}) => ({
    encode: async () => new Encoder$13().writeBytes(finalMessage)
})
;
var _request2$v = exports$4v;
var exports$4w = {};
exports$4w = {
    firstMessage: {
        request: _request$w,
        response: _response2$v
    },
    finalMessage: {
        request: _request2$v,
        response: _response2$v
    }
};
var _scram = exports$4w;
var exports$4x = {};
var Buffer$6 = e$1.Buffer;
const scram = _scram;
const {
    KafkaJSSASLAuthenticationError: KafkaJSSASLAuthenticationError$2,
    KafkaJSNonRetriableError: KafkaJSNonRetriableError$1
} = _errors;
const GS2_HEADER = "n,,";
const EQUAL_SIGN_REGEX = /=/g;
const COMMA_SIGN_REGEX = /,/g;
const URLSAFE_BASE64_PLUS_REGEX = /\+/g;
const URLSAFE_BASE64_SLASH_REGEX = /\//g;
const URLSAFE_BASE64_TRAILING_EQUAL_REGEX = /=+$/;
const HMAC_CLIENT_KEY = "Client Key";
const HMAC_SERVER_KEY = "Server Key";
const DIGESTS = {
    SHA256: {
        length: 32,
        type: "sha256",
        minIterations: 4096
    },
    SHA512: {
        length: 64,
        type: "sha512",
        minIterations: 4096
    }
};
const encode64 = (str) => Buffer$6.from(str).toString("base64")
;

class SCRAM {
    constructor(connection1, logger1, saslAuthenticate1, digestDefinition) {
        this.connection = connection1;
        this.logger = logger1;
        this.saslAuthenticate = saslAuthenticate1;
        this.digestDefinition = digestDefinition;
        const digestType = digestDefinition.type.toUpperCase();
        this.PREFIX = `SASL SCRAM ${digestType} authentication`;
        this.currentNonce = SCRAM.nonce();
    }

    static sanitizeString(str) {
        return str.replace(EQUAL_SIGN_REGEX, "=3D").replace(COMMA_SIGN_REGEX, "=2C");
    }

    static nonce() {
        return l$q.randomBytes(16).toString("base64").replace(URLSAFE_BASE64_PLUS_REGEX, "-").replace(URLSAFE_BASE64_SLASH_REGEX, "_").replace(URLSAFE_BASE64_TRAILING_EQUAL_REGEX, "").toString("ascii");
    }

    static hi(password, salt, iterations, digestDefinition) {
        return new Promise((resolve, reject) => {
            l$q.pbkdf2(password, salt, iterations, digestDefinition.length, digestDefinition.type, (err, derivedKey) => err ? reject(err) : resolve(derivedKey)
            );
        });
    }

    static xor(left, right) {
        const bufferA = Buffer$6.from(left);
        const bufferB = Buffer$6.from(right);
        const length = Buffer$6.byteLength(bufferA);
        if (length !== Buffer$6.byteLength(bufferB)) {
            throw new KafkaJSNonRetriableError$1("Buffers must be of the same length");
        }
        const result = [];
        for (let i53 = 0; i53 < length; i53++) {
            result.push(bufferA[i53] ^ bufferB[i53]);
        }
        return Buffer$6.from(result);
    }

    async authenticate() {
        const {PREFIX} = this;
        const {host: host1, port: port1, sasl} = this.connection;
        const broker3 = `${host1}:${port1}`;
        if (sasl.username == null || sasl.password == null) {
            throw new KafkaJSSASLAuthenticationError$2(`${this.PREFIX}: Invalid username or password`);
        }
        try {
            this.logger.debug("Exchanging first client message", {
                broker: broker3
            });
            const clientMessageResponse = await this.sendClientFirstMessage();
            this.logger.debug("Sending final message", {
                broker: broker3
            });
            const finalResponse = await this.sendClientFinalMessage(clientMessageResponse);
            if (finalResponse.e) {
                throw new Error(finalResponse.e);
            }
            const serverKey = await this.serverKey(clientMessageResponse);
            const serverSignature = this.serverSignature(serverKey, clientMessageResponse);
            if (finalResponse.v !== serverSignature) {
                throw new Error("Invalid server signature in server final message");
            }
            this.logger.debug(`${PREFIX} successful`, {
                broker: broker3
            });
        } catch (e46) {
            const error = new KafkaJSSASLAuthenticationError$2(`${PREFIX} failed: ${e46.message}`);
            this.logger.error(error.message, {
                broker: broker3
            });
            throw error;
        }
    }

    async sendClientFirstMessage() {
        const clientFirstMessage = `${GS2_HEADER}${this.firstMessageBare()}`;
        const request = scram.firstMessage.request({
            clientFirstMessage
        });
        const response = scram.firstMessage.response;
        return this.saslAuthenticate({
            authExpectResponse: true,
            request,
            response
        });
    }

    async sendClientFinalMessage(clientMessageResponse) {
        const {PREFIX} = this;
        const iterations = parseInt(clientMessageResponse.i, 10);
        const {minIterations} = this.digestDefinition;
        if (!clientMessageResponse.r.startsWith(this.currentNonce)) {
            throw new KafkaJSSASLAuthenticationError$2(`${PREFIX} failed: Invalid server nonce, it does not start with the client nonce`);
        }
        if (iterations < minIterations) {
            throw new KafkaJSSASLAuthenticationError$2(`${PREFIX} failed: Requested iterations ${iterations} is less than the minimum ${minIterations}`);
        }
        const finalMessageWithoutProof = this.finalMessageWithoutProof(clientMessageResponse);
        const clientProof = await this.clientProof(clientMessageResponse);
        const finalMessage = `${finalMessageWithoutProof},p=${clientProof}`;
        const request = scram.finalMessage.request({
            finalMessage
        });
        const response = scram.finalMessage.response;
        return this.saslAuthenticate({
            authExpectResponse: true,
            request,
            response
        });
    }

    async clientProof(clientMessageResponse) {
        const clientKey = await this.clientKey(clientMessageResponse);
        const storedKey = this.H(clientKey);
        const clientSignature = this.clientSignature(storedKey, clientMessageResponse);
        return encode64(SCRAM.xor(clientKey, clientSignature));
    }

    async clientKey(clientMessageResponse) {
        const saltedPassword = await this.saltPassword(clientMessageResponse);
        return this.HMAC(saltedPassword, HMAC_CLIENT_KEY);
    }

    async serverKey(clientMessageResponse) {
        const saltedPassword = await this.saltPassword(clientMessageResponse);
        return this.HMAC(saltedPassword, HMAC_SERVER_KEY);
    }

    clientSignature(storedKey, clientMessageResponse) {
        return this.HMAC(storedKey, this.authMessage(clientMessageResponse));
    }

    serverSignature(serverKey, clientMessageResponse) {
        return encode64(this.HMAC(serverKey, this.authMessage(clientMessageResponse)));
    }

    authMessage(clientMessageResponse) {
        return [
            this.firstMessageBare(),
            clientMessageResponse.original,
            this.finalMessageWithoutProof(clientMessageResponse)
        ].join(",");
    }

    async saltPassword(clientMessageResponse) {
        const salt = Buffer$6.from(clientMessageResponse.s, "base64");
        const iterations = parseInt(clientMessageResponse.i, 10);
        return SCRAM.hi(this.encodedPassword(), salt, iterations, this.digestDefinition);
    }

    firstMessageBare() {
        return `n=${this.encodedUsername()},r=${this.currentNonce}`;
    }

    finalMessageWithoutProof(clientMessageResponse) {
        const rnonce = clientMessageResponse.r;
        return `c=${encode64(GS2_HEADER)},r=${rnonce}`;
    }

    encodedUsername() {
        const {username} = this.connection.sasl;
        return SCRAM.sanitizeString(username).toString("utf-8");
    }

    encodedPassword() {
        const {password} = this.connection.sasl;
        return password.toString("utf-8");
    }

    H(data) {
        return l$q.createHash(this.digestDefinition.type).update(data).digest();
    }

    HMAC(key, data) {
        return l$q.createHmac(this.digestDefinition.type, key).update(data).digest();
    }
}

exports$4x = {
    DIGESTS,
    SCRAM
};
var _scram$1 = exports$4x;
var exports$4y = {};
const {SCRAM: SCRAM$1, DIGESTS: DIGESTS$1} = _scram$1;
exports$4y = class SCRAM256Authenticator extends SCRAM$1 {
    constructor(connection2, logger2, saslAuthenticate2) {
        super(connection2, logger2.namespace("SCRAM256Authenticator"), saslAuthenticate2, DIGESTS$1.SHA256);
    }
};
var _scram$2 = exports$4y;
var exports$4z = {};
const {SCRAM: SCRAM$2, DIGESTS: DIGESTS$2} = _scram$1;
exports$4z = class SCRAM512Authenticator extends SCRAM$2 {
    constructor(connection3, logger3, saslAuthenticate3) {
        super(connection3, logger3.namespace("SCRAM512Authenticator"), saslAuthenticate3, DIGESTS$2.SHA512);
    }
};
var _scram2 = exports$4z;
var exports$4A = {};
const Encoder$14 = _encoder;
const US_ASCII_NULL_CHAR$1 = "\0";
exports$4A = ({authorizationIdentity, accessKeyId, secretAccessKey, sessionToken = ""}) => ({
    encode: async () => {
        return new Encoder$14().writeBytes([
            authorizationIdentity,
            accessKeyId,
            secretAccessKey,
            sessionToken
        ].join(US_ASCII_NULL_CHAR$1));
    }
})
;
var _request$x = exports$4A;
var exports$4B = {};
exports$4B = {
    decode: async () => true
    ,
    parse: async () => true
};
var _response$w = exports$4B;
var exports$4C = {};
exports$4C = {
    request: _request$x,
    response: _response$w
};
var _awsIam = exports$4C;
var exports$4D = {};
const awsIam = _awsIam;
const {KafkaJSSASLAuthenticationError: KafkaJSSASLAuthenticationError$3} = _errors;
exports$4D = class AWSIAMAuthenticator {
    constructor(connection4, logger4, saslAuthenticate4) {
        this.connection = connection4;
        this.logger = logger4.namespace("SASLAWSIAMAuthenticator");
        this.saslAuthenticate = saslAuthenticate4;
    }

    async authenticate() {
        const {sasl} = this.connection;
        if (!sasl.authorizationIdentity) {
            throw new KafkaJSSASLAuthenticationError$3("SASL AWS-IAM: Missing authorizationIdentity");
        }
        if (!sasl.accessKeyId) {
            throw new KafkaJSSASLAuthenticationError$3("SASL AWS-IAM: Missing accessKeyId");
        }
        if (!sasl.secretAccessKey) {
            throw new KafkaJSSASLAuthenticationError$3("SASL AWS-IAM: Missing secretAccessKey");
        }
        if (!sasl.sessionToken) {
            sasl.sessionToken = "";
        }
        const request = awsIam.request(sasl);
        const response = awsIam.response;
        const {host: host1, port: port1} = this.connection;
        const broker3 = `${host1}:${port1}`;
        try {
            this.logger.debug("Authenticate with SASL AWS-IAM", {
                broker: broker3
            });
            await this.saslAuthenticate({
                request,
                response
            });
            this.logger.debug("SASL AWS-IAM authentication successful", {
                broker: broker3
            });
        } catch (e46) {
            const error = new KafkaJSSASLAuthenticationError$3(`SASL AWS-IAM authentication failed: ${e46.message}`);
            this.logger.error(error.message, {
                broker: broker3
            });
            throw error;
        }
    }
};
var _awsIam$1 = exports$4D;
var exports$4E = {};
var Buffer$7 = e$1.Buffer;
const Encoder$15 = _encoder;
const SEPARATOR = "\x01";

function formatExtensions(extensions) {
    let msg = "";
    if (extensions == null) {
        return msg;
    }
    let prefix = "";
    for (const k7 in extensions) {
        msg += `${prefix}${k7}=${extensions[k7]}`;
        prefix = SEPARATOR;
    }
    return msg;
}

exports$4E = async ({authorizationIdentity = null}, oauthBearerToken) => {
    const authzid = authorizationIdentity == null ? "" : `"a=${authorizationIdentity}`;
    let ext = formatExtensions(oauthBearerToken.extensions);
    if (ext.length > 0) {
        ext = `${SEPARATOR}${ext}`;
    }
    const oauthMsg = `n,${authzid},${SEPARATOR}auth=Bearer ${oauthBearerToken.value}${ext}${SEPARATOR}${SEPARATOR}`;
    return {
        encode: async () => {
            return new Encoder$15().writeBytes(Buffer$7.from(oauthMsg));
        }
    };
};
var _request$y = exports$4E;
var exports$4F = {};
exports$4F = {
    decode: async () => true
    ,
    parse: async () => true
};
var _response$x = exports$4F;
var exports$4G = {};
exports$4G = {
    request: _request$y,
    response: _response$x
};
var _oauthBearer = exports$4G;
var exports$4H = {};
const oauthBearer = _oauthBearer;
const {KafkaJSSASLAuthenticationError: KafkaJSSASLAuthenticationError$4} = _errors;
exports$4H = class OAuthBearerAuthenticator {
    constructor(connection5, logger5, saslAuthenticate5) {
        this.connection = connection5;
        this.logger = logger5.namespace("SASLOAuthBearerAuthenticator");
        this.saslAuthenticate = saslAuthenticate5;
    }

    async authenticate() {
        const {sasl} = this.connection;
        if (sasl.oauthBearerProvider == null) {
            throw new KafkaJSSASLAuthenticationError$4("SASL OAUTHBEARER: Missing OAuth bearer token provider");
        }
        const {oauthBearerProvider} = sasl;
        const oauthBearerToken = await oauthBearerProvider();
        if (oauthBearerToken.value == null) {
            throw new KafkaJSSASLAuthenticationError$4("SASL OAUTHBEARER: Invalid OAuth bearer token");
        }
        const request = await oauthBearer.request(sasl, oauthBearerToken);
        const response = oauthBearer.response;
        const {host: host1, port: port1} = this.connection;
        const broker3 = `${host1}:${port1}`;
        try {
            this.logger.debug("Authenticate with SASL OAUTHBEARER", {
                broker: broker3
            });
            await this.saslAuthenticate({
                request,
                response
            });
            this.logger.debug("SASL OAUTHBEARER authentication successful", {
                broker: broker3
            });
        } catch (e46) {
            const error = new KafkaJSSASLAuthenticationError$4(`SASL OAUTHBEARER authentication failed: ${e46.message}`);
            this.logger.error(error.message, {
                broker: broker3
            });
            throw error;
        }
    }
};
var _oauthBearer$1 = exports$4H;
var exports$4I = {};
const {requests: requests$1, lookup: lookup$1} = _requests;
const apiKeys$1 = _apiKeys;
const PlainAuthenticator = _plain$1;
const SCRAM256Authenticator = _scram$2;
const SCRAM512Authenticator = _scram2;
const AWSIAMAuthenticator = _awsIam$1;
const OAuthBearerAuthenticator = _oauthBearer$1;
const {KafkaJSSASLAuthenticationError: KafkaJSSASLAuthenticationError$5} = _errors;
const AUTHENTICATORS = {
    PLAIN: PlainAuthenticator,
    "SCRAM-SHA-256": SCRAM256Authenticator,
    "SCRAM-SHA-512": SCRAM512Authenticator,
    AWS: AWSIAMAuthenticator,
    OAUTHBEARER: OAuthBearerAuthenticator
};
const SUPPORTED_MECHANISMS = Object.keys(AUTHENTICATORS);
const UNLIMITED_SESSION_LIFETIME = "0";
exports$4I = class SASLAuthenticator {
    constructor(connection6, logger6, versions1, supportAuthenticationProtocol) {
        this.connection = connection6;
        this.logger = logger6;
        this.sessionLifetime = UNLIMITED_SESSION_LIFETIME;
        const lookupRequest = lookup$1(versions1);
        this.saslHandshake = lookupRequest(apiKeys$1.SaslHandshake, requests$1.SaslHandshake);
        this.protocolAuthentication = supportAuthenticationProtocol ? lookupRequest(apiKeys$1.SaslAuthenticate, requests$1.SaslAuthenticate) : null;
    }

    async authenticate() {
        const mechanism = this.connection.sasl.mechanism.toUpperCase();
        if (!SUPPORTED_MECHANISMS.includes(mechanism)) {
            throw new KafkaJSSASLAuthenticationError$5(`SASL ${mechanism} mechanism is not supported by the client`);
        }
        const handshake = await this.connection.send(this.saslHandshake({
            mechanism
        }));
        if (!handshake.enabledMechanisms.includes(mechanism)) {
            throw new KafkaJSSASLAuthenticationError$5(`SASL ${mechanism} mechanism is not supported by the server`);
        }
        const saslAuthenticate6 = async ({request, response, authExpectResponse}) => {
            if (this.protocolAuthentication) {
                const {buffer: requestAuthBytes} = await request.encode();
                const authResponse = await this.connection.send(this.protocolAuthentication({
                    authBytes: requestAuthBytes
                }));
                this.sessionLifetime = authResponse.sessionLifetimeMs || UNLIMITED_SESSION_LIFETIME;
                if (!authExpectResponse) {
                    return;
                }
                const {authBytes: responseAuthBytes} = authResponse;
                const payloadDecoded = await response.decode(responseAuthBytes);
                return response.parse(payloadDecoded);
            }
            return this.connection.authenticate({
                request,
                response,
                authExpectResponse
            });
        };
        const Authenticator = AUTHENTICATORS[mechanism];
        await new Authenticator(this.connection, this.logger, saslAuthenticate6).authenticate();
    }
};
var _saslAuthenticator = exports$4I;
var exports$4J = {};
exports$4J = (array) => {
    if (!Array.isArray(array)) {
        throw new TypeError("'array' is not an array");
    }
    if (array.length < 2) {
        return array;
    }
    const copy = array.slice();
    for (let i53 = copy.length - 1; i53 > 0; i53--) {
        const j7 = Math.floor(Math.random() * (i53 + 1));
        const temp = copy[i53];
        copy[i53] = copy[j7];
        copy[j7] = temp;
    }
    return copy;
};
var _shuffle = exports$4J;
var exports$4K = {};
var process$1 = T1;
const Long$4 = _long;
const Lock = _lock;
const {Types: Compression$3} = _compression;
const {requests: requests$2, lookup: lookup$2} = _requests;
const {KafkaJSNonRetriableError: KafkaJSNonRetriableError$2} = _errors;
const apiKeys$2 = _apiKeys;
const SASLAuthenticator = _saslAuthenticator;
const shuffle = _shuffle;
const PRIVATE$1 = {
    SHOULD_REAUTHENTICATE: Symbol("private:Broker:shouldReauthenticate"),
    SEND_REQUEST: Symbol("private:Broker:sendRequest")
};
exports$4K = class Broker {
    constructor({
        connection: connection7,
        logger: logger7,
        nodeId: nodeId1 = null,
        versions: versions2 = null,
        authenticationTimeout = 1000,
        reauthenticationThreshold = 10000,
        allowAutoTopicCreation: allowAutoTopicCreation3 = true,
        supportAuthenticationProtocol: supportAuthenticationProtocol1 = null
    }) {
        this.connection = connection7;
        this.nodeId = nodeId1;
        this.rootLogger = logger7;
        this.logger = logger7.namespace("Broker");
        this.versions = versions2;
        this.authenticationTimeout = authenticationTimeout;
        this.reauthenticationThreshold = reauthenticationThreshold;
        this.allowAutoTopicCreation = allowAutoTopicCreation3;
        this.supportAuthenticationProtocol = supportAuthenticationProtocol1;
        this.authenticatedAt = null;
        this.sessionLifetime = Long$4.ZERO;
        const lockTimeout = 2 * this.connection.connectionTimeout + this.authenticationTimeout;
        this.brokerAddress = `${this.connection.host}:${this.connection.port}`;
        this.lock = new Lock({
            timeout: lockTimeout,
            description: `connect to broker ${this.brokerAddress}`
        });
        this.lookupRequest = () => {
            throw new Error("Broker not connected");
        };
    }

    isConnected() {
        const {connected, sasl} = this.connection;
        const isAuthenticated = this.authenticatedAt != null && !this[PRIVATE$1.SHOULD_REAUTHENTICATE]();
        return sasl ? connected && isAuthenticated : connected;
    }

    async connect() {
        try {
            await this.lock.acquire();
            if (this.isConnected()) {
                return;
            }
            this.authenticatedAt = null;
            await this.connection.connect();
            if (!this.versions) {
                this.versions = await this.apiVersions();
            }
            this.lookupRequest = lookup$2(this.versions);
            if (this.supportAuthenticationProtocol === null) {
                try {
                    this.lookupRequest(apiKeys$2.SaslAuthenticate, requests$2.SaslAuthenticate);
                    this.supportAuthenticationProtocol = true;
                } catch (_13) {
                    this.supportAuthenticationProtocol = false;
                }
                this.logger.debug(`Verified support for SaslAuthenticate`, {
                    broker: this.brokerAddress,
                    supportAuthenticationProtocol: this.supportAuthenticationProtocol
                });
            }
            if (this.authenticatedAt == null && this.connection.sasl) {
                const authenticator = new SASLAuthenticator(this.connection, this.rootLogger, this.versions, this.supportAuthenticationProtocol);
                await authenticator.authenticate();
                this.authenticatedAt = process$1.hrtime();
                this.sessionLifetime = Long$4.fromValue(authenticator.sessionLifetime);
            }
        } finally {
            await this.lock.release();
        }
    }

    async disconnect() {
        this.authenticatedAt = null;
        await this.connection.disconnect();
    }

    async apiVersions() {
        let response;
        const availableVersions = requests$2.ApiVersions.versions.map(Number).sort().reverse();
        for (const candidateVersion of availableVersions) {
            try {
                const apiVersions = requests$2.ApiVersions.protocol({
                    version: candidateVersion
                });
                response = await this[PRIVATE$1.SEND_REQUEST]({
                    ...apiVersions(),
                    requestTimeout: this.connection.connectionTimeout
                });
                break;
            } catch (e46) {
                if (e46.type !== "UNSUPPORTED_VERSION") {
                    throw e46;
                }
            }
        }
        if (!response) {
            throw new KafkaJSNonRetriableError$2("API Versions not supported");
        }
        return response.apiVersions.reduce((obj, version) => Object.assign(obj, {
                    [version.apiKey]: {
                        minVersion: version.minVersion,
                        maxVersion: version.maxVersion
                    }
                })
                , {});
    }

    async metadata(topics = []) {
        const metadata = this.lookupRequest(apiKeys$2.Metadata, requests$2.Metadata);
        const shuffledTopics = shuffle(topics);
        return await this[PRIVATE$1.SEND_REQUEST](metadata({
            topics: shuffledTopics,
            allowAutoTopicCreation: this.allowAutoTopicCreation
        }));
    }

    async produce({
        topicData,
        transactionalId,
        producerId,
        producerEpoch,
        acks = -1,
        timeout = 30000,
        compression = Compression$3.None
    }) {
        const produce = this.lookupRequest(apiKeys$2.Produce, requests$2.Produce);
        return await this[PRIVATE$1.SEND_REQUEST](produce({
            acks,
            timeout,
            compression,
            topicData,
            transactionalId,
            producerId,
            producerEpoch
        }));
    }

    async fetch({
        replicaId,
        isolationLevel,
        maxWaitTime = 5000,
        minBytes = 1,
        maxBytes = 10485760,
        topics,
        rackId = ""
    }) {
        const fetch = this.lookupRequest(apiKeys$2.Fetch, requests$2.Fetch);
        const flattenedTopicPartitions = topics.reduce((topicPartitions, {topic: topic3, partitions: partitions1}) => {
            partitions1.forEach((partition2) => {
                topicPartitions.push({
                    topic: topic3,
                    partition: partition2
                });
            });
            return topicPartitions;
        }, []);
        const shuffledTopicPartitions = shuffle(flattenedTopicPartitions);
        const consolidatedTopicPartitions = shuffledTopicPartitions.reduce((topicPartitions, {
            topic: topic3,
            partition: partition2
        }) => {
            const last = topicPartitions[topicPartitions.length - 1];
            if (last != null && last.topic === topic3) {
                topicPartitions[topicPartitions.length - 1].partitions.push(partition2);
            } else {
                topicPartitions.push({
                    topic: topic3,
                    partitions: [
                        partition2
                    ]
                });
            }
            return topicPartitions;
        }, []);
        return await this[PRIVATE$1.SEND_REQUEST](fetch({
            replicaId,
            isolationLevel,
            maxWaitTime,
            minBytes,
            maxBytes,
            topics: consolidatedTopicPartitions,
            rackId
        }));
    }

    async heartbeat({groupId, groupGenerationId, memberId}) {
        const heartbeat = this.lookupRequest(apiKeys$2.Heartbeat, requests$2.Heartbeat);
        return await this[PRIVATE$1.SEND_REQUEST](heartbeat({
            groupId,
            groupGenerationId,
            memberId
        }));
    }

    async findGroupCoordinator({groupId, coordinatorType}) {
        const findCoordinator = this.lookupRequest(apiKeys$2.GroupCoordinator, requests$2.GroupCoordinator);
        return await this[PRIVATE$1.SEND_REQUEST](findCoordinator({
            groupId,
            coordinatorType
        }));
    }

    async joinGroup({
        groupId,
        sessionTimeout,
        rebalanceTimeout,
        memberId = "",
        protocolType = "consumer",
        groupProtocols
    }) {
        const joinGroup = this.lookupRequest(apiKeys$2.JoinGroup, requests$2.JoinGroup);
        const makeRequest = (assignedMemberId = memberId) => this[PRIVATE$1.SEND_REQUEST](joinGroup({
                    groupId,
                    sessionTimeout,
                    rebalanceTimeout,
                    memberId: assignedMemberId,
                    protocolType,
                    groupProtocols
                }))
        ;
        try {
            return await makeRequest();
        } catch (error) {
            if (error.name === "KafkaJSMemberIdRequired") {
                return makeRequest(error.memberId);
            }
            throw error;
        }
    }

    async leaveGroup({groupId, memberId}) {
        const leaveGroup = this.lookupRequest(apiKeys$2.LeaveGroup, requests$2.LeaveGroup);
        return await this[PRIVATE$1.SEND_REQUEST](leaveGroup({
            groupId,
            memberId
        }));
    }

    async syncGroup({groupId, generationId, memberId, groupAssignment}) {
        const syncGroup = this.lookupRequest(apiKeys$2.SyncGroup, requests$2.SyncGroup);
        return await this[PRIVATE$1.SEND_REQUEST](syncGroup({
            groupId,
            generationId,
            memberId,
            groupAssignment
        }));
    }

    async listOffsets({replicaId, isolationLevel, topics}) {
        const listOffsets = this.lookupRequest(apiKeys$2.ListOffsets, requests$2.ListOffsets);
        const result = await this[PRIVATE$1.SEND_REQUEST](listOffsets({
            replicaId,
            isolationLevel,
            topics
        }));
        for (const response of result.responses) {
            response.partitions = response.partitions.map(({offsets, ...partitionData}) => {
                return offsets ? {
                    ...partitionData,
                    offset: offsets.pop()
                } : partitionData;
            });
        }
        return result;
    }

    async offsetCommit({groupId, groupGenerationId, memberId, retentionTime, topics}) {
        const offsetCommit = this.lookupRequest(apiKeys$2.OffsetCommit, requests$2.OffsetCommit);
        return await this[PRIVATE$1.SEND_REQUEST](offsetCommit({
            groupId,
            groupGenerationId,
            memberId,
            retentionTime,
            topics
        }));
    }

    async offsetFetch({groupId, topics}) {
        const offsetFetch = this.lookupRequest(apiKeys$2.OffsetFetch, requests$2.OffsetFetch);
        return await this[PRIVATE$1.SEND_REQUEST](offsetFetch({
            groupId,
            topics
        }));
    }

    async describeGroups({groupIds}) {
        const describeGroups = this.lookupRequest(apiKeys$2.DescribeGroups, requests$2.DescribeGroups);
        return await this[PRIVATE$1.SEND_REQUEST](describeGroups({
            groupIds
        }));
    }

    async createTopics({topics, validateOnly = false, timeout = 5000}) {
        const createTopics = this.lookupRequest(apiKeys$2.CreateTopics, requests$2.CreateTopics);
        return await this[PRIVATE$1.SEND_REQUEST](createTopics({
            topics,
            validateOnly,
            timeout
        }));
    }

    async createPartitions({topicPartitions, validateOnly = false, timeout = 5000}) {
        const createPartitions = this.lookupRequest(apiKeys$2.CreatePartitions, requests$2.CreatePartitions);
        return await this[PRIVATE$1.SEND_REQUEST](createPartitions({
            topicPartitions,
            validateOnly,
            timeout
        }));
    }

    async deleteTopics({topics, timeout = 5000}) {
        const deleteTopics = this.lookupRequest(apiKeys$2.DeleteTopics, requests$2.DeleteTopics);
        return await this[PRIVATE$1.SEND_REQUEST](deleteTopics({
            topics,
            timeout
        }));
    }

    async describeConfigs({resources, includeSynonyms = false}) {
        const describeConfigs = this.lookupRequest(apiKeys$2.DescribeConfigs, requests$2.DescribeConfigs);
        return await this[PRIVATE$1.SEND_REQUEST](describeConfigs({
            resources,
            includeSynonyms
        }));
    }

    async alterConfigs({resources, validateOnly = false}) {
        const alterConfigs = this.lookupRequest(apiKeys$2.AlterConfigs, requests$2.AlterConfigs);
        return await this[PRIVATE$1.SEND_REQUEST](alterConfigs({
            resources,
            validateOnly
        }));
    }

    async initProducerId({transactionalId, transactionTimeout}) {
        const initProducerId = this.lookupRequest(apiKeys$2.InitProducerId, requests$2.InitProducerId);
        return await this[PRIVATE$1.SEND_REQUEST](initProducerId({
            transactionalId,
            transactionTimeout
        }));
    }

    async addPartitionsToTxn({transactionalId, producerId, producerEpoch, topics}) {
        const addPartitionsToTxn = this.lookupRequest(apiKeys$2.AddPartitionsToTxn, requests$2.AddPartitionsToTxn);
        return await this[PRIVATE$1.SEND_REQUEST](addPartitionsToTxn({
            transactionalId,
            producerId,
            producerEpoch,
            topics
        }));
    }

    async addOffsetsToTxn({transactionalId, producerId, producerEpoch, groupId}) {
        const addOffsetsToTxn = this.lookupRequest(apiKeys$2.AddOffsetsToTxn, requests$2.AddOffsetsToTxn);
        return await this[PRIVATE$1.SEND_REQUEST](addOffsetsToTxn({
            transactionalId,
            producerId,
            producerEpoch,
            groupId
        }));
    }

    async txnOffsetCommit({transactionalId, groupId, producerId, producerEpoch, topics}) {
        const txnOffsetCommit = this.lookupRequest(apiKeys$2.TxnOffsetCommit, requests$2.TxnOffsetCommit);
        return await this[PRIVATE$1.SEND_REQUEST](txnOffsetCommit({
            transactionalId,
            groupId,
            producerId,
            producerEpoch,
            topics
        }));
    }

    async endTxn({transactionalId, producerId, producerEpoch, transactionResult}) {
        const endTxn = this.lookupRequest(apiKeys$2.EndTxn, requests$2.EndTxn);
        return await this[PRIVATE$1.SEND_REQUEST](endTxn({
            transactionalId,
            producerId,
            producerEpoch,
            transactionResult
        }));
    }

    async listGroups() {
        const listGroups = this.lookupRequest(apiKeys$2.ListGroups, requests$2.ListGroups);
        return await this[PRIVATE$1.SEND_REQUEST](listGroups());
    }

    async deleteGroups(groupIds) {
        const deleteGroups = this.lookupRequest(apiKeys$2.DeleteGroups, requests$2.DeleteGroups);
        return await this[PRIVATE$1.SEND_REQUEST](deleteGroups(groupIds));
    }

    async deleteRecords({topics}) {
        const deleteRecords = this.lookupRequest(apiKeys$2.DeleteRecords, requests$2.DeleteRecords);
        return await this[PRIVATE$1.SEND_REQUEST](deleteRecords({
            topics
        }));
    }

    async createAcls({acl}) {
        const createAcls = this.lookupRequest(apiKeys$2.CreateAcls, requests$2.CreateAcls);
        return await this[PRIVATE$1.SEND_REQUEST](createAcls({
            creations: acl
        }));
    }

    async describeAcls({resourceType, resourceName, resourcePatternType, principal, host, operation, permissionType}) {
        const describeAcls = this.lookupRequest(apiKeys$2.DescribeAcls, requests$2.DescribeAcls);
        return await this[PRIVATE$1.SEND_REQUEST](describeAcls({
            resourceType,
            resourceName,
            resourcePatternType,
            principal,
            host,
            operation,
            permissionType
        }));
    }

    async deleteAcls({filters}) {
        const deleteAcls = this.lookupRequest(apiKeys$2.DeleteAcls, requests$2.DeleteAcls);
        return await this[PRIVATE$1.SEND_REQUEST](deleteAcls({
            filters
        }));
    }

    [PRIVATE$1.SHOULD_REAUTHENTICATE]() {
        if (this.sessionLifetime.equals(Long$4.ZERO)) {
            return false;
        }
        if (this.authenticatedAt == null) {
            return true;
        }
        const [secondsSince, remainingNanosSince] = process$1.hrtime(this.authenticatedAt);
        const millisSince = Long$4.fromValue(secondsSince).multiply(1000).add(Long$4.fromValue(remainingNanosSince).divide(1000000));
        const reauthenticateAt = millisSince.add(this.reauthenticationThreshold);
        return reauthenticateAt.greaterThanOrEqual(this.sessionLifetime);
    }

    async [PRIVATE$1.SEND_REQUEST](protocolRequest) {
        try {
            return await this.connection.send(protocolRequest);
        } catch (e46) {
            if (e46.name === "KafkaJSConnectionClosedError") {
                await this.disconnect();
            }
            throw e46;
        }
    }
};
var _broker = exports$4K;
var exports$4L = {};
exports$4L = {
    maxRetryTime: 1000,
    initialRetryTime: 50,
    factor: 0.02,
    multiplier: 1.5,
    retries: 15
};
var _defaults = exports$4L;
var exports$4M = {};
exports$4M = {
    maxRetryTime: 30 * 1000,
    initialRetryTime: 300,
    factor: 0.2,
    multiplier: 2,
    retries: 5
};
var _defaults$1 = exports$4M;
var exports$4N = {};
const {KafkaJSNumberOfRetriesExceeded: KafkaJSNumberOfRetriesExceeded$1} = _errors;
const RETRY_DEFAULT = false ? _defaults : _defaults$1;
const random = (min, max) => {
    return Math.random() * (max - min) + min;
};
const randomFromRetryTime = (factor, retryTime1) => {
    const delta = factor * retryTime1;
    return Math.ceil(random(retryTime1 - delta, retryTime1 + delta));
};
const UNRECOVERABLE_ERRORS = [
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError"
];
const isErrorUnrecoverable = (e46) => UNRECOVERABLE_ERRORS.includes(e46.name)
;
const isErrorRetriable = (error) => (error.retriable || error.retriable !== false) && !isErrorUnrecoverable(error)
;
const createRetriable = (configs, resolve, reject, fn) => {
    let aborted = false;
    const {factor, multiplier, maxRetryTime, retries} = configs;
    const bail = (error) => {
        aborted = true;
        reject(error || new Error("Aborted"));
    };
    const calculateExponentialRetryTime = (retryTime1) => {
        return Math.min(randomFromRetryTime(factor, retryTime1) * multiplier, maxRetryTime);
    };
    const retry = (retryTime1, retryCount1 = 0) => {
        if (aborted) {
            return;
        }
        const nextRetryTime = calculateExponentialRetryTime(retryTime1);
        const shouldRetry = retryCount1 < retries;
        const scheduleRetry = () => {
            setTimeout(() => retry(nextRetryTime, retryCount1 + 1)
                    , retryTime1);
        };
        fn(bail, retryCount1, retryTime1).then(resolve).catch((e46) => {
            if (shouldRetry && isErrorRetriable(e46)) {
                scheduleRetry();
            } else {
                reject(new KafkaJSNumberOfRetriesExceeded$1(e46, {
                    retryCount: retryCount1,
                    retryTime: retryTime1
                }));
            }
        });
    };
    return retry;
};
exports$4N = (opts = {}) => (fn) => {
    return new Promise((resolve, reject) => {
        const configs = Object.assign({}, RETRY_DEFAULT, opts);
        const start = createRetriable(configs, resolve, reject, fn);
        start(randomFromRetryTime(configs.factor, configs.initialRetryTime));
    });
}
;
var _retry = exports$4N;
var exports$4O = {};
exports$4O = (a49, b19) => {
    const result = [];
    const length = a49.length;
    let i53 = 0;
    while (i53 < length) {
        if (b19.indexOf(a49[i53]) === -1) {
            result.push(a49[i53]);
        }
        i53 += 1;
    }
    return result;
};
var _arrayDiff = exports$4O;
var exports$4P = {};
const Broker = _broker;
const createRetry = _retry;
const shuffle$1 = _shuffle;
const arrayDiff = _arrayDiff;
const {KafkaJSBrokerNotFound: KafkaJSBrokerNotFound$1, KafkaJSProtocolError: KafkaJSProtocolError$3} = _errors;
const {keys: keys$1, assign: assign$1, values} = Object;
const hasBrokerBeenReplaced = (broker3, {
            host: host2,
            port: port1,
            rack
        }) => broker3.connection.host !== host2 || broker3.connection.port !== port1 || broker3.connection.rack !== rack
;
exports$4P = class BrokerPool {
    constructor({
        connectionBuilder,
        logger: logger8,
        retry: retry6,
        allowAutoTopicCreation: allowAutoTopicCreation1,
        authenticationTimeout: authenticationTimeout1,
        reauthenticationThreshold: reauthenticationThreshold1,
        metadataMaxAge: metadataMaxAge3
    }) {
        this.rootLogger = logger8;
        this.connectionBuilder = connectionBuilder;
        this.metadataMaxAge = metadataMaxAge3 || 0;
        this.logger = logger8.namespace("BrokerPool");
        this.retrier = createRetry(assign$1({}, retry6));
        this.createBroker = (options) => new Broker({
            allowAutoTopicCreation: allowAutoTopicCreation1,
            authenticationTimeout: authenticationTimeout1,
            reauthenticationThreshold: reauthenticationThreshold1,
            ...options
        })
        ;
        this.brokers = {};
        this.metadata = null;
        this.metadataExpireAt = null;
        this.versions = null;
        this.supportAuthenticationProtocol = null;
    }

    hasConnectedBrokers() {
        const brokers = values(this.brokers);
        return !!brokers.find((broker3) => broker3.isConnected()
        ) || (this.seedBroker ? this.seedBroker.isConnected() : false);
    }

    async createSeedBroker() {
        if (this.seedBroker) {
            await this.seedBroker.disconnect();
        }
        this.seedBroker = this.createBroker({
            connection: await this.connectionBuilder.build(),
            logger: this.rootLogger
        });
    }

    async connect() {
        if (this.hasConnectedBrokers()) {
            return;
        }
        if (!this.seedBroker) {
            await this.createSeedBroker();
        }
        return this.retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await this.seedBroker.connect();
                this.versions = this.seedBroker.versions;
            } catch (e46) {
                if (e46.name === "KafkaJSConnectionError" || e46.type === "ILLEGAL_SASL_STATE") {
                    await this.createSeedBroker();
                    this.logger.error(`Failed to connect to seed broker, trying another broker from the list: ${e46.message}`, {
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                } else {
                    this.logger.error(e46.message, {
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                }
                if (e46.retriable) {
                    throw e46;
                }
                bail(e46);
            }
        });
    }

    async disconnect() {
        this.seedBroker && await this.seedBroker.disconnect();
        await Promise.all(values(this.brokers).map((broker3) => broker3.disconnect()
        ));
        this.brokers = {};
        this.metadata = null;
        this.versions = null;
        this.supportAuthenticationProtocol = null;
    }

    removeBroker({host, port}) {
        const removedBroker = values(this.brokers).find((broker3) => broker3.connection.host === host && broker3.connection.port === port
        );
        if (removedBroker) {
            delete this.brokers[removedBroker.nodeId];
            this.metadataExpireAt = null;
            if (this.seedBroker.nodeId === removedBroker.nodeId) {
                this.seedBroker = shuffle$1(values(this.brokers))[0];
            }
        }
    }

    async refreshMetadata(topics) {
        const broker3 = await this.findConnectedBroker();
        const {host: seedHost, port: seedPort} = this.seedBroker.connection;
        return this.retrier(async (bail, retryCount1, retryTime1) => {
            try {
                this.metadata = await broker3.metadata(topics);
                this.metadataExpireAt = Date.now() + this.metadataMaxAge;
                const replacedBrokers = [];
                this.brokers = await this.metadata.brokers.reduce(async (resultPromise, {
                    nodeId: nodeId1,
                    host: host2,
                    port: port2,
                    rack
                }) => {
                    const result = await resultPromise;
                    if (result[nodeId1]) {
                        if (!hasBrokerBeenReplaced(result[nodeId1], {
                            host: host2,
                            port: port2,
                            rack
                        })) {
                            return result;
                        }
                        replacedBrokers.push(result[nodeId1]);
                    }
                    if (host2 === seedHost && port2 === seedPort) {
                        this.seedBroker.nodeId = nodeId1;
                        this.seedBroker.connection.rack = rack;
                        return assign$1(result, {
                            [nodeId1]: this.seedBroker
                        });
                    }
                    return assign$1(result, {
                        [nodeId1]: this.createBroker({
                            logger: this.rootLogger,
                            versions: this.versions,
                            supportAuthenticationProtocol: this.supportAuthenticationProtocol,
                            connection: await this.connectionBuilder.build({
                                host: host2,
                                port: port2,
                                rack
                            }),
                            nodeId: nodeId1
                        })
                    });
                }, this.brokers);
                const freshBrokerIds = this.metadata.brokers.map(({nodeId: nodeId1}) => `${nodeId1}`
                ).sort();
                const currentBrokerIds = keys$1(this.brokers).sort();
                const unusedBrokerIds = arrayDiff(currentBrokerIds, freshBrokerIds);
                const brokerDisconnects = unusedBrokerIds.map((nodeId1) => {
                    const broker4 = this.brokers[nodeId1];
                    return broker4.disconnect().then(() => {
                        delete this.brokers[nodeId1];
                    });
                });
                const replacedBrokersDisconnects = replacedBrokers.map((broker4) => broker4.disconnect()
                );
                await Promise.all([
                    ...brokerDisconnects,
                    ...replacedBrokersDisconnects
                ]);
            } catch (e46) {
                if (e46.type === "LEADER_NOT_AVAILABLE") {
                    throw e46;
                }
                bail(e46);
            }
        });
    }

    async refreshMetadataIfNecessary(topics) {
        const shouldRefresh = this.metadata == null || this.metadataExpireAt == null || Date.now() > this.metadataExpireAt || !topics.every((topic3) => this.metadata.topicMetadata.some((topicMetadata1) => topicMetadata1.topic === topic3
                )
        );
        if (shouldRefresh) {
            return this.refreshMetadata(topics);
        }
    }

    async findBroker({nodeId}) {
        const broker3 = this.brokers[nodeId];
        if (!broker3) {
            throw new KafkaJSBrokerNotFound$1(`Broker ${nodeId} not found in the cached metadata`);
        }
        await this.connectBroker(broker3);
        return broker3;
    }

    async withBroker(callback) {
        const brokers = shuffle$1(keys$1(this.brokers));
        if (brokers.length === 0) {
            throw new KafkaJSBrokerNotFound$1("No brokers in the broker pool");
        }
        for (const nodeId2 of brokers) {
            const broker3 = await this.findBroker({
                nodeId: nodeId2
            });
            try {
                return await callback({
                    nodeId: nodeId2,
                    broker: broker3
                });
            } catch (e46) {
            }
        }
        return null;
    }

    async findConnectedBroker() {
        const nodeIds = shuffle$1(keys$1(this.brokers));
        const connectedBrokerId = nodeIds.find((nodeId2) => this.brokers[nodeId2].isConnected()
        );
        if (connectedBrokerId) {
            return await this.findBroker({
                nodeId: connectedBrokerId
            });
        }
        for (const nodeId2 of nodeIds) {
            try {
                return await this.findBroker({
                    nodeId: nodeId2
                });
            } catch (e46) {
            }
        }
        await this.connect();
        return this.seedBroker;
    }

    async connectBroker(broker) {
        if (broker.isConnected()) {
            return;
        }
        return this.retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await broker.connect();
            } catch (e46) {
                if (e46.name === "KafkaJSConnectionError" || e46.type === "ILLEGAL_SASL_STATE") {
                    await broker.disconnect();
                }
                if (e46.name === "KafkaJSConnectionError") {
                    return bail(e46);
                }
                if (e46.type === "ILLEGAL_SASL_STATE") {
                    broker.connection = await this.connectionBuilder.build({
                        host: broker.connection.host,
                        port: broker.connection.port,
                        rack: broker.connection.rack
                    });
                    this.logger.error(`Failed to connect to broker, reconnecting`, {
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    throw new KafkaJSProtocolError$3(e46, {
                        retriable: true
                    });
                }
                if (e46.retriable) {
                    throw e46;
                }
                this.logger.error(e46, {
                    retryCount: retryCount1,
                    retryTime: retryTime1,
                    stack: e46.stack
                });
                bail(e46);
            }
        });
    }
};
var _brokerPool = exports$4P;
var exports$4Q = {};
exports$4Q = ({socketFactory, host: host2, port: port2, ssl, onConnect, onData, onEnd, onError, onTimeout}) => {
    const socket = socketFactory({
        host: host2,
        port: port2,
        ssl,
        onConnect
    });
    socket.on("data", onData);
    socket.on("end", onEnd);
    socket.on("error", onError);
    socket.on("timeout", onTimeout);
    return socket;
};
var _socket = exports$4Q;
var exports$4R = {};
const Encoder$16 = _encoder;
exports$4R = async ({
    correlationId: correlationId1,
    clientId,
    request: {apiKey: apiKey2, apiVersion: apiVersion1, encode}
}) => {
    const payload2 = await encode();
    const requestPayload = new Encoder$16().writeInt16(apiKey2).writeInt16(apiVersion1).writeInt32(correlationId1).writeString(clientId).writeEncoder(payload2);
    return new Encoder$16().writeInt32(requestPayload.size()).writeEncoder(requestPayload);
};
var _request$z = exports$4R;
var exports$4S = {};
const EARLIEST_OFFSET = -2;
const LATEST_OFFSET = -1;
const INT_32_MAX_VALUE = Math.pow(2, 32);
exports$4S = {
    EARLIEST_OFFSET,
    LATEST_OFFSET,
    INT_32_MAX_VALUE
};
var _constants = exports$4S;
var exports$4T = {};
var process$2 = T1;
exports$4T = () => ({
    KAFKAJS_DEBUG_PROTOCOL_BUFFERS: process$2.env.KAFKAJS_DEBUG_PROTOCOL_BUFFERS,
    KAFKAJS_DEBUG_EXTENDED_PROTOCOL_BUFFERS: process$2.env.KAFKAJS_DEBUG_EXTENDED_PROTOCOL_BUFFERS
})
;
var _env = exports$4T;
var exports$4U = {};
exports$4U = (namespace) => (type1) => `${namespace}.${type1}`
;
var _eventType = exports$4U;
var exports$4V = {};
const InstrumentationEventType = _eventType;
const eventType = InstrumentationEventType("network");
exports$4V = {
    NETWORK_REQUEST: eventType("request"),
    NETWORK_REQUEST_TIMEOUT: eventType("request_timeout"),
    NETWORK_REQUEST_QUEUE_SIZE: eventType("request_queue_size")
};
var _instrumentationEvents = exports$4V;
var exports$4W = {};
const {
    KafkaJSRequestTimeoutError: KafkaJSRequestTimeoutError$1,
    KafkaJSNonRetriableError: KafkaJSNonRetriableError$3
} = _errors;
const events = _instrumentationEvents;
const PRIVATE$2 = {
    STATE: Symbol("private:SocketRequest:state"),
    EMIT_EVENT: Symbol("private:SocketRequest:emitEvent")
};
const REQUEST_STATE = {
    PENDING: Symbol("PENDING"),
    SENT: Symbol("SENT"),
    COMPLETED: Symbol("COMPLETED"),
    REJECTED: Symbol("REJECTED")
};
exports$4W = class SocketRequest {
    constructor({
        requestTimeout: requestTimeout1,
        broker: broker4,
        clientId,
        entry,
        expectResponse,
        send,
        timeout: timeout2,
        instrumentationEmitter = null
    }) {
        this.createdAt = Date.now();
        this.requestTimeout = requestTimeout1;
        this.broker = broker4;
        this.clientId = clientId;
        this.entry = entry;
        this.correlationId = entry.correlationId;
        this.expectResponse = expectResponse;
        this.sendRequest = send;
        this.timeoutHandler = timeout2;
        this.sentAt = null;
        this.duration = null;
        this.pendingDuration = null;
        this[PRIVATE$2.STATE] = REQUEST_STATE.PENDING;
        this[PRIVATE$2.EMIT_EVENT] = (eventName, payload2) => instrumentationEmitter && instrumentationEmitter.emit(eventName, payload2)
        ;
    }

    send() {
        this.throwIfInvalidState({
            accepted: [
                REQUEST_STATE.PENDING
            ],
            next: REQUEST_STATE.SENT
        });
        this.sendRequest();
        this.sentAt = Date.now();
        this.pendingDuration = this.sentAt - this.createdAt;
        this[PRIVATE$2.STATE] = REQUEST_STATE.SENT;
    }

    timeoutRequest() {
        const {apiName: apiName1, apiKey: apiKey2, apiVersion: apiVersion1} = this.entry;
        const requestInfo = `${apiName1}(key: ${apiKey2}, version: ${apiVersion1})`;
        const eventData = {
            broker: this.broker,
            clientId: this.clientId,
            correlationId: this.correlationId,
            createdAt: this.createdAt,
            sentAt: this.sentAt,
            pendingDuration: this.pendingDuration
        };
        this.timeoutHandler();
        this.rejected(new KafkaJSRequestTimeoutError$1(`Request ${requestInfo} timed out`, eventData));
        this[PRIVATE$2.EMIT_EVENT](events.NETWORK_REQUEST_TIMEOUT, {
            ...eventData,
            apiName: apiName1,
            apiKey: apiKey2,
            apiVersion: apiVersion1
        });
    }

    completed({size, payload}) {
        this.throwIfInvalidState({
            accepted: [
                REQUEST_STATE.SENT
            ],
            next: REQUEST_STATE.COMPLETED
        });
        const {
            entry: entry1,
            correlationId: correlationId1,
            broker: broker5,
            clientId: clientId1,
            createdAt: createdAt1,
            sentAt: sentAt1,
            pendingDuration: pendingDuration1
        } = this;
        this[PRIVATE$2.STATE] = REQUEST_STATE.COMPLETED;
        this.duration = Date.now() - this.sentAt;
        entry1.resolve({
            correlationId: correlationId1,
            entry: entry1,
            size,
            payload
        });
        this[PRIVATE$2.EMIT_EVENT](events.NETWORK_REQUEST, {
            broker: broker5,
            clientId: clientId1,
            correlationId: correlationId1,
            size,
            createdAt: createdAt1,
            sentAt: sentAt1,
            pendingDuration: pendingDuration1,
            duration: this.duration,
            apiName: entry1.apiName,
            apiKey: entry1.apiKey,
            apiVersion: entry1.apiVersion
        });
    }

    rejected(error) {
        this.throwIfInvalidState({
            accepted: [
                REQUEST_STATE.PENDING,
                REQUEST_STATE.SENT
            ],
            next: REQUEST_STATE.REJECTED
        });
        this[PRIVATE$2.STATE] = REQUEST_STATE.REJECTED;
        this.duration = Date.now() - this.sentAt;
        this.entry.reject(error);
    }

    throwIfInvalidState({accepted, next}) {
        if (accepted.includes(this[PRIVATE$2.STATE])) {
            return;
        }
        const current = this[PRIVATE$2.STATE].toString();
        throw new KafkaJSNonRetriableError$3(`Invalid state, can't transition from ${current} to ${next.toString()}`);
    }
};
var _socketRequest = exports$4W;
var exports$4X = {};
const EventEmitter$1 = y1;
const SocketRequest = _socketRequest;
const events$1 = _instrumentationEvents;
const {KafkaJSInvariantViolation: KafkaJSInvariantViolation$1} = _errors;
const PRIVATE$3 = {
    EMIT_QUEUE_SIZE_EVENT: Symbol("private:RequestQueue:emitQueueSizeEvent"),
    EMIT_REQUEST_QUEUE_EMPTY: Symbol("private:RequestQueue:emitQueueEmpty")
};
const REQUEST_QUEUE_EMPTY = "requestQueueEmpty";
exports$4X = class RequestQueue extends EventEmitter$1 {
    constructor({
        instrumentationEmitter: instrumentationEmitter1 = null,
        maxInFlightRequests: maxInFlightRequests3,
        requestTimeout: requestTimeout2,
        enforceRequestTimeout,
        clientId: clientId1,
        broker: broker5,
        logger: logger9,
        isConnected = () => true
    }) {
        super();
        this.instrumentationEmitter = instrumentationEmitter1;
        this.maxInFlightRequests = maxInFlightRequests3;
        this.requestTimeout = requestTimeout2;
        this.enforceRequestTimeout = enforceRequestTimeout;
        this.clientId = clientId1;
        this.broker = broker5;
        this.logger = logger9;
        this.isConnected = isConnected;
        this.inflight = new Map();
        this.pending = [];
        this.throttledUntil = -1;
        this.throttleCheckTimeoutId = null;
        this[PRIVATE$3.EMIT_REQUEST_QUEUE_EMPTY] = () => {
            if (this.pending.length === 0 && this.inflight.size === 0) {
                this.emit(REQUEST_QUEUE_EMPTY);
            }
        };
        this[PRIVATE$3.EMIT_QUEUE_SIZE_EVENT] = () => {
            instrumentationEmitter1 && instrumentationEmitter1.emit(events$1.NETWORK_REQUEST_QUEUE_SIZE, {
                broker: this.broker,
                clientId: this.clientId,
                queueSize: this.pending.length
            });
            this[PRIVATE$3.EMIT_REQUEST_QUEUE_EMPTY]();
        };
    }

    scheduleRequestTimeoutCheck() {
        if (this.enforceRequestTimeout) {
            this.destroy();
            this.requestTimeoutIntervalId = setInterval(() => {
                this.inflight.forEach((request) => {
                    if (Date.now() - request.sentAt > request.requestTimeout) {
                        request.timeoutRequest();
                    }
                });
                if (!this.isConnected()) {
                    this.destroy();
                }
            }, Math.min(this.requestTimeout, 100));
        }
    }

    maybeThrottle(clientSideThrottleTime) {
        if (clientSideThrottleTime) {
            const minimumThrottledUntil = Date.now() + clientSideThrottleTime;
            this.throttledUntil = Math.max(minimumThrottledUntil, this.throttledUntil);
        }
    }

    push(pushedRequest) {
        const {correlationId: correlationId1} = pushedRequest.entry;
        const defaultRequestTimeout = this.requestTimeout;
        const customRequestTimeout = pushedRequest.requestTimeout;
        const requestTimeout3 = Math.max(defaultRequestTimeout, customRequestTimeout || 0);
        const socketRequest = new SocketRequest({
            entry: pushedRequest.entry,
            expectResponse: pushedRequest.expectResponse,
            broker: this.broker,
            clientId: this.clientId,
            instrumentationEmitter: this.instrumentationEmitter,
            requestTimeout: requestTimeout3,
            send: () => {
                if (this.inflight.has(correlationId1)) {
                    throw new KafkaJSInvariantViolation$1("Correlation id already exists");
                }
                this.inflight.set(correlationId1, socketRequest);
                pushedRequest.sendRequest();
            },
            timeout: () => {
                this.inflight.delete(correlationId1);
                this.checkPendingRequests();
            }
        });
        if (this.canSendSocketRequestImmediately()) {
            this.sendSocketRequest(socketRequest);
            return;
        }
        this.pending.push(socketRequest);
        this.scheduleCheckPendingRequests();
        this.logger.debug(`Request enqueued`, {
            clientId: this.clientId,
            broker: this.broker,
            correlationId: correlationId1
        });
        this[PRIVATE$3.EMIT_QUEUE_SIZE_EVENT]();
    }

    sendSocketRequest(socketRequest) {
        socketRequest.send();
        if (!socketRequest.expectResponse) {
            this.logger.debug(`Request does not expect a response, resolving immediately`, {
                clientId: this.clientId,
                broker: this.broker,
                correlationId: socketRequest.correlationId
            });
            this.inflight.delete(socketRequest.correlationId);
            socketRequest.completed({
                size: 0,
                payload: null
            });
        }
    }

    fulfillRequest({correlationId, payload, size}) {
        const socketRequest = this.inflight.get(correlationId);
        this.inflight.delete(correlationId);
        this.checkPendingRequests();
        if (socketRequest) {
            socketRequest.completed({
                size,
                payload
            });
        } else {
            this.logger.warn(`Response without match`, {
                clientId: this.clientId,
                broker: this.broker,
                correlationId
            });
        }
        this[PRIVATE$3.EMIT_REQUEST_QUEUE_EMPTY]();
    }

    rejectAll(error) {
        const requests1 = [
            ...this.inflight.values(),
            ...this.pending
        ];
        for (const socketRequest of requests1) {
            socketRequest.rejected(error);
            this.inflight.delete(socketRequest.correlationId);
        }
        this.pending = [];
        this.inflight.clear();
        this[PRIVATE$3.EMIT_QUEUE_SIZE_EVENT]();
    }

    waitForPendingRequests() {
        return new Promise((resolve) => {
            if (this.pending.length === 0 && this.inflight.size === 0) {
                return resolve();
            }
            this.logger.debug("Waiting for pending requests", {
                clientId: this.clientId,
                broker: this.broker,
                currentInflightRequests: this.inflight.size,
                currentPendingQueueSize: this.pending.length
            });
            this.once(REQUEST_QUEUE_EMPTY, () => resolve()
            );
        });
    }

    destroy() {
        clearInterval(this.requestTimeoutIntervalId);
        clearTimeout(this.throttleCheckTimeoutId);
        this.throttleCheckTimeoutId = null;
    }

    canSendSocketRequestImmediately() {
        const shouldEnqueue = this.maxInFlightRequests != null && this.inflight.size >= this.maxInFlightRequests || this.throttledUntil > Date.now();
        return !shouldEnqueue;
    }

    checkPendingRequests() {
        while (this.pending.length > 0 && this.canSendSocketRequestImmediately()) {
            const pendingRequest = this.pending.shift();
            this.sendSocketRequest(pendingRequest);
            this.logger.debug(`Consumed pending request`, {
                clientId: this.clientId,
                broker: this.broker,
                correlationId: pendingRequest.correlationId,
                pendingDuration: pendingRequest.pendingDuration,
                currentPendingQueueSize: this.pending.length
            });
            this[PRIVATE$3.EMIT_QUEUE_SIZE_EVENT]();
        }
        this.scheduleCheckPendingRequests();
    }

    scheduleCheckPendingRequests() {
        const timeUntilUnthrottled = this.throttledUntil - Date.now();
        if (timeUntilUnthrottled > 0 && !this.throttleCheckTimeoutId) {
            this.throttleCheckTimeoutId = setTimeout(() => {
                this.throttleCheckTimeoutId = null;
                this.checkPendingRequests();
            }, timeUntilUnthrottled);
        }
    }
};
var _requestQueue = exports$4X;
var exports$4Y = {};
const CONNECTION_STATUS = {
    CONNECTED: "connected",
    DISCONNECTING: "disconnecting",
    DISCONNECTED: "disconnected"
};
const CONNECTED_STATUS = [
    CONNECTION_STATUS.CONNECTED,
    CONNECTION_STATUS.DISCONNECTING
];
exports$4Y = {
    CONNECTION_STATUS,
    CONNECTED_STATUS
};
var _connectionStatus = exports$4Y;
var exports$4Z = {};
var Buffer$8 = e$1.Buffer;
const createRetry$1 = _retry;
const createSocket = _socket;
const createRequest = _request$z;
const Decoder$17 = _decoder;
const {
    KafkaJSConnectionError: KafkaJSConnectionError$1,
    KafkaJSConnectionClosedError: KafkaJSConnectionClosedError$1
} = _errors;
const {INT_32_MAX_VALUE: INT_32_MAX_VALUE$1} = _constants;
const getEnv = _env;
const RequestQueue = _requestQueue;
const {CONNECTION_STATUS: CONNECTION_STATUS$1, CONNECTED_STATUS: CONNECTED_STATUS$1} = _connectionStatus;
const requestInfo = ({
            apiName: apiName1,
            apiKey: apiKey2,
            apiVersion: apiVersion1
        }) => `${apiName1}(key: ${apiKey2}, version: ${apiVersion1})`
;
exports$4Z = class Connection {
    constructor({
        host: host2,
        port: port2,
        logger: logger10,
        socketFactory,
        requestTimeout: requestTimeout3,
        rack = null,
        ssl = null,
        sasl = null,
        clientId: clientId2 = "kafkajs",
        connectionTimeout = 1000,
        enforceRequestTimeout: enforceRequestTimeout1 = false,
        maxInFlightRequests: maxInFlightRequests1 = null,
        instrumentationEmitter: instrumentationEmitter2 = null,
        retry: retry1 = {}
    }) {
        this.host = host2;
        this.port = port2;
        this.rack = rack;
        this.clientId = clientId2;
        this.broker = `${this.host}:${this.port}`;
        this.logger = logger10.namespace("Connection");
        this.socketFactory = socketFactory;
        this.ssl = ssl;
        this.sasl = sasl;
        this.retry = retry1;
        this.retrier = createRetry$1({
            ...this.retry
        });
        this.requestTimeout = requestTimeout3;
        this.connectionTimeout = connectionTimeout;
        this.bytesBuffered = 0;
        this.bytesNeeded = Decoder$17.int32Size();
        this.chunks = [];
        this.connectionStatus = CONNECTION_STATUS$1.DISCONNECTED;
        this.correlationId = 0;
        this.requestQueue = new RequestQueue({
            instrumentationEmitter: instrumentationEmitter2,
            maxInFlightRequests: maxInFlightRequests1,
            requestTimeout: requestTimeout3,
            enforceRequestTimeout: enforceRequestTimeout1,
            clientId: clientId2,
            broker: this.broker,
            logger: logger10.namespace("RequestQueue"),
            isConnected: () => this.connected
        });
        this.authHandlers = null;
        this.authExpectResponse = false;
        const log = (level) => (message1, extra = {}) => {
                    const logFn = this.logger[level];
                    logFn(message1, {
                        broker: this.broker,
                        clientId: clientId2,
                        ...extra
                    });
                }
        ;
        this.logDebug = log("debug");
        this.logError = log("error");
        const env = getEnv();
        this.shouldLogBuffers = env.KAFKAJS_DEBUG_PROTOCOL_BUFFERS === "1";
        this.shouldLogFetchBuffer = this.shouldLogBuffers && env.KAFKAJS_DEBUG_EXTENDED_PROTOCOL_BUFFERS === "1";
    }

    get connected() {
        return CONNECTED_STATUS$1.includes(this.connectionStatus);
    }

    connect() {
        return new Promise((resolve, reject) => {
            if (this.connected) {
                return resolve(true);
            }
            let timeoutId;
            const onConnect = () => {
                clearTimeout(timeoutId);
                this.connectionStatus = CONNECTION_STATUS$1.CONNECTED;
                this.requestQueue.scheduleRequestTimeoutCheck();
                resolve(true);
            };
            const onData = (data) => {
                this.processData(data);
            };
            const onEnd = async () => {
                clearTimeout(timeoutId);
                const wasConnected = this.connected;
                if (this.authHandlers) {
                    this.authHandlers.onError();
                } else if (wasConnected) {
                    this.logDebug("Kafka server has closed connection");
                    this.rejectRequests(new KafkaJSConnectionClosedError$1("Closed connection", {
                        host: this.host,
                        port: this.port
                    }));
                }
                await this.disconnect();
            };
            const onError = async (e46) => {
                clearTimeout(timeoutId);
                const error = new KafkaJSConnectionError$1(`Connection error: ${e46.message}`, {
                    broker: `${this.host}:${this.port}`,
                    code: e46.code
                });
                this.logError(error.message, {
                    stack: e46.stack
                });
                this.rejectRequests(error);
                await this.disconnect();
                reject(error);
            };
            const onTimeout = async () => {
                const error = new KafkaJSConnectionError$1("Connection timeout", {
                    broker: `${this.host}:${this.port}`
                });
                this.logError(error.message);
                this.rejectRequests(error);
                await this.disconnect();
                reject(error);
            };
            this.logDebug(`Connecting`, {
                ssl: !!this.ssl,
                sasl: !!this.sasl
            });
            try {
                timeoutId = setTimeout(onTimeout, this.connectionTimeout);
                this.socket = createSocket({
                    socketFactory: this.socketFactory,
                    host: this.host,
                    port: this.port,
                    ssl: this.ssl,
                    onConnect,
                    onData,
                    onEnd,
                    onError,
                    onTimeout
                });
            } catch (e46) {
                clearTimeout(timeoutId);
                reject(new KafkaJSConnectionError$1(`Failed to connect: ${e46.message}`, {
                    broker: `${this.host}:${this.port}`
                }));
            }
        });
    }

    async disconnect() {
        this.connectionStatus = CONNECTION_STATUS$1.DISCONNECTING;
        this.logDebug("disconnecting...");
        await this.requestQueue.waitForPendingRequests();
        this.requestQueue.destroy();
        if (this.socket) {
            this.socket.end();
            this.socket.unref();
        }
        this.connectionStatus = CONNECTION_STATUS$1.DISCONNECTED;
        this.logDebug("disconnected");
        return true;
    }

    authenticate({authExpectResponse = false, request, response}) {
        this.authExpectResponse = authExpectResponse;
        return new Promise(async (resolve, reject) => {
            this.authHandlers = {
                onSuccess: (rawData) => {
                    this.authHandlers = null;
                    this.authExpectResponse = false;
                    response.decode(rawData).then((data) => response.parse(data)
                    ).then(resolve).catch(reject);
                },
                onError: () => {
                    this.authHandlers = null;
                    this.authExpectResponse = false;
                    reject(new KafkaJSConnectionError$1("Connection closed by the server", {
                        broker: `${this.host}:${this.port}`
                    }));
                }
            };
            try {
                const requestPayload = await request.encode();
                this.failIfNotConnected();
                this.socket.write(requestPayload.buffer, "binary");
            } catch (e46) {
                reject(e46);
            }
        });
    }

    async send({request, response, requestTimeout = null, logResponseError = true}) {
        this.failIfNotConnected();
        const expectResponse1 = !request.expectResponse || request.expectResponse();
        const sendRequest = async () => {
            const {clientId: clientId3} = this;
            const correlationId2 = this.nextCorrelationId();
            const requestPayload = await createRequest({
                request,
                correlationId: correlationId2,
                clientId: clientId3
            });
            const {apiKey: apiKey2, apiName: apiName1, apiVersion: apiVersion1} = request;
            this.logDebug(`Request ${requestInfo(request)}`, {
                correlationId: correlationId2,
                expectResponse: expectResponse1,
                size: Buffer$8.byteLength(requestPayload.buffer)
            });
            return new Promise((resolve, reject) => {
                try {
                    this.failIfNotConnected();
                    const entry1 = {
                        apiKey: apiKey2,
                        apiName: apiName1,
                        apiVersion: apiVersion1,
                        correlationId: correlationId2,
                        resolve,
                        reject
                    };
                    this.requestQueue.push({
                        entry: entry1,
                        expectResponse: expectResponse1,
                        requestTimeout,
                        sendRequest: () => {
                            this.socket.write(requestPayload.buffer, "binary");
                        }
                    });
                } catch (e46) {
                    reject(e46);
                }
            });
        };
        const {correlationId: correlationId2, size, entry: entry1, payload: payload2} = await sendRequest();
        if (!expectResponse1) {
            return;
        }
        try {
            const payloadDecoded = await response.decode(payload2);
            this.requestQueue.maybeThrottle(payloadDecoded.clientSideThrottleTime);
            const data = await response.parse(payloadDecoded);
            const isFetchApi = entry1.apiName === "Fetch";
            this.logDebug(`Response ${requestInfo(entry1)}`, {
                correlationId: correlationId2,
                size,
                data: isFetchApi && !this.shouldLogFetchBuffer ? "[filtered]" : data
            });
            return data;
        } catch (e46) {
            if (logResponseError) {
                this.logError(`Response ${requestInfo(entry1)}`, {
                    error: e46.message,
                    correlationId: correlationId2,
                    size
                });
            }
            const isBuffer = Buffer$8.isBuffer(payload2);
            this.logDebug(`Response ${requestInfo(entry1)}`, {
                error: e46.message,
                correlationId: correlationId2,
                payload: isBuffer && !this.shouldLogBuffers ? {
                    type: "Buffer",
                    data: "[filtered]"
                } : payload2
            });
            throw e46;
        }
    }

    failIfNotConnected() {
        if (!this.connected) {
            throw new KafkaJSConnectionError$1("Not connected", {
                broker: `${this.host}:${this.port}`
            });
        }
    }

    nextCorrelationId() {
        if (this.correlationId >= INT_32_MAX_VALUE$1) {
            this.correlationId = 0;
        }
        return this.correlationId++;
    }

    processData(rawData) {
        if (this.authHandlers && !this.authExpectResponse) {
            return this.authHandlers.onSuccess(rawData);
        }
        this.chunks.push(rawData);
        this.bytesBuffered += Buffer$8.byteLength(rawData);
        while (this.bytesNeeded <= this.bytesBuffered) {
            const buffer2 = this.chunks.length > 1 ? Buffer$8.concat(this.chunks) : this.chunks[0];
            const decoder = new Decoder$17(buffer2);
            const expectedResponseSize = decoder.readInt32();
            if (!decoder.canReadBytes(expectedResponseSize)) {
                this.chunks = [
                    buffer2
                ];
                this.bytesBuffered = Buffer$8.byteLength(buffer2);
                this.bytesNeeded = Decoder$17.int32Size() + expectedResponseSize;
                return;
            }
            const response = new Decoder$17(decoder.readBytes(expectedResponseSize));
            const remainderBuffer = decoder.readAll();
            this.chunks = [
                remainderBuffer
            ];
            this.bytesBuffered = Buffer$8.byteLength(remainderBuffer);
            this.bytesNeeded = Decoder$17.int32Size();
            if (this.authHandlers) {
                const rawResponseSize = Decoder$17.int32Size() + expectedResponseSize;
                const rawResponseBuffer = buffer2.slice(0, rawResponseSize);
                return this.authHandlers.onSuccess(rawResponseBuffer);
            }
            const correlationId2 = response.readInt32();
            const payload2 = response.readAll();
            this.requestQueue.fulfillRequest({
                size: expectedResponseSize,
                correlationId: correlationId2,
                payload: payload2
            });
        }
    }

    rejectRequests(error) {
        this.requestQueue.rejectAll(error);
    }
};
var _connection = exports$4Z;
var exports$4_ = {};
const Connection = _connection;
const {
    KafkaJSConnectionError: KafkaJSConnectionError$2,
    KafkaJSNonRetriableError: KafkaJSNonRetriableError$4
} = _errors;
exports$4_ = ({
    socketFactory: socketFactory1,
    brokers,
    ssl: ssl1,
    sasl: sasl1,
    clientId: clientId3,
    requestTimeout: requestTimeout5,
    enforceRequestTimeout: enforceRequestTimeout2,
    connectionTimeout: connectionTimeout1,
    maxInFlightRequests: maxInFlightRequests2,
    retry: retry2,
    logger: logger11,
    instrumentationEmitter: instrumentationEmitter3 = null
}) => {
    let index = 0;
    const getBrokers = async () => {
        if (!brokers) {
            throw new KafkaJSNonRetriableError$4(`Failed to connect: brokers parameter should not be null`);
        }
        if (Array.isArray(brokers)) {
            if (!brokers.length) {
                throw new KafkaJSNonRetriableError$4(`Failed to connect: brokers array is empty`);
            }
            return brokers;
        }
        let list;
        try {
            list = await brokers();
        } catch (e46) {
            const wrappedError = new KafkaJSConnectionError$2(`Failed to connect: "config.brokers" threw: ${e46.message}`);
            wrappedError.stack = `${wrappedError.name}\n  Caused by: ${e46.stack}`;
            throw wrappedError;
        }
        if (!list || list.length === 0) {
            throw new KafkaJSConnectionError$2(`Failed to connect: "config.brokers" returned void or empty array`);
        }
        return list;
    };
    return {
        build: async ({host: host3, port: port3, rack: rack1} = {}) => {
            if (!host3) {
                const list = await getBrokers();
                const randomBroker = list[(index++) % list.length];
                host3 = randomBroker.split(":")[0];
                port3 = Number(randomBroker.split(":")[1]);
            }
            return new Connection({
                host: host3,
                port: port3,
                rack: rack1,
                sasl: sasl1,
                ssl: ssl1,
                clientId: clientId3,
                socketFactory: socketFactory1,
                connectionTimeout: connectionTimeout1,
                requestTimeout: requestTimeout5,
                enforceRequestTimeout: enforceRequestTimeout2,
                maxInFlightRequests: maxInFlightRequests2,
                instrumentationEmitter: instrumentationEmitter3,
                retry: retry2,
                logger: logger11
            });
        }
    };
};
var _connectionBuilder = exports$4_;
var exports$4$ = {};
const BrokerPool = _brokerPool;
const Lock$1 = _lock;
const createRetry$2 = _retry;
const connectionBuilder1 = _connectionBuilder;
const flatten$b = _flatten;
const {EARLIEST_OFFSET: EARLIEST_OFFSET$1, LATEST_OFFSET: LATEST_OFFSET$1} = _constants;
const {
    KafkaJSError: KafkaJSError$2,
    KafkaJSBrokerNotFound: KafkaJSBrokerNotFound$2,
    KafkaJSMetadataNotLoaded: KafkaJSMetadataNotLoaded$1,
    KafkaJSTopicMetadataNotLoaded: KafkaJSTopicMetadataNotLoaded$1,
    KafkaJSGroupCoordinatorNotFound: KafkaJSGroupCoordinatorNotFound$1
} = _errors;
const COORDINATOR_TYPES$1 = _coordinatorTypes;
const {keys: keys$2} = Object;
const mergeTopics = (obj, {topic: topic3, partitions: partitions1}) => ({
            ...obj,
            [topic3]: [
                ...obj[topic3] || [],
                ...partitions1
            ]
        })
;
exports$4$ = class Cluster {
    constructor({
        logger: rootLogger,
        socketFactory: socketFactory1,
        brokers,
        ssl: ssl1,
        sasl: sasl1,
        clientId: clientId3,
        connectionTimeout: connectionTimeout1,
        authenticationTimeout: authenticationTimeout2,
        reauthenticationThreshold: reauthenticationThreshold2,
        requestTimeout: requestTimeout5 = 30000,
        enforceRequestTimeout: enforceRequestTimeout2,
        metadataMaxAge: metadataMaxAge1,
        retry: retry2,
        allowAutoTopicCreation: allowAutoTopicCreation2,
        maxInFlightRequests: maxInFlightRequests2,
        isolationLevel,
        instrumentationEmitter: instrumentationEmitter3 = null,
        offsets: offsets1 = new Map()
    }) {
        this.rootLogger = rootLogger;
        this.logger = rootLogger.namespace("Cluster");
        this.retry = {
            ...retry2
        };
        this.retrier = createRetry$2(this.retry);
        this.connectionBuilder = connectionBuilder1({
            logger: rootLogger,
            instrumentationEmitter: instrumentationEmitter3,
            socketFactory: socketFactory1,
            brokers,
            ssl: ssl1,
            sasl: sasl1,
            clientId: clientId3,
            connectionTimeout: connectionTimeout1,
            requestTimeout: requestTimeout5,
            enforceRequestTimeout: enforceRequestTimeout2,
            maxInFlightRequests: maxInFlightRequests2,
            retry: retry2
        });
        this.targetTopics = new Set();
        this.mutatingTargetTopics = new Lock$1({
            description: `updating target topics`,
            timeout: requestTimeout5
        });
        this.isolationLevel = isolationLevel;
        this.brokerPool = new BrokerPool({
            connectionBuilder: this.connectionBuilder,
            logger: this.rootLogger,
            retry: retry2,
            allowAutoTopicCreation: allowAutoTopicCreation2,
            authenticationTimeout: authenticationTimeout2,
            reauthenticationThreshold: reauthenticationThreshold2,
            metadataMaxAge: metadataMaxAge1
        });
        this.committedOffsetsByGroup = offsets1;
    }

    isConnected() {
        return this.brokerPool.hasConnectedBrokers();
    }

    async connect() {
        await this.brokerPool.connect();
    }

    async disconnect() {
        await this.brokerPool.disconnect();
    }

    removeBroker({host, port}) {
        this.brokerPool.removeBroker({
            host,
            port
        });
    }

    async refreshMetadata() {
        await this.brokerPool.refreshMetadata(Array.from(this.targetTopics));
    }

    async refreshMetadataIfNecessary() {
        await this.brokerPool.refreshMetadataIfNecessary(Array.from(this.targetTopics));
    }

    async metadata({topics = []} = {}) {
        return this.retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await this.brokerPool.refreshMetadataIfNecessary(topics);
                return this.brokerPool.withBroker(async ({broker: broker6}) => broker6.metadata(topics)
                );
            } catch (e46) {
                if (e46.type === "LEADER_NOT_AVAILABLE") {
                    throw e46;
                }
                bail(e46);
            }
        });
    }

    async addTargetTopic(topic) {
        return this.addMultipleTargetTopics([
            topic
        ]);
    }

    async addMultipleTargetTopics(topics) {
        await this.mutatingTargetTopics.acquire();
        try {
            const previousSize = this.targetTopics.size;
            const previousTopics = new Set(this.targetTopics);
            for (const topic4 of topics) {
                this.targetTopics.add(topic4);
            }
            const hasChanged = previousSize !== this.targetTopics.size || !this.brokerPool.metadata;
            if (hasChanged) {
                try {
                    await this.refreshMetadata();
                } catch (e46) {
                    if (e46.type === "INVALID_TOPIC_EXCEPTION" || e46.type === "UNKNOWN_TOPIC_OR_PARTITION") {
                        this.targetTopics = previousTopics;
                    }
                    throw e46;
                }
            }
        } finally {
            await this.mutatingTargetTopics.release();
        }
    }

    async findBroker({nodeId}) {
        try {
            return await this.brokerPool.findBroker({
                nodeId
            });
        } catch (e46) {
            if (e46.name === "KafkaJSBrokerNotFound" || e46.name === "KafkaJSLockTimeout" || e46.name === "KafkaJSConnectionError") {
                await this.refreshMetadata();
            }
            throw e46;
        }
    }

    async findControllerBroker() {
        const {metadata} = this.brokerPool;
        if (!metadata || metadata.controllerId == null) {
            throw new KafkaJSMetadataNotLoaded$1("Topic metadata not loaded");
        }
        const broker6 = await this.findBroker({
            nodeId: metadata.controllerId
        });
        if (!broker6) {
            throw new KafkaJSBrokerNotFound$2(`Controller broker with id ${metadata.controllerId} not found in the cached metadata`);
        }
        return broker6;
    }

    findTopicPartitionMetadata(topic) {
        const {metadata} = this.brokerPool;
        if (!metadata || !metadata.topicMetadata) {
            throw new KafkaJSTopicMetadataNotLoaded$1("Topic metadata not loaded", {
                topic
            });
        }
        const topicMetadata1 = metadata.topicMetadata.find((t25) => t25.topic === topic
        );
        return topicMetadata1 ? topicMetadata1.partitionMetadata : [];
    }

    findLeaderForPartitions(topic, partitions) {
        const partitionMetadata1 = this.findTopicPartitionMetadata(topic);
        return partitions.reduce((result, id1) => {
            const partitionId = parseInt(id1, 10);
            const metadata = partitionMetadata1.find((p35) => p35.partitionId === partitionId
            );
            if (!metadata) {
                return result;
            }
            if (metadata.leader === null || metadata.leader === undefined) {
                throw new KafkaJSError$2("Invalid partition metadata", {
                    topic,
                    partitionId,
                    metadata
                });
            }
            const {leader} = metadata;
            const current = result[leader] || [];
            return {
                ...result,
                [leader]: [
                    ...current,
                    partitionId
                ]
            };
        }, {});
    }

    async findGroupCoordinator({groupId, coordinatorType = COORDINATOR_TYPES$1.GROUP}) {
        return this.retrier(async (bail, retryCount1, retryTime1) => {
            try {
                const {coordinator} = await this.findGroupCoordinatorMetadata({
                    groupId,
                    coordinatorType
                });
                return await this.findBroker({
                    nodeId: coordinator.nodeId
                });
            } catch (e46) {
                if (e46.name === "KafkaJSBrokerNotFound" || e46.type === "GROUP_COORDINATOR_NOT_AVAILABLE") {
                    this.logger.debug(`${e46.message}, refreshing metadata and trying again...`, {
                        groupId,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    await this.refreshMetadata();
                    throw e46;
                }
                if (e46.code === "ECONNREFUSED") {
                    throw e46;
                }
                bail(e46);
            }
        });
    }

    async findGroupCoordinatorMetadata({groupId, coordinatorType}) {
        const brokerMetadata = await this.brokerPool.withBroker(async ({nodeId: nodeId2, broker: broker6}) => {
            return await this.retrier(async (bail, retryCount1, retryTime1) => {
                try {
                    const brokerMetadata1 = await broker6.findGroupCoordinator({
                        groupId,
                        coordinatorType
                    });
                    this.logger.debug("Found group coordinator", {
                        broker: brokerMetadata1.host,
                        nodeId: brokerMetadata1.coordinator.nodeId
                    });
                    return brokerMetadata1;
                } catch (e46) {
                    this.logger.debug("Tried to find group coordinator", {
                        nodeId: nodeId2,
                        error: e46
                    });
                    if (e46.type === "GROUP_COORDINATOR_NOT_AVAILABLE") {
                        this.logger.debug("Group coordinator not available, retrying...", {
                            nodeId: nodeId2,
                            retryCount: retryCount1,
                            retryTime: retryTime1
                        });
                        throw e46;
                    }
                    bail(e46);
                }
            });
        });
        if (brokerMetadata) {
            return brokerMetadata;
        }
        throw new KafkaJSGroupCoordinatorNotFound$1("Failed to find group coordinator");
    }

    defaultOffset({fromBeginning}) {
        return fromBeginning ? EARLIEST_OFFSET$1 : LATEST_OFFSET$1;
    }

    async fetchTopicsOffset(topics) {
        const partitionsPerBroker = {};
        const topicConfigurations = {};
        const addDefaultOffset = (topic4) => (partition2) => {
                    const {timestamp} = topicConfigurations[topic4];
                    return {
                        ...partition2,
                        timestamp
                    };
                }
        ;
        for (const topicData of topics) {
            const {topic: topic4, partitions: partitions2, fromBeginning, fromTimestamp} = topicData;
            const partitionsPerLeader = this.findLeaderForPartitions(topic4, partitions2.map((p35) => p35.partition
            ));
            const timestamp = fromTimestamp != null ? fromTimestamp : this.defaultOffset({
                fromBeginning
            });
            topicConfigurations[topic4] = {
                timestamp
            };
            keys$2(partitionsPerLeader).map((nodeId2) => {
                partitionsPerBroker[nodeId2] = partitionsPerBroker[nodeId2] || {};
                partitionsPerBroker[nodeId2][topic4] = partitions2.filter((p35) => partitionsPerLeader[nodeId2].includes(p35.partition)
                );
            });
        }
        const requests1 = keys$2(partitionsPerBroker).map(async (nodeId2) => {
            const broker6 = await this.findBroker({
                nodeId: nodeId2
            });
            const partitions2 = partitionsPerBroker[nodeId2];
            const {responses: topicOffsets} = await broker6.listOffsets({
                isolationLevel: this.isolationLevel,
                topics: keys$2(partitions2).map((topic4) => ({
                            topic: topic4,
                            partitions: partitions2[topic4].map(addDefaultOffset(topic4))
                        })
                )
            });
            return topicOffsets;
        });
        const responses = await Promise.all(requests1);
        const partitionsPerTopic = flatten$b(responses).reduce(mergeTopics, {});
        return keys$2(partitionsPerTopic).map((topic4) => ({
                    topic: topic4,
                    partitions: partitionsPerTopic[topic4].map(({partition: partition2, offset}) => ({
                                partition: partition2,
                                offset
                            })
                    )
                })
        );
    }

    committedOffsets({groupId}) {
        if (!this.committedOffsetsByGroup.has(groupId)) {
            this.committedOffsetsByGroup.set(groupId, {});
        }
        return this.committedOffsetsByGroup.get(groupId);
    }

    markOffsetAsCommitted({groupId, topic, partition, offset}) {
        const committedOffsets = this.committedOffsets({
            groupId
        });
        committedOffsets[topic] = committedOffsets[topic] || {};
        committedOffsets[topic][partition] = offset;
    }
};
var _cluster = exports$4$;
var exports$50 = {};
var Buffer$9 = e$1.Buffer;
const SEED = 2538058380;
const M12 = 1540483477;
const R8 = 24;
exports$50 = (key) => {
    const data = Buffer$9.isBuffer(key) ? key : Buffer$9.from(String(key));
    const length = data.length;
    let h31 = SEED ^ length;
    let length4 = length / 4;
    for (let i53 = 0; i53 < length4; i53++) {
        const i410 = i53 * 4;
        let k7 = (data[i410 + 0] & 255) + ((data[i410 + 1] & 255) << 8) + ((data[i410 + 2] & 255) << 16) + ((data[i410 + 3] & 255) << 24);
        k7 *= M12;
        k7 ^= k7 >>> R8;
        k7 *= M12;
        h31 *= M12;
        h31 ^= k7;
    }
    switch (length % 4) {
        case 3:
            h31 ^= (data[(length & ~3) + 2] & 255) << 16;
        case 2:
            h31 ^= (data[(length & ~3) + 1] & 255) << 8;
        case 1:
            h31 ^= data[length & ~3] & 255;
            h31 *= M12;
    }
    h31 ^= h31 >>> 13;
    h31 *= M12;
    h31 ^= h31 >>> 15;
    return h31;
};
var _murmur = exports$50;
var _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
var exports$51 = {};
var Buffer$a = e$1.Buffer;
const {KafkaJSNonRetriableError: KafkaJSNonRetriableError$5} = _errors;
const toNodeCompatible = (crypto) => ({
            randomBytes: (size) => crypto.getRandomValues(Buffer$a.allocUnsafe(size))
        })
;
let cryptoImplementation = null;
if (_global$1 && _global$1.crypto) {
    cryptoImplementation = _global$1.crypto.randomBytes === undefined ? toNodeCompatible(_global$1.crypto) : _global$1.crypto;
} else if (_global$1 && _global$1.msCrypto) {
    cryptoImplementation = toNodeCompatible(_global$1.msCrypto);
} else if (_global$1 && !_global$1.crypto) {
    cryptoImplementation = l$q;
}
const MAX_BYTES = 65536;
exports$51 = (size) => {
    if (size > MAX_BYTES) {
        throw new KafkaJSNonRetriableError$5(`Byte length (${size}) exceeds the max number of bytes of entropy available (${MAX_BYTES})`);
    }
    if (!cryptoImplementation) {
        throw new KafkaJSNonRetriableError$5("No available crypto implementation");
    }
    return cryptoImplementation.randomBytes(size);
};
var _randomBytes = exports$51;
var exports$52 = {};
const randomBytes = _randomBytes;
const toPositive = (x10) => x10 & 2147483647
;
exports$52 = (murmur2) => () => {
    let counter = randomBytes(32).readUInt32BE(0);
    return ({topic: topic4, partitionMetadata: partitionMetadata1, message: message1}) => {
        const numPartitions = partitionMetadata1.length;
        const availablePartitions = partitionMetadata1.filter((p35) => p35.leader >= 0
        );
        const numAvailablePartitions = availablePartitions.length;
        if (message1.partition !== null && message1.partition !== undefined) {
            return message1.partition;
        }
        if (message1.key !== null && message1.key !== undefined) {
            return toPositive(murmur2(message1.key)) % numPartitions;
        }
        if (numAvailablePartitions > 0) {
            const i53 = toPositive(++counter) % numAvailablePartitions;
            return availablePartitions[i53].partitionId;
        }
        return toPositive(++counter) % numPartitions;
    };
}
;
var _partitioner = exports$52;
var exports$53 = {};
const murmur2 = _murmur;
const createDefaultPartitioner = _partitioner;
exports$53 = createDefaultPartitioner(murmur2);
var _default = exports$53;
var exports$54 = {};
var Buffer$b = e$1.Buffer;
const Long$5 = _long;
const SEED$1 = _long.fromValue(2538058380);
const M$13 = _long.fromValue(1540483477);
const R$13 = _long.fromValue(24);
exports$54 = (key) => {
    const data = Buffer$b.isBuffer(key) ? key : Buffer$b.from(String(key));
    const length = data.length;
    let h31 = Long$5.fromValue(SEED$1.xor(length));
    let length4 = Math.floor(length / 4);
    for (let i53 = 0; i53 < length4; i53++) {
        const i410 = i53 * 4;
        let k7 = (data[i410 + 0] & 255) + ((data[i410 + 1] & 255) << 8) + ((data[i410 + 2] & 255) << 16) + ((data[i410 + 3] & 255) << 24);
        k7 = Long$5.fromValue(k7);
        k7 = k7.multiply(M$13);
        k7 = k7.xor(k7.toInt() >>> R$13);
        k7 = Long$5.fromValue(k7).multiply(M$13);
        h31 = h31.multiply(M$13);
        h31 = h31.xor(k7);
    }
    switch (length % 4) {
        case 3:
            h31 = h31.xor((data[(length & ~3) + 2] & 255) << 16);
        case 2:
            h31 = h31.xor((data[(length & ~3) + 1] & 255) << 8);
        case 1:
            h31 = h31.xor(data[length & ~3] & 255);
            h31 = h31.multiply(M$13);
    }
    h31 = h31.xor(h31.toInt() >>> 13);
    h31 = h31.multiply(M$13);
    h31 = h31.xor(h31.toInt() >>> 15);
    return h31.toInt();
};
var _murmur$1 = exports$54;
var exports$55 = {};
const murmur2$1 = _murmur$1;
const createDefaultPartitioner$1 = _partitioner;
exports$55 = createDefaultPartitioner$1(murmur2$1);
var _defaultJava = exports$55;
var exports$56 = {};
const DefaultPartitioner = _default;
const JavaCompatiblePartitioner = _defaultJava;
exports$56 = {
    DefaultPartitioner,
    JavaCompatiblePartitioner
};
var _partitioners = exports$56;
var exports$57 = {};
exports$57 = {
    UNINITIALIZED: "UNINITIALIZED",
    READY: "READY",
    TRANSACTING: "TRANSACTING",
    COMMITTING: "COMMITTING",
    ABORTING: "ABORTING"
};
var _transactionStates = exports$57;
var exports$58 = {};
const {EventEmitter: EventEmitter$2} = y1;
const {KafkaJSNonRetriableError: KafkaJSNonRetriableError$6} = _errors;
const STATES = _transactionStates;
const VALID_STATE_TRANSITIONS = {
    [STATES.UNINITIALIZED]: [
        STATES.READY
    ],
    [STATES.READY]: [
        STATES.READY,
        STATES.TRANSACTING
    ],
    [STATES.TRANSACTING]: [
        STATES.COMMITTING,
        STATES.ABORTING
    ],
    [STATES.COMMITTING]: [
        STATES.READY
    ],
    [STATES.ABORTING]: [
        STATES.READY
    ]
};
exports$58 = ({logger: logger11, initialState = STATES.UNINITIALIZED}) => {
    let currentState = initialState;
    const guard = (object, method, {legalStates, async: isAsync = true}) => {
        if (!object[method]) {
            throw new KafkaJSNonRetriableError$6(`Cannot add guard on missing method "${method}"`);
        }
        return (...args) => {
            const fn = object[method];
            if (!legalStates.includes(currentState)) {
                const error = new KafkaJSNonRetriableError$6(`Transaction state exception: Cannot call "${method}" in state "${currentState}"`);
                if (isAsync) {
                    return Promise.reject(error);
                } else {
                    throw error;
                }
            }
            return fn.apply(object, args);
        };
    };
    const stateMachine = Object.assign(new EventEmitter$2(), {
        createGuarded(object, methodStateMapping) {
            const guardedMethods = Object.keys(methodStateMapping).reduce((guards, method) => {
                guards[method] = guard(object, method, methodStateMapping[method]);
                return guards;
            }, {});
            return {
                ...object,
                ...guardedMethods
            };
        },
        transitionTo(state) {
            logger11.debug(`Transaction state transition ${currentState} --> ${state}`);
            if (!VALID_STATE_TRANSITIONS[currentState].includes(state)) {
                throw new KafkaJSNonRetriableError$6(`Transaction state exception: Invalid transition ${currentState} --> ${state}`);
            }
            stateMachine.emit("transition", {
                to: state,
                from: currentState
            });
            currentState = state;
        },
        state() {
            return currentState;
        }
    });
    return stateMachine;
};
var _transactionStateMachine = exports$58;
var exports$59 = {};
const createRetry$3 = _retry;
const {KafkaJSNonRetriableError: KafkaJSNonRetriableError$7} = _errors;
const COORDINATOR_TYPES$2 = _coordinatorTypes;
const createStateMachine = _transactionStateMachine;
const assert = et;
const STATES$1 = _transactionStates;
const NO_PRODUCER_ID = -1;
const SEQUENCE_START = 0;
const INT_32_MAX_VALUE$2 = Math.pow(2, 32);
const INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS = [
    "NOT_COORDINATOR_FOR_GROUP",
    "GROUP_COORDINATOR_NOT_AVAILABLE",
    "GROUP_LOAD_IN_PROGRESS",
    "CONCURRENT_TRANSACTIONS"
];
const COMMIT_RETRIABLE_PROTOCOL_ERRORS = [
    "UNKNOWN_TOPIC_OR_PARTITION",
    "COORDINATOR_LOAD_IN_PROGRESS"
];
const COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS = [
    "COORDINATOR_NOT_AVAILABLE",
    "NOT_COORDINATOR"
];
exports$59 = ({logger: logger11, cluster, transactionTimeout = 60000, transactional, transactionalId}) => {
    if (transactional && !transactionalId) {
        throw new KafkaJSNonRetriableError$7("Cannot manage transactions without a transactionalId");
    }
    const retrier = createRetry$3(cluster.retry);
    let producerId = NO_PRODUCER_ID;
    let producerEpoch = 0;
    let producerSequence = {};
    let transactionTopicPartitions = {};
    const stateMachine = createStateMachine({
        logger: logger11
    });
    stateMachine.on("transition", ({to}) => {
        if (to === STATES$1.READY) {
            transactionTopicPartitions = {};
        }
    });
    const findTransactionCoordinator = () => {
        return cluster.findGroupCoordinator({
            groupId: transactionalId,
            coordinatorType: COORDINATOR_TYPES$2.TRANSACTION
        });
    };
    const transactionalGuard = () => {
        if (!transactional) {
            throw new KafkaJSNonRetriableError$7("Method unavailable if non-transactional");
        }
    };
    const eosManager = stateMachine.createGuarded({
        getProducerId() {
            return producerId;
        },
        getProducerEpoch() {
            return producerEpoch;
        },
        getTransactionalId() {
            return transactionalId;
        },
        async initProducerId() {
            return retrier(async (bail, retryCount1, retryTime1) => {
                try {
                    await cluster.refreshMetadataIfNecessary();
                    const broker6 = await (transactional ? findTransactionCoordinator() : cluster.findControllerBroker());
                    const result = await broker6.initProducerId({
                        transactionalId: transactional ? transactionalId : undefined,
                        transactionTimeout
                    });
                    stateMachine.transitionTo(STATES$1.READY);
                    producerId = result.producerId;
                    producerEpoch = result.producerEpoch;
                    producerSequence = {};
                    logger11.debug("Initialized producer id & epoch", {
                        producerId,
                        producerEpoch
                    });
                } catch (e46) {
                    if (INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS.includes(e46.type)) {
                        if (e46.type === "CONCURRENT_TRANSACTIONS") {
                            logger11.debug("There is an ongoing transaction on this transactionId, retrying", {
                                error: e46.message,
                                stack: e46.stack,
                                transactionalId,
                                retryCount: retryCount1,
                                retryTime: retryTime1
                            });
                        }
                        throw e46;
                    }
                    bail(e46);
                }
            });
        },
        getSequence(topic, partition) {
            if (!eosManager.isInitialized()) {
                return SEQUENCE_START;
            }
            producerSequence[topic] = producerSequence[topic] || {};
            producerSequence[topic][partition] = producerSequence[topic][partition] || SEQUENCE_START;
            return producerSequence[topic][partition];
        },
        updateSequence(topic, partition, increment) {
            if (!eosManager.isInitialized()) {
                return;
            }
            const previous = eosManager.getSequence(topic, partition);
            let sequence = previous + increment;
            if (sequence >= INT_32_MAX_VALUE$2) {
                logger11.debug(`Sequence for ${topic} ${partition} exceeds max value (${sequence}). Rotating to 0.`);
                sequence = 0;
            }
            producerSequence[topic][partition] = sequence;
        },
        beginTransaction() {
            transactionalGuard();
            stateMachine.transitionTo(STATES$1.TRANSACTING);
        },
        async addPartitionsToTransaction(topicData) {
            transactionalGuard();
            const newTopicPartitions = {};
            topicData.forEach(({topic: topic4, partitions: partitions2}) => {
                transactionTopicPartitions[topic4] = transactionTopicPartitions[topic4] || {};
                partitions2.forEach(({partition: partition3}) => {
                    if (!transactionTopicPartitions[topic4][partition3]) {
                        newTopicPartitions[topic4] = newTopicPartitions[topic4] || [];
                        newTopicPartitions[topic4].push(partition3);
                    }
                });
            });
            const topics = Object.keys(newTopicPartitions).map((topic4) => ({
                        topic: topic4,
                        partitions: newTopicPartitions[topic4]
                    })
            );
            if (topics.length) {
                const broker6 = await findTransactionCoordinator();
                await broker6.addPartitionsToTxn({
                    transactionalId,
                    producerId,
                    producerEpoch,
                    topics
                });
            }
            topics.forEach(({topic: topic4, partitions: partitions2}) => {
                partitions2.forEach((partition3) => {
                    transactionTopicPartitions[topic4][partition3] = true;
                });
            });
        },
        async commit() {
            transactionalGuard();
            stateMachine.transitionTo(STATES$1.COMMITTING);
            const broker6 = await findTransactionCoordinator();
            await broker6.endTxn({
                producerId,
                producerEpoch,
                transactionalId,
                transactionResult: true
            });
            stateMachine.transitionTo(STATES$1.READY);
        },
        async abort() {
            transactionalGuard();
            stateMachine.transitionTo(STATES$1.ABORTING);
            const broker6 = await findTransactionCoordinator();
            await broker6.endTxn({
                producerId,
                producerEpoch,
                transactionalId,
                transactionResult: false
            });
            stateMachine.transitionTo(STATES$1.READY);
        },
        isInitialized() {
            return producerId !== NO_PRODUCER_ID;
        },
        isTransactional() {
            return transactional;
        },
        isInTransaction() {
            return stateMachine.state() === STATES$1.TRANSACTING;
        },
        async sendOffsets({consumerGroupId, topics}) {
            assert(consumerGroupId, "Missing consumerGroupId");
            assert(topics, "Missing offset topics");
            const transactionCoordinator = await findTransactionCoordinator();
            await transactionCoordinator.addOffsetsToTxn({
                transactionalId,
                producerId,
                producerEpoch,
                groupId: consumerGroupId
            });
            let groupCoordinator = await cluster.findGroupCoordinator({
                groupId: consumerGroupId,
                coordinatorType: COORDINATOR_TYPES$2.GROUP
            });
            return retrier(async (bail, retryCount1, retryTime1) => {
                try {
                    await groupCoordinator.txnOffsetCommit({
                        transactionalId,
                        producerId,
                        producerEpoch,
                        groupId: consumerGroupId,
                        topics
                    });
                } catch (e46) {
                    if (COMMIT_RETRIABLE_PROTOCOL_ERRORS.includes(e46.type)) {
                        logger11.debug("Group coordinator is not ready yet, retrying", {
                            error: e46.message,
                            stack: e46.stack,
                            transactionalId,
                            retryCount: retryCount1,
                            retryTime: retryTime1
                        });
                        throw e46;
                    }
                    if (COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS.includes(e46.type) || e46.code === "ECONNREFUSED") {
                        logger11.debug("Invalid group coordinator, finding new group coordinator and retrying", {
                            error: e46.message,
                            stack: e46.stack,
                            transactionalId,
                            retryCount: retryCount1,
                            retryTime: retryTime1
                        });
                        groupCoordinator = await cluster.findGroupCoordinator({
                            groupId: consumerGroupId,
                            coordinatorType: COORDINATOR_TYPES$2.GROUP
                        });
                        throw e46;
                    }
                    bail(e46);
                }
            });
        }
    }, {
        initProducerId: {
            legalStates: [
                STATES$1.UNINITIALIZED,
                STATES$1.READY
            ]
        },
        beginTransaction: {
            legalStates: [
                STATES$1.READY
            ],
            async: false
        },
        addPartitionsToTransaction: {
            legalStates: [
                STATES$1.TRANSACTING
            ]
        },
        sendOffsets: {
            legalStates: [
                STATES$1.TRANSACTING
            ]
        },
        commit: {
            legalStates: [
                STATES$1.TRANSACTING
            ]
        },
        abort: {
            legalStates: [
                STATES$1.TRANSACTING
            ]
        }
    });
    return eosManager;
};
var _eosManager = exports$59;
var exports$5a = {};
exports$5a = ({topic: topic4, partitionMetadata: partitionMetadata1, messages, partitioner}) => {
    if (partitionMetadata1.length === 0) {
        return {};
    }
    return messages.reduce((result, message1) => {
        const partition3 = partitioner({
            topic: topic4,
            partitionMetadata: partitionMetadata1,
            message: message1
        });
        const current = result[partition3] || [];
        return Object.assign(result, {
            [partition3]: [
                ...current,
                message1
            ]
        });
    }, {});
};
var _groupMessagesPerPartition = exports$5a;
var exports$5b = {};
exports$5b = (topicDataForBroker) => {
    return topicDataForBroker.map(({
                topic: topic4,
                partitions: partitions2,
                messagesPerPartition,
                sequencePerPartition
            }) => ({
                topic: topic4,
                partitions: partitions2.map((partition3) => ({
                            partition: partition3,
                            firstSequence: sequencePerPartition[partition3],
                            messages: messagesPerPartition[partition3]
                        })
                )
            })
    );
};
var _createTopicData = exports$5b;
var exports$5c = {};
const flatten$c = _flatten;
exports$5c = ({topics}) => {
    const partitions2 = topics.map(({topicName, partitions: partitions3}) => partitions3.map((partition3) => ({
                topicName,
                ...partition3
            })
            )
    );
    return flatten$c(partitions2);
};
var _responseSerializer = exports$5c;
var exports$5d = {};
const flatten$d = _flatten;
const {KafkaJSMetadataNotLoaded: KafkaJSMetadataNotLoaded$2} = _errors;
const {staleMetadata: staleMetadata$1} = _error;
const groupMessagesPerPartition = _groupMessagesPerPartition;
const createTopicData = _createTopicData;
const responseSerializer = _responseSerializer;
const {keys: keys$3} = Object;
exports$5d = ({logger: logger11, cluster, partitioner, eosManager, retrier}) => {
    return async ({acks, timeout: timeout3, compression, topicMessages}) => {
        const responsePerBroker = new Map();
        const createProducerRequests = async (responsePerBroker1) => {
            const topicMetadata1 = new Map();
            await cluster.refreshMetadataIfNecessary();
            for (const {topic: topic4, messages} of topicMessages) {
                const partitionMetadata1 = cluster.findTopicPartitionMetadata(topic4);
                if (partitionMetadata1.length === 0) {
                    logger11.debug("Producing to topic without metadata", {
                        topic: topic4,
                        targetTopics: Array.from(cluster.targetTopics)
                    });
                    throw new KafkaJSMetadataNotLoaded$2("Producing to topic without metadata");
                }
                const messagesPerPartition = groupMessagesPerPartition({
                    topic: topic4,
                    partitionMetadata: partitionMetadata1,
                    messages,
                    partitioner
                });
                const partitions2 = keys$3(messagesPerPartition);
                const sequencePerPartition = partitions2.reduce((result, partition3) => {
                    result[partition3] = eosManager.getSequence(topic4, partition3);
                    return result;
                }, {});
                const partitionsPerLeader = cluster.findLeaderForPartitions(topic4, partitions2);
                const leaders = keys$3(partitionsPerLeader);
                topicMetadata1.set(topic4, {
                    partitionsPerLeader,
                    messagesPerPartition,
                    sequencePerPartition
                });
                for (const nodeId2 of leaders) {
                    const broker6 = await cluster.findBroker({
                        nodeId: nodeId2
                    });
                    if (!responsePerBroker1.has(broker6)) {
                        responsePerBroker1.set(broker6, null);
                    }
                }
            }
            const brokers1 = Array.from(responsePerBroker1.keys());
            const brokersWithoutResponse = brokers1.filter((broker6) => !responsePerBroker1.get(broker6)
            );
            return brokersWithoutResponse.map(async (broker6) => {
                const entries = Array.from(topicMetadata1.entries());
                const topicDataForBroker = entries.filter(([_13, {partitionsPerLeader}]) => !!partitionsPerLeader[broker6.nodeId]
                ).map(([topic5, {partitionsPerLeader, messagesPerPartition, sequencePerPartition}]) => ({
                            topic: topic5,
                            partitions: partitionsPerLeader[broker6.nodeId],
                            sequencePerPartition,
                            messagesPerPartition
                        })
                );
                const topicData = createTopicData(topicDataForBroker);
                try {
                    if (eosManager.isTransactional()) {
                        await eosManager.addPartitionsToTransaction(topicData);
                    }
                    const response = await broker6.produce({
                        transactionalId: eosManager.isTransactional() ? eosManager.getTransactionalId() : undefined,
                        producerId: eosManager.getProducerId(),
                        producerEpoch: eosManager.getProducerEpoch(),
                        acks,
                        timeout: timeout3,
                        compression,
                        topicData
                    });
                    const expectResponse1 = acks !== 0;
                    const formattedResponse = expectResponse1 ? responseSerializer(response) : [];
                    formattedResponse.forEach(({topicName, partition: partition3}) => {
                        const increment = topicMetadata1.get(topicName).messagesPerPartition[partition3].length;
                        eosManager.updateSequence(topicName, partition3, increment);
                    });
                    responsePerBroker1.set(broker6, formattedResponse);
                } catch (e46) {
                    responsePerBroker1.delete(broker6);
                    throw e46;
                }
            });
        };
        return retrier(async (bail, retryCount1, retryTime1) => {
            const topics = topicMessages.map(({topic: topic4}) => topic4
            );
            await cluster.addMultipleTargetTopics(topics);
            try {
                const requests1 = await createProducerRequests(responsePerBroker);
                await Promise.all(requests1);
                const responses = Array.from(responsePerBroker.values());
                return flatten$d(responses);
            } catch (e46) {
                if (e46.name === "KafkaJSConnectionClosedError") {
                    cluster.removeBroker({
                        host: e46.host,
                        port: e46.port
                    });
                }
                if (!cluster.isConnected()) {
                    logger11.debug(`Cluster has disconnected, reconnecting: ${e46.message}`, {
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    await cluster.connect();
                    await cluster.refreshMetadata();
                    throw e46;
                }
                if (staleMetadata$1(e46) || e46.name === "KafkaJSMetadataNotLoaded" || e46.name === "KafkaJSConnectionError" || e46.name === "KafkaJSConnectionClosedError" || e46.name === "KafkaJSProtocolError" && e46.retriable) {
                    logger11.error(`Failed to send messages: ${e46.message}`, {
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    await cluster.refreshMetadata();
                    throw e46;
                }
                logger11.error(`${e46.message}`, {
                    retryCount: retryCount1,
                    retryTime: retryTime1
                });
                if (e46.retriable) {
                    throw e46;
                }
                bail(e46);
            }
        });
    };
};
var _sendMessages = exports$5d;
var exports$5e = {};
const createSendMessages = _sendMessages;
const {KafkaJSError: KafkaJSError$3, KafkaJSNonRetriableError: KafkaJSNonRetriableError$8} = _errors;
const {CONNECTION_STATUS: CONNECTION_STATUS$2} = _connectionStatus;
exports$5e = ({logger: logger11, cluster, partitioner, eosManager, idempotent, retrier, getConnectionStatus}) => {
    const sendMessages = createSendMessages({
        logger: logger11,
        cluster,
        retrier,
        partitioner,
        eosManager
    });
    const validateConnectionStatus = () => {
        const connectionStatus = getConnectionStatus();
        switch (connectionStatus) {
            case CONNECTION_STATUS$2.DISCONNECTING:
                throw new KafkaJSNonRetriableError$8(`The producer is disconnecting; therefore, it can't safely accept messages anymore`);
            case CONNECTION_STATUS$2.DISCONNECTED:
                throw new KafkaJSError$3("The producer is disconnected");
        }
    };
    const sendBatch = async ({acks = -1, timeout: timeout3, compression, topicMessages = []}) => {
        if (topicMessages.some(({topic: topic4}) => !topic4
        )) {
            throw new KafkaJSNonRetriableError$8(`Invalid topic`);
        }
        if (idempotent && acks !== -1) {
            throw new KafkaJSNonRetriableError$8(`Not requiring ack for all messages invalidates the idempotent producer's EoS guarantees`);
        }
        for (const {topic: topic4, messages} of topicMessages) {
            if (!messages) {
                throw new KafkaJSNonRetriableError$8(`Invalid messages array [${messages}] for topic "${topic4}"`);
            }
            const messageWithoutValue = messages.find((message1) => message1.value === undefined
            );
            if (messageWithoutValue) {
                throw new KafkaJSNonRetriableError$8(`Invalid message without value for topic "${topic4}": ${JSON.stringify(messageWithoutValue)}`);
            }
        }
        validateConnectionStatus();
        const mergedTopicMessages = topicMessages.reduce((merged, {topic: topic5, messages: messages1}) => {
            const index = merged.findIndex(({topic: mergedTopic}) => topic5 === mergedTopic
            );
            if (index === -1) {
                merged.push({
                    topic: topic5,
                    messages: messages1
                });
            } else {
                merged[index].messages = [
                    ...merged[index].messages,
                    ...messages1
                ];
            }
            return merged;
        }, []);
        return await sendMessages({
            acks,
            timeout: timeout3,
            compression,
            topicMessages: mergedTopicMessages
        });
    };
    const send1 = async ({acks, timeout: timeout3, compression, topic: topic4, messages}) => {
        const topicMessage = {
            topic: topic4,
            messages
        };
        return sendBatch({
            acks,
            timeout: timeout3,
            compression,
            topicMessages: [
                topicMessage
            ]
        });
    };
    return {
        send: send1,
        sendBatch
    };
};
var _messageProducer = exports$5e;
var exports$5f = {};
const {keys: keys$4} = Object;
exports$5f = (object) => keys$4(object).reduce((result, key) => ({
            ...result,
            [object[key]]: key
        })
        , {})
;
var _swapObject = exports$5f;
var exports$5g = {};
const swapObject = _swapObject;
const networkEvents = _instrumentationEvents;
const InstrumentationEventType$1 = _eventType;
const producerType = InstrumentationEventType$1("producer");
const events$2 = {
    CONNECT: producerType("connect"),
    DISCONNECT: producerType("disconnect"),
    REQUEST: producerType(networkEvents.NETWORK_REQUEST),
    REQUEST_TIMEOUT: producerType(networkEvents.NETWORK_REQUEST_TIMEOUT),
    REQUEST_QUEUE_SIZE: producerType(networkEvents.NETWORK_REQUEST_QUEUE_SIZE)
};
const wrappedEvents = {
    [events$2.REQUEST]: networkEvents.NETWORK_REQUEST,
    [events$2.REQUEST_TIMEOUT]: networkEvents.NETWORK_REQUEST_TIMEOUT,
    [events$2.REQUEST_QUEUE_SIZE]: networkEvents.NETWORK_REQUEST_QUEUE_SIZE
};
const reversedWrappedEvents = swapObject(wrappedEvents);
const unwrap = (eventName) => wrappedEvents[eventName] || eventName
;
const wrap = (eventName) => reversedWrappedEvents[eventName] || eventName
;
exports$5g = {
    events: events$2,
    wrap,
    unwrap
};
var _instrumentationEvents$1 = exports$5g;
var exports$5h = {};
const createRetry$4 = _retry;
const {CONNECTION_STATUS: CONNECTION_STATUS$3} = _connectionStatus;
const {DefaultPartitioner: DefaultPartitioner$1} = _partitioners;
const InstrumentationEventEmitter = _emitter;
const createEosManager = _eosManager;
const createMessageProducer = _messageProducer;
const {events: events$3, wrap: wrapEvent, unwrap: unwrapEvent} = _instrumentationEvents$1;
const {KafkaJSNonRetriableError: KafkaJSNonRetriableError$9} = _errors;
const {values: values$1, keys: keys$5} = Object;
const eventNames = values$1(events$3);
const eventKeys = keys$5(events$3).map((key) => `producer.events.${key}`
).join(", ");
const {CONNECT, DISCONNECT} = events$3;
exports$5h = ({
    cluster,
    logger: rootLogger1,
    createPartitioner = DefaultPartitioner$1,
    retry: retry3,
    idempotent = false,
    transactionalId,
    transactionTimeout,
    instrumentationEmitter: rootInstrumentationEmitter
}) => {
    let connectionStatus = CONNECTION_STATUS$3.DISCONNECTED;
    retry3 = retry3 || {
        retries: idempotent ? Number.MAX_SAFE_INTEGER : 5
    };
    if (idempotent && retry3.retries < 1) {
        throw new KafkaJSNonRetriableError$9("Idempotent producer must allow retries to protect against transient errors");
    }
    const logger11 = rootLogger1.namespace("Producer");
    if (idempotent && retry3.retries < Number.MAX_SAFE_INTEGER) {
        logger11.warn("Limiting retries for the idempotent producer may invalidate EoS guarantees");
    }
    const partitioner = createPartitioner();
    const retrier = createRetry$4(Object.assign({}, cluster.retry, retry3));
    const instrumentationEmitter4 = rootInstrumentationEmitter || new InstrumentationEventEmitter();
    const idempotentEosManager = createEosManager({
        logger: logger11,
        cluster,
        transactionTimeout,
        transactional: false,
        transactionalId
    });
    const {send: send1, sendBatch} = createMessageProducer({
        logger: logger11,
        cluster,
        partitioner,
        eosManager: idempotentEosManager,
        idempotent,
        retrier,
        getConnectionStatus: () => connectionStatus
    });
    let transactionalEosManager;
    const on = (eventName, listener) => {
        if (!eventNames.includes(eventName)) {
            throw new KafkaJSNonRetriableError$9(`Event name should be one of ${eventKeys}`);
        }
        return instrumentationEmitter4.addListener(unwrapEvent(eventName), (event) => {
            event.type = wrapEvent(event.type);
            Promise.resolve(listener(event)).catch((e46) => {
                logger11.error(`Failed to execute listener: ${e46.message}`, {
                    eventName,
                    stack: e46.stack
                });
            });
        });
    };
    const transaction = async () => {
        if (!transactionalId) {
            throw new KafkaJSNonRetriableError$9("Must provide transactional id for transactional producer");
        }
        let transactionDidEnd = false;
        transactionalEosManager = transactionalEosManager || createEosManager({
            logger: logger11,
            cluster,
            transactionTimeout,
            transactional: true,
            transactionalId
        });
        if (transactionalEosManager.isInTransaction()) {
            throw new KafkaJSNonRetriableError$9("There is already an ongoing transaction for this producer. Please end the transaction before beginning another.");
        }
        if (!transactionalEosManager.isInitialized()) {
            await transactionalEosManager.initProducerId();
        }
        transactionalEosManager.beginTransaction();
        const {send: sendTxn, sendBatch: sendBatchTxn} = createMessageProducer({
            logger: logger11,
            cluster,
            partitioner,
            retrier,
            eosManager: transactionalEosManager,
            idempotent: true,
            getConnectionStatus: () => connectionStatus
        });
        const isActive = () => transactionalEosManager.isInTransaction() && !transactionDidEnd
        ;
        const transactionGuard = (fn) => (...args) => {
                    if (!isActive()) {
                        return Promise.reject(new KafkaJSNonRetriableError$9("Cannot continue to use transaction once ended"));
                    }
                    return fn(...args);
                }
        ;
        return {
            sendBatch: transactionGuard(sendBatchTxn),
            send: transactionGuard(sendTxn),
            abort: transactionGuard(async () => {
                await transactionalEosManager.abort();
                transactionDidEnd = true;
            }),
            commit: transactionGuard(async () => {
                await transactionalEosManager.commit();
                transactionDidEnd = true;
            }),
            sendOffsets: transactionGuard(async ({consumerGroupId, topics}) => {
                await transactionalEosManager.sendOffsets({
                    consumerGroupId,
                    topics
                });
                for (const topicOffsets of topics) {
                    const {topic: topic4, partitions: partitions2} = topicOffsets;
                    for (const {partition: partition3, offset} of partitions2) {
                        cluster.markOffsetAsCommitted({
                            groupId: consumerGroupId,
                            topic: topic4,
                            partition: partition3,
                            offset
                        });
                    }
                }
            }),
            isActive
        };
    };
    const getLogger = () => logger11
    ;
    return {
        connect: async () => {
            await cluster.connect();
            connectionStatus = CONNECTION_STATUS$3.CONNECTED;
            instrumentationEmitter4.emit(CONNECT);
            if (idempotent && !idempotentEosManager.isInitialized()) {
                await idempotentEosManager.initProducerId();
            }
        },
        disconnect: async () => {
            connectionStatus = CONNECTION_STATUS$3.DISCONNECTING;
            await cluster.disconnect();
            connectionStatus = CONNECTION_STATUS$3.DISCONNECTED;
            instrumentationEmitter4.emit(DISCONNECT);
        },
        isIdempotent: () => {
            return idempotent;
        },
        events: events$3,
        on,
        send: send1,
        sendBatch,
        transaction,
        logger: getLogger
    };
};
var _producer = exports$5h;
var exports$5i = {};
exports$5i = (timeInMs) => new Promise((resolve) => {
    setTimeout(resolve, timeInMs);
})
;
var _sleep = exports$5i;
var exports$5j = {};
const defaultErrorHandler = (e46) => {
    throw e46;
};

function* BufferedAsyncIterator(promises, handleError = defaultErrorHandler) {
    const promisesQueue = [];
    const resolveRejectQueue = [];
    promises.forEach((promise) => {
        let resolvePromise;
        let rejectPromise;
        promisesQueue.push(new Promise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
        }));
        resolveRejectQueue.push({
            resolve: resolvePromise,
            reject: rejectPromise
        });
        promise.then((result) => {
            const {resolve} = resolveRejectQueue.pop();
            resolve(result);
        }, async (err) => {
            const {reject} = resolveRejectQueue.pop();
            try {
                await handleError(err);
                reject(err);
            } catch (newError) {
                reject(newError);
            }
        });
    });
    while (promisesQueue.length > 0) {
        const nextPromise = promisesQueue.pop();
        yield nextPromise;
    }
}

exports$5j = BufferedAsyncIterator;
var _bufferedAsyncIterator = exports$5j;
var exports$5k = {};
const Long$6 = _long;
exports$5k = (offset) => !offset && offset !== 0 || Long$6.fromValue(offset).isNegative()
;
var _isInvalidOffset = exports$5k;
var exports$5l = {};
const isInvalidOffset = _isInvalidOffset;
const {keys: keys$6, assign: assign$2} = Object;
const indexPartitions = (obj, {partition: partition3, offset}) => assign$2(obj, {
            [partition3]: offset
        })
;
const indexTopics = (obj, {topic: topic4, partitions: partitions2}) => assign$2(obj, {
            [topic4]: partitions2.reduce(indexPartitions, {})
        })
;
exports$5l = (consumerOffsets, topicOffsets) => {
    const indexedConsumerOffsets = consumerOffsets.reduce(indexTopics, {});
    const indexedTopicOffsets = topicOffsets.reduce(indexTopics, {});
    return keys$6(indexedConsumerOffsets).map((topic4) => {
        const partitions2 = indexedConsumerOffsets[topic4];
        return {
            topic: topic4,
            partitions: keys$6(partitions2).map((partition3) => {
                const offset = partitions2[partition3];
                const resolvedOffset = isInvalidOffset(offset) ? indexedTopicOffsets[topic4][partition3] : offset;
                return {
                    partition: Number(partition3),
                    offset: resolvedOffset
                };
            })
        };
    });
};
var _initializeConsumerOffsets = exports$5l;
var exports$5m = {};
const swapObject$1 = _swapObject;
const InstrumentationEventType$2 = _eventType;
const networkEvents$1 = _instrumentationEvents;
const consumerType = InstrumentationEventType$2("consumer");
const events$4 = {
    HEARTBEAT: consumerType("heartbeat"),
    COMMIT_OFFSETS: consumerType("commit_offsets"),
    GROUP_JOIN: consumerType("group_join"),
    FETCH: consumerType("fetch"),
    FETCH_START: consumerType("fetch_start"),
    START_BATCH_PROCESS: consumerType("start_batch_process"),
    END_BATCH_PROCESS: consumerType("end_batch_process"),
    CONNECT: consumerType("connect"),
    DISCONNECT: consumerType("disconnect"),
    STOP: consumerType("stop"),
    CRASH: consumerType("crash"),
    RECEIVED_UNSUBSCRIBED_TOPICS: consumerType("received_unsubscribed_topics"),
    REQUEST: consumerType(networkEvents$1.NETWORK_REQUEST),
    REQUEST_TIMEOUT: consumerType(networkEvents$1.NETWORK_REQUEST_TIMEOUT),
    REQUEST_QUEUE_SIZE: consumerType(networkEvents$1.NETWORK_REQUEST_QUEUE_SIZE)
};
const wrappedEvents$1 = {
    [events$4.REQUEST]: networkEvents$1.NETWORK_REQUEST,
    [events$4.REQUEST_TIMEOUT]: networkEvents$1.NETWORK_REQUEST_TIMEOUT,
    [events$4.REQUEST_QUEUE_SIZE]: networkEvents$1.NETWORK_REQUEST_QUEUE_SIZE
};
const reversedWrappedEvents$1 = swapObject$1(wrappedEvents$1);
const unwrap$1 = (eventName) => wrappedEvents$1[eventName] || eventName
;
const wrap$1 = (eventName) => reversedWrappedEvents$1[eventName] || eventName
;
exports$5m = {
    events: events$4,
    wrap: wrap$1,
    unwrap: unwrap$1
};
var _instrumentationEvents$2 = exports$5m;
var exports$5n = {};
const Long$7 = _long;
const flatten$e = _flatten;
const isInvalidOffset$1 = _isInvalidOffset;
const initializeConsumerOffsets = _initializeConsumerOffsets;
const {events: {COMMIT_OFFSETS}} = _instrumentationEvents$2;
const {keys: keys$7, assign: assign$3} = Object;
const indexTopics$1 = (topics) => topics.reduce((obj, topic4) => assign$3(obj, {
            [topic4]: {}
        })
        , {})
;
const PRIVATE$4 = {
    COMMITTED_OFFSETS: Symbol("private:OffsetManager:committedOffsets")
};
exports$5n = class OffsetManager {
    constructor({
        cluster,
        coordinator,
        memberAssignment,
        autoCommitInterval,
        autoCommitThreshold,
        topicConfigurations,
        instrumentationEmitter: instrumentationEmitter4,
        groupId: groupId2,
        generationId,
        memberId: memberId2
    }) {
        this.cluster = cluster;
        this.coordinator = coordinator;
        this.memberAssignment = memberAssignment;
        this.topicConfigurations = topicConfigurations;
        this.instrumentationEmitter = instrumentationEmitter4;
        this.groupId = groupId2;
        this.generationId = generationId;
        this.memberId = memberId2;
        this.autoCommitInterval = autoCommitInterval;
        this.autoCommitThreshold = autoCommitThreshold;
        this.lastCommit = Date.now();
        this.topics = keys$7(memberAssignment);
        this.clearAllOffsets();
    }

    nextOffset(topic, partition) {
        if (!this.resolvedOffsets[topic][partition]) {
            this.resolvedOffsets[topic][partition] = this.committedOffsets()[topic][partition];
        }
        let offset = this.resolvedOffsets[topic][partition];
        if (isInvalidOffset$1(offset)) {
            offset = "0";
        }
        return Long$7.fromValue(offset);
    }

    async getCoordinator() {
        if (!this.coordinator.isConnected()) {
            this.coordinator = await this.cluster.findBroker(this.coordinator);
        }
        return this.coordinator;
    }

    resetOffset({topic, partition}) {
        this.resolvedOffsets[topic][partition] = this.committedOffsets()[topic][partition];
    }

    resolveOffset({topic, partition, offset}) {
        this.resolvedOffsets[topic][partition] = Long$7.fromValue(offset).add(1).toString();
    }

    countResolvedOffsets() {
        const committedOffsets = this.committedOffsets();
        const subtractOffsets = (resolvedOffset, committedOffset) => {
            const resolvedOffsetLong = Long$7.fromValue(resolvedOffset);
            return isInvalidOffset$1(committedOffset) ? resolvedOffsetLong : resolvedOffsetLong.subtract(Long$7.fromValue(committedOffset));
        };
        const subtractPartitionOffsets = (resolvedTopicOffsets, committedTopicOffsets) => keys$7(resolvedTopicOffsets).map((partition3) => subtractOffsets(resolvedTopicOffsets[partition3], committedTopicOffsets[partition3])
                )
        ;
        const subtractTopicOffsets = (topic4) => subtractPartitionOffsets(this.resolvedOffsets[topic4], committedOffsets[topic4])
        ;
        const offsetsDiff = this.topics.map(subtractTopicOffsets);
        return flatten$e(offsetsDiff).reduce((sum, offset) => sum.add(offset)
                , Long$7.fromValue(0));
    }

    async setDefaultOffset({topic, partition}) {
        const {groupId: groupId1, generationId: generationId1, memberId: memberId3} = this;
        const defaultOffset = this.cluster.defaultOffset(this.topicConfigurations[topic]);
        const coordinator1 = await this.getCoordinator();
        await coordinator1.offsetCommit({
            groupId: groupId1,
            memberId: memberId3,
            groupGenerationId: generationId1,
            topics: [
                {
                    topic,
                    partitions: [
                        {
                            partition,
                            offset: defaultOffset
                        }
                    ]
                }
            ]
        });
        this.clearOffsets({
            topic,
            partition
        });
    }

    async seek({topic, partition, offset}) {
        if (!this.memberAssignment[topic] || !this.memberAssignment[topic].includes(partition)) {
            return;
        }
        const {groupId: groupId1, generationId: generationId1, memberId: memberId3} = this;
        const coordinator1 = await this.getCoordinator();
        await coordinator1.offsetCommit({
            groupId: groupId1,
            memberId: memberId3,
            groupGenerationId: generationId1,
            topics: [
                {
                    topic,
                    partitions: [
                        {
                            partition,
                            offset
                        }
                    ]
                }
            ]
        });
        this.clearOffsets({
            topic,
            partition
        });
    }

    async commitOffsetsIfNecessary() {
        const now = Date.now();
        const timeoutReached = this.autoCommitInterval != null && now >= this.lastCommit + this.autoCommitInterval;
        const thresholdReached = this.autoCommitThreshold != null && this.countResolvedOffsets().gte(Long$7.fromValue(this.autoCommitThreshold));
        if (timeoutReached || thresholdReached) {
            return this.commitOffsets();
        }
    }

    uncommittedOffsets() {
        const offsets1 = (topic4) => keys$7(this.resolvedOffsets[topic4])
        ;
        const emptyPartitions = ({partitions: partitions2}) => partitions2.length > 0
        ;
        const toPartitions = (topic4) => (partition3) => ({
                    partition: partition3,
                    offset: this.resolvedOffsets[topic4][partition3]
                })
        ;
        const changedOffsets = (topic4) => ({partition: partition3, offset}) => {
                    return offset !== this.committedOffsets()[topic4][partition3] && Long$7.fromValue(offset).greaterThanOrEqual(0);
                }
        ;
        const topicsWithPartitionsToCommit = this.topics.map((topic4) => ({
                    topic: topic4,
                    partitions: offsets1(topic4).map(toPartitions(topic4)).filter(changedOffsets(topic4))
                })
        ).filter(emptyPartitions);
        return {
            topics: topicsWithPartitionsToCommit
        };
    }

    async commitOffsets(offsets = {}) {
        const {groupId: groupId1, generationId: generationId1, memberId: memberId3} = this;
        const {topics = this.uncommittedOffsets().topics} = offsets;
        if (topics.length === 0) {
            this.lastCommit = Date.now();
            return;
        }
        const payload2 = {
            groupId: groupId1,
            memberId: memberId3,
            groupGenerationId: generationId1,
            topics
        };
        try {
            const coordinator1 = await this.getCoordinator();
            await coordinator1.offsetCommit(payload2);
            this.instrumentationEmitter.emit(COMMIT_OFFSETS, payload2);
            topics.forEach(({topic: topic4, partitions: partitions2}) => {
                const updatedOffsets = partitions2.reduce((obj, {partition: partition3, offset}) => assign$3(obj, {
                            [partition3]: offset
                        })
                        , {});
                assign$3(this.committedOffsets()[topic4], updatedOffsets);
            });
            this.lastCommit = Date.now();
        } catch (e46) {
            if (e46.type === "NOT_COORDINATOR_FOR_GROUP") {
                await this.cluster.refreshMetadata();
            }
            throw e46;
        }
    }

    async resolveOffsets() {
        const {groupId: groupId1} = this;
        const invalidOffset = (topic4) => (partition3) => {
                    return isInvalidOffset$1(this.committedOffsets()[topic4][partition3]);
                }
        ;
        const pendingPartitions = this.topics.map((topic4) => ({
                    topic: topic4,
                    partitions: this.memberAssignment[topic4].filter(invalidOffset(topic4)).map((partition3) => ({
                                partition: partition3
                            })
                    )
                })
        ).filter((t25) => t25.partitions.length > 0
        );
        if (pendingPartitions.length === 0) {
            return;
        }
        const coordinator1 = await this.getCoordinator();
        const {responses: consumerOffsets} = await coordinator1.offsetFetch({
            groupId: groupId1,
            topics: pendingPartitions
        });
        const unresolvedPartitions = consumerOffsets.map(({topic: topic4, partitions: partitions2}) => assign$3({
                    topic: topic4,
                    partitions: partitions2.filter(({offset}) => isInvalidOffset$1(offset)
                    ).map(({partition: partition3}) => assign$3({
                                partition: partition3
                            })
                    )
                }, this.topicConfigurations[topic4])
        );
        const indexPartitions1 = (obj, {partition: partition3, offset}) => {
            return assign$3(obj, {
                [partition3]: offset
            });
        };
        const hasUnresolvedPartitions = () => unresolvedPartitions.filter((t25) => t25.partitions.length > 0
                ).length > 0
        ;
        let offsets2 = consumerOffsets;
        if (hasUnresolvedPartitions()) {
            const topicOffsets = await this.cluster.fetchTopicsOffset(unresolvedPartitions);
            offsets2 = initializeConsumerOffsets(consumerOffsets, topicOffsets);
        }
        offsets2.forEach(({topic: topic4, partitions: partitions2}) => {
            this.committedOffsets()[topic4] = partitions2.reduce(indexPartitions1, {
                ...this.committedOffsets()[topic4]
            });
        });
    }

    clearOffsets({topic, partition}) {
        delete this.committedOffsets()[topic][partition];
        delete this.resolvedOffsets[topic][partition];
    }

    clearAllOffsets() {
        const committedOffsets = this.committedOffsets();
        for (const topic4 in committedOffsets) {
            delete committedOffsets[topic4];
        }
        for (const topic5 of this.topics) {
            committedOffsets[topic5] = {};
        }
        this.resolvedOffsets = indexTopics$1(this.topics);
    }

    committedOffsets() {
        if (!this[PRIVATE$4.COMMITTED_OFFSETS]) {
            this[PRIVATE$4.COMMITTED_OFFSETS] = this.groupId ? this.cluster.committedOffsets({
                groupId: this.groupId
            }) : {};
        }
        return this[PRIVATE$4.COMMITTED_OFFSETS];
    }
};
var _offsetManager = exports$5n;
var exports$5o = {};
var Buffer$c = e$1.Buffer;
const Long$8 = _long;
const ABORTED_MESSAGE_KEY = Buffer$c.from([
    0,
    0,
    0,
    0
]);
const isAbortMarker = ({key}) => {
    if (!key) {
        return false;
    }
    return Buffer$c.from(key).equals(ABORTED_MESSAGE_KEY);
};
exports$5o = ({messages, abortedTransactions}) => {
    const currentAbortedTransactions = new Map();
    if (!abortedTransactions || !abortedTransactions.length) {
        return messages;
    }
    const remainingAbortedTransactions = [
        ...abortedTransactions
    ];
    return messages.filter((message1) => {
        if (remainingAbortedTransactions.length && Long$8.fromValue(message1.offset).gte(remainingAbortedTransactions[0].firstOffset)) {
            const {producerId} = remainingAbortedTransactions.shift();
            currentAbortedTransactions.set(producerId, true);
        }
        const {producerId, inTransaction} = message1.batchContext;
        if (isAbortMarker(message1)) {
            currentAbortedTransactions.delete(producerId);
        } else if (currentAbortedTransactions.has(producerId) && inTransaction) {
            return false;
        }
        return true;
    });
};
var _filterAbortedMessages = exports$5o;
var exports$5p = {};
const Long$9 = _long;
const filterAbortedMessages = _filterAbortedMessages;
exports$5p = class Batch {
    constructor(topic4, fetchedOffset, partitionData) {
        this.fetchedOffset = fetchedOffset;
        const longFetchedOffset = Long$9.fromValue(this.fetchedOffset);
        const {abortedTransactions, messages} = partitionData;
        this.topic = topic4;
        this.partition = partitionData.partition;
        this.highWatermark = partitionData.highWatermark;
        this.rawMessages = messages;
        this.messagesWithinOffset = this.rawMessages.filter((message1) => Long$9.fromValue(message1.offset).gte(longFetchedOffset)
        );
        this.messages = filterAbortedMessages({
            messages: this.messagesWithinOffset,
            abortedTransactions
        }).filter((message1) => !message1.isControlRecord
        );
    }

    isEmpty() {
        return this.messages.length === 0;
    }

    isEmptyIncludingFiltered() {
        return this.messagesWithinOffset.length === 0;
    }

    isEmptyControlRecord() {
        return this.isEmpty() && this.messagesWithinOffset.some(({isControlRecord}) => isControlRecord
        );
    }

    isEmptyDueToLogCompactedMessages() {
        const hasMessages = this.rawMessages.length > 0;
        return hasMessages && this.isEmptyIncludingFiltered();
    }

    firstOffset() {
        return this.isEmptyIncludingFiltered() ? null : this.messagesWithinOffset[0].offset;
    }

    lastOffset() {
        if (this.isEmptyDueToLogCompactedMessages()) {
            return this.fetchedOffset;
        }
        if (this.isEmptyIncludingFiltered()) {
            return Long$9.fromValue(this.highWatermark).add(-1).toString();
        }
        return this.messagesWithinOffset[this.messagesWithinOffset.length - 1].offset;
    }

    offsetLag() {
        const lastOffsetOfPartition = Long$9.fromValue(this.highWatermark).add(-1);
        const lastConsumedOffset = Long$9.fromValue(this.lastOffset());
        return lastOffsetOfPartition.add(lastConsumedOffset.multiply(-1)).toString();
    }

    offsetLagLow() {
        if (this.isEmptyIncludingFiltered()) {
            return "0";
        }
        const lastOffsetOfPartition = Long$9.fromValue(this.highWatermark).add(-1);
        const firstConsumedOffset = Long$9.fromValue(this.firstOffset());
        return lastOffsetOfPartition.add(firstConsumedOffset.multiply(-1)).toString();
    }
};
var _batch = exports$5p;
var exports$5q = {};
exports$5q = class SeekOffsets extends Map {
    set(topic, partition, offset) {
        super.set([
            topic,
            partition
        ], offset);
    }

    has(topic, partition) {
        return Array.from(this.keys()).some(([t25, p35]) => t25 === topic && p35 === partition
        );
    }

    pop() {
        if (this.size === 0) {
            return;
        }
        const [key, offset] = this.entries().next().value;
        this.delete(key);
        const [topic5, partition3] = key;
        return {
            topic: topic5,
            partition: partition3,
            offset
        };
    }
};
var _seekOffsets = exports$5q;
var exports$5r = {};
const createState = (topic5) => ({
            topic: topic5,
            paused: new Set(),
            pauseAll: false,
            resumed: new Set()
        })
;
exports$5r = class SubscriptionState {
    constructor() {
        this.assignedPartitionsByTopic = {};
        this.subscriptionStatesByTopic = {};
    }

    assign(topicPartitions = []) {
        this.assignedPartitionsByTopic = topicPartitions.reduce((assigned, {
            topic: topic5,
            partitions: partitions2 = []
        }) => {
            return {
                ...assigned,
                [topic5]: {
                    topic: topic5,
                    partitions: partitions2
                }
            };
        }, {});
    }

    pause(topicPartitions = []) {
        topicPartitions.forEach(({topic: topic5, partitions: partitions2}) => {
            const state = this.subscriptionStatesByTopic[topic5] || createState(topic5);
            if (typeof partitions2 === "undefined") {
                state.paused.clear();
                state.resumed.clear();
                state.pauseAll = true;
            } else if (Array.isArray(partitions2)) {
                partitions2.forEach((partition3) => {
                    state.paused.add(partition3);
                    state.resumed.delete(partition3);
                });
                state.pauseAll = false;
            }
            this.subscriptionStatesByTopic[topic5] = state;
        });
    }

    resume(topicPartitions = []) {
        topicPartitions.forEach(({topic: topic5, partitions: partitions2}) => {
            const state = this.subscriptionStatesByTopic[topic5] || createState(topic5);
            if (typeof partitions2 === "undefined") {
                state.paused.clear();
                state.resumed.clear();
                state.pauseAll = false;
            } else if (Array.isArray(partitions2)) {
                partitions2.forEach((partition3) => {
                    state.paused.delete(partition3);
                    if (state.pauseAll) {
                        state.resumed.add(partition3);
                    }
                });
            }
            this.subscriptionStatesByTopic[topic5] = state;
        });
    }

    assigned() {
        return Object.values(this.assignedPartitionsByTopic).map(({topic: topic5, partitions: partitions2}) => ({
                    topic: topic5,
                    partitions: partitions2.sort()
                })
        );
    }

    active() {
        return Object.values(this.assignedPartitionsByTopic).map(({topic: topic5, partitions: partitions2}) => ({
                    topic: topic5,
                    partitions: partitions2.filter((partition3) => !this.isPaused(topic5, partition3)
                    ).sort()
                })
        );
    }

    paused() {
        return Object.values(this.assignedPartitionsByTopic).map(({topic: topic5, partitions: partitions2}) => ({
                    topic: topic5,
                    partitions: partitions2.filter((partition3) => this.isPaused(topic5, partition3)
                    ).sort()
                })
        ).filter(({partitions: partitions2}) => partitions2.length !== 0
        );
    }

    isPaused(topic, partition) {
        const state = this.subscriptionStatesByTopic[topic];
        if (!state) {
            return false;
        }
        const partitionResumed = state.resumed.has(partition);
        const partitionPaused = state.paused.has(partition);
        return state.pauseAll && !partitionResumed || partitionPaused;
    }
};
var _subscriptionState = exports$5r;
var exports$5s = {};
const flatten$f = _flatten;
const sleep = _sleep;
const BufferedAsyncIterator$1 = _bufferedAsyncIterator;
const websiteUrl$1 = _websiteUrl;
const arrayDiff$1 = _arrayDiff;
const createRetry$5 = _retry;
const OffsetManager = _offsetManager;
const Batch = _batch;
const SeekOffsets = _seekOffsets;
const SubscriptionState = _subscriptionState;
const {events: {GROUP_JOIN, HEARTBEAT, CONNECT: CONNECT$1, RECEIVED_UNSUBSCRIBED_TOPICS}} = _instrumentationEvents$2;
const {MemberAssignment: MemberAssignment1} = _assignerProtocol;
const {
    KafkaJSError: KafkaJSError$4,
    KafkaJSNonRetriableError: KafkaJSNonRetriableError$a,
    KafkaJSStaleTopicMetadataAssignment: KafkaJSStaleTopicMetadataAssignment$1
} = _errors;
const {keys: keys$8} = Object;
const STALE_METADATA_ERRORS = [
    "LEADER_NOT_AVAILABLE",
    "NOT_LEADER_FOR_PARTITION",
    "FENCED_LEADER_EPOCH",
    "UNKNOWN_LEADER_EPOCH",
    "UNKNOWN_TOPIC_OR_PARTITION"
];
const isRebalancing = (e46) => e46.type === "REBALANCE_IN_PROGRESS" || e46.type === "NOT_COORDINATOR_FOR_GROUP"
;
const PRIVATE$5 = {
    JOIN: Symbol("private:ConsumerGroup:join"),
    SYNC: Symbol("private:ConsumerGroup:sync")
};
exports$5s = class ConsumerGroup {
    constructor({
        retry: retry3,
        cluster: cluster1,
        groupId: groupId1,
        topics: topics1,
        topicConfigurations: topicConfigurations1,
        logger: logger11,
        instrumentationEmitter: instrumentationEmitter5,
        assigners,
        sessionTimeout: sessionTimeout1,
        rebalanceTimeout: rebalanceTimeout1,
        maxBytesPerPartition: maxBytesPerPartition1,
        minBytes: minBytes1,
        maxBytes: maxBytes1,
        maxWaitTimeInMs: maxWaitTimeInMs1,
        autoCommitInterval: autoCommitInterval1,
        autoCommitThreshold: autoCommitThreshold1,
        isolationLevel: isolationLevel1,
        rackId: rackId1,
        metadataMaxAge: metadataMaxAge2
    }) {
        this.cluster = cluster1;
        this.groupId = groupId1;
        this.topics = topics1;
        this.topicsSubscribed = topics1;
        this.topicConfigurations = topicConfigurations1;
        this.logger = logger11.namespace("ConsumerGroup");
        this.instrumentationEmitter = instrumentationEmitter5;
        this.retrier = createRetry$5(Object.assign({}, retry3));
        this.assigners = assigners;
        this.sessionTimeout = sessionTimeout1;
        this.rebalanceTimeout = rebalanceTimeout1;
        this.maxBytesPerPartition = maxBytesPerPartition1;
        this.minBytes = minBytes1;
        this.maxBytes = maxBytes1;
        this.maxWaitTime = maxWaitTimeInMs1;
        this.autoCommitInterval = autoCommitInterval1;
        this.autoCommitThreshold = autoCommitThreshold1;
        this.isolationLevel = isolationLevel1;
        this.rackId = rackId1;
        this.metadataMaxAge = metadataMaxAge2;
        this.seekOffset = new SeekOffsets();
        this.coordinator = null;
        this.generationId = null;
        this.leaderId = null;
        this.memberId = null;
        this.members = null;
        this.groupProtocol = null;
        this.partitionsPerSubscribedTopic = null;
        this.preferredReadReplicasPerTopicPartition = {};
        this.offsetManager = null;
        this.subscriptionState = new SubscriptionState();
        this.lastRequest = Date.now();
    }

    isLeader() {
        return this.leaderId && this.memberId === this.leaderId;
    }

    async connect() {
        await this.cluster.connect();
        this.instrumentationEmitter.emit(CONNECT$1);
        await this.cluster.refreshMetadataIfNecessary();
    }

    async [PRIVATE$5.JOIN]() {
        const {groupId: groupId2, sessionTimeout: sessionTimeout1, rebalanceTimeout: rebalanceTimeout1} = this;
        this.coordinator = await this.cluster.findGroupCoordinator({
            groupId: groupId2
        });
        const groupData = await this.coordinator.joinGroup({
            groupId: groupId2,
            sessionTimeout: sessionTimeout1,
            rebalanceTimeout: rebalanceTimeout1,
            memberId: this.memberId || "",
            groupProtocols: this.assigners.map((assigner) => assigner.protocol({
                        topics: this.topicsSubscribed
                    })
            )
        });
        this.generationId = groupData.generationId;
        this.leaderId = groupData.leaderId;
        this.memberId = groupData.memberId;
        this.members = groupData.members;
        this.groupProtocol = groupData.groupProtocol;
    }

    async leave() {
        const {groupId: groupId2, memberId: memberId3} = this;
        if (memberId3) {
            await this.coordinator.leaveGroup({
                groupId: groupId2,
                memberId: memberId3
            });
            this.memberId = null;
        }
    }

    async [PRIVATE$5.SYNC]() {
        let assignment = [];
        const {
            groupId: groupId2,
            generationId: generationId1,
            memberId: memberId3,
            members,
            groupProtocol,
            topics: topics1,
            topicsSubscribed,
            coordinator: coordinator1
        } = this;
        if (this.isLeader()) {
            this.logger.debug("Chosen as group leader", {
                groupId: groupId2,
                generationId: generationId1,
                memberId: memberId3,
                topics: topics1
            });
            const assigner = this.assigners.find(({name}) => name === groupProtocol
            );
            if (!assigner) {
                throw new KafkaJSNonRetriableError$a(`Unsupported partition assigner "${groupProtocol}", the assigner wasn't found in the assigners list`);
            }
            await this.cluster.refreshMetadata();
            assignment = await assigner.assign({
                members,
                topics: topicsSubscribed
            });
            this.logger.debug("Group assignment", {
                groupId: groupId2,
                generationId: generationId1,
                groupProtocol,
                assignment,
                topics: topicsSubscribed
            });
        }
        this.partitionsPerSubscribedTopic = this.generatePartitionsPerSubscribedTopic();
        const {memberAssignment: memberAssignment1} = await this.coordinator.syncGroup({
            groupId: groupId2,
            generationId: generationId1,
            memberId: memberId3,
            groupAssignment: assignment
        });
        const decodedMemberAssignment = MemberAssignment1.decode(memberAssignment1);
        const decodedAssignment = decodedMemberAssignment != null ? decodedMemberAssignment.assignment : {};
        this.logger.debug("Received assignment", {
            groupId: groupId2,
            generationId: generationId1,
            memberId: memberId3,
            memberAssignment: decodedAssignment
        });
        const assignedTopics = keys$8(decodedAssignment);
        const topicsNotSubscribed = arrayDiff$1(assignedTopics, topicsSubscribed);
        if (topicsNotSubscribed.length > 0) {
            const payload2 = {
                groupId: groupId2,
                generationId: generationId1,
                memberId: memberId3,
                assignedTopics,
                topicsSubscribed,
                topicsNotSubscribed
            };
            this.instrumentationEmitter.emit(RECEIVED_UNSUBSCRIBED_TOPICS, payload2);
            this.logger.warn("Consumer group received unsubscribed topics", {
                ...payload2,
                helpUrl: websiteUrl$1("docs/faq", "why-am-i-receiving-messages-for-topics-i-m-not-subscribed-to")
            });
        }
        const safeAssignment = arrayDiff$1(assignedTopics, topicsNotSubscribed);
        const currentMemberAssignment = safeAssignment.map((topic5) => ({
                    topic: topic5,
                    partitions: decodedAssignment[topic5]
                })
        );
        for (const assignment1 of currentMemberAssignment) {
            const {topic: topic5, partitions: assignedPartitions} = assignment1;
            const knownPartitions = this.partitionsPerSubscribedTopic.get(topic5);
            const isAwareOfAllAssignedPartitions = assignedPartitions.every((partition3) => knownPartitions.includes(partition3)
            );
            if (!isAwareOfAllAssignedPartitions) {
                this.logger.warn("Consumer is not aware of all assigned partitions, refreshing metadata", {
                    groupId: groupId2,
                    generationId: generationId1,
                    memberId: memberId3,
                    topic: topic5,
                    knownPartitions,
                    assignedPartitions
                });
                await this.cluster.refreshMetadata();
                this.partitionsPerSubscribedTopic = this.generatePartitionsPerSubscribedTopic();
                break;
            }
        }
        this.topics = currentMemberAssignment.map(({topic: topic5}) => topic5
        );
        this.subscriptionState.assign(currentMemberAssignment);
        this.offsetManager = new OffsetManager({
            cluster: this.cluster,
            topicConfigurations: this.topicConfigurations,
            instrumentationEmitter: this.instrumentationEmitter,
            memberAssignment: currentMemberAssignment.reduce((partitionsByTopic, {
                        topic: topic5,
                        partitions: partitions2
                    }) => ({
                        ...partitionsByTopic,
                        [topic5]: partitions2
                    })
                    , {}),
            autoCommitInterval: this.autoCommitInterval,
            autoCommitThreshold: this.autoCommitThreshold,
            coordinator: coordinator1,
            groupId: groupId2,
            generationId: generationId1,
            memberId: memberId3
        });
    }

    joinAndSync() {
        const startJoin = Date.now();
        return this.retrier(async (bail) => {
            try {
                await this[PRIVATE$5.JOIN]();
                await this[PRIVATE$5.SYNC]();
                const memberAssignment1 = this.assigned().reduce((result, {
                            topic: topic5,
                            partitions: partitions2
                        }) => ({
                            ...result,
                            [topic5]: partitions2
                        })
                        , {});
                const payload2 = {
                    groupId: this.groupId,
                    memberId: this.memberId,
                    leaderId: this.leaderId,
                    isLeader: this.isLeader(),
                    memberAssignment: memberAssignment1,
                    groupProtocol: this.groupProtocol,
                    duration: Date.now() - startJoin
                };
                this.instrumentationEmitter.emit(GROUP_JOIN, payload2);
                this.logger.info("Consumer has joined the group", payload2);
            } catch (e46) {
                if (isRebalancing(e46)) {
                    throw new KafkaJSError$4(e46);
                }
                bail(e46);
            }
        });
    }

    resetOffset({topic, partition}) {
        this.offsetManager.resetOffset({
            topic,
            partition
        });
    }

    resolveOffset({topic, partition, offset}) {
        this.offsetManager.resolveOffset({
            topic,
            partition,
            offset
        });
    }

    seek({topic, partition, offset}) {
        this.seekOffset.set(topic, partition, offset);
    }

    pause(topicPartitions) {
        this.logger.info(`Pausing fetching from ${topicPartitions.length} topics`, {
            topicPartitions
        });
        this.subscriptionState.pause(topicPartitions);
    }

    resume(topicPartitions) {
        this.logger.info(`Resuming fetching from ${topicPartitions.length} topics`, {
            topicPartitions
        });
        this.subscriptionState.resume(topicPartitions);
    }

    assigned() {
        return this.subscriptionState.assigned();
    }

    paused() {
        return this.subscriptionState.paused();
    }

    async commitOffsetsIfNecessary() {
        await this.offsetManager.commitOffsetsIfNecessary();
    }

    async commitOffsets(offsets) {
        await this.offsetManager.commitOffsets(offsets);
    }

    uncommittedOffsets() {
        return this.offsetManager.uncommittedOffsets();
    }

    async heartbeat({interval}) {
        const {groupId: groupId2, generationId: generationId1, memberId: memberId3} = this;
        const now = Date.now();
        if (memberId3 && now >= this.lastRequest + interval) {
            const payload2 = {
                groupId: groupId2,
                memberId: memberId3,
                groupGenerationId: generationId1
            };
            await this.coordinator.heartbeat(payload2);
            this.instrumentationEmitter.emit(HEARTBEAT, payload2);
            this.lastRequest = Date.now();
        }
    }

    async fetch() {
        try {
            const {
                topics: topics1,
                maxBytesPerPartition: maxBytesPerPartition1,
                maxWaitTime,
                minBytes: minBytes1,
                maxBytes: maxBytes1
            } = this;
            const requestsPerNode = {};
            await this.cluster.refreshMetadataIfNecessary();
            this.checkForStaleAssignment();
            while (this.seekOffset.size > 0) {
                const seekEntry = this.seekOffset.pop();
                this.logger.debug("Seek offset", {
                    groupId: this.groupId,
                    memberId: this.memberId,
                    seek: seekEntry
                });
                await this.offsetManager.seek(seekEntry);
            }
            const pausedTopicPartitions = this.subscriptionState.paused();
            const activeTopicPartitions = this.subscriptionState.active();
            const activePartitions = flatten$f(activeTopicPartitions.map(({partitions: partitions2}) => partitions2
            ));
            const activeTopics = activeTopicPartitions.filter(({partitions: partitions2}) => partitions2.length > 0
            ).map(({topic: topic5}) => topic5
            );
            if (activePartitions.length === 0) {
                this.logger.debug(`No active topic partitions, sleeping for ${this.maxWaitTime}ms`, {
                    topics: topics1,
                    activeTopicPartitions,
                    pausedTopicPartitions
                });
                await sleep(this.maxWaitTime);
                return BufferedAsyncIterator$1([]);
            }
            await this.offsetManager.resolveOffsets();
            this.logger.debug(`Fetching from ${activePartitions.length} partitions for ${activeTopics.length} out of ${topics1.length} topics`, {
                topics: topics1,
                activeTopicPartitions,
                pausedTopicPartitions
            });
            for (const topicPartition of activeTopicPartitions) {
                const partitionsPerNode = this.findReadReplicaForPartitions(topicPartition.topic, topicPartition.partitions);
                const nodeIds = keys$8(partitionsPerNode);
                const committedOffsets = this.offsetManager.committedOffsets();
                for (const nodeId2 of nodeIds) {
                    const partitions2 = partitionsPerNode[nodeId2].filter((partition3) => {
                        return committedOffsets[topicPartition.topic][partition3] != null;
                    }).map((partition3) => ({
                                partition: partition3,
                                fetchOffset: this.offsetManager.nextOffset(topicPartition.topic, partition3).toString(),
                                maxBytes: maxBytesPerPartition1
                            })
                    );
                    requestsPerNode[nodeId2] = requestsPerNode[nodeId2] || [];
                    requestsPerNode[nodeId2].push({
                        topic: topicPartition.topic,
                        partitions: partitions2
                    });
                }
            }
            const requests1 = keys$8(requestsPerNode).map(async (nodeId2) => {
                const broker6 = await this.cluster.findBroker({
                    nodeId: nodeId2
                });
                const {responses} = await broker6.fetch({
                    maxWaitTime,
                    minBytes: minBytes1,
                    maxBytes: maxBytes1,
                    isolationLevel: this.isolationLevel,
                    topics: requestsPerNode[nodeId2],
                    rackId: this.rackId
                });
                const batchesPerPartition = responses.map(({topicName, partitions: partitions2}) => {
                    const topicRequestData = requestsPerNode[nodeId2].find(({topic: topic5}) => topic5 === topicName
                    );
                    let preferredReadReplicas = this.preferredReadReplicasPerTopicPartition[topicName];
                    if (!preferredReadReplicas) {
                        this.preferredReadReplicasPerTopicPartition[topicName] = preferredReadReplicas = {};
                    }
                    return partitions2.filter((partitionData1) => !this.seekOffset.has(topicName, partitionData1.partition) && !this.subscriptionState.isPaused(topicName, partitionData1.partition)
                    ).map((partitionData1) => {
                        const {partition: partition3, preferredReadReplica} = partitionData1;
                        if (preferredReadReplica != null && preferredReadReplica !== -1) {
                            const {nodeId: currentPreferredReadReplica} = preferredReadReplicas[partition3] || {};
                            if (currentPreferredReadReplica !== preferredReadReplica) {
                                this.logger.info(`Preferred read replica is now ${preferredReadReplica}`, {
                                    groupId: this.groupId,
                                    memberId: this.memberId,
                                    topic: topicName,
                                    partition: partition3
                                });
                            }
                            preferredReadReplicas[partition3] = {
                                nodeId: preferredReadReplica,
                                expireAt: Date.now() + this.metadataMaxAge
                            };
                        }
                        const partitionRequestData = topicRequestData.partitions.find(({partition: partition4}) => partition4 === partitionData1.partition
                        );
                        const fetchedOffset1 = partitionRequestData.fetchOffset;
                        const batch = new Batch(topicName, fetchedOffset1, partitionData1);
                        if (batch.isEmptyControlRecord() || batch.isEmptyDueToLogCompactedMessages()) {
                            this.resolveOffset({
                                topic: batch.topic,
                                partition: batch.partition,
                                offset: batch.lastOffset()
                            });
                        }
                        return batch;
                    });
                });
                return flatten$f(batchesPerPartition);
            });
            if (requests1.length === 0) {
                await sleep(this.maxWaitTime);
                return BufferedAsyncIterator$1([]);
            }
            return BufferedAsyncIterator$1(requests1, (e46) => this.recoverFromFetch(e46)
            );
        } catch (e46) {
            await this.recoverFromFetch(e46);
        }
    }

    async recoverFromFetch(e) {
        if (STALE_METADATA_ERRORS.includes(e.type) || e.name === "KafkaJSTopicMetadataNotLoaded") {
            this.logger.debug("Stale cluster metadata, refreshing...", {
                groupId: this.groupId,
                memberId: this.memberId,
                error: e.message
            });
            await this.cluster.refreshMetadata();
            await this.joinAndSync();
            throw new KafkaJSError$4(e.message);
        }
        if (e.name === "KafkaJSStaleTopicMetadataAssignment") {
            this.logger.warn(`${e.message}, resync group`, {
                groupId: this.groupId,
                memberId: this.memberId,
                topic: e.topic,
                unknownPartitions: e.unknownPartitions
            });
            await this.joinAndSync();
        }
        if (e.name === "KafkaJSOffsetOutOfRange") {
            await this.recoverFromOffsetOutOfRange(e);
        }
        if (e.name === "KafkaJSConnectionClosedError") {
            this.cluster.removeBroker({
                host: e.host,
                port: e.port
            });
        }
        if (e.name === "KafkaJSBrokerNotFound" || e.name === "KafkaJSConnectionClosedError") {
            this.logger.debug(`${e.message}, refreshing metadata and retrying...`);
            await this.cluster.refreshMetadata();
        }
        throw e;
    }

    async recoverFromOffsetOutOfRange(e) {
        const preferredReadReplicas = this.preferredReadReplicasPerTopicPartition[e.topic];
        if (preferredReadReplicas && typeof preferredReadReplicas[e.partition] === "number") {
            this.logger.info("Offset out of range while fetching from follower, retrying with leader", {
                topic: e.topic,
                partition: e.partition,
                groupId: this.groupId,
                memberId: this.memberId
            });
            delete preferredReadReplicas[e.partition];
        } else {
            this.logger.error("Offset out of range, resetting to default offset", {
                topic: e.topic,
                partition: e.partition,
                groupId: this.groupId,
                memberId: this.memberId
            });
            await this.offsetManager.setDefaultOffset({
                topic: e.topic,
                partition: e.partition
            });
        }
    }

    generatePartitionsPerSubscribedTopic() {
        const map = new Map();
        for (const topic5 of this.topicsSubscribed) {
            const partitions2 = this.cluster.findTopicPartitionMetadata(topic5).map((m19) => m19.partitionId
            ).sort();
            map.set(topic5, partitions2);
        }
        return map;
    }

    checkForStaleAssignment() {
        if (!this.partitionsPerSubscribedTopic) {
            return;
        }
        const newPartitionsPerSubscribedTopic = this.generatePartitionsPerSubscribedTopic();
        for (const [topic5, partitions2] of newPartitionsPerSubscribedTopic) {
            const diff = arrayDiff$1(partitions2, this.partitionsPerSubscribedTopic.get(topic5));
            if (diff.length > 0) {
                throw new KafkaJSStaleTopicMetadataAssignment$1("Topic has been updated", {
                    topic: topic5,
                    unknownPartitions: diff
                });
            }
        }
    }

    hasSeekOffset({topic, partition}) {
        return this.seekOffset.has(topic, partition);
    }

    findReadReplicaForPartitions(topic, partitions) {
        const partitionMetadata1 = this.cluster.findTopicPartitionMetadata(topic);
        const preferredReadReplicas = this.preferredReadReplicasPerTopicPartition[topic];
        return partitions.reduce((result, id1) => {
            const partitionId = parseInt(id1, 10);
            const metadata = partitionMetadata1.find((p35) => p35.partitionId === partitionId
            );
            if (!metadata) {
                return result;
            }
            if (metadata.leader == null) {
                throw new KafkaJSError$4("Invalid partition metadata", {
                    topic,
                    partitionId,
                    metadata
                });
            }
            let nodeId2 = metadata.leader;
            if (preferredReadReplicas) {
                const {nodeId: preferredReadReplica, expireAt} = preferredReadReplicas[partitionId] || {};
                if (Date.now() >= expireAt) {
                    this.logger.debug("Preferred read replica information has expired, using leader", {
                        topic,
                        partitionId,
                        groupId: this.groupId,
                        memberId: this.memberId,
                        preferredReadReplica,
                        leader: metadata.leader
                    });
                    delete preferredReadReplicas[partitionId];
                } else if (preferredReadReplica != null) {
                    const offlineReplicas = metadata.offlineReplicas;
                    if (Array.isArray(offlineReplicas) && offlineReplicas.includes(nodeId2)) {
                        this.logger.debug("Preferred read replica is offline, using leader", {
                            topic,
                            partitionId,
                            groupId: this.groupId,
                            memberId: this.memberId,
                            preferredReadReplica,
                            leader: metadata.leader
                        });
                    } else {
                        nodeId2 = preferredReadReplica;
                    }
                }
            }
            const current = result[nodeId2] || [];
            return {
                ...result,
                [nodeId2]: [
                    ...current,
                    partitionId
                ]
            };
        }, {});
    }
};
var _consumerGroup = exports$5s;
var exports$5t = {};
const {KafkaJSNonRetriableError: KafkaJSNonRetriableError$b} = _errors;
const REJECTED_ERROR = new KafkaJSNonRetriableError$b("Queued function aborted due to earlier promise rejection");

function NOOP() {
}

const concurrency = ({limit, onChange = NOOP} = {}) => {
    if (isNaN(limit) || typeof limit !== "number" || limit < 1) {
        throw new KafkaJSNonRetriableError$b(`"limit" cannot be less than 1`);
    }
    let waiting = [];
    let semaphore = 0;
    const clear = () => {
        for (const lazyAction of waiting) {
            lazyAction((_13, _21, reject) => reject(REJECTED_ERROR)
            );
        }
        waiting = [];
        semaphore = 0;
    };
    const next = () => {
        semaphore--;
        onChange(semaphore);
        if (waiting.length > 0) {
            const lazyAction = waiting.shift();
            lazyAction();
        }
    };
    const invoke = (action, resolve, reject) => {
        semaphore++;
        onChange(semaphore);
        action().then((result) => {
            resolve(result);
            next();
        }).catch((error) => {
            reject(error);
            clear();
        });
    };
    const push = (action, resolve, reject) => {
        if (semaphore < limit) {
            invoke(action, resolve, reject);
        } else {
            waiting.push((override) => {
                const execute = override || invoke;
                execute(action, resolve, reject);
            });
        }
    };
    return (action) => new Promise((resolve, reject) => push(action, resolve, reject)
    )
            ;
};
exports$5t = concurrency;
var _concurrency = exports$5t;
var exports$5u = {};
exports$5u = () => {
    let unlock;
    let unlockWithError;
    const lock = new Promise((resolve) => {
        unlock = resolve;
        unlockWithError = resolve;
    });
    return {
        lock,
        unlock,
        unlockWithError
    };
};
var _barrier = exports$5u;
var exports$5v = {};
var process$3 = T1;
const EventEmitter$3 = y1;
const createRetry$6 = _retry;
const limitConcurrency = _concurrency;
const {KafkaJSError: KafkaJSError$5} = _errors;
const barrier = _barrier;
const {events: {FETCH, FETCH_START, START_BATCH_PROCESS, END_BATCH_PROCESS}} = _instrumentationEvents$2;
const isRebalancing$1 = (e46) => e46.type === "REBALANCE_IN_PROGRESS" || e46.type === "NOT_COORDINATOR_FOR_GROUP"
;
const isKafkaJSError = (e46) => e46 instanceof KafkaJSError$5
;
const isSameOffset = (offsetA, offsetB) => _long.fromValue(offsetA).equals(_long.fromValue(offsetB))
;
const CONSUMING_START = "consuming-start";
const CONSUMING_STOP = "consuming-stop";
exports$5v = class Runner extends EventEmitter$3 {
    constructor({
        logger: logger12,
        consumerGroup,
        instrumentationEmitter: instrumentationEmitter6,
        eachBatchAutoResolve = true,
        partitionsConsumedConcurrently,
        eachBatch,
        eachMessage,
        heartbeatInterval: heartbeatInterval1,
        onCrash,
        retry: retry4,
        autoCommit = true
    }) {
        super();
        this.logger = logger12.namespace("Runner");
        this.consumerGroup = consumerGroup;
        this.instrumentationEmitter = instrumentationEmitter6;
        this.eachBatchAutoResolve = eachBatchAutoResolve;
        this.eachBatch = eachBatch;
        this.eachMessage = eachMessage;
        this.heartbeatInterval = heartbeatInterval1;
        this.retrier = createRetry$6(Object.assign({}, retry4));
        this.onCrash = onCrash;
        this.autoCommit = autoCommit;
        this.partitionsConsumedConcurrently = partitionsConsumedConcurrently;
        this.running = false;
        this.consuming = false;
    }

    get consuming() {
        return this._consuming;
    }

    set consuming(value) {
        if (this._consuming !== value) {
            this._consuming = value;
            this.emit(value ? CONSUMING_START : CONSUMING_STOP);
        }
    }

    async join() {
        await this.consumerGroup.joinAndSync();
        this.running = true;
    }

    async scheduleJoin() {
        if (!this.running) {
            this.logger.debug("consumer not running, exiting", {
                groupId: this.consumerGroup.groupId,
                memberId: this.consumerGroup.memberId
            });
            return;
        }
        return this.join().catch(this.onCrash);
    }

    async start() {
        if (this.running) {
            return;
        }
        try {
            await this.consumerGroup.connect();
            await this.join();
            this.running = true;
            this.scheduleFetch();
        } catch (e46) {
            this.onCrash(e46);
        }
    }

    async stop() {
        if (!this.running) {
            return;
        }
        this.logger.debug("stop consumer group", {
            groupId: this.consumerGroup.groupId,
            memberId: this.consumerGroup.memberId
        });
        this.running = false;
        try {
            await this.waitForConsumer();
            await this.consumerGroup.leave();
        } catch (e46) {
        }
    }

    waitForConsumer() {
        return new Promise((resolve) => {
            if (!this.consuming) {
                return resolve();
            }
            this.logger.debug("waiting for consumer to finish...", {
                groupId: this.consumerGroup.groupId,
                memberId: this.consumerGroup.memberId
            });
            this.once(CONSUMING_STOP, () => resolve()
            );
        });
    }

    async processEachMessage(batch) {
        const {topic: topic5, partition: partition3} = batch;
        for (const message1 of batch.messages) {
            if (!this.running || this.consumerGroup.hasSeekOffset({
                topic: topic5,
                partition: partition3
            })) {
                break;
            }
            try {
                await this.eachMessage({
                    topic: topic5,
                    partition: partition3,
                    message: message1
                });
            } catch (e46) {
                if (!isKafkaJSError(e46)) {
                    this.logger.error(`Error when calling eachMessage`, {
                        topic: topic5,
                        partition: partition3,
                        offset: message1.offset,
                        stack: e46.stack,
                        error: e46
                    });
                }
                await this.autoCommitOffsets();
                throw e46;
            }
            this.consumerGroup.resolveOffset({
                topic: topic5,
                partition: partition3,
                offset: message1.offset
            });
            await this.consumerGroup.heartbeat({
                interval: this.heartbeatInterval
            });
            await this.consumerGroup.commitOffsetsIfNecessary();
        }
    }

    async processEachBatch(batch) {
        const {topic: topic5, partition: partition3} = batch;
        const lastFilteredMessage = batch.messages[batch.messages.length - 1];
        try {
            await this.eachBatch({
                batch,
                resolveOffset: (offset) => {
                    const offsetToResolve = lastFilteredMessage && isSameOffset(offset, lastFilteredMessage.offset) ? batch.lastOffset() : offset;
                    this.consumerGroup.resolveOffset({
                        topic: topic5,
                        partition: partition3,
                        offset: offsetToResolve
                    });
                },
                heartbeat: async () => {
                    await this.consumerGroup.heartbeat({
                        interval: this.heartbeatInterval
                    });
                },
                commitOffsetsIfNecessary: async (offsets2) => {
                    return offsets2 ? this.consumerGroup.commitOffsets(offsets2) : this.consumerGroup.commitOffsetsIfNecessary();
                },
                uncommittedOffsets: () => this.consumerGroup.uncommittedOffsets()
                ,
                isRunning: () => this.running
                ,
                isStale: () => this.consumerGroup.hasSeekOffset({
                    topic: topic5,
                    partition: partition3
                })
            });
        } catch (e46) {
            if (!isKafkaJSError(e46)) {
                this.logger.error(`Error when calling eachBatch`, {
                    topic: topic5,
                    partition: partition3,
                    offset: batch.firstOffset(),
                    stack: e46.stack,
                    error: e46
                });
            }
            await this.autoCommitOffsets();
            throw e46;
        }
        if (this.eachBatchAutoResolve) {
            this.consumerGroup.resolveOffset({
                topic: topic5,
                partition: partition3,
                offset: batch.lastOffset()
            });
        }
    }

    async fetch() {
        const startFetch = Date.now();
        this.instrumentationEmitter.emit(FETCH_START, {});
        const iterator = await this.consumerGroup.fetch();
        this.instrumentationEmitter.emit(FETCH, {
            numberOfBatches: 0,
            duration: Date.now() - startFetch
        });
        const onBatch = async (batch) => {
            const startBatchProcess = Date.now();
            const payload2 = {
                topic: batch.topic,
                partition: batch.partition,
                highWatermark: batch.highWatermark,
                offsetLag: batch.offsetLag(),
                offsetLagLow: batch.offsetLagLow(),
                batchSize: batch.messages.length,
                firstOffset: batch.firstOffset(),
                lastOffset: batch.lastOffset()
            };
            this.instrumentationEmitter.emit(START_BATCH_PROCESS, payload2);
            if (this.eachMessage) {
                await this.processEachMessage(batch);
            } else if (this.eachBatch) {
                await this.processEachBatch(batch);
            }
            this.instrumentationEmitter.emit(END_BATCH_PROCESS, {
                ...payload2,
                duration: Date.now() - startBatchProcess
            });
        };
        const {lock, unlock, unlockWithError} = barrier();
        const concurrently = limitConcurrency({
            limit: this.partitionsConsumedConcurrently
        });
        let requestsCompleted = false;
        let numberOfExecutions = 0;
        let expectedNumberOfExecutions = 0;
        const enqueuedTasks = [];
        while (true) {
            const result = iterator.next();
            if (result.done) {
                break;
            }
            if (!this.running) {
                result.value.catch((error) => {
                    this.logger.debug("Ignoring error in fetch request while stopping runner", {
                        error: error.message || error,
                        stack: error.stack
                    });
                });
                continue;
            }
            enqueuedTasks.push(async () => {
                const batches = await result.value;
                expectedNumberOfExecutions += batches.length;
                batches.map((batch) => concurrently(async () => {
                            try {
                                if (!this.running) {
                                    return;
                                }
                                if (batch.isEmpty()) {
                                    return;
                                }
                                await onBatch(batch);
                                await this.consumerGroup.heartbeat({
                                    interval: this.heartbeatInterval
                                });
                            } catch (e46) {
                                unlockWithError(e46);
                            } finally {
                                numberOfExecutions++;
                                if (requestsCompleted && numberOfExecutions === expectedNumberOfExecutions) {
                                    unlock();
                                }
                            }
                        }).catch(unlockWithError)
                );
            });
        }
        await Promise.all(enqueuedTasks.map((fn) => fn()
        ));
        requestsCompleted = true;
        if (expectedNumberOfExecutions === numberOfExecutions) {
            unlock();
        }
        const error = await lock;
        if (error) {
            throw error;
        }
        await this.autoCommitOffsets();
        await this.consumerGroup.heartbeat({
            interval: this.heartbeatInterval
        });
    }

    async scheduleFetch() {
        if (!this.running) {
            this.logger.debug("consumer not running, exiting", {
                groupId: this.consumerGroup.groupId,
                memberId: this.consumerGroup.memberId
            });
            return;
        }
        return this.retrier(async (bail, retryCount1, retryTime1) => {
            try {
                this.consuming = true;
                await this.fetch();
                this.consuming = false;
                if (this.running) {
                    process$3.nextTick(() => this.scheduleFetch()
                    );
                }
            } catch (e46) {
                if (!this.running) {
                    this.logger.debug("consumer not running, exiting", {
                        error: e46.message,
                        groupId: this.consumerGroup.groupId,
                        memberId: this.consumerGroup.memberId
                    });
                    return;
                }
                if (isRebalancing$1(e46)) {
                    this.logger.error("The group is rebalancing, re-joining", {
                        groupId: this.consumerGroup.groupId,
                        memberId: this.consumerGroup.memberId,
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    await this.join();
                    process$3.nextTick(() => this.scheduleFetch()
                    );
                    return;
                }
                if (e46.type === "UNKNOWN_MEMBER_ID") {
                    this.logger.error("The coordinator is not aware of this member, re-joining the group", {
                        groupId: this.consumerGroup.groupId,
                        memberId: this.consumerGroup.memberId,
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    this.consumerGroup.memberId = null;
                    await this.join();
                    process$3.nextTick(() => this.scheduleFetch()
                    );
                    return;
                }
                if (e46.name === "KafkaJSOffsetOutOfRange") {
                    process$3.nextTick(() => this.scheduleFetch()
                    );
                    return;
                }
                if (e46.name === "KafkaJSNotImplemented") {
                    return bail(e46);
                }
                this.logger.debug("Error while fetching data, trying again...", {
                    groupId: this.consumerGroup.groupId,
                    memberId: this.consumerGroup.memberId,
                    error: e46.message,
                    stack: e46.stack,
                    retryCount: retryCount1,
                    retryTime: retryTime1
                });
                throw e46;
            } finally {
                this.consuming = false;
            }
        }).catch(this.onCrash);
    }

    autoCommitOffsets() {
        if (this.autoCommit) {
            return this.consumerGroup.commitOffsets();
        }
    }

    autoCommitOffsetsIfNecessary() {
        if (this.autoCommit) {
            return this.consumerGroup.commitOffsetsIfNecessary();
        }
    }

    commitOffsets(offsets) {
        if (!this.running) {
            this.logger.debug("consumer not running, exiting", {
                groupId: this.consumerGroup.groupId,
                memberId: this.consumerGroup.memberId,
                offsets
            });
            return;
        }
        return this.retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await this.consumerGroup.commitOffsets(offsets);
            } catch (e46) {
                if (!this.running) {
                    this.logger.debug("consumer not running, exiting", {
                        error: e46.message,
                        groupId: this.consumerGroup.groupId,
                        memberId: this.consumerGroup.memberId,
                        offsets
                    });
                    return;
                }
                if (isRebalancing$1(e46)) {
                    this.logger.error("The group is rebalancing, re-joining", {
                        groupId: this.consumerGroup.groupId,
                        memberId: this.consumerGroup.memberId,
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    process$3.nextTick(() => this.scheduleJoin()
                    );
                    bail(new KafkaJSError$5(e46));
                }
                if (e46.type === "UNKNOWN_MEMBER_ID") {
                    this.logger.error("The coordinator is not aware of this member, re-joining the group", {
                        groupId: this.consumerGroup.groupId,
                        memberId: this.consumerGroup.memberId,
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    this.consumerGroup.memberId = null;
                    process$3.nextTick(() => this.scheduleJoin()
                    );
                    bail(new KafkaJSError$5(e46));
                }
                if (e46.name === "KafkaJSNotImplemented") {
                    return bail(e46);
                }
                this.logger.debug("Error while committing offsets, trying again...", {
                    groupId: this.consumerGroup.groupId,
                    memberId: this.consumerGroup.memberId,
                    error: e46.message,
                    stack: e46.stack,
                    retryCount: retryCount1,
                    retryTime: retryTime1,
                    offsets
                });
                throw e46;
            }
        });
    }
};
var _runner = exports$5v;
var _global$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
var exports$5w = {};
const {MemberMetadata: MemberMetadata1, MemberAssignment: MemberAssignment$1} = _assignerProtocol;
const flatten$g = _flatten;
exports$5w = ({cluster: cluster2}) => ({
    name: "RoundRobinAssigner",
    version: 1,
    async assign({members, topics}) {
        const membersCount = members.length;
        const sortedMembers = members.map(({memberId: memberId3}) => memberId3
        ).sort();
        const assignment = {};
        const topicsPartionArrays = topics.map((topic5) => {
            const partitionMetadata1 = cluster2.findTopicPartitionMetadata(topic5);
            return partitionMetadata1.map((m19) => ({
                        topic: topic5,
                        partitionId: m19.partitionId
                    })
            );
        });
        const topicsPartitions = flatten$g(topicsPartionArrays);
        topicsPartitions.forEach((topicPartition, i53) => {
            const assignee = sortedMembers[i53 % membersCount];
            if (!assignment[assignee]) {
                assignment[assignee] = [];
            }
            if (!assignment[assignee][topicPartition.topic]) {
                assignment[assignee][topicPartition.topic] = [];
            }
            assignment[assignee][topicPartition.topic].push(topicPartition.partitionId);
        });
        return Object.keys(assignment).map((memberId3) => ({
                    memberId: memberId3,
                    memberAssignment: MemberAssignment$1.encode({
                        version: (this || _global$2).version,
                        assignment: assignment[memberId3]
                    })
                })
        );
    },
    protocol({topics}) {
        return {
            name: (this || _global$2).name,
            metadata: MemberMetadata1.encode({
                version: (this || _global$2).version,
                topics
            })
        };
    }
})
;
var _roundRobinAssigner = exports$5w;
var exports$5x = {};
const roundRobin = _roundRobinAssigner;
exports$5x = {
    roundRobin
};
var _assigners = exports$5x;
var exports$5y = {};
const Long$b = _long;
const createRetry$7 = _retry;
const {initialRetryTime} = _defaults$1;
const ConsumerGroup = _consumerGroup;
const Runner = _runner;
const {events: events$5, wrap: wrapEvent$1, unwrap: unwrapEvent$1} = _instrumentationEvents$2;
const InstrumentationEventEmitter$1 = _emitter;
const {KafkaJSNonRetriableError: KafkaJSNonRetriableError$c} = _errors;
const {roundRobin: roundRobin$1} = _assigners;
const {EARLIEST_OFFSET: EARLIEST_OFFSET$2, LATEST_OFFSET: LATEST_OFFSET$2} = _constants;
const ISOLATION_LEVEL$a = _isolationLevel;
const {keys: keys$9, values: values$2} = Object;
const {CONNECT: CONNECT$2, DISCONNECT: DISCONNECT$1, STOP, CRASH} = events$5;
const eventNames$1 = values$2(events$5);
const eventKeys$1 = keys$9(events$5).map((key) => `consumer.events.${key}`
).join(", ");
const specialOffsets = [
    _long.fromValue(EARLIEST_OFFSET$2).toString(),
    _long.fromValue(LATEST_OFFSET$2).toString()
];
exports$5y = ({
    cluster: cluster2,
    groupId: groupId2,
    retry: retry5,
    logger: rootLogger1,
    partitionAssigners = [
        roundRobin$1
    ],
    sessionTimeout: sessionTimeout1 = 30000,
    rebalanceTimeout: rebalanceTimeout1 = 60000,
    heartbeatInterval: heartbeatInterval1 = 3000,
    maxBytesPerPartition: maxBytesPerPartition1 = 1048576,
    minBytes: minBytes1 = 1,
    maxBytes: maxBytes1 = 10485760,
    maxWaitTimeInMs: maxWaitTimeInMs1 = 5000,
    isolationLevel: isolationLevel2 = ISOLATION_LEVEL$a.READ_COMMITTED,
    rackId: rackId1 = "",
    instrumentationEmitter: rootInstrumentationEmitter,
    metadataMaxAge: metadataMaxAge3
}) => {
    if (!groupId2) {
        throw new KafkaJSNonRetriableError$c("Consumer groupId must be a non-empty string.");
    }
    const logger13 = rootLogger1.namespace("Consumer");
    const instrumentationEmitter7 = rootInstrumentationEmitter || new InstrumentationEventEmitter$1();
    const assigners1 = partitionAssigners.map((createAssigner) => createAssigner({
                groupId: groupId2,
                logger: logger13,
                cluster: cluster2
            })
    );
    const topics2 = {};
    let runner = null;
    let consumerGroup1 = null;
    if (heartbeatInterval1 >= sessionTimeout1) {
        throw new KafkaJSNonRetriableError$c(`Consumer heartbeatInterval (${heartbeatInterval1}) must be lower than sessionTimeout (${sessionTimeout1}). It is recommended to set heartbeatInterval to approximately a third of the sessionTimeout.`);
    }
    const createConsumerGroup = ({
        autoCommitInterval: autoCommitInterval2,
        autoCommitThreshold: autoCommitThreshold2
    }) => {
        return new ConsumerGroup({
            logger: rootLogger1,
            topics: keys$9(topics2),
            topicConfigurations: topics2,
            retry: retry5,
            cluster: cluster2,
            groupId: groupId2,
            assigners: assigners1,
            sessionTimeout: sessionTimeout1,
            rebalanceTimeout: rebalanceTimeout1,
            maxBytesPerPartition: maxBytesPerPartition1,
            minBytes: minBytes1,
            maxBytes: maxBytes1,
            maxWaitTimeInMs: maxWaitTimeInMs1,
            instrumentationEmitter: instrumentationEmitter7,
            autoCommitInterval: autoCommitInterval2,
            autoCommitThreshold: autoCommitThreshold2,
            isolationLevel: isolationLevel2,
            rackId: rackId1,
            metadataMaxAge: metadataMaxAge3
        });
    };
    const createRunner = ({
        eachBatchAutoResolve: eachBatchAutoResolve1,
        eachBatch: eachBatch1,
        eachMessage: eachMessage1,
        onCrash: onCrash1,
        autoCommit: autoCommit1,
        partitionsConsumedConcurrently: partitionsConsumedConcurrently1
    }) => {
        return new Runner({
            autoCommit: autoCommit1,
            logger: rootLogger1,
            consumerGroup: consumerGroup1,
            instrumentationEmitter: instrumentationEmitter7,
            eachBatchAutoResolve: eachBatchAutoResolve1,
            eachBatch: eachBatch1,
            eachMessage: eachMessage1,
            heartbeatInterval: heartbeatInterval1,
            retry: retry5,
            onCrash: onCrash1,
            partitionsConsumedConcurrently: partitionsConsumedConcurrently1
        });
    };
    const connect = async () => {
        await cluster2.connect();
        instrumentationEmitter7.emit(CONNECT$2);
    };
    const disconnect = async () => {
        try {
            await stop();
            logger13.debug("consumer has stopped, disconnecting", {
                groupId: groupId2
            });
            await cluster2.disconnect();
            instrumentationEmitter7.emit(DISCONNECT$1);
        } catch (e46) {
        }
    };
    const stop = async () => {
        try {
            if (runner) {
                await runner.stop();
                runner = null;
                consumerGroup1 = null;
                instrumentationEmitter7.emit(STOP);
            }
            logger13.info("Stopped", {
                groupId: groupId2
            });
        } catch (e46) {
        }
    };
    const subscribe = async ({topic: topic5, fromBeginning = false}) => {
        if (consumerGroup1) {
            throw new KafkaJSNonRetriableError$c("Cannot subscribe to topic while consumer is running");
        }
        if (!topic5) {
            throw new KafkaJSNonRetriableError$c(`Invalid topic ${topic5}`);
        }
        const isRegExp = topic5 instanceof RegExp;
        if (typeof topic5 !== "string" && !isRegExp) {
            throw new KafkaJSNonRetriableError$c(`Invalid topic ${topic5} (${typeof topic5}), the topic name has to be a String or a RegExp`);
        }
        const topicsToSubscribe = [];
        if (isRegExp) {
            const topicRegExp = topic5;
            const metadata = await cluster2.metadata();
            const matchedTopics = metadata.topicMetadata.map(({topic: topicName}) => topicName
            ).filter((topicName) => topicRegExp.test(topicName)
            );
            logger13.debug("Subscription based on RegExp", {
                groupId: groupId2,
                topicRegExp: topicRegExp.toString(),
                matchedTopics
            });
            topicsToSubscribe.push(...matchedTopics);
        } else {
            topicsToSubscribe.push(topic5);
        }
        for (const t25 of topicsToSubscribe) {
            topics2[t25] = {
                fromBeginning
            };
        }
        await cluster2.addMultipleTargetTopics(topicsToSubscribe);
    };
    const run = async ({
        autoCommit: autoCommit1 = true,
        autoCommitInterval: autoCommitInterval2 = null,
        autoCommitThreshold: autoCommitThreshold2 = null,
        eachBatchAutoResolve: eachBatchAutoResolve1 = true,
        partitionsConsumedConcurrently: partitionsConsumedConcurrently1 = 1,
        eachBatch: eachBatch1 = null,
        eachMessage: eachMessage1 = null
    } = {}) => {
        if (consumerGroup1) {
            logger13.warn("consumer#run was called, but the consumer is already running", {
                groupId: groupId2
            });
            return;
        }
        consumerGroup1 = createConsumerGroup({
            autoCommitInterval: autoCommitInterval2,
            autoCommitThreshold: autoCommitThreshold2
        });
        const start = async (onCrash1) => {
            logger13.info("Starting", {
                groupId: groupId2
            });
            runner = createRunner({
                autoCommit: autoCommit1,
                eachBatchAutoResolve: eachBatchAutoResolve1,
                eachBatch: eachBatch1,
                eachMessage: eachMessage1,
                onCrash: onCrash1,
                partitionsConsumedConcurrently: partitionsConsumedConcurrently1
            });
            await runner.start();
        };
        const restart = (onCrash1) => {
            consumerGroup1 = createConsumerGroup({
                autoCommitInterval: autoCommitInterval2,
                autoCommitThreshold: autoCommitThreshold2
            });
            start(onCrash1);
        };
        const onCrash1 = async (e46) => {
            logger13.error(`Crash: ${e46.name}: ${e46.message}`, {
                groupId: groupId2,
                retryCount: e46.retryCount,
                stack: e46.stack
            });
            if (e46.name === "KafkaJSConnectionClosedError") {
                cluster2.removeBroker({
                    host: e46.host,
                    port: e46.port
                });
            }
            await disconnect();
            const isErrorRetriable1 = e46.name === "KafkaJSNumberOfRetriesExceeded" || e46.retriable === true;
            const shouldRestart = isErrorRetriable1 && (!retry5 || !retry5.restartOnFailure || await retry5.restartOnFailure(e46).catch((error) => {
                logger13.error("Caught error when invoking user-provided \"restartOnFailure\" callback. Defaulting to restarting.", {
                    error: error.message || error,
                    originalError: e46.message || e46,
                    groupId: groupId2
                });
                return true;
            }));
            instrumentationEmitter7.emit(CRASH, {
                error: e46,
                groupId: groupId2,
                restart: shouldRestart
            });
            if (shouldRestart) {
                const retryTime1 = e46.retryTime || retry5 && retry5.initialRetryTime || initialRetryTime;
                logger13.error(`Restarting the consumer in ${retryTime1}ms`, {
                    retryCount: e46.retryCount,
                    retryTime: retryTime1,
                    groupId: groupId2
                });
                setTimeout(() => restart(onCrash1)
                        , retryTime1);
            }
        };
        await start(onCrash1);
    };
    const on = (eventName, listener) => {
        if (!eventNames$1.includes(eventName)) {
            throw new KafkaJSNonRetriableError$c(`Event name should be one of ${eventKeys$1}`);
        }
        return instrumentationEmitter7.addListener(unwrapEvent$1(eventName), (event) => {
            event.type = wrapEvent$1(event.type);
            Promise.resolve(listener(event)).catch((e46) => {
                logger13.error(`Failed to execute listener: ${e46.message}`, {
                    eventName,
                    stack: e46.stack
                });
            });
        });
    };
    const commitOffsets = async (topicPartitions = []) => {
        const commitsByTopic = topicPartitions.reduce((payload2, {
            topic: topic5,
            partition: partition3,
            offset,
            metadata = null
        }) => {
            if (!topic5) {
                throw new KafkaJSNonRetriableError$c(`Invalid topic ${topic5}`);
            }
            if (isNaN(partition3)) {
                throw new KafkaJSNonRetriableError$c(`Invalid partition, expected a number received ${partition3}`);
            }
            let commitOffset;
            try {
                commitOffset = Long$b.fromValue(offset);
            } catch (_13) {
                throw new KafkaJSNonRetriableError$c(`Invalid offset, expected a long received ${offset}`);
            }
            if (commitOffset.lessThan(0)) {
                throw new KafkaJSNonRetriableError$c("Offset must not be a negative number");
            }
            if (metadata !== null && typeof metadata !== "string") {
                throw new KafkaJSNonRetriableError$c(`Invalid offset metadata, expected string or null, received ${metadata}`);
            }
            const topicCommits = payload2[topic5] || [];
            topicCommits.push({
                partition: partition3,
                offset: commitOffset,
                metadata
            });
            return {
                ...payload2,
                [topic5]: topicCommits
            };
        }, {});
        if (!consumerGroup1) {
            throw new KafkaJSNonRetriableError$c("Consumer group was not initialized, consumer#run must be called first");
        }
        const topics3 = Object.keys(commitsByTopic);
        return runner.commitOffsets({
            topics: topics3.map((topic5) => {
                return {
                    topic: topic5,
                    partitions: commitsByTopic[topic5]
                };
            })
        });
    };
    const seek = ({topic: topic5, partition: partition3, offset}) => {
        if (!topic5) {
            throw new KafkaJSNonRetriableError$c(`Invalid topic ${topic5}`);
        }
        if (isNaN(partition3)) {
            throw new KafkaJSNonRetriableError$c(`Invalid partition, expected a number received ${partition3}`);
        }
        let seekOffset;
        try {
            seekOffset = Long$b.fromValue(offset);
        } catch (_13) {
            throw new KafkaJSNonRetriableError$c(`Invalid offset, expected a long received ${offset}`);
        }
        if (seekOffset.lessThan(0) && !specialOffsets.includes(seekOffset.toString())) {
            throw new KafkaJSNonRetriableError$c("Offset must not be a negative number");
        }
        if (!consumerGroup1) {
            throw new KafkaJSNonRetriableError$c("Consumer group was not initialized, consumer#run must be called first");
        }
        consumerGroup1.seek({
            topic: topic5,
            partition: partition3,
            offset: seekOffset.toString()
        });
    };
    const describeGroup = async () => {
        const coordinator1 = await cluster2.findGroupCoordinator({
            groupId: groupId2
        });
        const retrier = createRetry$7(retry5);
        return retrier(async () => {
            const {groups: groups1} = await coordinator1.describeGroups({
                groupIds: [
                    groupId2
                ]
            });
            return groups1.find((group) => group.groupId === groupId2
            );
        });
    };
    const pause = (topicPartitions = []) => {
        for (const topicPartition of topicPartitions) {
            if (!topicPartition || !topicPartition.topic) {
                throw new KafkaJSNonRetriableError$c(`Invalid topic ${topicPartition && topicPartition.topic || topicPartition}`);
            } else if (typeof topicPartition.partitions !== "undefined" && (!Array.isArray(topicPartition.partitions) || topicPartition.partitions.some(isNaN))) {
                throw new KafkaJSNonRetriableError$c(`Array of valid partitions required to pause specific partitions instead of ${topicPartition.partitions}`);
            }
        }
        if (!consumerGroup1) {
            throw new KafkaJSNonRetriableError$c("Consumer group was not initialized, consumer#run must be called first");
        }
        consumerGroup1.pause(topicPartitions);
    };
    const paused = () => {
        if (!consumerGroup1) {
            return [];
        }
        return consumerGroup1.paused();
    };
    const resume = (topicPartitions = []) => {
        for (const topicPartition of topicPartitions) {
            if (!topicPartition || !topicPartition.topic) {
                throw new KafkaJSNonRetriableError$c(`Invalid topic ${topicPartition && topicPartition.topic || topicPartition}`);
            } else if (typeof topicPartition.partitions !== "undefined" && (!Array.isArray(topicPartition.partitions) || topicPartition.partitions.some(isNaN))) {
                throw new KafkaJSNonRetriableError$c(`Array of valid partitions required to resume specific partitions instead of ${topicPartition.partitions}`);
            }
        }
        if (!consumerGroup1) {
            throw new KafkaJSNonRetriableError$c("Consumer group was not initialized, consumer#run must be called first");
        }
        consumerGroup1.resume(topicPartitions);
    };
    const getLogger = () => logger13
    ;
    return {
        connect,
        disconnect,
        subscribe,
        stop,
        run,
        commitOffsets,
        seek,
        describeGroup,
        pause,
        paused,
        resume,
        on,
        events: events$5,
        logger: getLogger
    };
};
var _consumer = exports$5y;
var exports$5z = {};
const sleep$1 = _sleep;
const {KafkaJSTimeout: KafkaJSTimeout$1} = _errors;
exports$5z = (fn, {delay = 50, maxWait = 10000, timeoutMessage = "Timeout", ignoreTimeout = false} = {}) => {
    let timeoutId;
    let totalWait = 0;
    let fulfilled = false;
    const checkCondition = async (resolve, reject) => {
        totalWait += delay;
        await sleep$1(delay);
        try {
            const result = await fn(totalWait);
            if (result) {
                fulfilled = true;
                clearTimeout(timeoutId);
                return resolve(result);
            }
            checkCondition(resolve, reject);
        } catch (e46) {
            fulfilled = true;
            clearTimeout(timeoutId);
            reject(e46);
        }
    };
    return new Promise((resolve, reject) => {
        checkCondition(resolve, reject);
        if (ignoreTimeout) {
            return;
        }
        timeoutId = setTimeout(() => {
            if (!fulfilled) {
                return reject(new KafkaJSTimeout$1(timeoutMessage));
            }
        }, maxWait);
    });
};
var _waitFor = exports$5z;
var exports$5A = {};
exports$5A = async (array, groupFn) => {
    const result = new Map();
    for (const item of array) {
        const group = await Promise.resolve(groupFn(item));
        result.set(group, result.has(group) ? [
            ...result.get(group),
            item
        ] : [
            item
        ]);
    }
    return result;
};
var _groupBy = exports$5A;
var exports$5B = {};
const swapObject$2 = _swapObject;
const networkEvents$2 = _instrumentationEvents;
const InstrumentationEventType$3 = _eventType;
const adminType = InstrumentationEventType$3("admin");
const events$6 = {
    CONNECT: adminType("connect"),
    DISCONNECT: adminType("disconnect"),
    REQUEST: adminType(networkEvents$2.NETWORK_REQUEST),
    REQUEST_TIMEOUT: adminType(networkEvents$2.NETWORK_REQUEST_TIMEOUT),
    REQUEST_QUEUE_SIZE: adminType(networkEvents$2.NETWORK_REQUEST_QUEUE_SIZE)
};
const wrappedEvents$2 = {
    [events$6.REQUEST]: networkEvents$2.NETWORK_REQUEST,
    [events$6.REQUEST_TIMEOUT]: networkEvents$2.NETWORK_REQUEST_TIMEOUT,
    [events$6.REQUEST_QUEUE_SIZE]: networkEvents$2.NETWORK_REQUEST_QUEUE_SIZE
};
const reversedWrappedEvents$2 = swapObject$2(wrappedEvents$2);
const unwrap$2 = (eventName) => wrappedEvents$2[eventName] || eventName
;
const wrap$2 = (eventName) => reversedWrappedEvents$2[eventName] || eventName
;
exports$5B = {
    events: events$6,
    wrap: wrap$2,
    unwrap: unwrap$2
};
var _instrumentationEvents$3 = exports$5B;
var exports$5C = {};
exports$5C = {
    UNKNOWN: 0,
    TOPIC: 2,
    BROKER: 4,
    BROKER_LOGGER: 8
};
var _configResourceTypes = exports$5C;
var exports$5D = {};
exports$5D = {
    UNKNOWN: 0,
    ANY: 1,
    TOPIC: 2,
    GROUP: 3,
    CLUSTER: 4,
    TRANSACTIONAL_ID: 5,
    DELEGATION_TOKEN: 6
};
var _aclResourceTypes = exports$5D;
var exports$5E = {};
exports$5E = {
    UNKNOWN: 0,
    ANY: 1,
    ALL: 2,
    READ: 3,
    WRITE: 4,
    CREATE: 5,
    DELETE: 6,
    ALTER: 7,
    DESCRIBE: 8,
    CLUSTER_ACTION: 9,
    DESCRIBE_CONFIGS: 10,
    ALTER_CONFIGS: 11,
    IDEMPOTENT_WRITE: 12
};
var _aclOperationTypes = exports$5E;
var exports$5F = {};
exports$5F = {
    UNKNOWN: 0,
    ANY: 1,
    DENY: 2,
    ALLOW: 3
};
var _aclPermissionTypes = exports$5F;
var exports$5G = {};
exports$5G = {
    UNKNOWN: 0,
    ANY: 1,
    MATCH: 2,
    LITERAL: 3,
    PREFIXED: 4
};
var _resourcePatternTypes = exports$5G;
var exports$5H = {};
const createRetry$8 = _retry;
const flatten$h = _flatten;
const waitFor = _waitFor;
const groupBy = _groupBy;
const createConsumer = _consumer;
const InstrumentationEventEmitter$2 = _emitter;
const {events: events$7, wrap: wrapEvent$2, unwrap: unwrapEvent$2} = _instrumentationEvents$3;
const {LEVELS: LEVELS$1} = _loggers;
const {
    KafkaJSNonRetriableError: KafkaJSNonRetriableError$d,
    KafkaJSDeleteGroupsError: KafkaJSDeleteGroupsError$1,
    KafkaJSBrokerNotFound: KafkaJSBrokerNotFound$3,
    KafkaJSDeleteTopicRecordsError: KafkaJSDeleteTopicRecordsError$2
} = _errors;
const {staleMetadata: staleMetadata$2} = _error;
const CONFIG_RESOURCE_TYPES = _configResourceTypes;
const ACL_RESOURCE_TYPES = _aclResourceTypes;
const ACL_OPERATION_TYPES = _aclOperationTypes;
const ACL_PERMISSION_TYPES = _aclPermissionTypes;
const RESOURCE_PATTERN_TYPES = _resourcePatternTypes;
const {EARLIEST_OFFSET: EARLIEST_OFFSET$3, LATEST_OFFSET: LATEST_OFFSET$3} = _constants;
const {CONNECT: CONNECT$3, DISCONNECT: DISCONNECT$2} = events$7;
const NO_CONTROLLER_ID = -1;
const {values: values$3, keys: keys$a, entries} = Object;
const eventNames$2 = values$3(events$7);
const eventKeys$2 = keys$a(events$7).map((key) => `admin.events.${key}`
).join(", ");
const retryOnLeaderNotAvailable = (fn, opts = {}) => {
    const callback = async () => {
        try {
            return await fn();
        } catch (e46) {
            if (e46.type !== "LEADER_NOT_AVAILABLE") {
                throw e46;
            }
            return false;
        }
    };
    return waitFor(callback, opts);
};
const isConsumerGroupRunning = (description1) => [
            "Empty",
            "Dead"
        ].includes(description1.state)
;
const findTopicPartitions = async (cluster2, topic5) => {
    await cluster2.addTargetTopic(topic5);
    await cluster2.refreshMetadataIfNecessary();
    return cluster2.findTopicPartitionMetadata(topic5).map(({partitionId}) => partitionId
    ).sort();
};
const indexByPartition = (array) => array.reduce((obj, {partition: partition3, ...props}) => Object.assign(obj, {
            [partition3]: {
                ...props
            }
        })
        , {})
;
exports$5H = ({
    logger: rootLogger1,
    instrumentationEmitter: rootInstrumentationEmitter,
    retry: retry5,
    cluster: cluster2
}) => {
    const logger13 = rootLogger1.namespace("Admin");
    const instrumentationEmitter7 = rootInstrumentationEmitter || new InstrumentationEventEmitter$2();
    const connect = async () => {
        await cluster2.connect();
        instrumentationEmitter7.emit(CONNECT$3);
    };
    const disconnect = async () => {
        await cluster2.disconnect();
        instrumentationEmitter7.emit(DISCONNECT$2);
    };
    const listTopics = async () => {
        const {topicMetadata: topicMetadata1} = await cluster2.metadata();
        const topics2 = topicMetadata1.map((t25) => t25.topic
        );
        return topics2;
    };
    const createTopics = async ({topics: topics2, validateOnly, timeout: timeout3, waitForLeaders = true}) => {
        if (!topics2 || !Array.isArray(topics2)) {
            throw new KafkaJSNonRetriableError$d(`Invalid topics array ${topics2}`);
        }
        if (topics2.filter(({topic: topic5}) => typeof topic5 !== "string"
        ).length > 0) {
            throw new KafkaJSNonRetriableError$d("Invalid topics array, the topic names have to be a valid string");
        }
        const topicNames = new Set(topics2.map(({topic: topic5}) => topic5
        ));
        if (topicNames.size < topics2.length) {
            throw new KafkaJSNonRetriableError$d("Invalid topics array, it cannot have multiple entries for the same topic");
        }
        const retrier = createRetry$8(retry5);
        return retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await cluster2.refreshMetadata();
                const broker6 = await cluster2.findControllerBroker();
                await broker6.createTopics({
                    topics: topics2,
                    validateOnly,
                    timeout: timeout3
                });
                if (waitForLeaders) {
                    const topicNamesArray = Array.from(topicNames.values());
                    await retryOnLeaderNotAvailable(async () => await broker6.metadata(topicNamesArray)
                            , {
                                delay: 100,
                                maxWait: timeout3,
                                timeoutMessage: "Timed out while waiting for topic leaders"
                            });
                }
                return true;
            } catch (e46) {
                if (e46.type === "NOT_CONTROLLER") {
                    logger13.warn("Could not create topics", {
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    throw e46;
                }
                if (e46.type === "TOPIC_ALREADY_EXISTS") {
                    return false;
                }
                bail(e46);
            }
        });
    };
    const createPartitions = async ({topicPartitions, validateOnly, timeout: timeout3}) => {
        if (!topicPartitions || !Array.isArray(topicPartitions)) {
            throw new KafkaJSNonRetriableError$d(`Invalid topic partitions array ${topicPartitions}`);
        }
        if (topicPartitions.length === 0) {
            throw new KafkaJSNonRetriableError$d(`Empty topic partitions array`);
        }
        if (topicPartitions.filter(({topic: topic5}) => typeof topic5 !== "string"
        ).length > 0) {
            throw new KafkaJSNonRetriableError$d("Invalid topic partitions array, the topic names have to be a valid string");
        }
        const topicNames = new Set(topicPartitions.map(({topic: topic5}) => topic5
        ));
        if (topicNames.size < topicPartitions.length) {
            throw new KafkaJSNonRetriableError$d("Invalid topic partitions array, it cannot have multiple entries for the same topic");
        }
        const retrier = createRetry$8(retry5);
        return retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await cluster2.refreshMetadata();
                const broker6 = await cluster2.findControllerBroker();
                await broker6.createPartitions({
                    topicPartitions,
                    validateOnly,
                    timeout: timeout3
                });
            } catch (e46) {
                if (e46.type === "NOT_CONTROLLER") {
                    logger13.warn("Could not create topics", {
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    throw e46;
                }
                bail(e46);
            }
        });
    };
    const deleteTopics = async ({topics: topics2, timeout: timeout3}) => {
        if (!topics2 || !Array.isArray(topics2)) {
            throw new KafkaJSNonRetriableError$d(`Invalid topics array ${topics2}`);
        }
        if (topics2.filter((topic5) => typeof topic5 !== "string"
        ).length > 0) {
            throw new KafkaJSNonRetriableError$d("Invalid topics array, the names must be a valid string");
        }
        const retrier = createRetry$8(retry5);
        return retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await cluster2.refreshMetadata();
                const broker6 = await cluster2.findControllerBroker();
                await broker6.deleteTopics({
                    topics: topics2,
                    timeout: timeout3
                });
                for (const topic5 of topics2) {
                    cluster2.targetTopics.delete(topic5);
                }
                await cluster2.refreshMetadata();
            } catch (e46) {
                if ([
                    "NOT_CONTROLLER",
                    "UNKNOWN_TOPIC_OR_PARTITION"
                ].includes(e46.type)) {
                    logger13.warn("Could not delete topics", {
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    throw e46;
                }
                if (e46.type === "REQUEST_TIMED_OUT") {
                    logger13.error("Could not delete topics, check if \"delete.topic.enable\" is set to \"true\" (the default value is \"false\") or increase the timeout", {
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                }
                bail(e46);
            }
        });
    };
    const fetchTopicOffsets = async (topic5) => {
        if (!topic5 || typeof topic5 !== "string") {
            throw new KafkaJSNonRetriableError$d(`Invalid topic ${topic5}`);
        }
        const retrier = createRetry$8(retry5);
        return retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await cluster2.addTargetTopic(topic5);
                await cluster2.refreshMetadataIfNecessary();
                const metadata = cluster2.findTopicPartitionMetadata(topic5);
                const high = await cluster2.fetchTopicsOffset([
                    {
                        topic: topic5,
                        fromBeginning: false,
                        partitions: metadata.map((p35) => ({
                                    partition: p35.partitionId
                                })
                        )
                    }
                ]);
                const low = await cluster2.fetchTopicsOffset([
                    {
                        topic: topic5,
                        fromBeginning: true,
                        partitions: metadata.map((p35) => ({
                                    partition: p35.partitionId
                                })
                        )
                    }
                ]);
                const {partitions: highPartitions} = high.pop();
                const {partitions: lowPartitions} = low.pop();
                return highPartitions.map(({partition: partition3, offset}) => ({
                            partition: partition3,
                            offset,
                            high: offset,
                            low: lowPartitions.find(({partition: lowPartition}) => lowPartition === partition3
                            ).offset
                        })
                );
            } catch (e46) {
                if (e46.type === "UNKNOWN_TOPIC_OR_PARTITION") {
                    await cluster2.refreshMetadata();
                    throw e46;
                }
                bail(e46);
            }
        });
    };
    const fetchTopicOffsetsByTimestamp = async (topic5, timestamp) => {
        if (!topic5 || typeof topic5 !== "string") {
            throw new KafkaJSNonRetriableError$d(`Invalid topic ${topic5}`);
        }
        const retrier = createRetry$8(retry5);
        return retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await cluster2.addTargetTopic(topic5);
                await cluster2.refreshMetadataIfNecessary();
                const metadata = cluster2.findTopicPartitionMetadata(topic5);
                const partitions2 = metadata.map((p35) => ({
                            partition: p35.partitionId
                        })
                );
                const high = await cluster2.fetchTopicsOffset([
                    {
                        topic: topic5,
                        fromBeginning: false,
                        partitions: partitions2
                    }
                ]);
                const {partitions: highPartitions} = high.pop();
                const offsets2 = await cluster2.fetchTopicsOffset([
                    {
                        topic: topic5,
                        fromTimestamp: timestamp,
                        partitions: partitions2
                    }
                ]);
                const {partitions: lowPartitions} = offsets2.pop();
                return lowPartitions.map(({partition: partition3, offset}) => ({
                            partition: partition3,
                            offset: parseInt(offset, 10) >= 0 ? offset : highPartitions.find(({partition: highPartition}) => highPartition === partition3
                            ).offset
                        })
                );
            } catch (e46) {
                if (e46.type === "UNKNOWN_TOPIC_OR_PARTITION") {
                    await cluster2.refreshMetadata();
                    throw e46;
                }
                bail(e46);
            }
        });
    };
    const fetchOffsets = async ({groupId: groupId2, topic: topic5, resolveOffsets = false}) => {
        if (!groupId2) {
            throw new KafkaJSNonRetriableError$d(`Invalid groupId ${groupId2}`);
        }
        if (!topic5) {
            throw new KafkaJSNonRetriableError$d(`Invalid topic ${topic5}`);
        }
        const partitions2 = await findTopicPartitions(cluster2, topic5);
        const coordinator1 = await cluster2.findGroupCoordinator({
            groupId: groupId2
        });
        const partitionsToFetch = partitions2.map((partition3) => ({
                    partition: partition3
                })
        );
        let {responses: consumerOffsets} = await coordinator1.offsetFetch({
            groupId: groupId2,
            topics: [
                {
                    topic: topic5,
                    partitions: partitionsToFetch
                }
            ]
        });
        if (resolveOffsets) {
            const indexedOffsets = indexByPartition(await fetchTopicOffsets(topic5));
            consumerOffsets = consumerOffsets.map(({topic: topic6, partitions: partitions3}) => ({
                        topic: topic6,
                        partitions: partitions3.map(({offset, partition: partition3, ...props}) => {
                            let resolvedOffset = offset;
                            if (Number(offset) === EARLIEST_OFFSET$3) {
                                resolvedOffset = indexedOffsets[partition3].low;
                            }
                            if (Number(offset) === LATEST_OFFSET$3) {
                                resolvedOffset = indexedOffsets[partition3].high;
                            }
                            return {
                                partition: partition3,
                                offset: resolvedOffset,
                                ...props
                            };
                        })
                    })
            );
            const [{partitions: partitions3}] = consumerOffsets;
            await setOffsets({
                groupId: groupId2,
                topic: topic5,
                partitions: partitions3
            });
        }
        return consumerOffsets.filter((response) => response.topic === topic5
        ).map(({partitions: partitions3}) => partitions3.map(({partition: partition3, offset, metadata}) => ({
                    partition: partition3,
                    offset,
                    metadata: metadata || null
                })
                )
        ).pop();
    };
    const resetOffsets = async ({groupId: groupId2, topic: topic5, earliest = false}) => {
        if (!groupId2) {
            throw new KafkaJSNonRetriableError$d(`Invalid groupId ${groupId2}`);
        }
        if (!topic5) {
            throw new KafkaJSNonRetriableError$d(`Invalid topic ${topic5}`);
        }
        const partitions2 = await findTopicPartitions(cluster2, topic5);
        const partitionsToSeek = partitions2.map((partition3) => ({
                    partition: partition3,
                    offset: cluster2.defaultOffset({
                        fromBeginning: earliest
                    })
                })
        );
        return setOffsets({
            groupId: groupId2,
            topic: topic5,
            partitions: partitionsToSeek
        });
    };
    const setOffsets = async ({groupId: groupId2, topic: topic5, partitions: partitions2}) => {
        if (!groupId2) {
            throw new KafkaJSNonRetriableError$d(`Invalid groupId ${groupId2}`);
        }
        if (!topic5) {
            throw new KafkaJSNonRetriableError$d(`Invalid topic ${topic5}`);
        }
        if (!partitions2 || partitions2.length === 0) {
            throw new KafkaJSNonRetriableError$d(`Invalid partitions`);
        }
        const consumer = createConsumer({
            logger: rootLogger1.namespace("Admin", LEVELS$1.NOTHING),
            cluster: cluster2,
            groupId: groupId2
        });
        await consumer.subscribe({
            topic: topic5,
            fromBeginning: true
        });
        const description1 = await consumer.describeGroup();
        if (!isConsumerGroupRunning(description1)) {
            throw new KafkaJSNonRetriableError$d(`The consumer group must have no running instances, current state: ${description1.state}`);
        }
        return new Promise((resolve, reject) => {
            consumer.on(consumer.events.FETCH, async () => consumer.stop().then(resolve).catch(reject)
            );
            consumer.run({
                eachBatchAutoResolve: false,
                eachBatch: async () => true
            }).catch(reject);
            consumer.pause([
                {
                    topic: topic5
                }
            ]);
            for (const seekData of partitions2) {
                consumer.seek({
                    topic: topic5,
                    ...seekData
                });
            }
        });
    };
    const isBrokerConfig = (type1) => [
                CONFIG_RESOURCE_TYPES.BROKER,
                CONFIG_RESOURCE_TYPES.BROKER_LOGGER
            ].includes(type1)
    ;
    const groupResourcesByBroker = ({resources, defaultBroker}) => groupBy(resources, async ({
                type: type1,
                name: nodeId2
            }) => {
                return isBrokerConfig(type1) ? await cluster2.findBroker({
                    nodeId: String(nodeId2)
                }) : defaultBroker;
            })
    ;
    const describeConfigs = async ({resources, includeSynonyms}) => {
        if (!resources || !Array.isArray(resources)) {
            throw new KafkaJSNonRetriableError$d(`Invalid resources array ${resources}`);
        }
        if (resources.length === 0) {
            throw new KafkaJSNonRetriableError$d("Resources array cannot be empty");
        }
        const validResourceTypes = Object.values(CONFIG_RESOURCE_TYPES);
        const invalidType = resources.find((r33) => !validResourceTypes.includes(r33.type)
        );
        if (invalidType) {
            throw new KafkaJSNonRetriableError$d(`Invalid resource type ${invalidType.type}: ${JSON.stringify(invalidType)}`);
        }
        const invalidName = resources.find((r33) => !r33.name || typeof r33.name !== "string"
        );
        if (invalidName) {
            throw new KafkaJSNonRetriableError$d(`Invalid resource name ${invalidName.name}: ${JSON.stringify(invalidName)}`);
        }
        const invalidConfigs = resources.find((r33) => !Array.isArray(r33.configNames) && r33.configNames != null
        );
        if (invalidConfigs) {
            const {configNames} = invalidConfigs;
            throw new KafkaJSNonRetriableError$d(`Invalid resource configNames ${configNames}: ${JSON.stringify(invalidConfigs)}`);
        }
        const retrier = createRetry$8(retry5);
        return retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await cluster2.refreshMetadata();
                const controller = await cluster2.findControllerBroker();
                const resourcerByBroker = await groupResourcesByBroker({
                    resources,
                    defaultBroker: controller
                });
                const describeConfigsAction = async (broker6) => {
                    const targetBroker = broker6 || controller;
                    return targetBroker.describeConfigs({
                        resources: resourcerByBroker.get(targetBroker),
                        includeSynonyms
                    });
                };
                const brokers1 = Array.from(resourcerByBroker.keys());
                const responses = await Promise.all(brokers1.map(describeConfigsAction));
                const responseResources = responses.reduce((result, {resources: resources1}) => [
                            ...result,
                            ...resources1
                        ]
                        , []);
                return {
                    resources: responseResources
                };
            } catch (e46) {
                if (e46.type === "NOT_CONTROLLER") {
                    logger13.warn("Could not describe configs", {
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    throw e46;
                }
                bail(e46);
            }
        });
    };
    const alterConfigs = async ({resources, validateOnly}) => {
        if (!resources || !Array.isArray(resources)) {
            throw new KafkaJSNonRetriableError$d(`Invalid resources array ${resources}`);
        }
        if (resources.length === 0) {
            throw new KafkaJSNonRetriableError$d("Resources array cannot be empty");
        }
        const validResourceTypes = Object.values(CONFIG_RESOURCE_TYPES);
        const invalidType = resources.find((r33) => !validResourceTypes.includes(r33.type)
        );
        if (invalidType) {
            throw new KafkaJSNonRetriableError$d(`Invalid resource type ${invalidType.type}: ${JSON.stringify(invalidType)}`);
        }
        const invalidName = resources.find((r33) => !r33.name || typeof r33.name !== "string"
        );
        if (invalidName) {
            throw new KafkaJSNonRetriableError$d(`Invalid resource name ${invalidName.name}: ${JSON.stringify(invalidName)}`);
        }
        const invalidConfigs = resources.find((r33) => !Array.isArray(r33.configEntries)
        );
        if (invalidConfigs) {
            const {configEntries} = invalidConfigs;
            throw new KafkaJSNonRetriableError$d(`Invalid resource configEntries ${configEntries}: ${JSON.stringify(invalidConfigs)}`);
        }
        const invalidConfigValue = resources.find((r33) => r33.configEntries.some((e46) => typeof e46.name !== "string" || typeof e46.value !== "string"
                )
        );
        if (invalidConfigValue) {
            throw new KafkaJSNonRetriableError$d(`Invalid resource config value: ${JSON.stringify(invalidConfigValue)}`);
        }
        const retrier = createRetry$8(retry5);
        return retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await cluster2.refreshMetadata();
                const controller = await cluster2.findControllerBroker();
                const resourcerByBroker = await groupResourcesByBroker({
                    resources,
                    defaultBroker: controller
                });
                const alterConfigsAction = async (broker6) => {
                    const targetBroker = broker6 || controller;
                    return targetBroker.alterConfigs({
                        resources: resourcerByBroker.get(targetBroker),
                        validateOnly: !!validateOnly
                    });
                };
                const brokers1 = Array.from(resourcerByBroker.keys());
                const responses = await Promise.all(brokers1.map(alterConfigsAction));
                const responseResources = responses.reduce((result, {resources: resources1}) => [
                            ...result,
                            ...resources1
                        ]
                        , []);
                return {
                    resources: responseResources
                };
            } catch (e46) {
                if (e46.type === "NOT_CONTROLLER") {
                    logger13.warn("Could not alter configs", {
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    throw e46;
                }
                bail(e46);
            }
        });
    };
    const getTopicMetadata = async (options) => {
        const {topics: topics2} = options || {};
        if (topics2) {
            await Promise.all(topics2.map(async (topic5) => {
                if (!topic5) {
                    throw new KafkaJSNonRetriableError$d(`Invalid topic ${topic5}`);
                }
                try {
                    await cluster2.addTargetTopic(topic5);
                } catch (e46) {
                    e46.message = `Failed to add target topic ${topic5}: ${e46.message}`;
                    throw e46;
                }
            }));
        }
        await cluster2.refreshMetadataIfNecessary();
        const targetTopics = topics2 || [
            ...cluster2.targetTopics
        ];
        return {
            topics: await Promise.all(targetTopics.map(async (topic5) => ({
                        name: topic5,
                        partitions: cluster2.findTopicPartitionMetadata(topic5)
                    })
            ))
        };
    };
    const fetchTopicMetadata = async ({topics: topics2 = []} = {}) => {
        if (topics2) {
            topics2.forEach((topic5) => {
                if (!topic5 || typeof topic5 !== "string") {
                    throw new KafkaJSNonRetriableError$d(`Invalid topic ${topic5}`);
                }
            });
        }
        const metadata = await cluster2.metadata({
            topics: topics2
        });
        return {
            topics: metadata.topicMetadata.map((topicMetadata1) => ({
                        name: topicMetadata1.topic,
                        partitions: topicMetadata1.partitionMetadata
                    })
            )
        };
    };
    const describeCluster = async () => {
        const {brokers: nodes, clusterId, controllerId} = await cluster2.metadata({
            topics: []
        });
        const brokers1 = nodes.map(({nodeId: nodeId2, host: host3, port: port3}) => ({
                    nodeId: nodeId2,
                    host: host3,
                    port: port3
                })
        );
        const controller = controllerId == null || controllerId === NO_CONTROLLER_ID ? null : controllerId;
        return {
            brokers: brokers1,
            controller,
            clusterId
        };
    };
    const listGroups = async () => {
        await cluster2.refreshMetadata();
        let groups1 = [];
        for (var nodeId2 in cluster2.brokerPool.brokers) {
            const broker6 = await cluster2.findBroker({
                nodeId: nodeId2
            });
            const response = await broker6.listGroups();
            groups1 = groups1.concat(response.groups);
        }
        return {
            groups: groups1
        };
    };
    const describeGroups = async (groupIds) => {
        const coordinatorsForGroup = await Promise.all(groupIds.map(async (groupId2) => {
            const coordinator1 = await cluster2.findGroupCoordinator({
                groupId: groupId2
            });
            return {
                coordinator: coordinator1,
                groupId: groupId2
            };
        }));
        const groupsByCoordinator = Object.values(coordinatorsForGroup.reduce((coordinators, {
            coordinator: coordinator1,
            groupId: groupId2
        }) => {
            const group = coordinators[coordinator1.nodeId];
            if (group) {
                coordinators[coordinator1.nodeId] = {
                    ...group,
                    groupIds: [
                        ...group.groupIds,
                        groupId2
                    ]
                };
            } else {
                coordinators[coordinator1.nodeId] = {
                    coordinator: coordinator1,
                    groupIds: [
                        groupId2
                    ]
                };
            }
            return coordinators;
        }, {}));
        const responses = await Promise.all(groupsByCoordinator.map(async ({
            coordinator: coordinator1,
            groupIds: groupIds1
        }) => {
            const retrier = createRetry$8(retry5);
            const {groups: groups1} = await retrier(() => coordinator1.describeGroups({
                        groupIds: groupIds1
                    })
            );
            return groups1;
        }));
        const groups1 = [].concat.apply([], responses);
        return {
            groups: groups1
        };
    };
    const deleteGroups = async (groupIds) => {
        if (!groupIds || !Array.isArray(groupIds)) {
            throw new KafkaJSNonRetriableError$d(`Invalid groupIds array ${groupIds}`);
        }
        const invalidGroupId = groupIds.some((g16) => typeof g16 !== "string"
        );
        if (invalidGroupId) {
            throw new KafkaJSNonRetriableError$d(`Invalid groupId name: ${JSON.stringify(invalidGroupId)}`);
        }
        const retrier = createRetry$8(retry5);
        let results = [];
        let clonedGroupIds = groupIds.slice();
        return retrier(async (bail, retryCount1, retryTime1) => {
            try {
                if (clonedGroupIds.length === 0) {
                    return [];
                }
                await cluster2.refreshMetadata();
                const brokersPerGroups = {};
                const brokersPerNode = {};
                for (const groupId2 of clonedGroupIds) {
                    const broker6 = await cluster2.findGroupCoordinator({
                        groupId: groupId2
                    });
                    if (brokersPerGroups[broker6.nodeId] === undefined) {
                        brokersPerGroups[broker6.nodeId] = [];
                    }
                    brokersPerGroups[broker6.nodeId].push(groupId2);
                    brokersPerNode[broker6.nodeId] = broker6;
                }
                const res = await Promise.all(Object.keys(brokersPerNode).map(async (nodeId3) => await brokersPerNode[nodeId3].deleteGroups(brokersPerGroups[nodeId3])
                ));
                const errors = flatten$h(res.map(({results: results1}) => results1.map(({
                            groupId: groupId3,
                            errorCode,
                            error
                        }) => {
                            return {
                                groupId: groupId3,
                                errorCode,
                                error
                            };
                        })
                )).filter(({errorCode}) => errorCode !== 0
                );
                clonedGroupIds = errors.map(({groupId: groupId3}) => groupId3
                );
                if (errors.length > 0) {
                    throw new KafkaJSDeleteGroupsError$1("Error in DeleteGroups", errors);
                }
                results = flatten$h(res.map(({results: results1}) => results1
                ));
                return results;
            } catch (e46) {
                if (e46.type === "NOT_CONTROLLER" || e46.type === "COORDINATOR_NOT_AVAILABLE") {
                    logger13.warn("Could not delete groups", {
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    throw e46;
                }
                bail(e46);
            }
        });
    };
    const deleteTopicRecords = async ({topic: topic5, partitions: partitions2}) => {
        if (!topic5 || typeof topic5 !== "string") {
            throw new KafkaJSNonRetriableError$d(`Invalid topic "${topic5}"`);
        }
        if (!partitions2 || partitions2.length === 0) {
            throw new KafkaJSNonRetriableError$d(`Invalid partitions`);
        }
        const partitionsByBroker = cluster2.findLeaderForPartitions(topic5, partitions2.map((p35) => p35.partition
        ));
        const partitionsFound = flatten$h(values$3(partitionsByBroker));
        const topicOffsets = await fetchTopicOffsets(topic5);
        const leaderNotFoundErrors = [];
        partitions2.forEach(({partition: partition3, offset}) => {
            if (!partitionsFound.includes(partition3)) {
                leaderNotFoundErrors.push({
                    partition: partition3,
                    offset,
                    error: new KafkaJSBrokerNotFound$3("Could not find the leader for the partition", {
                        retriable: false
                    })
                });
                return;
            }
            const {low} = topicOffsets.find((p35) => p35.partition === partition3
            ) || {
                high: undefined,
                low: undefined
            };
            if (parseInt(offset) < parseInt(low)) {
                logger13.warn("The requested offset is before the earliest offset maintained on the partition - no records will be deleted from this partition", {
                    topic: topic5,
                    partition: partition3,
                    offset
                });
            }
        });
        if (leaderNotFoundErrors.length > 0) {
            throw new KafkaJSDeleteTopicRecordsError$2({
                topic: topic5,
                partitions: leaderNotFoundErrors
            });
        }
        const seekEntriesByBroker = entries(partitionsByBroker).reduce((obj, [nodeId3, nodePartitions]) => {
            obj[nodeId3] = {
                topic: topic5,
                partitions: partitions2.filter((p35) => nodePartitions.includes(p35.partition)
                )
            };
            return obj;
        }, {});
        const retrier = createRetry$8(retry5);
        return retrier(async (bail) => {
            try {
                const partitionErrors = [];
                const brokerRequests = entries(seekEntriesByBroker).map(([nodeId3, {
                            topic: topic6,
                            partitions: partitions3
                        }]) => async () => {
                            const broker6 = await cluster2.findBroker({
                                nodeId: nodeId3
                            });
                            await broker6.deleteRecords({
                                topics: [
                                    {
                                        topic: topic6,
                                        partitions: partitions3
                                    }
                                ]
                            });
                            delete seekEntriesByBroker[nodeId3];
                        }
                );
                await Promise.all(brokerRequests.map((request) => request().catch((e46) => {
                            if (e46.name === "KafkaJSDeleteTopicRecordsError") {
                                e46.partitions.forEach(({partition: partition3, offset, error}) => {
                                    partitionErrors.push({
                                        partition: partition3,
                                        offset,
                                        error
                                    });
                                });
                            } else {
                                throw e46;
                            }
                        })
                ));
                if (partitionErrors.length > 0) {
                    throw new KafkaJSDeleteTopicRecordsError$2({
                        topic: topic5,
                        partitions: partitionErrors
                    });
                }
            } catch (e46) {
                if (e46.retriable && e46.partitions.some(({error}) => staleMetadata$2(error) || error.name === "KafkaJSMetadataNotLoaded"
                )) {
                    await cluster2.refreshMetadata();
                }
                throw e46;
            }
        });
    };
    const createAcls = async ({acl}) => {
        if (!acl || !Array.isArray(acl)) {
            throw new KafkaJSNonRetriableError$d(`Invalid ACL array ${acl}`);
        }
        if (acl.length === 0) {
            throw new KafkaJSNonRetriableError$d("Empty ACL array");
        }
        if (acl.some(({principal}) => typeof principal !== "string"
        )) {
            throw new KafkaJSNonRetriableError$d("Invalid ACL array, the principals have to be a valid string");
        }
        if (acl.some(({host: host3}) => typeof host3 !== "string"
        )) {
            throw new KafkaJSNonRetriableError$d("Invalid ACL array, the hosts have to be a valid string");
        }
        if (acl.some(({resourceName}) => typeof resourceName !== "string"
        )) {
            throw new KafkaJSNonRetriableError$d("Invalid ACL array, the resourceNames have to be a valid string");
        }
        let invalidType;
        const validOperationTypes = Object.values(ACL_OPERATION_TYPES);
        invalidType = acl.find((i53) => !validOperationTypes.includes(i53.operation)
        );
        if (invalidType) {
            throw new KafkaJSNonRetriableError$d(`Invalid operation type ${invalidType.operation}: ${JSON.stringify(invalidType)}`);
        }
        const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES);
        invalidType = acl.find((i53) => !validResourcePatternTypes.includes(i53.resourcePatternType)
        );
        if (invalidType) {
            throw new KafkaJSNonRetriableError$d(`Invalid resource pattern type ${invalidType.resourcePatternType}: ${JSON.stringify(invalidType)}`);
        }
        const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES);
        invalidType = acl.find((i53) => !validPermissionTypes.includes(i53.permissionType)
        );
        if (invalidType) {
            throw new KafkaJSNonRetriableError$d(`Invalid permission type ${invalidType.permissionType}: ${JSON.stringify(invalidType)}`);
        }
        const validResourceTypes = Object.values(ACL_RESOURCE_TYPES);
        invalidType = acl.find((i53) => !validResourceTypes.includes(i53.resourceType)
        );
        if (invalidType) {
            throw new KafkaJSNonRetriableError$d(`Invalid resource type ${invalidType.resourceType}: ${JSON.stringify(invalidType)}`);
        }
        const retrier = createRetry$8(retry5);
        return retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await cluster2.refreshMetadata();
                const broker6 = await cluster2.findControllerBroker();
                await broker6.createAcls({
                    acl
                });
                return true;
            } catch (e46) {
                if (e46.type === "NOT_CONTROLLER") {
                    logger13.warn("Could not create ACL", {
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    throw e46;
                }
                bail(e46);
            }
        });
    };
    const describeAcls = async ({
        resourceType,
        resourceName,
        resourcePatternType,
        principal,
        host: host3,
        operation,
        permissionType
    }) => {
        if (typeof principal !== "string" && typeof principal !== "undefined") {
            throw new KafkaJSNonRetriableError$d("Invalid principal, the principal have to be a valid string");
        }
        if (typeof host3 !== "string" && typeof host3 !== "undefined") {
            throw new KafkaJSNonRetriableError$d("Invalid host, the host have to be a valid string");
        }
        if (typeof resourceName !== "string" && typeof resourceName !== "undefined") {
            throw new KafkaJSNonRetriableError$d("Invalid resourceName, the resourceName have to be a valid string");
        }
        const validOperationTypes = Object.values(ACL_OPERATION_TYPES);
        if (!validOperationTypes.includes(operation)) {
            throw new KafkaJSNonRetriableError$d(`Invalid operation type ${operation}`);
        }
        const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES);
        if (!validResourcePatternTypes.includes(resourcePatternType)) {
            throw new KafkaJSNonRetriableError$d(`Invalid resource pattern filter type ${resourcePatternType}`);
        }
        const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES);
        if (!validPermissionTypes.includes(permissionType)) {
            throw new KafkaJSNonRetriableError$d(`Invalid permission type ${permissionType}`);
        }
        const validResourceTypes = Object.values(ACL_RESOURCE_TYPES);
        if (!validResourceTypes.includes(resourceType)) {
            throw new KafkaJSNonRetriableError$d(`Invalid resource type ${resourceType}`);
        }
        const retrier = createRetry$8(retry5);
        return retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await cluster2.refreshMetadata();
                const broker6 = await cluster2.findControllerBroker();
                const {resources} = await broker6.describeAcls({
                    resourceType,
                    resourceName,
                    resourcePatternType,
                    principal,
                    host: host3,
                    operation,
                    permissionType
                });
                return {
                    resources
                };
            } catch (e46) {
                if (e46.type === "NOT_CONTROLLER") {
                    logger13.warn("Could not describe ACL", {
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    throw e46;
                }
                bail(e46);
            }
        });
    };
    const deleteAcls = async ({filters}) => {
        if (!filters || !Array.isArray(filters)) {
            throw new KafkaJSNonRetriableError$d(`Invalid ACL Filter array ${filters}`);
        }
        if (filters.length === 0) {
            throw new KafkaJSNonRetriableError$d("Empty ACL Filter array");
        }
        if (filters.some(({principal}) => typeof principal !== "string" && typeof principal !== "undefined"
        )) {
            throw new KafkaJSNonRetriableError$d("Invalid ACL Filter array, the principals have to be a valid string");
        }
        if (filters.some(({host: host3}) => typeof host3 !== "string" && typeof host3 !== "undefined"
        )) {
            throw new KafkaJSNonRetriableError$d("Invalid ACL Filter array, the hosts have to be a valid string");
        }
        if (filters.some(({resourceName}) => typeof resourceName !== "string" && typeof resourceName !== "undefined"
        )) {
            throw new KafkaJSNonRetriableError$d("Invalid ACL Filter array, the resourceNames have to be a valid string");
        }
        let invalidType;
        const validOperationTypes = Object.values(ACL_OPERATION_TYPES);
        invalidType = filters.find((i53) => !validOperationTypes.includes(i53.operation)
        );
        if (invalidType) {
            throw new KafkaJSNonRetriableError$d(`Invalid operation type ${invalidType.operation}: ${JSON.stringify(invalidType)}`);
        }
        const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES);
        invalidType = filters.find((i53) => !validResourcePatternTypes.includes(i53.resourcePatternType)
        );
        if (invalidType) {
            throw new KafkaJSNonRetriableError$d(`Invalid resource pattern type ${invalidType.resourcePatternType}: ${JSON.stringify(invalidType)}`);
        }
        const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES);
        invalidType = filters.find((i53) => !validPermissionTypes.includes(i53.permissionType)
        );
        if (invalidType) {
            throw new KafkaJSNonRetriableError$d(`Invalid permission type ${invalidType.permissionType}: ${JSON.stringify(invalidType)}`);
        }
        const validResourceTypes = Object.values(ACL_RESOURCE_TYPES);
        invalidType = filters.find((i53) => !validResourceTypes.includes(i53.resourceType)
        );
        if (invalidType) {
            throw new KafkaJSNonRetriableError$d(`Invalid resource type ${invalidType.resourceType}: ${JSON.stringify(invalidType)}`);
        }
        const retrier = createRetry$8(retry5);
        return retrier(async (bail, retryCount1, retryTime1) => {
            try {
                await cluster2.refreshMetadata();
                const broker6 = await cluster2.findControllerBroker();
                const {filterResponses} = await broker6.deleteAcls({
                    filters
                });
                return {
                    filterResponses
                };
            } catch (e46) {
                if (e46.type === "NOT_CONTROLLER") {
                    logger13.warn("Could not delete ACL", {
                        error: e46.message,
                        retryCount: retryCount1,
                        retryTime: retryTime1
                    });
                    throw e46;
                }
                bail(e46);
            }
        });
    };
    const on = (eventName, listener) => {
        if (!eventNames$2.includes(eventName)) {
            throw new KafkaJSNonRetriableError$d(`Event name should be one of ${eventKeys$2}`);
        }
        return instrumentationEmitter7.addListener(unwrapEvent$2(eventName), (event) => {
            event.type = wrapEvent$2(event.type);
            Promise.resolve(listener(event)).catch((e46) => {
                logger13.error(`Failed to execute listener: ${e46.message}`, {
                    eventName,
                    stack: e46.stack
                });
            });
        });
    };
    const getLogger = () => logger13
    ;
    return {
        connect,
        disconnect,
        listTopics,
        createTopics,
        deleteTopics,
        createPartitions,
        getTopicMetadata,
        fetchTopicMetadata,
        describeCluster,
        events: events$7,
        fetchOffsets,
        fetchTopicOffsets,
        fetchTopicOffsetsByTimestamp,
        setOffsets,
        resetOffsets,
        describeConfigs,
        alterConfigs,
        on,
        logger: getLogger,
        listGroups,
        describeGroups,
        deleteGroups,
        describeAcls,
        deleteAcls,
        createAcls,
        deleteTopicRecords
    };
};
var _admin = exports$5H;
var exports$5I = {};
const KEEP_ALIVE_DELAY = 60000;
exports$5I = () => {
    const net1 = net;
    const tls1 = tls;
    return ({host: host3, port: port3, ssl: ssl2, onConnect}) => {
        const socket = ssl2 ? tls1.connect(Object.assign({
            host: host3,
            port: port3,
            servername: host3
        }, ssl2), onConnect) : net1.connect({
            host: host3,
            port: port3
        }, onConnect);
        socket.setKeepAlive(true, KEEP_ALIVE_DELAY);
        return socket;
    };
};
var _socketFactory = exports$5I;
var exports$5J = {};
const {createLogger: createLogger$1, LEVELS: {INFO}} = _loggers;
const InstrumentationEventEmitter$3 = _emitter;
const LoggerConsole = _console;
const Cluster = _cluster;
const createProducer = _producer;
const createConsumer$1 = _consumer;
const createAdmin = _admin;
const ISOLATION_LEVEL$b = _isolationLevel;
const defaultSocketFactory = _socketFactory;
const PRIVATE$6 = {
    CREATE_CLUSTER: Symbol("private:Kafka:createCluster"),
    CLUSTER_RETRY: Symbol("private:Kafka:clusterRetry"),
    LOGGER: Symbol("private:Kafka:logger"),
    OFFSETS: Symbol("private:Kafka:offsets")
};
const DEFAULT_METADATA_MAX_AGE = 300000;
exports$5J = class Client {
    constructor({
        brokers: brokers1,
        ssl: ssl2,
        sasl: sasl2,
        clientId: clientId4,
        connectionTimeout: connectionTimeout2,
        authenticationTimeout: authenticationTimeout3,
        reauthenticationThreshold: reauthenticationThreshold3,
        requestTimeout: requestTimeout6,
        enforceRequestTimeout: enforceRequestTimeout3 = false,
        retry: retry5,
        socketFactory: socketFactory2 = defaultSocketFactory(),
        logLevel: logLevel1 = INFO,
        logCreator = LoggerConsole
    }) {
        this[PRIVATE$6.OFFSETS] = new Map();
        this[PRIVATE$6.LOGGER] = createLogger$1({
            level: logLevel1,
            logCreator
        });
        this[PRIVATE$6.CLUSTER_RETRY] = retry5;
        this[PRIVATE$6.CREATE_CLUSTER] = ({
            metadataMaxAge: metadataMaxAge3,
            allowAutoTopicCreation: allowAutoTopicCreation3 = true,
            maxInFlightRequests: maxInFlightRequests3 = null,
            instrumentationEmitter: instrumentationEmitter7 = null,
            isolationLevel: isolationLevel2
        }) => new Cluster({
            logger: this[PRIVATE$6.LOGGER],
            retry: this[PRIVATE$6.CLUSTER_RETRY],
            offsets: this[PRIVATE$6.OFFSETS],
            socketFactory: socketFactory2,
            brokers: brokers1,
            ssl: ssl2,
            sasl: sasl2,
            clientId: clientId4,
            connectionTimeout: connectionTimeout2,
            authenticationTimeout: authenticationTimeout3,
            reauthenticationThreshold: reauthenticationThreshold3,
            requestTimeout: requestTimeout6,
            enforceRequestTimeout: enforceRequestTimeout3,
            metadataMaxAge: metadataMaxAge3,
            instrumentationEmitter: instrumentationEmitter7,
            allowAutoTopicCreation: allowAutoTopicCreation3,
            maxInFlightRequests: maxInFlightRequests3,
            isolationLevel: isolationLevel2
        })
        ;
    }

    producer({
        createPartitioner,
        retry,
        metadataMaxAge = DEFAULT_METADATA_MAX_AGE,
        allowAutoTopicCreation,
        idempotent,
        transactionalId,
        transactionTimeout,
        maxInFlightRequests
    } = {}) {
        const instrumentationEmitter7 = new InstrumentationEventEmitter$3();
        const cluster2 = this[PRIVATE$6.CREATE_CLUSTER]({
            metadataMaxAge,
            allowAutoTopicCreation,
            maxInFlightRequests,
            instrumentationEmitter: instrumentationEmitter7
        });
        return createProducer({
            retry: {
                ...this[PRIVATE$6.CLUSTER_RETRY],
                ...retry
            },
            logger: this[PRIVATE$6.LOGGER],
            cluster: cluster2,
            createPartitioner,
            idempotent,
            transactionalId,
            transactionTimeout,
            instrumentationEmitter: instrumentationEmitter7
        });
    }

    consumer({
        groupId,
        partitionAssigners,
        metadataMaxAge = DEFAULT_METADATA_MAX_AGE,
        sessionTimeout,
        rebalanceTimeout,
        heartbeatInterval,
        maxBytesPerPartition,
        minBytes,
        maxBytes,
        maxWaitTimeInMs,
        retry = {
            retries: 5
        },
        allowAutoTopicCreation,
        maxInFlightRequests,
        readUncommitted = false,
        rackId = ""
    } = {}) {
        const isolationLevel2 = readUncommitted ? ISOLATION_LEVEL$b.READ_UNCOMMITTED : ISOLATION_LEVEL$b.READ_COMMITTED;
        const instrumentationEmitter7 = new InstrumentationEventEmitter$3();
        const cluster2 = this[PRIVATE$6.CREATE_CLUSTER]({
            metadataMaxAge,
            allowAutoTopicCreation,
            maxInFlightRequests,
            isolationLevel: isolationLevel2,
            instrumentationEmitter: instrumentationEmitter7
        });
        return createConsumer$1({
            retry: {
                ...this[PRIVATE$6.CLUSTER_RETRY],
                ...retry
            },
            logger: this[PRIVATE$6.LOGGER],
            cluster: cluster2,
            groupId,
            partitionAssigners,
            sessionTimeout,
            rebalanceTimeout,
            heartbeatInterval,
            maxBytesPerPartition,
            minBytes,
            maxBytes,
            maxWaitTimeInMs,
            isolationLevel: isolationLevel2,
            instrumentationEmitter: instrumentationEmitter7,
            rackId,
            metadataMaxAge
        });
    }

    admin({retry} = {}) {
        const instrumentationEmitter7 = new InstrumentationEventEmitter$3();
        const cluster2 = this[PRIVATE$6.CREATE_CLUSTER]({
            allowAutoTopicCreation: false,
            instrumentationEmitter: instrumentationEmitter7
        });
        return createAdmin({
            retry: {
                ...this[PRIVATE$6.CLUSTER_RETRY],
                ...retry
            },
            logger: this[PRIVATE$6.LOGGER],
            instrumentationEmitter: instrumentationEmitter7,
            cluster: cluster2
        });
    }

    logger() {
        return this[PRIVATE$6.LOGGER];
    }
};
var _src = exports$5J;
var exports$5K = {};
const ACLResourceTypes = _aclResourceTypes;
exports$5K = ACLResourceTypes;
var _resourceTypes = exports$5K;
var exports$5L = {};
const Kafka1 = _src;
const PartitionAssigners1 = _assigners;
const AssignerProtocol1 = _assignerProtocol;
const Partitioners1 = _partitioners;
const Compression$4 = _compression;
const ResourceTypes = _resourceTypes;
const ConfigResourceTypes = _configResourceTypes;
const AclResourceTypes = _aclResourceTypes;
const AclOperationTypes = _aclOperationTypes;
const AclPermissionTypes = _aclPermissionTypes;
const ResourcePatternTypes = _resourcePatternTypes;
const {LEVELS: LEVELS$2} = _loggers;
exports$5L = {
    Kafka: Kafka1,
    PartitionAssigners: PartitionAssigners1,
    AssignerProtocol: AssignerProtocol1,
    Partitioners: Partitioners1,
    logLevel: LEVELS$2,
    CompressionTypes: Compression$4.Types,
    CompressionCodecs: Compression$4.Codecs,
    ResourceTypes,
    ConfigResourceTypes,
    AclResourceTypes,
    AclOperationTypes,
    AclPermissionTypes,
    ResourcePatternTypes
};
var exports$5M = exports$5L;
const logLevel$1 = exports$5L.logLevel, CompressionTypes1 = exports$5L.CompressionTypes;
const _Kafka = exports$5L.Kafka, _PartitionAssigners = exports$5L.PartitionAssigners,
        _AssignerProtocol = exports$5L.AssignerProtocol, _Partitioners = exports$5L.Partitioners;
export {
    _AssignerProtocol as AssignerProtocol,
    CompressionTypes1 as CompressionTypes,
    _Kafka as Kafka,
    _PartitionAssigners as PartitionAssigners,
    _Partitioners as Partitioners,
    logLevel$1 as logLevel
};
export {exports$5M as default};
