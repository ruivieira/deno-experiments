var entities = {
    Aacute: "\xC1",
    aacute: "\xE1",
    Abreve: "\u0102",
    abreve: "\u0103",
    ac: "\u223E",
    acd: "\u223F",
    acE: "\u223E\u0333",
    Acirc: "\xC2",
    acirc: "\xE2",
    acute: "\xB4",
    Acy: "\u0410",
    acy: "\u0430",
    AElig: "\xC6",
    aelig: "\xE6",
    af: "\u2061",
    Afr: "\u{1D504}",
    afr: "\u{1D51E}",
    Agrave: "\xC0",
    agrave: "\xE0",
    alefsym: "\u2135",
    aleph: "\u2135",
    Alpha: "\u0391",
    alpha: "\u03B1",
    Amacr: "\u0100",
    amacr: "\u0101",
    amalg: "\u2A3F",
    AMP: "&",
    amp: "&",
    And: "\u2A53",
    and: "\u2227",
    andand: "\u2A55",
    andd: "\u2A5C",
    andslope: "\u2A58",
    andv: "\u2A5A",
    ang: "\u2220",
    ange: "\u29A4",
    angle: "\u2220",
    angmsd: "\u2221",
    angmsdaa: "\u29A8",
    angmsdab: "\u29A9",
    angmsdac: "\u29AA",
    angmsdad: "\u29AB",
    angmsdae: "\u29AC",
    angmsdaf: "\u29AD",
    angmsdag: "\u29AE",
    angmsdah: "\u29AF",
    angrt: "\u221F",
    angrtvb: "\u22BE",
    angrtvbd: "\u299D",
    angsph: "\u2222",
    angst: "\xC5",
    angzarr: "\u237C",
    Aogon: "\u0104",
    aogon: "\u0105",
    Aopf: "\u{1D538}",
    aopf: "\u{1D552}",
    ap: "\u2248",
    apacir: "\u2A6F",
    apE: "\u2A70",
    ape: "\u224A",
    apid: "\u224B",
    apos: "'",
    ApplyFunction: "\u2061",
    approx: "\u2248",
    approxeq: "\u224A",
    Aring: "\xC5",
    aring: "\xE5",
    Ascr: "\u{1D49C}",
    ascr: "\u{1D4B6}",
    Assign: "\u2254",
    ast: "*",
    asymp: "\u2248",
    asympeq: "\u224D",
    Atilde: "\xC3",
    atilde: "\xE3",
    Auml: "\xC4",
    auml: "\xE4",
    awconint: "\u2233",
    awint: "\u2A11",
    backcong: "\u224C",
    backepsilon: "\u03F6",
    backprime: "\u2035",
    backsim: "\u223D",
    backsimeq: "\u22CD",
    Backslash: "\u2216",
    Barv: "\u2AE7",
    barvee: "\u22BD",
    Barwed: "\u2306",
    barwed: "\u2305",
    barwedge: "\u2305",
    bbrk: "\u23B5",
    bbrktbrk: "\u23B6",
    bcong: "\u224C",
    Bcy: "\u0411",
    bcy: "\u0431",
    bdquo: "\u201E",
    becaus: "\u2235",
    Because: "\u2235",
    because: "\u2235",
    bemptyv: "\u29B0",
    bepsi: "\u03F6",
    bernou: "\u212C",
    Bernoullis: "\u212C",
    Beta: "\u0392",
    beta: "\u03B2",
    beth: "\u2136",
    between: "\u226C",
    Bfr: "\u{1D505}",
    bfr: "\u{1D51F}",
    bigcap: "\u22C2",
    bigcirc: "\u25EF",
    bigcup: "\u22C3",
    bigodot: "\u2A00",
    bigoplus: "\u2A01",
    bigotimes: "\u2A02",
    bigsqcup: "\u2A06",
    bigstar: "\u2605",
    bigtriangledown: "\u25BD",
    bigtriangleup: "\u25B3",
    biguplus: "\u2A04",
    bigvee: "\u22C1",
    bigwedge: "\u22C0",
    bkarow: "\u290D",
    blacklozenge: "\u29EB",
    blacksquare: "\u25AA",
    blacktriangle: "\u25B4",
    blacktriangledown: "\u25BE",
    blacktriangleleft: "\u25C2",
    blacktriangleright: "\u25B8",
    blank: "\u2423",
    blk12: "\u2592",
    blk14: "\u2591",
    blk34: "\u2593",
    block: "\u2588",
    bne: "=\u20E5",
    bnequiv: "\u2261\u20E5",
    bNot: "\u2AED",
    bnot: "\u2310",
    Bopf: "\u{1D539}",
    bopf: "\u{1D553}",
    bot: "\u22A5",
    bottom: "\u22A5",
    bowtie: "\u22C8",
    boxbox: "\u29C9",
    boxDL: "\u2557",
    boxDl: "\u2556",
    boxdL: "\u2555",
    boxdl: "\u2510",
    boxDR: "\u2554",
    boxDr: "\u2553",
    boxdR: "\u2552",
    boxdr: "\u250C",
    boxH: "\u2550",
    boxh: "\u2500",
    boxHD: "\u2566",
    boxHd: "\u2564",
    boxhD: "\u2565",
    boxhd: "\u252C",
    boxHU: "\u2569",
    boxHu: "\u2567",
    boxhU: "\u2568",
    boxhu: "\u2534",
    boxminus: "\u229F",
    boxplus: "\u229E",
    boxtimes: "\u22A0",
    boxUL: "\u255D",
    boxUl: "\u255C",
    boxuL: "\u255B",
    boxul: "\u2518",
    boxUR: "\u255A",
    boxUr: "\u2559",
    boxuR: "\u2558",
    boxur: "\u2514",
    boxV: "\u2551",
    boxv: "\u2502",
    boxVH: "\u256C",
    boxVh: "\u256B",
    boxvH: "\u256A",
    boxvh: "\u253C",
    boxVL: "\u2563",
    boxVl: "\u2562",
    boxvL: "\u2561",
    boxvl: "\u2524",
    boxVR: "\u2560",
    boxVr: "\u255F",
    boxvR: "\u255E",
    boxvr: "\u251C",
    bprime: "\u2035",
    Breve: "\u02D8",
    breve: "\u02D8",
    brvbar: "\xA6",
    Bscr: "\u212C",
    bscr: "\u{1D4B7}",
    bsemi: "\u204F",
    bsim: "\u223D",
    bsime: "\u22CD",
    bsol: "\\",
    bsolb: "\u29C5",
    bsolhsub: "\u27C8",
    bull: "\u2022",
    bullet: "\u2022",
    bump: "\u224E",
    bumpE: "\u2AAE",
    bumpe: "\u224F",
    Bumpeq: "\u224E",
    bumpeq: "\u224F",
    Cacute: "\u0106",
    cacute: "\u0107",
    Cap: "\u22D2",
    cap: "\u2229",
    capand: "\u2A44",
    capbrcup: "\u2A49",
    capcap: "\u2A4B",
    capcup: "\u2A47",
    capdot: "\u2A40",
    CapitalDifferentialD: "\u2145",
    caps: "\u2229\uFE00",
    caret: "\u2041",
    caron: "\u02C7",
    Cayleys: "\u212D",
    ccaps: "\u2A4D",
    Ccaron: "\u010C",
    ccaron: "\u010D",
    Ccedil: "\xC7",
    ccedil: "\xE7",
    Ccirc: "\u0108",
    ccirc: "\u0109",
    Cconint: "\u2230",
    ccups: "\u2A4C",
    ccupssm: "\u2A50",
    Cdot: "\u010A",
    cdot: "\u010B",
    cedil: "\xB8",
    Cedilla: "\xB8",
    cemptyv: "\u29B2",
    cent: "\xA2",
    CenterDot: "\xB7",
    centerdot: "\xB7",
    Cfr: "\u212D",
    cfr: "\u{1D520}",
    CHcy: "\u0427",
    chcy: "\u0447",
    check: "\u2713",
    checkmark: "\u2713",
    Chi: "\u03A7",
    chi: "\u03C7",
    cir: "\u25CB",
    circ: "\u02C6",
    circeq: "\u2257",
    circlearrowleft: "\u21BA",
    circlearrowright: "\u21BB",
    circledast: "\u229B",
    circledcirc: "\u229A",
    circleddash: "\u229D",
    CircleDot: "\u2299",
    circledR: "\xAE",
    circledS: "\u24C8",
    CircleMinus: "\u2296",
    CirclePlus: "\u2295",
    CircleTimes: "\u2297",
    cirE: "\u29C3",
    cire: "\u2257",
    cirfnint: "\u2A10",
    cirmid: "\u2AEF",
    cirscir: "\u29C2",
    ClockwiseContourIntegral: "\u2232",
    CloseCurlyDoubleQuote: "\u201D",
    CloseCurlyQuote: "\u2019",
    clubs: "\u2663",
    clubsuit: "\u2663",
    Colon: "\u2237",
    colon: ":",
    Colone: "\u2A74",
    colone: "\u2254",
    coloneq: "\u2254",
    comma: ",",
    commat: "@",
    comp: "\u2201",
    compfn: "\u2218",
    complement: "\u2201",
    complexes: "\u2102",
    cong: "\u2245",
    congdot: "\u2A6D",
    Congruent: "\u2261",
    Conint: "\u222F",
    conint: "\u222E",
    ContourIntegral: "\u222E",
    Copf: "\u2102",
    copf: "\u{1D554}",
    coprod: "\u2210",
    Coproduct: "\u2210",
    COPY: "\xA9",
    copy: "\xA9",
    copysr: "\u2117",
    CounterClockwiseContourIntegral: "\u2233",
    crarr: "\u21B5",
    Cross: "\u2A2F",
    cross: "\u2717",
    Cscr: "\u{1D49E}",
    cscr: "\u{1D4B8}",
    csub: "\u2ACF",
    csube: "\u2AD1",
    csup: "\u2AD0",
    csupe: "\u2AD2",
    ctdot: "\u22EF",
    cudarrl: "\u2938",
    cudarrr: "\u2935",
    cuepr: "\u22DE",
    cuesc: "\u22DF",
    cularr: "\u21B6",
    cularrp: "\u293D",
    Cup: "\u22D3",
    cup: "\u222A",
    cupbrcap: "\u2A48",
    CupCap: "\u224D",
    cupcap: "\u2A46",
    cupcup: "\u2A4A",
    cupdot: "\u228D",
    cupor: "\u2A45",
    cups: "\u222A\uFE00",
    curarr: "\u21B7",
    curarrm: "\u293C",
    curlyeqprec: "\u22DE",
    curlyeqsucc: "\u22DF",
    curlyvee: "\u22CE",
    curlywedge: "\u22CF",
    curren: "\xA4",
    curvearrowleft: "\u21B6",
    curvearrowright: "\u21B7",
    cuvee: "\u22CE",
    cuwed: "\u22CF",
    cwconint: "\u2232",
    cwint: "\u2231",
    cylcty: "\u232D",
    Dagger: "\u2021",
    dagger: "\u2020",
    daleth: "\u2138",
    Darr: "\u21A1",
    dArr: "\u21D3",
    darr: "\u2193",
    dash: "\u2010",
    Dashv: "\u2AE4",
    dashv: "\u22A3",
    dbkarow: "\u290F",
    dblac: "\u02DD",
    Dcaron: "\u010E",
    dcaron: "\u010F",
    Dcy: "\u0414",
    dcy: "\u0434",
    DD: "\u2145",
    dd: "\u2146",
    ddagger: "\u2021",
    ddarr: "\u21CA",
    DDotrahd: "\u2911",
    ddotseq: "\u2A77",
    deg: "\xB0",
    Del: "\u2207",
    Delta: "\u0394",
    delta: "\u03B4",
    demptyv: "\u29B1",
    dfisht: "\u297F",
    Dfr: "\u{1D507}",
    dfr: "\u{1D521}",
    dHar: "\u2965",
    dharl: "\u21C3",
    dharr: "\u21C2",
    DiacriticalAcute: "\xB4",
    DiacriticalDot: "\u02D9",
    DiacriticalDoubleAcute: "\u02DD",
    DiacriticalGrave: "`",
    DiacriticalTilde: "\u02DC",
    diam: "\u22C4",
    Diamond: "\u22C4",
    diamond: "\u22C4",
    diamondsuit: "\u2666",
    diams: "\u2666",
    die: "\xA8",
    DifferentialD: "\u2146",
    digamma: "\u03DD",
    disin: "\u22F2",
    div: "\xF7",
    divide: "\xF7",
    divideontimes: "\u22C7",
    divonx: "\u22C7",
    DJcy: "\u0402",
    djcy: "\u0452",
    dlcorn: "\u231E",
    dlcrop: "\u230D",
    dollar: "$",
    Dopf: "\u{1D53B}",
    dopf: "\u{1D555}",
    Dot: "\xA8",
    dot: "\u02D9",
    DotDot: "\u20DC",
    doteq: "\u2250",
    doteqdot: "\u2251",
    DotEqual: "\u2250",
    dotminus: "\u2238",
    dotplus: "\u2214",
    dotsquare: "\u22A1",
    doublebarwedge: "\u2306",
    DoubleContourIntegral: "\u222F",
    DoubleDot: "\xA8",
    DoubleDownArrow: "\u21D3",
    DoubleLeftArrow: "\u21D0",
    DoubleLeftRightArrow: "\u21D4",
    DoubleLeftTee: "\u2AE4",
    DoubleLongLeftArrow: "\u27F8",
    DoubleLongLeftRightArrow: "\u27FA",
    DoubleLongRightArrow: "\u27F9",
    DoubleRightArrow: "\u21D2",
    DoubleRightTee: "\u22A8",
    DoubleUpArrow: "\u21D1",
    DoubleUpDownArrow: "\u21D5",
    DoubleVerticalBar: "\u2225",
    DownArrow: "\u2193",
    Downarrow: "\u21D3",
    downarrow: "\u2193",
    DownArrowBar: "\u2913",
    DownArrowUpArrow: "\u21F5",
    DownBreve: "\u0311",
    downdownarrows: "\u21CA",
    downharpoonleft: "\u21C3",
    downharpoonright: "\u21C2",
    DownLeftRightVector: "\u2950",
    DownLeftTeeVector: "\u295E",
    DownLeftVector: "\u21BD",
    DownLeftVectorBar: "\u2956",
    DownRightTeeVector: "\u295F",
    DownRightVector: "\u21C1",
    DownRightVectorBar: "\u2957",
    DownTee: "\u22A4",
    DownTeeArrow: "\u21A7",
    drbkarow: "\u2910",
    drcorn: "\u231F",
    drcrop: "\u230C",
    Dscr: "\u{1D49F}",
    dscr: "\u{1D4B9}",
    DScy: "\u0405",
    dscy: "\u0455",
    dsol: "\u29F6",
    Dstrok: "\u0110",
    dstrok: "\u0111",
    dtdot: "\u22F1",
    dtri: "\u25BF",
    dtrif: "\u25BE",
    duarr: "\u21F5",
    duhar: "\u296F",
    dwangle: "\u29A6",
    DZcy: "\u040F",
    dzcy: "\u045F",
    dzigrarr: "\u27FF",
    Eacute: "\xC9",
    eacute: "\xE9",
    easter: "\u2A6E",
    Ecaron: "\u011A",
    ecaron: "\u011B",
    ecir: "\u2256",
    Ecirc: "\xCA",
    ecirc: "\xEA",
    ecolon: "\u2255",
    Ecy: "\u042D",
    ecy: "\u044D",
    eDDot: "\u2A77",
    Edot: "\u0116",
    eDot: "\u2251",
    edot: "\u0117",
    ee: "\u2147",
    efDot: "\u2252",
    Efr: "\u{1D508}",
    efr: "\u{1D522}",
    eg: "\u2A9A",
    Egrave: "\xC8",
    egrave: "\xE8",
    egs: "\u2A96",
    egsdot: "\u2A98",
    el: "\u2A99",
    Element: "\u2208",
    elinters: "\u23E7",
    ell: "\u2113",
    els: "\u2A95",
    elsdot: "\u2A97",
    Emacr: "\u0112",
    emacr: "\u0113",
    empty: "\u2205",
    emptyset: "\u2205",
    EmptySmallSquare: "\u25FB",
    emptyv: "\u2205",
    EmptyVerySmallSquare: "\u25AB",
    emsp: "\u2003",
    emsp13: "\u2004",
    emsp14: "\u2005",
    ENG: "\u014A",
    eng: "\u014B",
    ensp: "\u2002",
    Eogon: "\u0118",
    eogon: "\u0119",
    Eopf: "\u{1D53C}",
    eopf: "\u{1D556}",
    epar: "\u22D5",
    eparsl: "\u29E3",
    eplus: "\u2A71",
    epsi: "\u03B5",
    Epsilon: "\u0395",
    epsilon: "\u03B5",
    epsiv: "\u03F5",
    eqcirc: "\u2256",
    eqcolon: "\u2255",
    eqsim: "\u2242",
    eqslantgtr: "\u2A96",
    eqslantless: "\u2A95",
    Equal: "\u2A75",
    equals: "=",
    EqualTilde: "\u2242",
    equest: "\u225F",
    Equilibrium: "\u21CC",
    equiv: "\u2261",
    equivDD: "\u2A78",
    eqvparsl: "\u29E5",
    erarr: "\u2971",
    erDot: "\u2253",
    Escr: "\u2130",
    escr: "\u212F",
    esdot: "\u2250",
    Esim: "\u2A73",
    esim: "\u2242",
    Eta: "\u0397",
    eta: "\u03B7",
    ETH: "\xD0",
    eth: "\xF0",
    Euml: "\xCB",
    euml: "\xEB",
    euro: "\u20AC",
    excl: "!",
    exist: "\u2203",
    Exists: "\u2203",
    expectation: "\u2130",
    ExponentialE: "\u2147",
    exponentiale: "\u2147",
    fallingdotseq: "\u2252",
    Fcy: "\u0424",
    fcy: "\u0444",
    female: "\u2640",
    ffilig: "\uFB03",
    fflig: "\uFB00",
    ffllig: "\uFB04",
    Ffr: "\u{1D509}",
    ffr: "\u{1D523}",
    filig: "\uFB01",
    FilledSmallSquare: "\u25FC",
    FilledVerySmallSquare: "\u25AA",
    fjlig: "fj",
    flat: "\u266D",
    fllig: "\uFB02",
    fltns: "\u25B1",
    fnof: "\u0192",
    Fopf: "\u{1D53D}",
    fopf: "\u{1D557}",
    ForAll: "\u2200",
    forall: "\u2200",
    fork: "\u22D4",
    forkv: "\u2AD9",
    Fouriertrf: "\u2131",
    fpartint: "\u2A0D",
    frac12: "\xBD",
    frac13: "\u2153",
    frac14: "\xBC",
    frac15: "\u2155",
    frac16: "\u2159",
    frac18: "\u215B",
    frac23: "\u2154",
    frac25: "\u2156",
    frac34: "\xBE",
    frac35: "\u2157",
    frac38: "\u215C",
    frac45: "\u2158",
    frac56: "\u215A",
    frac58: "\u215D",
    frac78: "\u215E",
    frasl: "\u2044",
    frown: "\u2322",
    Fscr: "\u2131",
    fscr: "\u{1D4BB}",
    gacute: "\u01F5",
    Gamma: "\u0393",
    gamma: "\u03B3",
    Gammad: "\u03DC",
    gammad: "\u03DD",
    gap: "\u2A86",
    Gbreve: "\u011E",
    gbreve: "\u011F",
    Gcedil: "\u0122",
    Gcirc: "\u011C",
    gcirc: "\u011D",
    Gcy: "\u0413",
    gcy: "\u0433",
    Gdot: "\u0120",
    gdot: "\u0121",
    gE: "\u2267",
    ge: "\u2265",
    gEl: "\u2A8C",
    gel: "\u22DB",
    geq: "\u2265",
    geqq: "\u2267",
    geqslant: "\u2A7E",
    ges: "\u2A7E",
    gescc: "\u2AA9",
    gesdot: "\u2A80",
    gesdoto: "\u2A82",
    gesdotol: "\u2A84",
    gesl: "\u22DB\uFE00",
    gesles: "\u2A94",
    Gfr: "\u{1D50A}",
    gfr: "\u{1D524}",
    Gg: "\u22D9",
    gg: "\u226B",
    ggg: "\u22D9",
    gimel: "\u2137",
    GJcy: "\u0403",
    gjcy: "\u0453",
    gl: "\u2277",
    gla: "\u2AA5",
    glE: "\u2A92",
    glj: "\u2AA4",
    gnap: "\u2A8A",
    gnapprox: "\u2A8A",
    gnE: "\u2269",
    gne: "\u2A88",
    gneq: "\u2A88",
    gneqq: "\u2269",
    gnsim: "\u22E7",
    Gopf: "\u{1D53E}",
    gopf: "\u{1D558}",
    grave: "`",
    GreaterEqual: "\u2265",
    GreaterEqualLess: "\u22DB",
    GreaterFullEqual: "\u2267",
    GreaterGreater: "\u2AA2",
    GreaterLess: "\u2277",
    GreaterSlantEqual: "\u2A7E",
    GreaterTilde: "\u2273",
    Gscr: "\u{1D4A2}",
    gscr: "\u210A",
    gsim: "\u2273",
    gsime: "\u2A8E",
    gsiml: "\u2A90",
    GT: ">",
    Gt: "\u226B",
    gt: ">",
    gtcc: "\u2AA7",
    gtcir: "\u2A7A",
    gtdot: "\u22D7",
    gtlPar: "\u2995",
    gtquest: "\u2A7C",
    gtrapprox: "\u2A86",
    gtrarr: "\u2978",
    gtrdot: "\u22D7",
    gtreqless: "\u22DB",
    gtreqqless: "\u2A8C",
    gtrless: "\u2277",
    gtrsim: "\u2273",
    gvertneqq: "\u2269\uFE00",
    gvnE: "\u2269\uFE00",
    Hacek: "\u02C7",
    hairsp: "\u200A",
    half: "\xBD",
    hamilt: "\u210B",
    HARDcy: "\u042A",
    hardcy: "\u044A",
    hArr: "\u21D4",
    harr: "\u2194",
    harrcir: "\u2948",
    harrw: "\u21AD",
    Hat: "^",
    hbar: "\u210F",
    Hcirc: "\u0124",
    hcirc: "\u0125",
    hearts: "\u2665",
    heartsuit: "\u2665",
    hellip: "\u2026",
    hercon: "\u22B9",
    Hfr: "\u210C",
    hfr: "\u{1D525}",
    HilbertSpace: "\u210B",
    hksearow: "\u2925",
    hkswarow: "\u2926",
    hoarr: "\u21FF",
    homtht: "\u223B",
    hookleftarrow: "\u21A9",
    hookrightarrow: "\u21AA",
    Hopf: "\u210D",
    hopf: "\u{1D559}",
    horbar: "\u2015",
    HorizontalLine: "\u2500",
    Hscr: "\u210B",
    hscr: "\u{1D4BD}",
    hslash: "\u210F",
    Hstrok: "\u0126",
    hstrok: "\u0127",
    HumpDownHump: "\u224E",
    HumpEqual: "\u224F",
    hybull: "\u2043",
    hyphen: "\u2010",
    Iacute: "\xCD",
    iacute: "\xED",
    ic: "\u2063",
    Icirc: "\xCE",
    icirc: "\xEE",
    Icy: "\u0418",
    icy: "\u0438",
    Idot: "\u0130",
    IEcy: "\u0415",
    iecy: "\u0435",
    iexcl: "\xA1",
    iff: "\u21D4",
    Ifr: "\u2111",
    ifr: "\u{1D526}",
    Igrave: "\xCC",
    igrave: "\xEC",
    ii: "\u2148",
    iiiint: "\u2A0C",
    iiint: "\u222D",
    iinfin: "\u29DC",
    iiota: "\u2129",
    IJlig: "\u0132",
    ijlig: "\u0133",
    Im: "\u2111",
    Imacr: "\u012A",
    imacr: "\u012B",
    image: "\u2111",
    ImaginaryI: "\u2148",
    imagline: "\u2110",
    imagpart: "\u2111",
    imath: "\u0131",
    imof: "\u22B7",
    imped: "\u01B5",
    Implies: "\u21D2",
    in: "\u2208",
    incare: "\u2105",
    infin: "\u221E",
    infintie: "\u29DD",
    inodot: "\u0131",
    Int: "\u222C",
    int: "\u222B",
    intcal: "\u22BA",
    integers: "\u2124",
    Integral: "\u222B",
    intercal: "\u22BA",
    Intersection: "\u22C2",
    intlarhk: "\u2A17",
    intprod: "\u2A3C",
    InvisibleComma: "\u2063",
    InvisibleTimes: "\u2062",
    IOcy: "\u0401",
    iocy: "\u0451",
    Iogon: "\u012E",
    iogon: "\u012F",
    Iopf: "\u{1D540}",
    iopf: "\u{1D55A}",
    Iota: "\u0399",
    iota: "\u03B9",
    iprod: "\u2A3C",
    iquest: "\xBF",
    Iscr: "\u2110",
    iscr: "\u{1D4BE}",
    isin: "\u2208",
    isindot: "\u22F5",
    isinE: "\u22F9",
    isins: "\u22F4",
    isinsv: "\u22F3",
    isinv: "\u2208",
    it: "\u2062",
    Itilde: "\u0128",
    itilde: "\u0129",
    Iukcy: "\u0406",
    iukcy: "\u0456",
    Iuml: "\xCF",
    iuml: "\xEF",
    Jcirc: "\u0134",
    jcirc: "\u0135",
    Jcy: "\u0419",
    jcy: "\u0439",
    Jfr: "\u{1D50D}",
    jfr: "\u{1D527}",
    jmath: "\u0237",
    Jopf: "\u{1D541}",
    jopf: "\u{1D55B}",
    Jscr: "\u{1D4A5}",
    jscr: "\u{1D4BF}",
    Jsercy: "\u0408",
    jsercy: "\u0458",
    Jukcy: "\u0404",
    jukcy: "\u0454",
    Kappa: "\u039A",
    kappa: "\u03BA",
    kappav: "\u03F0",
    Kcedil: "\u0136",
    kcedil: "\u0137",
    Kcy: "\u041A",
    kcy: "\u043A",
    Kfr: "\u{1D50E}",
    kfr: "\u{1D528}",
    kgreen: "\u0138",
    KHcy: "\u0425",
    khcy: "\u0445",
    KJcy: "\u040C",
    kjcy: "\u045C",
    Kopf: "\u{1D542}",
    kopf: "\u{1D55C}",
    Kscr: "\u{1D4A6}",
    kscr: "\u{1D4C0}",
    lAarr: "\u21DA",
    Lacute: "\u0139",
    lacute: "\u013A",
    laemptyv: "\u29B4",
    lagran: "\u2112",
    Lambda: "\u039B",
    lambda: "\u03BB",
    Lang: "\u27EA",
    lang: "\u27E8",
    langd: "\u2991",
    langle: "\u27E8",
    lap: "\u2A85",
    Laplacetrf: "\u2112",
    laquo: "\xAB",
    Larr: "\u219E",
    lArr: "\u21D0",
    larr: "\u2190",
    larrb: "\u21E4",
    larrbfs: "\u291F",
    larrfs: "\u291D",
    larrhk: "\u21A9",
    larrlp: "\u21AB",
    larrpl: "\u2939",
    larrsim: "\u2973",
    larrtl: "\u21A2",
    lat: "\u2AAB",
    lAtail: "\u291B",
    latail: "\u2919",
    late: "\u2AAD",
    lates: "\u2AAD\uFE00",
    lBarr: "\u290E",
    lbarr: "\u290C",
    lbbrk: "\u2772",
    lbrace: "{",
    lbrack: "[",
    lbrke: "\u298B",
    lbrksld: "\u298F",
    lbrkslu: "\u298D",
    Lcaron: "\u013D",
    lcaron: "\u013E",
    Lcedil: "\u013B",
    lcedil: "\u013C",
    lceil: "\u2308",
    lcub: "{",
    Lcy: "\u041B",
    lcy: "\u043B",
    ldca: "\u2936",
    ldquo: "\u201C",
    ldquor: "\u201E",
    ldrdhar: "\u2967",
    ldrushar: "\u294B",
    ldsh: "\u21B2",
    lE: "\u2266",
    le: "\u2264",
    LeftAngleBracket: "\u27E8",
    LeftArrow: "\u2190",
    Leftarrow: "\u21D0",
    leftarrow: "\u2190",
    LeftArrowBar: "\u21E4",
    LeftArrowRightArrow: "\u21C6",
    leftarrowtail: "\u21A2",
    LeftCeiling: "\u2308",
    LeftDoubleBracket: "\u27E6",
    LeftDownTeeVector: "\u2961",
    LeftDownVector: "\u21C3",
    LeftDownVectorBar: "\u2959",
    LeftFloor: "\u230A",
    leftharpoondown: "\u21BD",
    leftharpoonup: "\u21BC",
    leftleftarrows: "\u21C7",
    LeftRightArrow: "\u2194",
    Leftrightarrow: "\u21D4",
    leftrightarrow: "\u2194",
    leftrightarrows: "\u21C6",
    leftrightharpoons: "\u21CB",
    leftrightsquigarrow: "\u21AD",
    LeftRightVector: "\u294E",
    LeftTee: "\u22A3",
    LeftTeeArrow: "\u21A4",
    LeftTeeVector: "\u295A",
    leftthreetimes: "\u22CB",
    LeftTriangle: "\u22B2",
    LeftTriangleBar: "\u29CF",
    LeftTriangleEqual: "\u22B4",
    LeftUpDownVector: "\u2951",
    LeftUpTeeVector: "\u2960",
    LeftUpVector: "\u21BF",
    LeftUpVectorBar: "\u2958",
    LeftVector: "\u21BC",
    LeftVectorBar: "\u2952",
    lEg: "\u2A8B",
    leg: "\u22DA",
    leq: "\u2264",
    leqq: "\u2266",
    leqslant: "\u2A7D",
    les: "\u2A7D",
    lescc: "\u2AA8",
    lesdot: "\u2A7F",
    lesdoto: "\u2A81",
    lesdotor: "\u2A83",
    lesg: "\u22DA\uFE00",
    lesges: "\u2A93",
    lessapprox: "\u2A85",
    lessdot: "\u22D6",
    lesseqgtr: "\u22DA",
    lesseqqgtr: "\u2A8B",
    LessEqualGreater: "\u22DA",
    LessFullEqual: "\u2266",
    LessGreater: "\u2276",
    lessgtr: "\u2276",
    LessLess: "\u2AA1",
    lesssim: "\u2272",
    LessSlantEqual: "\u2A7D",
    LessTilde: "\u2272",
    lfisht: "\u297C",
    lfloor: "\u230A",
    Lfr: "\u{1D50F}",
    lfr: "\u{1D529}",
    lg: "\u2276",
    lgE: "\u2A91",
    lHar: "\u2962",
    lhard: "\u21BD",
    lharu: "\u21BC",
    lharul: "\u296A",
    lhblk: "\u2584",
    LJcy: "\u0409",
    ljcy: "\u0459",
    Ll: "\u22D8",
    ll: "\u226A",
    llarr: "\u21C7",
    llcorner: "\u231E",
    Lleftarrow: "\u21DA",
    llhard: "\u296B",
    lltri: "\u25FA",
    Lmidot: "\u013F",
    lmidot: "\u0140",
    lmoust: "\u23B0",
    lmoustache: "\u23B0",
    lnap: "\u2A89",
    lnapprox: "\u2A89",
    lnE: "\u2268",
    lne: "\u2A87",
    lneq: "\u2A87",
    lneqq: "\u2268",
    lnsim: "\u22E6",
    loang: "\u27EC",
    loarr: "\u21FD",
    lobrk: "\u27E6",
    LongLeftArrow: "\u27F5",
    Longleftarrow: "\u27F8",
    longleftarrow: "\u27F5",
    LongLeftRightArrow: "\u27F7",
    Longleftrightarrow: "\u27FA",
    longleftrightarrow: "\u27F7",
    longmapsto: "\u27FC",
    LongRightArrow: "\u27F6",
    Longrightarrow: "\u27F9",
    longrightarrow: "\u27F6",
    looparrowleft: "\u21AB",
    looparrowright: "\u21AC",
    lopar: "\u2985",
    Lopf: "\u{1D543}",
    lopf: "\u{1D55D}",
    loplus: "\u2A2D",
    lotimes: "\u2A34",
    lowast: "\u2217",
    lowbar: "_",
    LowerLeftArrow: "\u2199",
    LowerRightArrow: "\u2198",
    loz: "\u25CA",
    lozenge: "\u25CA",
    lozf: "\u29EB",
    lpar: "(",
    lparlt: "\u2993",
    lrarr: "\u21C6",
    lrcorner: "\u231F",
    lrhar: "\u21CB",
    lrhard: "\u296D",
    lrm: "\u200E",
    lrtri: "\u22BF",
    lsaquo: "\u2039",
    Lscr: "\u2112",
    lscr: "\u{1D4C1}",
    Lsh: "\u21B0",
    lsh: "\u21B0",
    lsim: "\u2272",
    lsime: "\u2A8D",
    lsimg: "\u2A8F",
    lsqb: "[",
    lsquo: "\u2018",
    lsquor: "\u201A",
    Lstrok: "\u0141",
    lstrok: "\u0142",
    LT: "<",
    Lt: "\u226A",
    lt: "<",
    ltcc: "\u2AA6",
    ltcir: "\u2A79",
    ltdot: "\u22D6",
    lthree: "\u22CB",
    ltimes: "\u22C9",
    ltlarr: "\u2976",
    ltquest: "\u2A7B",
    ltri: "\u25C3",
    ltrie: "\u22B4",
    ltrif: "\u25C2",
    ltrPar: "\u2996",
    lurdshar: "\u294A",
    luruhar: "\u2966",
    lvertneqq: "\u2268\uFE00",
    lvnE: "\u2268\uFE00",
    macr: "\xAF",
    male: "\u2642",
    malt: "\u2720",
    maltese: "\u2720",
    Map: "\u2905",
    map: "\u21A6",
    mapsto: "\u21A6",
    mapstodown: "\u21A7",
    mapstoleft: "\u21A4",
    mapstoup: "\u21A5",
    marker: "\u25AE",
    mcomma: "\u2A29",
    Mcy: "\u041C",
    mcy: "\u043C",
    mdash: "\u2014",
    mDDot: "\u223A",
    measuredangle: "\u2221",
    MediumSpace: "\u205F",
    Mellintrf: "\u2133",
    Mfr: "\u{1D510}",
    mfr: "\u{1D52A}",
    mho: "\u2127",
    micro: "\xB5",
    mid: "\u2223",
    midast: "*",
    midcir: "\u2AF0",
    middot: "\xB7",
    minus: "\u2212",
    minusb: "\u229F",
    minusd: "\u2238",
    minusdu: "\u2A2A",
    MinusPlus: "\u2213",
    mlcp: "\u2ADB",
    mldr: "\u2026",
    mnplus: "\u2213",
    models: "\u22A7",
    Mopf: "\u{1D544}",
    mopf: "\u{1D55E}",
    mp: "\u2213",
    Mscr: "\u2133",
    mscr: "\u{1D4C2}",
    mstpos: "\u223E",
    Mu: "\u039C",
    mu: "\u03BC",
    multimap: "\u22B8",
    mumap: "\u22B8",
    nabla: "\u2207",
    Nacute: "\u0143",
    nacute: "\u0144",
    nang: "\u2220\u20D2",
    nap: "\u2249",
    napE: "\u2A70\u0338",
    napid: "\u224B\u0338",
    napos: "\u0149",
    napprox: "\u2249",
    natur: "\u266E",
    natural: "\u266E",
    naturals: "\u2115",
    nbsp: "\xA0",
    nbump: "\u224E\u0338",
    nbumpe: "\u224F\u0338",
    ncap: "\u2A43",
    Ncaron: "\u0147",
    ncaron: "\u0148",
    Ncedil: "\u0145",
    ncedil: "\u0146",
    ncong: "\u2247",
    ncongdot: "\u2A6D\u0338",
    ncup: "\u2A42",
    Ncy: "\u041D",
    ncy: "\u043D",
    ndash: "\u2013",
    ne: "\u2260",
    nearhk: "\u2924",
    neArr: "\u21D7",
    nearr: "\u2197",
    nearrow: "\u2197",
    nedot: "\u2250\u0338",
    NegativeMediumSpace: "\u200B",
    NegativeThickSpace: "\u200B",
    NegativeThinSpace: "\u200B",
    NegativeVeryThinSpace: "\u200B",
    nequiv: "\u2262",
    nesear: "\u2928",
    nesim: "\u2242\u0338",
    NestedGreaterGreater: "\u226B",
    NestedLessLess: "\u226A",
    NewLine: "\n",
    nexist: "\u2204",
    nexists: "\u2204",
    Nfr: "\u{1D511}",
    nfr: "\u{1D52B}",
    ngE: "\u2267\u0338",
    nge: "\u2271",
    ngeq: "\u2271",
    ngeqq: "\u2267\u0338",
    ngeqslant: "\u2A7E\u0338",
    nges: "\u2A7E\u0338",
    nGg: "\u22D9\u0338",
    ngsim: "\u2275",
    nGt: "\u226B\u20D2",
    ngt: "\u226F",
    ngtr: "\u226F",
    nGtv: "\u226B\u0338",
    nhArr: "\u21CE",
    nharr: "\u21AE",
    nhpar: "\u2AF2",
    ni: "\u220B",
    nis: "\u22FC",
    nisd: "\u22FA",
    niv: "\u220B",
    NJcy: "\u040A",
    njcy: "\u045A",
    nlArr: "\u21CD",
    nlarr: "\u219A",
    nldr: "\u2025",
    nlE: "\u2266\u0338",
    nle: "\u2270",
    nLeftarrow: "\u21CD",
    nleftarrow: "\u219A",
    nLeftrightarrow: "\u21CE",
    nleftrightarrow: "\u21AE",
    nleq: "\u2270",
    nleqq: "\u2266\u0338",
    nleqslant: "\u2A7D\u0338",
    nles: "\u2A7D\u0338",
    nless: "\u226E",
    nLl: "\u22D8\u0338",
    nlsim: "\u2274",
    nLt: "\u226A\u20D2",
    nlt: "\u226E",
    nltri: "\u22EA",
    nltrie: "\u22EC",
    nLtv: "\u226A\u0338",
    nmid: "\u2224",
    NoBreak: "\u2060",
    NonBreakingSpace: "\xA0",
    Nopf: "\u2115",
    nopf: "\u{1D55F}",
    Not: "\u2AEC",
    not: "\xAC",
    NotCongruent: "\u2262",
    NotCupCap: "\u226D",
    NotDoubleVerticalBar: "\u2226",
    NotElement: "\u2209",
    NotEqual: "\u2260",
    NotEqualTilde: "\u2242\u0338",
    NotExists: "\u2204",
    NotGreater: "\u226F",
    NotGreaterEqual: "\u2271",
    NotGreaterFullEqual: "\u2267\u0338",
    NotGreaterGreater: "\u226B\u0338",
    NotGreaterLess: "\u2279",
    NotGreaterSlantEqual: "\u2A7E\u0338",
    NotGreaterTilde: "\u2275",
    NotHumpDownHump: "\u224E\u0338",
    NotHumpEqual: "\u224F\u0338",
    notin: "\u2209",
    notindot: "\u22F5\u0338",
    notinE: "\u22F9\u0338",
    notinva: "\u2209",
    notinvb: "\u22F7",
    notinvc: "\u22F6",
    NotLeftTriangle: "\u22EA",
    NotLeftTriangleBar: "\u29CF\u0338",
    NotLeftTriangleEqual: "\u22EC",
    NotLess: "\u226E",
    NotLessEqual: "\u2270",
    NotLessGreater: "\u2278",
    NotLessLess: "\u226A\u0338",
    NotLessSlantEqual: "\u2A7D\u0338",
    NotLessTilde: "\u2274",
    NotNestedGreaterGreater: "\u2AA2\u0338",
    NotNestedLessLess: "\u2AA1\u0338",
    notni: "\u220C",
    notniva: "\u220C",
    notnivb: "\u22FE",
    notnivc: "\u22FD",
    NotPrecedes: "\u2280",
    NotPrecedesEqual: "\u2AAF\u0338",
    NotPrecedesSlantEqual: "\u22E0",
    NotReverseElement: "\u220C",
    NotRightTriangle: "\u22EB",
    NotRightTriangleBar: "\u29D0\u0338",
    NotRightTriangleEqual: "\u22ED",
    NotSquareSubset: "\u228F\u0338",
    NotSquareSubsetEqual: "\u22E2",
    NotSquareSuperset: "\u2290\u0338",
    NotSquareSupersetEqual: "\u22E3",
    NotSubset: "\u2282\u20D2",
    NotSubsetEqual: "\u2288",
    NotSucceeds: "\u2281",
    NotSucceedsEqual: "\u2AB0\u0338",
    NotSucceedsSlantEqual: "\u22E1",
    NotSucceedsTilde: "\u227F\u0338",
    NotSuperset: "\u2283\u20D2",
    NotSupersetEqual: "\u2289",
    NotTilde: "\u2241",
    NotTildeEqual: "\u2244",
    NotTildeFullEqual: "\u2247",
    NotTildeTilde: "\u2249",
    NotVerticalBar: "\u2224",
    npar: "\u2226",
    nparallel: "\u2226",
    nparsl: "\u2AFD\u20E5",
    npart: "\u2202\u0338",
    npolint: "\u2A14",
    npr: "\u2280",
    nprcue: "\u22E0",
    npre: "\u2AAF\u0338",
    nprec: "\u2280",
    npreceq: "\u2AAF\u0338",
    nrArr: "\u21CF",
    nrarr: "\u219B",
    nrarrc: "\u2933\u0338",
    nrarrw: "\u219D\u0338",
    nRightarrow: "\u21CF",
    nrightarrow: "\u219B",
    nrtri: "\u22EB",
    nrtrie: "\u22ED",
    nsc: "\u2281",
    nsccue: "\u22E1",
    nsce: "\u2AB0\u0338",
    Nscr: "\u{1D4A9}",
    nscr: "\u{1D4C3}",
    nshortmid: "\u2224",
    nshortparallel: "\u2226",
    nsim: "\u2241",
    nsime: "\u2244",
    nsimeq: "\u2244",
    nsmid: "\u2224",
    nspar: "\u2226",
    nsqsube: "\u22E2",
    nsqsupe: "\u22E3",
    nsub: "\u2284",
    nsubE: "\u2AC5\u0338",
    nsube: "\u2288",
    nsubset: "\u2282\u20D2",
    nsubseteq: "\u2288",
    nsubseteqq: "\u2AC5\u0338",
    nsucc: "\u2281",
    nsucceq: "\u2AB0\u0338",
    nsup: "\u2285",
    nsupE: "\u2AC6\u0338",
    nsupe: "\u2289",
    nsupset: "\u2283\u20D2",
    nsupseteq: "\u2289",
    nsupseteqq: "\u2AC6\u0338",
    ntgl: "\u2279",
    Ntilde: "\xD1",
    ntilde: "\xF1",
    ntlg: "\u2278",
    ntriangleleft: "\u22EA",
    ntrianglelefteq: "\u22EC",
    ntriangleright: "\u22EB",
    ntrianglerighteq: "\u22ED",
    Nu: "\u039D",
    nu: "\u03BD",
    num: "#",
    numero: "\u2116",
    numsp: "\u2007",
    nvap: "\u224D\u20D2",
    nVDash: "\u22AF",
    nVdash: "\u22AE",
    nvDash: "\u22AD",
    nvdash: "\u22AC",
    nvge: "\u2265\u20D2",
    nvgt: ">\u20D2",
    nvHarr: "\u2904",
    nvinfin: "\u29DE",
    nvlArr: "\u2902",
    nvle: "\u2264\u20D2",
    nvlt: "<\u20D2",
    nvltrie: "\u22B4\u20D2",
    nvrArr: "\u2903",
    nvrtrie: "\u22B5\u20D2",
    nvsim: "\u223C\u20D2",
    nwarhk: "\u2923",
    nwArr: "\u21D6",
    nwarr: "\u2196",
    nwarrow: "\u2196",
    nwnear: "\u2927",
    Oacute: "\xD3",
    oacute: "\xF3",
    oast: "\u229B",
    ocir: "\u229A",
    Ocirc: "\xD4",
    ocirc: "\xF4",
    Ocy: "\u041E",
    ocy: "\u043E",
    odash: "\u229D",
    Odblac: "\u0150",
    odblac: "\u0151",
    odiv: "\u2A38",
    odot: "\u2299",
    odsold: "\u29BC",
    OElig: "\u0152",
    oelig: "\u0153",
    ofcir: "\u29BF",
    Ofr: "\u{1D512}",
    ofr: "\u{1D52C}",
    ogon: "\u02DB",
    Ograve: "\xD2",
    ograve: "\xF2",
    ogt: "\u29C1",
    ohbar: "\u29B5",
    ohm: "\u03A9",
    oint: "\u222E",
    olarr: "\u21BA",
    olcir: "\u29BE",
    olcross: "\u29BB",
    oline: "\u203E",
    olt: "\u29C0",
    Omacr: "\u014C",
    omacr: "\u014D",
    Omega: "\u03A9",
    omega: "\u03C9",
    Omicron: "\u039F",
    omicron: "\u03BF",
    omid: "\u29B6",
    ominus: "\u2296",
    Oopf: "\u{1D546}",
    oopf: "\u{1D560}",
    opar: "\u29B7",
    OpenCurlyDoubleQuote: "\u201C",
    OpenCurlyQuote: "\u2018",
    operp: "\u29B9",
    oplus: "\u2295",
    Or: "\u2A54",
    or: "\u2228",
    orarr: "\u21BB",
    ord: "\u2A5D",
    order: "\u2134",
    orderof: "\u2134",
    ordf: "\xAA",
    ordm: "\xBA",
    origof: "\u22B6",
    oror: "\u2A56",
    orslope: "\u2A57",
    orv: "\u2A5B",
    oS: "\u24C8",
    Oscr: "\u{1D4AA}",
    oscr: "\u2134",
    Oslash: "\xD8",
    oslash: "\xF8",
    osol: "\u2298",
    Otilde: "\xD5",
    otilde: "\xF5",
    Otimes: "\u2A37",
    otimes: "\u2297",
    otimesas: "\u2A36",
    Ouml: "\xD6",
    ouml: "\xF6",
    ovbar: "\u233D",
    OverBar: "\u203E",
    OverBrace: "\u23DE",
    OverBracket: "\u23B4",
    OverParenthesis: "\u23DC",
    par: "\u2225",
    para: "\xB6",
    parallel: "\u2225",
    parsim: "\u2AF3",
    parsl: "\u2AFD",
    part: "\u2202",
    PartialD: "\u2202",
    Pcy: "\u041F",
    pcy: "\u043F",
    percnt: "%",
    period: ".",
    permil: "\u2030",
    perp: "\u22A5",
    pertenk: "\u2031",
    Pfr: "\u{1D513}",
    pfr: "\u{1D52D}",
    Phi: "\u03A6",
    phi: "\u03C6",
    phiv: "\u03D5",
    phmmat: "\u2133",
    phone: "\u260E",
    Pi: "\u03A0",
    pi: "\u03C0",
    pitchfork: "\u22D4",
    piv: "\u03D6",
    planck: "\u210F",
    planckh: "\u210E",
    plankv: "\u210F",
    plus: "+",
    plusacir: "\u2A23",
    plusb: "\u229E",
    pluscir: "\u2A22",
    plusdo: "\u2214",
    plusdu: "\u2A25",
    pluse: "\u2A72",
    PlusMinus: "\xB1",
    plusmn: "\xB1",
    plussim: "\u2A26",
    plustwo: "\u2A27",
    pm: "\xB1",
    Poincareplane: "\u210C",
    pointint: "\u2A15",
    Popf: "\u2119",
    popf: "\u{1D561}",
    pound: "\xA3",
    Pr: "\u2ABB",
    pr: "\u227A",
    prap: "\u2AB7",
    prcue: "\u227C",
    prE: "\u2AB3",
    pre: "\u2AAF",
    prec: "\u227A",
    precapprox: "\u2AB7",
    preccurlyeq: "\u227C",
    Precedes: "\u227A",
    PrecedesEqual: "\u2AAF",
    PrecedesSlantEqual: "\u227C",
    PrecedesTilde: "\u227E",
    preceq: "\u2AAF",
    precnapprox: "\u2AB9",
    precneqq: "\u2AB5",
    precnsim: "\u22E8",
    precsim: "\u227E",
    Prime: "\u2033",
    prime: "\u2032",
    primes: "\u2119",
    prnap: "\u2AB9",
    prnE: "\u2AB5",
    prnsim: "\u22E8",
    prod: "\u220F",
    Product: "\u220F",
    profalar: "\u232E",
    profline: "\u2312",
    profsurf: "\u2313",
    prop: "\u221D",
    Proportion: "\u2237",
    Proportional: "\u221D",
    propto: "\u221D",
    prsim: "\u227E",
    prurel: "\u22B0",
    Pscr: "\u{1D4AB}",
    pscr: "\u{1D4C5}",
    Psi: "\u03A8",
    psi: "\u03C8",
    puncsp: "\u2008",
    Qfr: "\u{1D514}",
    qfr: "\u{1D52E}",
    qint: "\u2A0C",
    Qopf: "\u211A",
    qopf: "\u{1D562}",
    qprime: "\u2057",
    Qscr: "\u{1D4AC}",
    qscr: "\u{1D4C6}",
    quaternions: "\u210D",
    quatint: "\u2A16",
    quest: "?",
    questeq: "\u225F",
    QUOT: '"',
    quot: '"',
    rAarr: "\u21DB",
    race: "\u223D\u0331",
    Racute: "\u0154",
    racute: "\u0155",
    radic: "\u221A",
    raemptyv: "\u29B3",
    Rang: "\u27EB",
    rang: "\u27E9",
    rangd: "\u2992",
    range: "\u29A5",
    rangle: "\u27E9",
    raquo: "\xBB",
    Rarr: "\u21A0",
    rArr: "\u21D2",
    rarr: "\u2192",
    rarrap: "\u2975",
    rarrb: "\u21E5",
    rarrbfs: "\u2920",
    rarrc: "\u2933",
    rarrfs: "\u291E",
    rarrhk: "\u21AA",
    rarrlp: "\u21AC",
    rarrpl: "\u2945",
    rarrsim: "\u2974",
    Rarrtl: "\u2916",
    rarrtl: "\u21A3",
    rarrw: "\u219D",
    rAtail: "\u291C",
    ratail: "\u291A",
    ratio: "\u2236",
    rationals: "\u211A",
    RBarr: "\u2910",
    rBarr: "\u290F",
    rbarr: "\u290D",
    rbbrk: "\u2773",
    rbrace: "}",
    rbrack: "]",
    rbrke: "\u298C",
    rbrksld: "\u298E",
    rbrkslu: "\u2990",
    Rcaron: "\u0158",
    rcaron: "\u0159",
    Rcedil: "\u0156",
    rcedil: "\u0157",
    rceil: "\u2309",
    rcub: "}",
    Rcy: "\u0420",
    rcy: "\u0440",
    rdca: "\u2937",
    rdldhar: "\u2969",
    rdquo: "\u201D",
    rdquor: "\u201D",
    rdsh: "\u21B3",
    Re: "\u211C",
    real: "\u211C",
    realine: "\u211B",
    realpart: "\u211C",
    reals: "\u211D",
    rect: "\u25AD",
    REG: "\xAE",
    reg: "\xAE",
    ReverseElement: "\u220B",
    ReverseEquilibrium: "\u21CB",
    ReverseUpEquilibrium: "\u296F",
    rfisht: "\u297D",
    rfloor: "\u230B",
    Rfr: "\u211C",
    rfr: "\u{1D52F}",
    rHar: "\u2964",
    rhard: "\u21C1",
    rharu: "\u21C0",
    rharul: "\u296C",
    Rho: "\u03A1",
    rho: "\u03C1",
    rhov: "\u03F1",
    RightAngleBracket: "\u27E9",
    RightArrow: "\u2192",
    Rightarrow: "\u21D2",
    rightarrow: "\u2192",
    RightArrowBar: "\u21E5",
    RightArrowLeftArrow: "\u21C4",
    rightarrowtail: "\u21A3",
    RightCeiling: "\u2309",
    RightDoubleBracket: "\u27E7",
    RightDownTeeVector: "\u295D",
    RightDownVector: "\u21C2",
    RightDownVectorBar: "\u2955",
    RightFloor: "\u230B",
    rightharpoondown: "\u21C1",
    rightharpoonup: "\u21C0",
    rightleftarrows: "\u21C4",
    rightleftharpoons: "\u21CC",
    rightrightarrows: "\u21C9",
    rightsquigarrow: "\u219D",
    RightTee: "\u22A2",
    RightTeeArrow: "\u21A6",
    RightTeeVector: "\u295B",
    rightthreetimes: "\u22CC",
    RightTriangle: "\u22B3",
    RightTriangleBar: "\u29D0",
    RightTriangleEqual: "\u22B5",
    RightUpDownVector: "\u294F",
    RightUpTeeVector: "\u295C",
    RightUpVector: "\u21BE",
    RightUpVectorBar: "\u2954",
    RightVector: "\u21C0",
    RightVectorBar: "\u2953",
    ring: "\u02DA",
    risingdotseq: "\u2253",
    rlarr: "\u21C4",
    rlhar: "\u21CC",
    rlm: "\u200F",
    rmoust: "\u23B1",
    rmoustache: "\u23B1",
    rnmid: "\u2AEE",
    roang: "\u27ED",
    roarr: "\u21FE",
    robrk: "\u27E7",
    ropar: "\u2986",
    Ropf: "\u211D",
    ropf: "\u{1D563}",
    roplus: "\u2A2E",
    rotimes: "\u2A35",
    RoundImplies: "\u2970",
    rpar: ")",
    rpargt: "\u2994",
    rppolint: "\u2A12",
    rrarr: "\u21C9",
    Rrightarrow: "\u21DB",
    rsaquo: "\u203A",
    Rscr: "\u211B",
    rscr: "\u{1D4C7}",
    Rsh: "\u21B1",
    rsh: "\u21B1",
    rsqb: "]",
    rsquo: "\u2019",
    rsquor: "\u2019",
    rthree: "\u22CC",
    rtimes: "\u22CA",
    rtri: "\u25B9",
    rtrie: "\u22B5",
    rtrif: "\u25B8",
    rtriltri: "\u29CE",
    RuleDelayed: "\u29F4",
    ruluhar: "\u2968",
    rx: "\u211E",
    Sacute: "\u015A",
    sacute: "\u015B",
    sbquo: "\u201A",
    Sc: "\u2ABC",
    sc: "\u227B",
    scap: "\u2AB8",
    Scaron: "\u0160",
    scaron: "\u0161",
    sccue: "\u227D",
    scE: "\u2AB4",
    sce: "\u2AB0",
    Scedil: "\u015E",
    scedil: "\u015F",
    Scirc: "\u015C",
    scirc: "\u015D",
    scnap: "\u2ABA",
    scnE: "\u2AB6",
    scnsim: "\u22E9",
    scpolint: "\u2A13",
    scsim: "\u227F",
    Scy: "\u0421",
    scy: "\u0441",
    sdot: "\u22C5",
    sdotb: "\u22A1",
    sdote: "\u2A66",
    searhk: "\u2925",
    seArr: "\u21D8",
    searr: "\u2198",
    searrow: "\u2198",
    sect: "\xA7",
    semi: ";",
    seswar: "\u2929",
    setminus: "\u2216",
    setmn: "\u2216",
    sext: "\u2736",
    Sfr: "\u{1D516}",
    sfr: "\u{1D530}",
    sfrown: "\u2322",
    sharp: "\u266F",
    SHCHcy: "\u0429",
    shchcy: "\u0449",
    SHcy: "\u0428",
    shcy: "\u0448",
    ShortDownArrow: "\u2193",
    ShortLeftArrow: "\u2190",
    shortmid: "\u2223",
    shortparallel: "\u2225",
    ShortRightArrow: "\u2192",
    ShortUpArrow: "\u2191",
    shy: "\xAD",
    Sigma: "\u03A3",
    sigma: "\u03C3",
    sigmaf: "\u03C2",
    sigmav: "\u03C2",
    sim: "\u223C",
    simdot: "\u2A6A",
    sime: "\u2243",
    simeq: "\u2243",
    simg: "\u2A9E",
    simgE: "\u2AA0",
    siml: "\u2A9D",
    simlE: "\u2A9F",
    simne: "\u2246",
    simplus: "\u2A24",
    simrarr: "\u2972",
    slarr: "\u2190",
    SmallCircle: "\u2218",
    smallsetminus: "\u2216",
    smashp: "\u2A33",
    smeparsl: "\u29E4",
    smid: "\u2223",
    smile: "\u2323",
    smt: "\u2AAA",
    smte: "\u2AAC",
    smtes: "\u2AAC\uFE00",
    SOFTcy: "\u042C",
    softcy: "\u044C",
    sol: "/",
    solb: "\u29C4",
    solbar: "\u233F",
    Sopf: "\u{1D54A}",
    sopf: "\u{1D564}",
    spades: "\u2660",
    spadesuit: "\u2660",
    spar: "\u2225",
    sqcap: "\u2293",
    sqcaps: "\u2293\uFE00",
    sqcup: "\u2294",
    sqcups: "\u2294\uFE00",
    Sqrt: "\u221A",
    sqsub: "\u228F",
    sqsube: "\u2291",
    sqsubset: "\u228F",
    sqsubseteq: "\u2291",
    sqsup: "\u2290",
    sqsupe: "\u2292",
    sqsupset: "\u2290",
    sqsupseteq: "\u2292",
    squ: "\u25A1",
    Square: "\u25A1",
    square: "\u25A1",
    SquareIntersection: "\u2293",
    SquareSubset: "\u228F",
    SquareSubsetEqual: "\u2291",
    SquareSuperset: "\u2290",
    SquareSupersetEqual: "\u2292",
    SquareUnion: "\u2294",
    squarf: "\u25AA",
    squf: "\u25AA",
    srarr: "\u2192",
    Sscr: "\u{1D4AE}",
    sscr: "\u{1D4C8}",
    ssetmn: "\u2216",
    ssmile: "\u2323",
    sstarf: "\u22C6",
    Star: "\u22C6",
    star: "\u2606",
    starf: "\u2605",
    straightepsilon: "\u03F5",
    straightphi: "\u03D5",
    strns: "\xAF",
    Sub: "\u22D0",
    sub: "\u2282",
    subdot: "\u2ABD",
    subE: "\u2AC5",
    sube: "\u2286",
    subedot: "\u2AC3",
    submult: "\u2AC1",
    subnE: "\u2ACB",
    subne: "\u228A",
    subplus: "\u2ABF",
    subrarr: "\u2979",
    Subset: "\u22D0",
    subset: "\u2282",
    subseteq: "\u2286",
    subseteqq: "\u2AC5",
    SubsetEqual: "\u2286",
    subsetneq: "\u228A",
    subsetneqq: "\u2ACB",
    subsim: "\u2AC7",
    subsub: "\u2AD5",
    subsup: "\u2AD3",
    succ: "\u227B",
    succapprox: "\u2AB8",
    succcurlyeq: "\u227D",
    Succeeds: "\u227B",
    SucceedsEqual: "\u2AB0",
    SucceedsSlantEqual: "\u227D",
    SucceedsTilde: "\u227F",
    succeq: "\u2AB0",
    succnapprox: "\u2ABA",
    succneqq: "\u2AB6",
    succnsim: "\u22E9",
    succsim: "\u227F",
    SuchThat: "\u220B",
    Sum: "\u2211",
    sum: "\u2211",
    sung: "\u266A",
    Sup: "\u22D1",
    sup: "\u2283",
    sup1: "\xB9",
    sup2: "\xB2",
    sup3: "\xB3",
    supdot: "\u2ABE",
    supdsub: "\u2AD8",
    supE: "\u2AC6",
    supe: "\u2287",
    supedot: "\u2AC4",
    Superset: "\u2283",
    SupersetEqual: "\u2287",
    suphsol: "\u27C9",
    suphsub: "\u2AD7",
    suplarr: "\u297B",
    supmult: "\u2AC2",
    supnE: "\u2ACC",
    supne: "\u228B",
    supplus: "\u2AC0",
    Supset: "\u22D1",
    supset: "\u2283",
    supseteq: "\u2287",
    supseteqq: "\u2AC6",
    supsetneq: "\u228B",
    supsetneqq: "\u2ACC",
    supsim: "\u2AC8",
    supsub: "\u2AD4",
    supsup: "\u2AD6",
    swarhk: "\u2926",
    swArr: "\u21D9",
    swarr: "\u2199",
    swarrow: "\u2199",
    swnwar: "\u292A",
    szlig: "\xDF",
    Tab: "	",
    target: "\u2316",
    Tau: "\u03A4",
    tau: "\u03C4",
    tbrk: "\u23B4",
    Tcaron: "\u0164",
    tcaron: "\u0165",
    Tcedil: "\u0162",
    tcedil: "\u0163",
    Tcy: "\u0422",
    tcy: "\u0442",
    tdot: "\u20DB",
    telrec: "\u2315",
    Tfr: "\u{1D517}",
    tfr: "\u{1D531}",
    there4: "\u2234",
    Therefore: "\u2234",
    therefore: "\u2234",
    Theta: "\u0398",
    theta: "\u03B8",
    thetasym: "\u03D1",
    thetav: "\u03D1",
    thickapprox: "\u2248",
    thicksim: "\u223C",
    ThickSpace: "\u205F\u200A",
    thinsp: "\u2009",
    ThinSpace: "\u2009",
    thkap: "\u2248",
    thksim: "\u223C",
    THORN: "\xDE",
    thorn: "\xFE",
    Tilde: "\u223C",
    tilde: "\u02DC",
    TildeEqual: "\u2243",
    TildeFullEqual: "\u2245",
    TildeTilde: "\u2248",
    times: "\xD7",
    timesb: "\u22A0",
    timesbar: "\u2A31",
    timesd: "\u2A30",
    tint: "\u222D",
    toea: "\u2928",
    top: "\u22A4",
    topbot: "\u2336",
    topcir: "\u2AF1",
    Topf: "\u{1D54B}",
    topf: "\u{1D565}",
    topfork: "\u2ADA",
    tosa: "\u2929",
    tprime: "\u2034",
    TRADE: "\u2122",
    trade: "\u2122",
    triangle: "\u25B5",
    triangledown: "\u25BF",
    triangleleft: "\u25C3",
    trianglelefteq: "\u22B4",
    triangleq: "\u225C",
    triangleright: "\u25B9",
    trianglerighteq: "\u22B5",
    tridot: "\u25EC",
    trie: "\u225C",
    triminus: "\u2A3A",
    TripleDot: "\u20DB",
    triplus: "\u2A39",
    trisb: "\u29CD",
    tritime: "\u2A3B",
    trpezium: "\u23E2",
    Tscr: "\u{1D4AF}",
    tscr: "\u{1D4C9}",
    TScy: "\u0426",
    tscy: "\u0446",
    TSHcy: "\u040B",
    tshcy: "\u045B",
    Tstrok: "\u0166",
    tstrok: "\u0167",
    twixt: "\u226C",
    twoheadleftarrow: "\u219E",
    twoheadrightarrow: "\u21A0",
    Uacute: "\xDA",
    uacute: "\xFA",
    Uarr: "\u219F",
    uArr: "\u21D1",
    uarr: "\u2191",
    Uarrocir: "\u2949",
    Ubrcy: "\u040E",
    ubrcy: "\u045E",
    Ubreve: "\u016C",
    ubreve: "\u016D",
    Ucirc: "\xDB",
    ucirc: "\xFB",
    Ucy: "\u0423",
    ucy: "\u0443",
    udarr: "\u21C5",
    Udblac: "\u0170",
    udblac: "\u0171",
    udhar: "\u296E",
    ufisht: "\u297E",
    Ufr: "\u{1D518}",
    ufr: "\u{1D532}",
    Ugrave: "\xD9",
    ugrave: "\xF9",
    uHar: "\u2963",
    uharl: "\u21BF",
    uharr: "\u21BE",
    uhblk: "\u2580",
    ulcorn: "\u231C",
    ulcorner: "\u231C",
    ulcrop: "\u230F",
    ultri: "\u25F8",
    Umacr: "\u016A",
    umacr: "\u016B",
    uml: "\xA8",
    UnderBar: "_",
    UnderBrace: "\u23DF",
    UnderBracket: "\u23B5",
    UnderParenthesis: "\u23DD",
    Union: "\u22C3",
    UnionPlus: "\u228E",
    Uogon: "\u0172",
    uogon: "\u0173",
    Uopf: "\u{1D54C}",
    uopf: "\u{1D566}",
    UpArrow: "\u2191",
    Uparrow: "\u21D1",
    uparrow: "\u2191",
    UpArrowBar: "\u2912",
    UpArrowDownArrow: "\u21C5",
    UpDownArrow: "\u2195",
    Updownarrow: "\u21D5",
    updownarrow: "\u2195",
    UpEquilibrium: "\u296E",
    upharpoonleft: "\u21BF",
    upharpoonright: "\u21BE",
    uplus: "\u228E",
    UpperLeftArrow: "\u2196",
    UpperRightArrow: "\u2197",
    Upsi: "\u03D2",
    upsi: "\u03C5",
    upsih: "\u03D2",
    Upsilon: "\u03A5",
    upsilon: "\u03C5",
    UpTee: "\u22A5",
    UpTeeArrow: "\u21A5",
    upuparrows: "\u21C8",
    urcorn: "\u231D",
    urcorner: "\u231D",
    urcrop: "\u230E",
    Uring: "\u016E",
    uring: "\u016F",
    urtri: "\u25F9",
    Uscr: "\u{1D4B0}",
    uscr: "\u{1D4CA}",
    utdot: "\u22F0",
    Utilde: "\u0168",
    utilde: "\u0169",
    utri: "\u25B5",
    utrif: "\u25B4",
    uuarr: "\u21C8",
    Uuml: "\xDC",
    uuml: "\xFC",
    uwangle: "\u29A7",
    vangrt: "\u299C",
    varepsilon: "\u03F5",
    varkappa: "\u03F0",
    varnothing: "\u2205",
    varphi: "\u03D5",
    varpi: "\u03D6",
    varpropto: "\u221D",
    vArr: "\u21D5",
    varr: "\u2195",
    varrho: "\u03F1",
    varsigma: "\u03C2",
    varsubsetneq: "\u228A\uFE00",
    varsubsetneqq: "\u2ACB\uFE00",
    varsupsetneq: "\u228B\uFE00",
    varsupsetneqq: "\u2ACC\uFE00",
    vartheta: "\u03D1",
    vartriangleleft: "\u22B2",
    vartriangleright: "\u22B3",
    Vbar: "\u2AEB",
    vBar: "\u2AE8",
    vBarv: "\u2AE9",
    Vcy: "\u0412",
    vcy: "\u0432",
    VDash: "\u22AB",
    Vdash: "\u22A9",
    vDash: "\u22A8",
    vdash: "\u22A2",
    Vdashl: "\u2AE6",
    Vee: "\u22C1",
    vee: "\u2228",
    veebar: "\u22BB",
    veeeq: "\u225A",
    vellip: "\u22EE",
    Verbar: "\u2016",
    verbar: "|",
    Vert: "\u2016",
    vert: "|",
    VerticalBar: "\u2223",
    VerticalLine: "|",
    VerticalSeparator: "\u2758",
    VerticalTilde: "\u2240",
    VeryThinSpace: "\u200A",
    Vfr: "\u{1D519}",
    vfr: "\u{1D533}",
    vltri: "\u22B2",
    vnsub: "\u2282\u20D2",
    vnsup: "\u2283\u20D2",
    Vopf: "\u{1D54D}",
    vopf: "\u{1D567}",
    vprop: "\u221D",
    vrtri: "\u22B3",
    Vscr: "\u{1D4B1}",
    vscr: "\u{1D4CB}",
    vsubnE: "\u2ACB\uFE00",
    vsubne: "\u228A\uFE00",
    vsupnE: "\u2ACC\uFE00",
    vsupne: "\u228B\uFE00",
    Vvdash: "\u22AA",
    vzigzag: "\u299A",
    Wcirc: "\u0174",
    wcirc: "\u0175",
    wedbar: "\u2A5F",
    Wedge: "\u22C0",
    wedge: "\u2227",
    wedgeq: "\u2259",
    weierp: "\u2118",
    Wfr: "\u{1D51A}",
    wfr: "\u{1D534}",
    Wopf: "\u{1D54E}",
    wopf: "\u{1D568}",
    wp: "\u2118",
    wr: "\u2240",
    wreath: "\u2240",
    Wscr: "\u{1D4B2}",
    wscr: "\u{1D4CC}",
    xcap: "\u22C2",
    xcirc: "\u25EF",
    xcup: "\u22C3",
    xdtri: "\u25BD",
    Xfr: "\u{1D51B}",
    xfr: "\u{1D535}",
    xhArr: "\u27FA",
    xharr: "\u27F7",
    Xi: "\u039E",
    xi: "\u03BE",
    xlArr: "\u27F8",
    xlarr: "\u27F5",
    xmap: "\u27FC",
    xnis: "\u22FB",
    xodot: "\u2A00",
    Xopf: "\u{1D54F}",
    xopf: "\u{1D569}",
    xoplus: "\u2A01",
    xotime: "\u2A02",
    xrArr: "\u27F9",
    xrarr: "\u27F6",
    Xscr: "\u{1D4B3}",
    xscr: "\u{1D4CD}",
    xsqcup: "\u2A06",
    xuplus: "\u2A04",
    xutri: "\u25B3",
    xvee: "\u22C1",
    xwedge: "\u22C0",
    Yacute: "\xDD",
    yacute: "\xFD",
    YAcy: "\u042F",
    yacy: "\u044F",
    Ycirc: "\u0176",
    ycirc: "\u0177",
    Ycy: "\u042B",
    ycy: "\u044B",
    yen: "\xA5",
    Yfr: "\u{1D51C}",
    yfr: "\u{1D536}",
    YIcy: "\u0407",
    yicy: "\u0457",
    Yopf: "\u{1D550}",
    yopf: "\u{1D56A}",
    Yscr: "\u{1D4B4}",
    yscr: "\u{1D4CE}",
    YUcy: "\u042E",
    yucy: "\u044E",
    Yuml: "\u0178",
    yuml: "\xFF",
    Zacute: "\u0179",
    zacute: "\u017A",
    Zcaron: "\u017D",
    zcaron: "\u017E",
    Zcy: "\u0417",
    zcy: "\u0437",
    Zdot: "\u017B",
    zdot: "\u017C",
    zeetrf: "\u2128",
    ZeroWidthSpace: "\u200B",
    Zeta: "\u0396",
    zeta: "\u03B6",
    Zfr: "\u2128",
    zfr: "\u{1D537}",
    ZHcy: "\u0416",
    zhcy: "\u0436",
    zigrarr: "\u21DD",
    Zopf: "\u2124",
    zopf: "\u{1D56B}",
    Zscr: "\u{1D4B5}",
    zscr: "\u{1D4CF}",
    zwj: "\u200D",
    zwnj: "\u200C"
};
var hasOwn = Object.prototype.hasOwnProperty;
function has(object, key) {
    return object ? hasOwn.call(object, key) : false;
}
function decodeEntity(name) {
    if (has(entities, name)) {
        return entities[name];
    } else {
        return name;
    }
}
var hasOwn$1 = Object.prototype.hasOwnProperty;
function has$1(object, key) {
    return object ? hasOwn$1.call(object, key) : false;
}
function assign(obj) {
    var sources = [].slice.call(arguments, 1);
    sources.forEach(function(source) {
        if (!source) {
            return;
        }
        if (typeof source !== "object") {
            throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
            obj[key] = source[key];
        });
    });
    return obj;
}
var UNESCAPE_MD_RE = /\\([\\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;
function unescapeMd(str) {
    if (str.indexOf("\\") < 0) {
        return str;
    }
    return str.replace(UNESCAPE_MD_RE, "$1");
}
function isValidEntityCode(c) {
    if (c >= 55296 && c <= 57343) {
        return false;
    }
    if (c >= 64976 && c <= 65007) {
        return false;
    }
    if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
    }
    if (c >= 0 && c <= 8) {
        return false;
    }
    if (c === 11) {
        return false;
    }
    if (c >= 14 && c <= 31) {
        return false;
    }
    if (c >= 127 && c <= 159) {
        return false;
    }
    if (c > 1114111) {
        return false;
    }
    return true;
}
function fromCodePoint(c) {
    if (c > 65535) {
        c -= 65536;
        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
    }
    return String.fromCharCode(c);
}
var NAMED_ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
function replaceEntityPattern(match, name) {
    var code2 = 0;
    var decoded = decodeEntity(name);
    if (name !== decoded) {
        return decoded;
    } else if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
        code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
        if (isValidEntityCode(code2)) {
            return fromCodePoint(code2);
        }
    }
    return match;
}
function replaceEntities(str) {
    if (str.indexOf("&") < 0) {
        return str;
    }
    return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);
}
var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
};
function replaceUnsafeChar(ch) {
    return HTML_REPLACEMENTS[ch];
}
function escapeHtml(str) {
    if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
    }
    return str;
}
var rules = {
};
rules.blockquote_open = function() {
    return "<blockquote>\n";
};
rules.blockquote_close = function(tokens, idx) {
    return "</blockquote>" + getBreak(tokens, idx);
};
rules.code = function(tokens, idx) {
    if (tokens[idx].block) {
        return "<pre><code>" + escapeHtml(tokens[idx].content) + "</code></pre>" + getBreak(tokens, idx);
    }
    return "<code>" + escapeHtml(tokens[idx].content) + "</code>";
};
rules.fence = function(tokens, idx, options, env, instance) {
    var token = tokens[idx];
    var langClass = "";
    var langPrefix = options.langPrefix;
    var langName = "", fences2, fenceName;
    var highlighted;
    if (token.params) {
        fences2 = token.params.split(/\s+/g);
        fenceName = fences2.join(" ");
        if (has$1(instance.rules.fence_custom, fences2[0])) {
            return instance.rules.fence_custom[fences2[0]](tokens, idx, options, env, instance);
        }
        langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));
        langClass = ' class="' + langPrefix + langName + '"';
    }
    if (options.highlight) {
        highlighted = options.highlight.apply(options.highlight, [
            token.content
        ].concat(fences2)) || escapeHtml(token.content);
    } else {
        highlighted = escapeHtml(token.content);
    }
    return "<pre><code" + langClass + ">" + highlighted + "</code></pre>" + getBreak(tokens, idx);
};
rules.fence_custom = {
};
rules.heading_open = function(tokens, idx) {
    return "<h" + tokens[idx].hLevel + ">";
};
rules.heading_close = function(tokens, idx) {
    return "</h" + tokens[idx].hLevel + ">\n";
};
rules.hr = function(tokens, idx, options) {
    return (options.xhtmlOut ? "<hr />" : "<hr>") + getBreak(tokens, idx);
};
rules.bullet_list_open = function() {
    return "<ul>\n";
};
rules.bullet_list_close = function(tokens, idx) {
    return "</ul>" + getBreak(tokens, idx);
};
rules.list_item_open = function() {
    return "<li>";
};
rules.list_item_close = function() {
    return "</li>\n";
};
rules.ordered_list_open = function(tokens, idx) {
    var token = tokens[idx];
    var order = token.order > 1 ? ' start="' + token.order + '"' : "";
    return "<ol" + order + ">\n";
};
rules.ordered_list_close = function(tokens, idx) {
    return "</ol>" + getBreak(tokens, idx);
};
rules.paragraph_open = function(tokens, idx) {
    return tokens[idx].tight ? "" : "<p>";
};
rules.paragraph_close = function(tokens, idx) {
    var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === "inline" && !tokens[idx - 1].content);
    return (tokens[idx].tight ? "" : "</p>") + (addBreak ? getBreak(tokens, idx) : "");
};
rules.link_open = function(tokens, idx, options) {
    var title = tokens[idx].title ? ' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"' : "";
    var target = options.linkTarget ? ' target="' + options.linkTarget + '"' : "";
    return '<a href="' + escapeHtml(tokens[idx].href) + '"' + title + target + ">";
};
rules.link_close = function() {
    return "</a>";
};
rules.image = function(tokens, idx, options) {
    var src = ' src="' + escapeHtml(tokens[idx].src) + '"';
    var title = tokens[idx].title ? ' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"' : "";
    var alt = ' alt="' + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : "") + '"';
    var suffix = options.xhtmlOut ? " /" : "";
    return "<img" + src + alt + title + suffix + ">";
};
rules.table_open = function() {
    return "<table>\n";
};
rules.table_close = function() {
    return "</table>\n";
};
rules.thead_open = function() {
    return "<thead>\n";
};
rules.thead_close = function() {
    return "</thead>\n";
};
rules.tbody_open = function() {
    return "<tbody>\n";
};
rules.tbody_close = function() {
    return "</tbody>\n";
};
rules.tr_open = function() {
    return "<tr>";
};
rules.tr_close = function() {
    return "</tr>\n";
};
rules.th_open = function(tokens, idx) {
    var token = tokens[idx];
    return "<th" + (token.align ? ' style="text-align:' + token.align + '"' : "") + ">";
};
rules.th_close = function() {
    return "</th>";
};
rules.td_open = function(tokens, idx) {
    var token = tokens[idx];
    return "<td" + (token.align ? ' style="text-align:' + token.align + '"' : "") + ">";
};
rules.td_close = function() {
    return "</td>";
};
rules.strong_open = function() {
    return "<strong>";
};
rules.strong_close = function() {
    return "</strong>";
};
rules.em_open = function() {
    return "<em>";
};
rules.em_close = function() {
    return "</em>";
};
rules.del_open = function() {
    return "<del>";
};
rules.del_close = function() {
    return "</del>";
};
rules.ins_open = function() {
    return "<ins>";
};
rules.ins_close = function() {
    return "</ins>";
};
rules.mark_open = function() {
    return "<mark>";
};
rules.mark_close = function() {
    return "</mark>";
};
rules.sub = function(tokens, idx) {
    return "<sub>" + escapeHtml(tokens[idx].content) + "</sub>";
};
rules.sup = function(tokens, idx) {
    return "<sup>" + escapeHtml(tokens[idx].content) + "</sup>";
};
rules.hardbreak = function(tokens, idx, options) {
    return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
rules.softbreak = function(tokens, idx, options) {
    return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
rules.text = function(tokens, idx) {
    return escapeHtml(tokens[idx].content);
};
rules.htmlblock = function(tokens, idx) {
    return tokens[idx].content;
};
rules.htmltag = function(tokens, idx) {
    return tokens[idx].content;
};
rules.abbr_open = function(tokens, idx) {
    return '<abbr title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '">';
};
rules.abbr_close = function() {
    return "</abbr>";
};
rules.footnote_ref = function(tokens, idx) {
    var n = Number(tokens[idx].id + 1).toString();
    var id = "fnref" + n;
    if (tokens[idx].subId > 0) {
        id += ":" + tokens[idx].subId;
    }
    return '<sup class="footnote-ref"><a href="#fn' + n + '" id="' + id + '">[' + n + "]</a></sup>";
};
rules.footnote_block_open = function(tokens, idx, options) {
    var hr2 = options.xhtmlOut ? '<hr class="footnotes-sep" />\n' : '<hr class="footnotes-sep">\n';
    return hr2 + '<section class="footnotes">\n<ol class="footnotes-list">\n';
};
rules.footnote_block_close = function() {
    return "</ol>\n</section>\n";
};
rules.footnote_open = function(tokens, idx) {
    var id = Number(tokens[idx].id + 1).toString();
    return '<li id="fn' + id + '"  class="footnote-item">';
};
rules.footnote_close = function() {
    return "</li>\n";
};
rules.footnote_anchor = function(tokens, idx) {
    var n = Number(tokens[idx].id + 1).toString();
    var id = "fnref" + n;
    if (tokens[idx].subId > 0) {
        id += ":" + tokens[idx].subId;
    }
    return ' <a href="#' + id + '" class="footnote-backref">\u21A9</a>';
};
rules.dl_open = function() {
    return "<dl>\n";
};
rules.dt_open = function() {
    return "<dt>";
};
rules.dd_open = function() {
    return "<dd>";
};
rules.dl_close = function() {
    return "</dl>\n";
};
rules.dt_close = function() {
    return "</dt>\n";
};
rules.dd_close = function() {
    return "</dd>\n";
};
function nextToken(tokens, idx) {
    if ((++idx) >= tokens.length - 2) {
        return idx;
    }
    if (tokens[idx].type === "paragraph_open" && tokens[idx].tight && tokens[idx + 1].type === "inline" && tokens[idx + 1].content.length === 0 && tokens[idx + 2].type === "paragraph_close" && tokens[idx + 2].tight) {
        return nextToken(tokens, idx + 2);
    }
    return idx;
}
var getBreak = rules.getBreak = function getBreak2(tokens, idx) {
    idx = nextToken(tokens, idx);
    if (idx < tokens.length && tokens[idx].type === "list_item_close") {
        return "";
    }
    return "\n";
};
function Renderer() {
    this.rules = assign({
    }, rules);
    this.getBreak = rules.getBreak;
}
Renderer.prototype.renderInline = function(tokens, options, env) {
    var _rules2 = this.rules;
    var len = tokens.length, i = 0;
    var result = "";
    while(len--){
        result += _rules2[tokens[i].type](tokens, i++, options, env, this);
    }
    return result;
};
Renderer.prototype.render = function(tokens, options, env) {
    var _rules2 = this.rules;
    var len = tokens.length, i = -1;
    var result = "";
    while((++i) < len){
        if (tokens[i].type === "inline") {
            result += this.renderInline(tokens[i].children, options, env);
        } else {
            result += _rules2[tokens[i].type](tokens, i, options, env, this);
        }
    }
    return result;
};
function Ruler() {
    this.__rules__ = [];
    this.__cache__ = null;
}
Ruler.prototype.__find__ = function(name) {
    var len = this.__rules__.length;
    var i = -1;
    while(len--){
        if (this.__rules__[++i].name === name) {
            return i;
        }
    }
    return -1;
};
Ruler.prototype.__compile__ = function() {
    var self = this;
    var chains = [
        ""
    ];
    self.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
            return;
        }
        rule.alt.forEach(function(altName) {
            if (chains.indexOf(altName) < 0) {
                chains.push(altName);
            }
        });
    });
    self.__cache__ = {
    };
    chains.forEach(function(chain) {
        self.__cache__[chain] = [];
        self.__rules__.forEach(function(rule) {
            if (!rule.enabled) {
                return;
            }
            if (chain && rule.alt.indexOf(chain) < 0) {
                return;
            }
            self.__cache__[chain].push(rule.fn);
        });
    });
};
Ruler.prototype.at = function(name, fn, options) {
    var idx = this.__find__(name);
    var opt = options || {
    };
    if (idx === -1) {
        throw new Error("Parser rule not found: " + name);
    }
    this.__rules__[idx].fn = fn;
    this.__rules__[idx].alt = opt.alt || [];
    this.__cache__ = null;
};
Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
    var idx = this.__find__(beforeName);
    var opt = options || {
    };
    if (idx === -1) {
        throw new Error("Parser rule not found: " + beforeName);
    }
    this.__rules__.splice(idx, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
    });
    this.__cache__ = null;
};
Ruler.prototype.after = function(afterName, ruleName, fn, options) {
    var idx = this.__find__(afterName);
    var opt = options || {
    };
    if (idx === -1) {
        throw new Error("Parser rule not found: " + afterName);
    }
    this.__rules__.splice(idx + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
    });
    this.__cache__ = null;
};
Ruler.prototype.push = function(ruleName, fn, options) {
    var opt = options || {
    };
    this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
    });
    this.__cache__ = null;
};
Ruler.prototype.enable = function(list2, strict) {
    list2 = !Array.isArray(list2) ? [
        list2
    ] : list2;
    if (strict) {
        this.__rules__.forEach(function(rule) {
            rule.enabled = false;
        });
    }
    list2.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
            throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = true;
    }, this);
    this.__cache__ = null;
};
Ruler.prototype.disable = function(list2) {
    list2 = !Array.isArray(list2) ? [
        list2
    ] : list2;
    list2.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
            throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = false;
    }, this);
    this.__cache__ = null;
};
Ruler.prototype.getRules = function(chainName) {
    if (this.__cache__ === null) {
        this.__compile__();
    }
    return this.__cache__[chainName] || [];
};
function block(state) {
    if (state.inlineMode) {
        state.tokens.push({
            type: "inline",
            content: state.src.replace(/\n/g, " ").trim(),
            level: 0,
            lines: [
                0,
                1
            ],
            children: []
        });
    } else {
        state.block.parse(state.src, state.options, state.env, state.tokens);
    }
}
function StateInline(src, parserInline, options, env, outTokens) {
    this.src = src;
    this.env = env;
    this.options = options;
    this.parser = parserInline;
    this.tokens = outTokens;
    this.pos = 0;
    this.posMax = this.src.length;
    this.level = 0;
    this.pending = "";
    this.pendingLevel = 0;
    this.cache = [];
    this.isInLabel = false;
    this.linkLevel = 0;
    this.linkContent = "";
    this.labelUnmatchedScopes = 0;
}
StateInline.prototype.pushPending = function() {
    this.tokens.push({
        type: "text",
        content: this.pending,
        level: this.pendingLevel
    });
    this.pending = "";
};
StateInline.prototype.push = function(token) {
    if (this.pending) {
        this.pushPending();
    }
    this.tokens.push(token);
    this.pendingLevel = this.level;
};
StateInline.prototype.cacheSet = function(key, val) {
    for(var i = this.cache.length; i <= key; i++){
        this.cache.push(0);
    }
    this.cache[key] = val;
};
StateInline.prototype.cacheGet = function(key) {
    return key < this.cache.length ? this.cache[key] : 0;
};
function parseLinkLabel(state, start) {
    var level, found, marker, labelEnd = -1, max = state.posMax, oldPos = state.pos, oldFlag = state.isInLabel;
    if (state.isInLabel) {
        return -1;
    }
    if (state.labelUnmatchedScopes) {
        state.labelUnmatchedScopes--;
        return -1;
    }
    state.pos = start + 1;
    state.isInLabel = true;
    level = 1;
    while(state.pos < max){
        marker = state.src.charCodeAt(state.pos);
        if (marker === 91) {
            level++;
        } else if (marker === 93) {
            level--;
            if (level === 0) {
                found = true;
                break;
            }
        }
        state.parser.skipToken(state);
    }
    if (found) {
        labelEnd = state.pos;
        state.labelUnmatchedScopes = 0;
    } else {
        state.labelUnmatchedScopes = level - 1;
    }
    state.pos = oldPos;
    state.isInLabel = oldFlag;
    return labelEnd;
}
function parseAbbr(str, parserInline, options, env) {
    var state, labelEnd, pos, max, label, title;
    if (str.charCodeAt(0) !== 42) {
        return -1;
    }
    if (str.charCodeAt(1) !== 91) {
        return -1;
    }
    if (str.indexOf("]:") === -1) {
        return -1;
    }
    state = new StateInline(str, parserInline, options, env, []);
    labelEnd = parseLinkLabel(state, 1);
    if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return -1;
    }
    max = state.posMax;
    for(pos = labelEnd + 2; pos < max; pos++){
        if (state.src.charCodeAt(pos) === 10) {
            break;
        }
    }
    label = str.slice(2, labelEnd);
    title = str.slice(labelEnd + 2, pos).trim();
    if (title.length === 0) {
        return -1;
    }
    if (!env.abbreviations) {
        env.abbreviations = {
        };
    }
    if (typeof env.abbreviations[":" + label] === "undefined") {
        env.abbreviations[":" + label] = title;
    }
    return pos;
}
function abbr(state) {
    var tokens = state.tokens, i, l, content, pos;
    if (state.inlineMode) {
        return;
    }
    for(i = 1, l = tokens.length - 1; i < l; i++){
        if (tokens[i - 1].type === "paragraph_open" && tokens[i].type === "inline" && tokens[i + 1].type === "paragraph_close") {
            content = tokens[i].content;
            while(content.length){
                pos = parseAbbr(content, state.inline, state.options, state.env);
                if (pos < 0) {
                    break;
                }
                content = content.slice(pos).trim();
            }
            tokens[i].content = content;
            if (!content.length) {
                tokens[i - 1].tight = true;
                tokens[i + 1].tight = true;
            }
        }
    }
}
function normalizeLink(url) {
    var normalized = replaceEntities(url);
    try {
        normalized = decodeURI(normalized);
    } catch (err) {
    }
    return encodeURI(normalized);
}
function parseLinkDestination(state, pos) {
    var code2, level, link, start = pos, max = state.posMax;
    if (state.src.charCodeAt(pos) === 60) {
        pos++;
        while(pos < max){
            code2 = state.src.charCodeAt(pos);
            if (code2 === 10) {
                return false;
            }
            if (code2 === 62) {
                link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));
                if (!state.parser.validateLink(link)) {
                    return false;
                }
                state.pos = pos + 1;
                state.linkContent = link;
                return true;
            }
            if (code2 === 92 && pos + 1 < max) {
                pos += 2;
                continue;
            }
            pos++;
        }
        return false;
    }
    level = 0;
    while(pos < max){
        code2 = state.src.charCodeAt(pos);
        if (code2 === 32) {
            break;
        }
        if (code2 < 32 || code2 === 127) {
            break;
        }
        if (code2 === 92 && pos + 1 < max) {
            pos += 2;
            continue;
        }
        if (code2 === 40) {
            level++;
            if (level > 1) {
                break;
            }
        }
        if (code2 === 41) {
            level--;
            if (level < 0) {
                break;
            }
        }
        pos++;
    }
    if (start === pos) {
        return false;
    }
    link = unescapeMd(state.src.slice(start, pos));
    if (!state.parser.validateLink(link)) {
        return false;
    }
    state.linkContent = link;
    state.pos = pos;
    return true;
}
function parseLinkTitle(state, pos) {
    var code2, start = pos, max = state.posMax, marker = state.src.charCodeAt(pos);
    if (marker !== 34 && marker !== 39 && marker !== 40) {
        return false;
    }
    pos++;
    if (marker === 40) {
        marker = 41;
    }
    while(pos < max){
        code2 = state.src.charCodeAt(pos);
        if (code2 === marker) {
            state.pos = pos + 1;
            state.linkContent = unescapeMd(state.src.slice(start + 1, pos));
            return true;
        }
        if (code2 === 92 && pos + 1 < max) {
            pos += 2;
            continue;
        }
        pos++;
    }
    return false;
}
function normalizeReference(str) {
    return str.trim().replace(/\s+/g, " ").toUpperCase();
}
function parseReference(str, parser, options, env) {
    var state, labelEnd, pos, max, code2, start, href, title, label;
    if (str.charCodeAt(0) !== 91) {
        return -1;
    }
    if (str.indexOf("]:") === -1) {
        return -1;
    }
    state = new StateInline(str, parser, options, env, []);
    labelEnd = parseLinkLabel(state, 0);
    if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return -1;
    }
    max = state.posMax;
    for(pos = labelEnd + 2; pos < max; pos++){
        code2 = state.src.charCodeAt(pos);
        if (code2 !== 32 && code2 !== 10) {
            break;
        }
    }
    if (!parseLinkDestination(state, pos)) {
        return -1;
    }
    href = state.linkContent;
    pos = state.pos;
    start = pos;
    for(pos = pos + 1; pos < max; pos++){
        code2 = state.src.charCodeAt(pos);
        if (code2 !== 32 && code2 !== 10) {
            break;
        }
    }
    if (pos < max && start !== pos && parseLinkTitle(state, pos)) {
        title = state.linkContent;
        pos = state.pos;
    } else {
        title = "";
        pos = start;
    }
    while(pos < max && state.src.charCodeAt(pos) === 32){
        pos++;
    }
    if (pos < max && state.src.charCodeAt(pos) !== 10) {
        return -1;
    }
    label = normalizeReference(str.slice(1, labelEnd));
    if (typeof env.references[label] === "undefined") {
        env.references[label] = {
            title,
            href
        };
    }
    return pos;
}
function references(state) {
    var tokens = state.tokens, i, l, content, pos;
    state.env.references = state.env.references || {
    };
    if (state.inlineMode) {
        return;
    }
    for(i = 1, l = tokens.length - 1; i < l; i++){
        if (tokens[i].type === "inline" && tokens[i - 1].type === "paragraph_open" && tokens[i + 1].type === "paragraph_close") {
            content = tokens[i].content;
            while(content.length){
                pos = parseReference(content, state.inline, state.options, state.env);
                if (pos < 0) {
                    break;
                }
                content = content.slice(pos).trim();
            }
            tokens[i].content = content;
            if (!content.length) {
                tokens[i - 1].tight = true;
                tokens[i + 1].tight = true;
            }
        }
    }
}
function inline(state) {
    var tokens = state.tokens, tok, i, l;
    for(i = 0, l = tokens.length; i < l; i++){
        tok = tokens[i];
        if (tok.type === "inline") {
            state.inline.parse(tok.content, state.options, state.env, tok.children);
        }
    }
}
function footnote_block(state) {
    var i, l, j, t, lastParagraph, list2, tokens, current, currentLabel, level = 0, insideRef = false, refTokens = {
    };
    if (!state.env.footnotes) {
        return;
    }
    state.tokens = state.tokens.filter(function(tok) {
        if (tok.type === "footnote_reference_open") {
            insideRef = true;
            current = [];
            currentLabel = tok.label;
            return false;
        }
        if (tok.type === "footnote_reference_close") {
            insideRef = false;
            refTokens[":" + currentLabel] = current;
            return false;
        }
        if (insideRef) {
            current.push(tok);
        }
        return !insideRef;
    });
    if (!state.env.footnotes.list) {
        return;
    }
    list2 = state.env.footnotes.list;
    state.tokens.push({
        type: "footnote_block_open",
        level: level++
    });
    for(i = 0, l = list2.length; i < l; i++){
        state.tokens.push({
            type: "footnote_open",
            id: i,
            level: level++
        });
        if (list2[i].tokens) {
            tokens = [];
            tokens.push({
                type: "paragraph_open",
                tight: false,
                level: level++
            });
            tokens.push({
                type: "inline",
                content: "",
                level,
                children: list2[i].tokens
            });
            tokens.push({
                type: "paragraph_close",
                tight: false,
                level: --level
            });
        } else if (list2[i].label) {
            tokens = refTokens[":" + list2[i].label];
        }
        state.tokens = state.tokens.concat(tokens);
        if (state.tokens[state.tokens.length - 1].type === "paragraph_close") {
            lastParagraph = state.tokens.pop();
        } else {
            lastParagraph = null;
        }
        t = list2[i].count > 0 ? list2[i].count : 1;
        for(j = 0; j < t; j++){
            state.tokens.push({
                type: "footnote_anchor",
                id: i,
                subId: j,
                level
            });
        }
        if (lastParagraph) {
            state.tokens.push(lastParagraph);
        }
        state.tokens.push({
            type: "footnote_close",
            level: --level
        });
    }
    state.tokens.push({
        type: "footnote_block_close",
        level: --level
    });
}
var PUNCT_CHARS = ` \n()[]'".,!?-`;
function regEscape(s) {
    return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1");
}
function abbr2(state) {
    var i, j, l, tokens, token, text2, nodes, pos, level, reg, m, regText, blockTokens = state.tokens;
    if (!state.env.abbreviations) {
        return;
    }
    if (!state.env.abbrRegExp) {
        regText = "(^|[" + PUNCT_CHARS.split("").map(regEscape).join("") + "])(" + Object.keys(state.env.abbreviations).map(function(x) {
            return x.substr(1);
        }).sort(function(a, b) {
            return b.length - a.length;
        }).map(regEscape).join("|") + ")($|[" + PUNCT_CHARS.split("").map(regEscape).join("") + "])";
        state.env.abbrRegExp = new RegExp(regText, "g");
    }
    reg = state.env.abbrRegExp;
    for(j = 0, l = blockTokens.length; j < l; j++){
        if (blockTokens[j].type !== "inline") {
            continue;
        }
        tokens = blockTokens[j].children;
        for(i = tokens.length - 1; i >= 0; i--){
            token = tokens[i];
            if (token.type !== "text") {
                continue;
            }
            pos = 0;
            text2 = token.content;
            reg.lastIndex = 0;
            level = token.level;
            nodes = [];
            while(m = reg.exec(text2)){
                if (reg.lastIndex > pos) {
                    nodes.push({
                        type: "text",
                        content: text2.slice(pos, m.index + m[1].length),
                        level
                    });
                }
                nodes.push({
                    type: "abbr_open",
                    title: state.env.abbreviations[":" + m[2]],
                    level: level++
                });
                nodes.push({
                    type: "text",
                    content: m[2],
                    level
                });
                nodes.push({
                    type: "abbr_close",
                    level: --level
                });
                pos = reg.lastIndex - m[3].length;
            }
            if (!nodes.length) {
                continue;
            }
            if (pos < text2.length) {
                nodes.push({
                    type: "text",
                    content: text2.slice(pos),
                    level
                });
            }
            blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));
        }
    }
}
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
    c: "\xA9",
    r: "\xAE",
    p: "\xA7",
    tm: "\u2122"
};
function replaceScopedAbbr(str) {
    if (str.indexOf("(") < 0) {
        return str;
    }
    return str.replace(SCOPED_ABBR_RE, function(match, name) {
        return SCOPED_ABBR[name.toLowerCase()];
    });
}
function replace(state) {
    var i, token, text2, inlineTokens, blkIdx;
    if (!state.options.typographer) {
        return;
    }
    for(blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--){
        if (state.tokens[blkIdx].type !== "inline") {
            continue;
        }
        inlineTokens = state.tokens[blkIdx].children;
        for(i = inlineTokens.length - 1; i >= 0; i--){
            token = inlineTokens[i];
            if (token.type === "text") {
                text2 = token.content;
                text2 = replaceScopedAbbr(text2);
                if (RARE_RE.test(text2)) {
                    text2 = text2.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---([^-]|$)/mg, "$1\u2014$2").replace(/(^|\s)--(\s|$)/mg, "$1\u2013$2").replace(/(^|[^-\s])--([^-\s]|$)/mg, "$1\u2013$2");
                }
                token.content = text2;
            }
        }
    }
}
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var PUNCT_RE = /[-\s()\[\]]/;
var APOSTROPHE = "\u2019";
function isLetter(str, pos) {
    if (pos < 0 || pos >= str.length) {
        return false;
    }
    return !PUNCT_RE.test(str[pos]);
}
function replaceAt(str, index, ch) {
    return str.substr(0, index) + ch + str.substr(index + 1);
}
function smartquotes(state) {
    var i, token, text2, t, pos, max, thisLevel, lastSpace, nextSpace, item, canOpen, canClose, j, isSingle, blkIdx, tokens, stack;
    if (!state.options.typographer) {
        return;
    }
    stack = [];
    for(blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--){
        if (state.tokens[blkIdx].type !== "inline") {
            continue;
        }
        tokens = state.tokens[blkIdx].children;
        stack.length = 0;
        for(i = 0; i < tokens.length; i++){
            token = tokens[i];
            if (token.type !== "text" || QUOTE_TEST_RE.test(token.text)) {
                continue;
            }
            thisLevel = tokens[i].level;
            for(j = stack.length - 1; j >= 0; j--){
                if (stack[j].level <= thisLevel) {
                    break;
                }
            }
            stack.length = j + 1;
            text2 = token.content;
            pos = 0;
            max = text2.length;
            OUTER: while(pos < max){
                QUOTE_RE.lastIndex = pos;
                t = QUOTE_RE.exec(text2);
                if (!t) {
                    break;
                }
                lastSpace = !isLetter(text2, t.index - 1);
                pos = t.index + 1;
                isSingle = t[0] === "'";
                nextSpace = !isLetter(text2, pos);
                if (!nextSpace && !lastSpace) {
                    if (isSingle) {
                        token.content = replaceAt(token.content, t.index, APOSTROPHE);
                    }
                    continue;
                }
                canOpen = !nextSpace;
                canClose = !lastSpace;
                if (canClose) {
                    for(j = stack.length - 1; j >= 0; j--){
                        item = stack[j];
                        if (stack[j].level < thisLevel) {
                            break;
                        }
                        if (item.single === isSingle && stack[j].level === thisLevel) {
                            item = stack[j];
                            if (isSingle) {
                                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);
                                token.content = replaceAt(token.content, t.index, state.options.quotes[3]);
                            } else {
                                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);
                                token.content = replaceAt(token.content, t.index, state.options.quotes[1]);
                            }
                            stack.length = j;
                            continue OUTER;
                        }
                    }
                }
                if (canOpen) {
                    stack.push({
                        token: i,
                        pos: t.index,
                        single: isSingle,
                        level: thisLevel
                    });
                } else if (canClose && isSingle) {
                    token.content = replaceAt(token.content, t.index, APOSTROPHE);
                }
            }
        }
    }
}
var _rules = [
    [
        "block",
        block
    ],
    [
        "abbr",
        abbr
    ],
    [
        "references",
        references
    ],
    [
        "inline",
        inline
    ],
    [
        "footnote_tail",
        footnote_block
    ],
    [
        "abbr2",
        abbr2
    ],
    [
        "replacements",
        replace
    ],
    [
        "smartquotes",
        smartquotes
    ]
];
function Core() {
    this.options = {
    };
    this.ruler = new Ruler();
    for(var i = 0; i < _rules.length; i++){
        this.ruler.push(_rules[i][0], _rules[i][1]);
    }
}
Core.prototype.process = function(state) {
    var i, l, rules2;
    rules2 = this.ruler.getRules("");
    for(i = 0, l = rules2.length; i < l; i++){
        rules2[i](state);
    }
};
function StateBlock(src, parser, options, env, tokens) {
    var ch, s, start, pos, len, indent, indent_found;
    this.src = src;
    this.parser = parser;
    this.options = options;
    this.env = env;
    this.tokens = tokens;
    this.bMarks = [];
    this.eMarks = [];
    this.tShift = [];
    this.blkIndent = 0;
    this.line = 0;
    this.lineMax = 0;
    this.tight = false;
    this.parentType = "root";
    this.ddIndent = -1;
    this.level = 0;
    this.result = "";
    s = this.src;
    indent = 0;
    indent_found = false;
    for(start = pos = indent = 0, len = s.length; pos < len; pos++){
        ch = s.charCodeAt(pos);
        if (!indent_found) {
            if (ch === 32) {
                indent++;
                continue;
            } else {
                indent_found = true;
            }
        }
        if (ch === 10 || pos === len - 1) {
            if (ch !== 10) {
                pos++;
            }
            this.bMarks.push(start);
            this.eMarks.push(pos);
            this.tShift.push(indent);
            indent_found = false;
            indent = 0;
            start = pos + 1;
        }
    }
    this.bMarks.push(s.length);
    this.eMarks.push(s.length);
    this.tShift.push(0);
    this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.isEmpty = function isEmpty(line) {
    return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
    for(var max = this.lineMax; from < max; from++){
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
            break;
        }
    }
    return from;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
    for(var max = this.src.length; pos < max; pos++){
        if (this.src.charCodeAt(pos) !== 32) {
            break;
        }
    }
    return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code2) {
    for(var max = this.src.length; pos < max; pos++){
        if (this.src.charCodeAt(pos) !== code2) {
            break;
        }
    }
    return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
    if (pos <= min) {
        return pos;
    }
    while(pos > min){
        if (code2 !== this.src.charCodeAt(--pos)) {
            return pos + 1;
        }
    }
    return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
    var i, first, last, queue, shift, line = begin;
    if (begin >= end) {
        return "";
    }
    if (line + 1 === end) {
        first = this.bMarks[line] + Math.min(this.tShift[line], indent);
        last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];
        return this.src.slice(first, last);
    }
    queue = new Array(end - begin);
    for(i = 0; line < end; line++, i++){
        shift = this.tShift[line];
        if (shift > indent) {
            shift = indent;
        }
        if (shift < 0) {
            shift = 0;
        }
        first = this.bMarks[line] + shift;
        if (line + 1 < end || keepLastLF) {
            last = this.eMarks[line] + 1;
        } else {
            last = this.eMarks[line];
        }
        queue[i] = this.src.slice(first, last);
    }
    return queue.join("");
};
function code(state, startLine, endLine) {
    var nextLine, last;
    if (state.tShift[startLine] - state.blkIndent < 4) {
        return false;
    }
    last = nextLine = startLine + 1;
    while(nextLine < endLine){
        if (state.isEmpty(nextLine)) {
            nextLine++;
            continue;
        }
        if (state.tShift[nextLine] - state.blkIndent >= 4) {
            nextLine++;
            last = nextLine;
            continue;
        }
        break;
    }
    state.line = nextLine;
    state.tokens.push({
        type: "code",
        content: state.getLines(startLine, last, 4 + state.blkIndent, true),
        block: true,
        lines: [
            startLine,
            state.line
        ],
        level: state.level
    });
    return true;
}
function fences(state, startLine, endLine, silent) {
    var marker, len, params, nextLine, mem, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (pos + 3 > max) {
        return false;
    }
    marker = state.src.charCodeAt(pos);
    if (marker !== 126 && marker !== 96) {
        return false;
    }
    mem = pos;
    pos = state.skipChars(pos, marker);
    len = pos - mem;
    if (len < 3) {
        return false;
    }
    params = state.src.slice(pos, max).trim();
    if (params.indexOf("`") >= 0) {
        return false;
    }
    if (silent) {
        return true;
    }
    nextLine = startLine;
    for(;;){
        nextLine++;
        if (nextLine >= endLine) {
            break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max && state.tShift[nextLine] < state.blkIndent) {
            break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
            continue;
        }
        if (state.tShift[nextLine] - state.blkIndent >= 4) {
            continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
            continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max) {
            continue;
        }
        haveEndMarker = true;
        break;
    }
    len = state.tShift[startLine];
    state.line = nextLine + (haveEndMarker ? 1 : 0);
    state.tokens.push({
        type: "fence",
        params,
        content: state.getLines(startLine + 1, nextLine, len, true),
        lines: [
            startLine,
            state.line
        ],
        level: state.level
    });
    return true;
}
function blockquote(state, startLine, endLine, silent) {
    var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines, terminatorRules, i, l, terminate, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (pos > max) {
        return false;
    }
    if (state.src.charCodeAt(pos++) !== 62) {
        return false;
    }
    if (state.level >= state.options.maxNesting) {
        return false;
    }
    if (silent) {
        return true;
    }
    if (state.src.charCodeAt(pos) === 32) {
        pos++;
    }
    oldIndent = state.blkIndent;
    state.blkIndent = 0;
    oldBMarks = [
        state.bMarks[startLine]
    ];
    state.bMarks[startLine] = pos;
    pos = pos < max ? state.skipSpaces(pos) : pos;
    lastLineEmpty = pos >= max;
    oldTShift = [
        state.tShift[startLine]
    ];
    state.tShift[startLine] = pos - state.bMarks[startLine];
    terminatorRules = state.parser.ruler.getRules("blockquote");
    for(nextLine = startLine + 1; nextLine < endLine; nextLine++){
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos >= max) {
            break;
        }
        if (state.src.charCodeAt(pos++) === 62) {
            if (state.src.charCodeAt(pos) === 32) {
                pos++;
            }
            oldBMarks.push(state.bMarks[nextLine]);
            state.bMarks[nextLine] = pos;
            pos = pos < max ? state.skipSpaces(pos) : pos;
            lastLineEmpty = pos >= max;
            oldTShift.push(state.tShift[nextLine]);
            state.tShift[nextLine] = pos - state.bMarks[nextLine];
            continue;
        }
        if (lastLineEmpty) {
            break;
        }
        terminate = false;
        for(i = 0, l = terminatorRules.length; i < l; i++){
            if (terminatorRules[i](state, nextLine, endLine, true)) {
                terminate = true;
                break;
            }
        }
        if (terminate) {
            break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        state.tShift[nextLine] = -1337;
    }
    oldParentType = state.parentType;
    state.parentType = "blockquote";
    state.tokens.push({
        type: "blockquote_open",
        lines: lines = [
            startLine,
            0
        ],
        level: state.level++
    });
    state.parser.tokenize(state, startLine, nextLine);
    state.tokens.push({
        type: "blockquote_close",
        level: --state.level
    });
    state.parentType = oldParentType;
    lines[1] = state.line;
    for(i = 0; i < oldTShift.length; i++){
        state.bMarks[i + startLine] = oldBMarks[i];
        state.tShift[i + startLine] = oldTShift[i];
    }
    state.blkIndent = oldIndent;
    return true;
}
function hr(state, startLine, endLine, silent) {
    var marker, cnt, ch, pos = state.bMarks[startLine], max = state.eMarks[startLine];
    pos += state.tShift[startLine];
    if (pos > max) {
        return false;
    }
    marker = state.src.charCodeAt(pos++);
    if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
    }
    cnt = 1;
    while(pos < max){
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && ch !== 32) {
            return false;
        }
        if (ch === marker) {
            cnt++;
        }
    }
    if (cnt < 3) {
        return false;
    }
    if (silent) {
        return true;
    }
    state.line = startLine + 1;
    state.tokens.push({
        type: "hr",
        lines: [
            startLine,
            state.line
        ],
        level: state.level
    });
    return true;
}
function skipBulletListMarker(state, startLine) {
    var marker, pos, max;
    pos = state.bMarks[startLine] + state.tShift[startLine];
    max = state.eMarks[startLine];
    if (pos >= max) {
        return -1;
    }
    marker = state.src.charCodeAt(pos++);
    if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
    }
    if (pos < max && state.src.charCodeAt(pos) !== 32) {
        return -1;
    }
    return pos;
}
function skipOrderedListMarker(state, startLine) {
    var ch, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (pos + 1 >= max) {
        return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch < 48 || ch > 57) {
        return -1;
    }
    for(;;){
        if (pos >= max) {
            return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
            continue;
        }
        if (ch === 41 || ch === 46) {
            break;
        }
        return -1;
    }
    if (pos < max && state.src.charCodeAt(pos) !== 32) {
        return -1;
    }
    return pos;
}
function markTightParagraphs(state, idx) {
    var i, l, level = state.level + 2;
    for(i = idx + 2, l = state.tokens.length - 2; i < l; i++){
        if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
            state.tokens[i + 2].tight = true;
            state.tokens[i].tight = true;
            i += 2;
        }
    }
}
function list(state, startLine, endLine, silent) {
    var nextLine, indent, oldTShift, oldIndent, oldTight, oldParentType, start, posAfterMarker, max, indentAfterMarker, markerValue, markerCharCode, isOrdered, contentStart, listTokIdx, prevEmptyEnd, listLines, itemLines, tight = true, terminatorRules, i, l, terminate;
    if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
        isOrdered = true;
    } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
        isOrdered = false;
    } else {
        return false;
    }
    if (state.level >= state.options.maxNesting) {
        return false;
    }
    markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
    if (silent) {
        return true;
    }
    listTokIdx = state.tokens.length;
    if (isOrdered) {
        start = state.bMarks[startLine] + state.tShift[startLine];
        markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));
        state.tokens.push({
            type: "ordered_list_open",
            order: markerValue,
            lines: listLines = [
                startLine,
                0
            ],
            level: state.level++
        });
    } else {
        state.tokens.push({
            type: "bullet_list_open",
            lines: listLines = [
                startLine,
                0
            ],
            level: state.level++
        });
    }
    nextLine = startLine;
    prevEmptyEnd = false;
    terminatorRules = state.parser.ruler.getRules("list");
    while(nextLine < endLine){
        contentStart = state.skipSpaces(posAfterMarker);
        max = state.eMarks[nextLine];
        if (contentStart >= max) {
            indentAfterMarker = 1;
        } else {
            indentAfterMarker = contentStart - posAfterMarker;
        }
        if (indentAfterMarker > 4) {
            indentAfterMarker = 1;
        }
        if (indentAfterMarker < 1) {
            indentAfterMarker = 1;
        }
        indent = posAfterMarker - state.bMarks[nextLine] + indentAfterMarker;
        state.tokens.push({
            type: "list_item_open",
            lines: itemLines = [
                startLine,
                0
            ],
            level: state.level++
        });
        oldIndent = state.blkIndent;
        oldTight = state.tight;
        oldTShift = state.tShift[startLine];
        oldParentType = state.parentType;
        state.tShift[startLine] = contentStart - state.bMarks[startLine];
        state.blkIndent = indent;
        state.tight = true;
        state.parentType = "list";
        state.parser.tokenize(state, startLine, endLine, true);
        if (!state.tight || prevEmptyEnd) {
            tight = false;
        }
        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = oldIndent;
        state.tShift[startLine] = oldTShift;
        state.tight = oldTight;
        state.parentType = oldParentType;
        state.tokens.push({
            type: "list_item_close",
            level: --state.level
        });
        nextLine = startLine = state.line;
        itemLines[1] = nextLine;
        contentStart = state.bMarks[startLine];
        if (nextLine >= endLine) {
            break;
        }
        if (state.isEmpty(nextLine)) {
            break;
        }
        if (state.tShift[nextLine] < state.blkIndent) {
            break;
        }
        terminate = false;
        for(i = 0, l = terminatorRules.length; i < l; i++){
            if (terminatorRules[i](state, nextLine, endLine, true)) {
                terminate = true;
                break;
            }
        }
        if (terminate) {
            break;
        }
        if (isOrdered) {
            posAfterMarker = skipOrderedListMarker(state, nextLine);
            if (posAfterMarker < 0) {
                break;
            }
        } else {
            posAfterMarker = skipBulletListMarker(state, nextLine);
            if (posAfterMarker < 0) {
                break;
            }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
            break;
        }
    }
    state.tokens.push({
        type: isOrdered ? "ordered_list_close" : "bullet_list_close",
        level: --state.level
    });
    listLines[1] = nextLine;
    state.line = nextLine;
    if (tight) {
        markTightParagraphs(state, listTokIdx);
    }
    return true;
}
function footnote(state, startLine, endLine, silent) {
    var oldBMark, oldTShift, oldParentType, pos, label, start = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (start + 4 > max) {
        return false;
    }
    if (state.src.charCodeAt(start) !== 91) {
        return false;
    }
    if (state.src.charCodeAt(start + 1) !== 94) {
        return false;
    }
    if (state.level >= state.options.maxNesting) {
        return false;
    }
    for(pos = start + 2; pos < max; pos++){
        if (state.src.charCodeAt(pos) === 32) {
            return false;
        }
        if (state.src.charCodeAt(pos) === 93) {
            break;
        }
    }
    if (pos === start + 2) {
        return false;
    }
    if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 58) {
        return false;
    }
    if (silent) {
        return true;
    }
    pos++;
    if (!state.env.footnotes) {
        state.env.footnotes = {
        };
    }
    if (!state.env.footnotes.refs) {
        state.env.footnotes.refs = {
        };
    }
    label = state.src.slice(start + 2, pos - 2);
    state.env.footnotes.refs[":" + label] = -1;
    state.tokens.push({
        type: "footnote_reference_open",
        label,
        level: state.level++
    });
    oldBMark = state.bMarks[startLine];
    oldTShift = state.tShift[startLine];
    oldParentType = state.parentType;
    state.tShift[startLine] = state.skipSpaces(pos) - pos;
    state.bMarks[startLine] = pos;
    state.blkIndent += 4;
    state.parentType = "footnote";
    if (state.tShift[startLine] < state.blkIndent) {
        state.tShift[startLine] += state.blkIndent;
        state.bMarks[startLine] -= state.blkIndent;
    }
    state.parser.tokenize(state, startLine, endLine, true);
    state.parentType = oldParentType;
    state.blkIndent -= 4;
    state.tShift[startLine] = oldTShift;
    state.bMarks[startLine] = oldBMark;
    state.tokens.push({
        type: "footnote_reference_close",
        level: --state.level
    });
    return true;
}
function heading(state, startLine, endLine, silent) {
    var ch, level, tmp, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (pos >= max) {
        return false;
    }
    ch = state.src.charCodeAt(pos);
    if (ch !== 35 || pos >= max) {
        return false;
    }
    level = 1;
    ch = state.src.charCodeAt(++pos);
    while(ch === 35 && pos < max && level <= 6){
        level++;
        ch = state.src.charCodeAt(++pos);
    }
    if (level > 6 || pos < max && ch !== 32) {
        return false;
    }
    if (silent) {
        return true;
    }
    max = state.skipCharsBack(max, 32, pos);
    tmp = state.skipCharsBack(max, 35, pos);
    if (tmp > pos && state.src.charCodeAt(tmp - 1) === 32) {
        max = tmp;
    }
    state.line = startLine + 1;
    state.tokens.push({
        type: "heading_open",
        hLevel: level,
        lines: [
            startLine,
            state.line
        ],
        level: state.level
    });
    if (pos < max) {
        state.tokens.push({
            type: "inline",
            content: state.src.slice(pos, max).trim(),
            level: state.level + 1,
            lines: [
                startLine,
                state.line
            ],
            children: []
        });
    }
    state.tokens.push({
        type: "heading_close",
        hLevel: level,
        level: state.level
    });
    return true;
}
function lheading(state, startLine, endLine) {
    var marker, pos, max, next = startLine + 1;
    if (next >= endLine) {
        return false;
    }
    if (state.tShift[next] < state.blkIndent) {
        return false;
    }
    if (state.tShift[next] - state.blkIndent > 3) {
        return false;
    }
    pos = state.bMarks[next] + state.tShift[next];
    max = state.eMarks[next];
    if (pos >= max) {
        return false;
    }
    marker = state.src.charCodeAt(pos);
    if (marker !== 45 && marker !== 61) {
        return false;
    }
    pos = state.skipChars(pos, marker);
    pos = state.skipSpaces(pos);
    if (pos < max) {
        return false;
    }
    pos = state.bMarks[startLine] + state.tShift[startLine];
    state.line = next + 1;
    state.tokens.push({
        type: "heading_open",
        hLevel: marker === 61 ? 1 : 2,
        lines: [
            startLine,
            state.line
        ],
        level: state.level
    });
    state.tokens.push({
        type: "inline",
        content: state.src.slice(pos, state.eMarks[startLine]).trim(),
        level: state.level + 1,
        lines: [
            startLine,
            state.line - 1
        ],
        children: []
    });
    state.tokens.push({
        type: "heading_close",
        hLevel: marker === 61 ? 1 : 2,
        level: state.level
    });
    return true;
}
var html_blocks = {
};
[
    "article",
    "aside",
    "button",
    "blockquote",
    "body",
    "canvas",
    "caption",
    "col",
    "colgroup",
    "dd",
    "div",
    "dl",
    "dt",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "hr",
    "iframe",
    "li",
    "map",
    "object",
    "ol",
    "output",
    "p",
    "pre",
    "progress",
    "script",
    "section",
    "style",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "tr",
    "thead",
    "ul",
    "video"
].forEach(function(name) {
    html_blocks[name] = true;
});
var HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\s\/>]/;
var HTML_TAG_CLOSE_RE = /^<\/([a-zA-Z]{1,15})[\s>]/;
function isLetter$1(ch) {
    var lc = ch | 32;
    return lc >= 97 && lc <= 122;
}
function htmlblock(state, startLine, endLine, silent) {
    var ch, match, nextLine, pos = state.bMarks[startLine], max = state.eMarks[startLine], shift = state.tShift[startLine];
    pos += shift;
    if (!state.options.html) {
        return false;
    }
    if (shift > 3 || pos + 2 >= max) {
        return false;
    }
    if (state.src.charCodeAt(pos) !== 60) {
        return false;
    }
    ch = state.src.charCodeAt(pos + 1);
    if (ch === 33 || ch === 63) {
        if (silent) {
            return true;
        }
    } else if (ch === 47 || isLetter$1(ch)) {
        if (ch === 47) {
            match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);
            if (!match) {
                return false;
            }
        } else {
            match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);
            if (!match) {
                return false;
            }
        }
        if (html_blocks[match[1].toLowerCase()] !== true) {
            return false;
        }
        if (silent) {
            return true;
        }
    } else {
        return false;
    }
    nextLine = startLine + 1;
    while(nextLine < state.lineMax && !state.isEmpty(nextLine)){
        nextLine++;
    }
    state.line = nextLine;
    state.tokens.push({
        type: "htmlblock",
        level: state.level,
        lines: [
            startLine,
            state.line
        ],
        content: state.getLines(startLine, nextLine, 0, true)
    });
    return true;
}
function getLine(state, line) {
    var pos = state.bMarks[line] + state.blkIndent, max = state.eMarks[line];
    return state.src.substr(pos, max - pos);
}
function table(state, startLine, endLine, silent) {
    var ch, lineText, pos, i, nextLine, rows, cell, aligns, t, tableLines, tbodyLines;
    if (startLine + 2 > endLine) {
        return false;
    }
    nextLine = startLine + 1;
    if (state.tShift[nextLine] < state.blkIndent) {
        return false;
    }
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    if (pos >= state.eMarks[nextLine]) {
        return false;
    }
    ch = state.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58) {
        return false;
    }
    lineText = getLine(state, startLine + 1);
    if (!/^[-:| ]+$/.test(lineText)) {
        return false;
    }
    rows = lineText.split("|");
    if (rows <= 2) {
        return false;
    }
    aligns = [];
    for(i = 0; i < rows.length; i++){
        t = rows[i].trim();
        if (!t) {
            if (i === 0 || i === rows.length - 1) {
                continue;
            } else {
                return false;
            }
        }
        if (!/^:?-+:?$/.test(t)) {
            return false;
        }
        if (t.charCodeAt(t.length - 1) === 58) {
            aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t.charCodeAt(0) === 58) {
            aligns.push("left");
        } else {
            aligns.push("");
        }
    }
    lineText = getLine(state, startLine).trim();
    if (lineText.indexOf("|") === -1) {
        return false;
    }
    rows = lineText.replace(/^\||\|$/g, "").split("|");
    if (aligns.length !== rows.length) {
        return false;
    }
    if (silent) {
        return true;
    }
    state.tokens.push({
        type: "table_open",
        lines: tableLines = [
            startLine,
            0
        ],
        level: state.level++
    });
    state.tokens.push({
        type: "thead_open",
        lines: [
            startLine,
            startLine + 1
        ],
        level: state.level++
    });
    state.tokens.push({
        type: "tr_open",
        lines: [
            startLine,
            startLine + 1
        ],
        level: state.level++
    });
    for(i = 0; i < rows.length; i++){
        state.tokens.push({
            type: "th_open",
            align: aligns[i],
            lines: [
                startLine,
                startLine + 1
            ],
            level: state.level++
        });
        state.tokens.push({
            type: "inline",
            content: rows[i].trim(),
            lines: [
                startLine,
                startLine + 1
            ],
            level: state.level,
            children: []
        });
        state.tokens.push({
            type: "th_close",
            level: --state.level
        });
    }
    state.tokens.push({
        type: "tr_close",
        level: --state.level
    });
    state.tokens.push({
        type: "thead_close",
        level: --state.level
    });
    state.tokens.push({
        type: "tbody_open",
        lines: tbodyLines = [
            startLine + 2,
            0
        ],
        level: state.level++
    });
    for(nextLine = startLine + 2; nextLine < endLine; nextLine++){
        if (state.tShift[nextLine] < state.blkIndent) {
            break;
        }
        lineText = getLine(state, nextLine).trim();
        if (lineText.indexOf("|") === -1) {
            break;
        }
        rows = lineText.replace(/^\||\|$/g, "").split("|");
        state.tokens.push({
            type: "tr_open",
            level: state.level++
        });
        for(i = 0; i < rows.length; i++){
            state.tokens.push({
                type: "td_open",
                align: aligns[i],
                level: state.level++
            });
            cell = rows[i].substring(rows[i].charCodeAt(0) === 124 ? 1 : 0, rows[i].charCodeAt(rows[i].length - 1) === 124 ? rows[i].length - 1 : rows[i].length).trim();
            state.tokens.push({
                type: "inline",
                content: cell,
                level: state.level,
                children: []
            });
            state.tokens.push({
                type: "td_close",
                level: --state.level
            });
        }
        state.tokens.push({
            type: "tr_close",
            level: --state.level
        });
    }
    state.tokens.push({
        type: "tbody_close",
        level: --state.level
    });
    state.tokens.push({
        type: "table_close",
        level: --state.level
    });
    tableLines[1] = tbodyLines[1] = nextLine;
    state.line = nextLine;
    return true;
}
function skipMarker(state, line) {
    var pos, marker, start = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
    if (start >= max) {
        return -1;
    }
    marker = state.src.charCodeAt(start++);
    if (marker !== 126 && marker !== 58) {
        return -1;
    }
    pos = state.skipSpaces(start);
    if (start === pos) {
        return -1;
    }
    if (pos >= max) {
        return -1;
    }
    return pos;
}
function markTightParagraphs$1(state, idx) {
    var i, l, level = state.level + 2;
    for(i = idx + 2, l = state.tokens.length - 2; i < l; i++){
        if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
            state.tokens[i + 2].tight = true;
            state.tokens[i].tight = true;
            i += 2;
        }
    }
}
function deflist(state, startLine, endLine, silent) {
    var contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, nextLine, oldIndent, oldDDIndent, oldParentType, oldTShift, oldTight, prevEmptyEnd, tight;
    if (silent) {
        if (state.ddIndent < 0) {
            return false;
        }
        return skipMarker(state, startLine) >= 0;
    }
    nextLine = startLine + 1;
    if (state.isEmpty(nextLine)) {
        if ((++nextLine) > endLine) {
            return false;
        }
    }
    if (state.tShift[nextLine] < state.blkIndent) {
        return false;
    }
    contentStart = skipMarker(state, nextLine);
    if (contentStart < 0) {
        return false;
    }
    if (state.level >= state.options.maxNesting) {
        return false;
    }
    listTokIdx = state.tokens.length;
    state.tokens.push({
        type: "dl_open",
        lines: listLines = [
            startLine,
            0
        ],
        level: state.level++
    });
    dtLine = startLine;
    ddLine = nextLine;
    OUTER: for(;;){
        tight = true;
        prevEmptyEnd = false;
        state.tokens.push({
            type: "dt_open",
            lines: [
                dtLine,
                dtLine
            ],
            level: state.level++
        });
        state.tokens.push({
            type: "inline",
            content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),
            level: state.level + 1,
            lines: [
                dtLine,
                dtLine
            ],
            children: []
        });
        state.tokens.push({
            type: "dt_close",
            level: --state.level
        });
        for(;;){
            state.tokens.push({
                type: "dd_open",
                lines: itemLines = [
                    nextLine,
                    0
                ],
                level: state.level++
            });
            oldTight = state.tight;
            oldDDIndent = state.ddIndent;
            oldIndent = state.blkIndent;
            oldTShift = state.tShift[ddLine];
            oldParentType = state.parentType;
            state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;
            state.tShift[ddLine] = contentStart - state.bMarks[ddLine];
            state.tight = true;
            state.parentType = "deflist";
            state.parser.tokenize(state, ddLine, endLine, true);
            if (!state.tight || prevEmptyEnd) {
                tight = false;
            }
            prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);
            state.tShift[ddLine] = oldTShift;
            state.tight = oldTight;
            state.parentType = oldParentType;
            state.blkIndent = oldIndent;
            state.ddIndent = oldDDIndent;
            state.tokens.push({
                type: "dd_close",
                level: --state.level
            });
            itemLines[1] = nextLine = state.line;
            if (nextLine >= endLine) {
                break OUTER;
            }
            if (state.tShift[nextLine] < state.blkIndent) {
                break OUTER;
            }
            contentStart = skipMarker(state, nextLine);
            if (contentStart < 0) {
                break;
            }
            ddLine = nextLine;
        }
        if (nextLine >= endLine) {
            break;
        }
        dtLine = nextLine;
        if (state.isEmpty(dtLine)) {
            break;
        }
        if (state.tShift[dtLine] < state.blkIndent) {
            break;
        }
        ddLine = dtLine + 1;
        if (ddLine >= endLine) {
            break;
        }
        if (state.isEmpty(ddLine)) {
            ddLine++;
        }
        if (ddLine >= endLine) {
            break;
        }
        if (state.tShift[ddLine] < state.blkIndent) {
            break;
        }
        contentStart = skipMarker(state, ddLine);
        if (contentStart < 0) {
            break;
        }
    }
    state.tokens.push({
        type: "dl_close",
        level: --state.level
    });
    listLines[1] = nextLine;
    state.line = nextLine;
    if (tight) {
        markTightParagraphs$1(state, listTokIdx);
    }
    return true;
}
function paragraph(state, startLine) {
    var endLine, content, terminate, i, l, nextLine = startLine + 1, terminatorRules;
    endLine = state.lineMax;
    if (nextLine < endLine && !state.isEmpty(nextLine)) {
        terminatorRules = state.parser.ruler.getRules("paragraph");
        for(; nextLine < endLine && !state.isEmpty(nextLine); nextLine++){
            if (state.tShift[nextLine] - state.blkIndent > 3) {
                continue;
            }
            terminate = false;
            for(i = 0, l = terminatorRules.length; i < l; i++){
                if (terminatorRules[i](state, nextLine, endLine, true)) {
                    terminate = true;
                    break;
                }
            }
            if (terminate) {
                break;
            }
        }
    }
    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    state.line = nextLine;
    if (content.length) {
        state.tokens.push({
            type: "paragraph_open",
            tight: false,
            lines: [
                startLine,
                state.line
            ],
            level: state.level
        });
        state.tokens.push({
            type: "inline",
            content,
            level: state.level + 1,
            lines: [
                startLine,
                state.line
            ],
            children: []
        });
        state.tokens.push({
            type: "paragraph_close",
            tight: false,
            level: state.level
        });
    }
    return true;
}
var _rules$1 = [
    [
        "code",
        code
    ],
    [
        "fences",
        fences,
        [
            "paragraph",
            "blockquote",
            "list"
        ]
    ],
    [
        "blockquote",
        blockquote,
        [
            "paragraph",
            "blockquote",
            "list"
        ]
    ],
    [
        "hr",
        hr,
        [
            "paragraph",
            "blockquote",
            "list"
        ]
    ],
    [
        "list",
        list,
        [
            "paragraph",
            "blockquote"
        ]
    ],
    [
        "footnote",
        footnote,
        [
            "paragraph"
        ]
    ],
    [
        "heading",
        heading,
        [
            "paragraph",
            "blockquote"
        ]
    ],
    [
        "lheading",
        lheading
    ],
    [
        "htmlblock",
        htmlblock,
        [
            "paragraph",
            "blockquote"
        ]
    ],
    [
        "table",
        table,
        [
            "paragraph"
        ]
    ],
    [
        "deflist",
        deflist,
        [
            "paragraph"
        ]
    ],
    [
        "paragraph",
        paragraph
    ]
];
function ParserBlock() {
    this.ruler = new Ruler();
    for(var i = 0; i < _rules$1.length; i++){
        this.ruler.push(_rules$1[i][0], _rules$1[i][1], {
            alt: (_rules$1[i][2] || []).slice()
        });
    }
}
ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
    var rules2 = this.ruler.getRules("");
    var len = rules2.length;
    var line = startLine;
    var hasEmptyLines = false;
    var ok, i;
    while(line < endLine){
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
            break;
        }
        if (state.tShift[line] < state.blkIndent) {
            break;
        }
        for(i = 0; i < len; i++){
            ok = rules2[i](state, line, endLine, false);
            if (ok) {
                break;
            }
        }
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
            hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
            hasEmptyLines = true;
            line++;
            if (line < endLine && state.parentType === "list" && state.isEmpty(line)) {
                break;
            }
            state.line = line;
        }
    }
};
var TABS_SCAN_RE = /[\n\t]/g;
var NEWLINES_RE = /\r[\n\u0085]|[\u2424\u2028\u0085]/g;
var SPACES_RE = /\u00a0/g;
ParserBlock.prototype.parse = function(str, options, env, outTokens) {
    var state, lineStart = 0, lastTabPos = 0;
    if (!str) {
        return [];
    }
    str = str.replace(SPACES_RE, " ");
    str = str.replace(NEWLINES_RE, "\n");
    if (str.indexOf("	") >= 0) {
        str = str.replace(TABS_SCAN_RE, function(match, offset) {
            var result;
            if (str.charCodeAt(offset) === 10) {
                lineStart = offset + 1;
                lastTabPos = 0;
                return match;
            }
            result = "    ".slice((offset - lineStart - lastTabPos) % 4);
            lastTabPos = offset - lineStart + 1;
            return result;
        });
    }
    state = new StateBlock(str, this, options, env, outTokens);
    this.tokenize(state, state.line, state.lineMax);
};
function isTerminatorChar(ch) {
    switch(ch){
        case 10:
        case 92:
        case 96:
        case 42:
        case 95:
        case 94:
        case 91:
        case 93:
        case 33:
        case 38:
        case 60:
        case 62:
        case 123:
        case 125:
        case 36:
        case 37:
        case 64:
        case 126:
        case 43:
        case 61:
        case 58:
            return true;
        default:
            return false;
    }
}
function text(state, silent) {
    var pos = state.pos;
    while(pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))){
        pos++;
    }
    if (pos === state.pos) {
        return false;
    }
    if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
    }
    state.pos = pos;
    return true;
}
function newline(state, silent) {
    var pmax, max, pos = state.pos;
    if (state.src.charCodeAt(pos) !== 10) {
        return false;
    }
    pmax = state.pending.length - 1;
    max = state.posMax;
    if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
            if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
                for(var i = pmax - 2; i >= 0; i--){
                    if (state.pending.charCodeAt(i) !== 32) {
                        state.pending = state.pending.substring(0, i + 1);
                        break;
                    }
                }
                state.push({
                    type: "hardbreak",
                    level: state.level
                });
            } else {
                state.pending = state.pending.slice(0, -1);
                state.push({
                    type: "softbreak",
                    level: state.level
                });
            }
        } else {
            state.push({
                type: "softbreak",
                level: state.level
            });
        }
    }
    pos++;
    while(pos < max && state.src.charCodeAt(pos) === 32){
        pos++;
    }
    state.pos = pos;
    return true;
}
var ESCAPED = [];
for(var i = 0; i < 256; i++){
    ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
    ESCAPED[ch.charCodeAt(0)] = 1;
});
function escape(state, silent) {
    var ch, pos = state.pos, max = state.posMax;
    if (state.src.charCodeAt(pos) !== 92) {
        return false;
    }
    pos++;
    if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (ch < 256 && ESCAPED[ch] !== 0) {
            if (!silent) {
                state.pending += state.src[pos];
            }
            state.pos += 2;
            return true;
        }
        if (ch === 10) {
            if (!silent) {
                state.push({
                    type: "hardbreak",
                    level: state.level
                });
            }
            pos++;
            while(pos < max && state.src.charCodeAt(pos) === 32){
                pos++;
            }
            state.pos = pos;
            return true;
        }
    }
    if (!silent) {
        state.pending += "\\";
    }
    state.pos++;
    return true;
}
function backticks(state, silent) {
    var start, max, marker, matchStart, matchEnd, pos = state.pos, ch = state.src.charCodeAt(pos);
    if (ch !== 96) {
        return false;
    }
    start = pos;
    pos++;
    max = state.posMax;
    while(pos < max && state.src.charCodeAt(pos) === 96){
        pos++;
    }
    marker = state.src.slice(start, pos);
    matchStart = matchEnd = pos;
    while((matchStart = state.src.indexOf("`", matchEnd)) !== -1){
        matchEnd = matchStart + 1;
        while(matchEnd < max && state.src.charCodeAt(matchEnd) === 96){
            matchEnd++;
        }
        if (matchEnd - matchStart === marker.length) {
            if (!silent) {
                state.push({
                    type: "code",
                    content: state.src.slice(pos, matchStart).replace(/[ \n]+/g, " ").trim(),
                    block: false,
                    level: state.level
                });
            }
            state.pos = matchEnd;
            return true;
        }
    }
    if (!silent) {
        state.pending += marker;
    }
    state.pos += marker.length;
    return true;
}
function del(state, silent) {
    var found, pos, stack, max = state.posMax, start = state.pos, lastChar, nextChar;
    if (state.src.charCodeAt(start) !== 126) {
        return false;
    }
    if (silent) {
        return false;
    }
    if (start + 4 >= max) {
        return false;
    }
    if (state.src.charCodeAt(start + 1) !== 126) {
        return false;
    }
    if (state.level >= state.options.maxNesting) {
        return false;
    }
    lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
    nextChar = state.src.charCodeAt(start + 2);
    if (lastChar === 126) {
        return false;
    }
    if (nextChar === 126) {
        return false;
    }
    if (nextChar === 32 || nextChar === 10) {
        return false;
    }
    pos = start + 2;
    while(pos < max && state.src.charCodeAt(pos) === 126){
        pos++;
    }
    if (pos > start + 3) {
        state.pos += pos - start;
        if (!silent) {
            state.pending += state.src.slice(start, pos);
        }
        return true;
    }
    state.pos = start + 2;
    stack = 1;
    while(state.pos + 1 < max){
        if (state.src.charCodeAt(state.pos) === 126) {
            if (state.src.charCodeAt(state.pos + 1) === 126) {
                lastChar = state.src.charCodeAt(state.pos - 1);
                nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
                if (nextChar !== 126 && lastChar !== 126) {
                    if (lastChar !== 32 && lastChar !== 10) {
                        stack--;
                    } else if (nextChar !== 32 && nextChar !== 10) {
                        stack++;
                    }
                    if (stack <= 0) {
                        found = true;
                        break;
                    }
                }
            }
        }
        state.parser.skipToken(state);
    }
    if (!found) {
        state.pos = start;
        return false;
    }
    state.posMax = state.pos;
    state.pos = start + 2;
    if (!silent) {
        state.push({
            type: "del_open",
            level: state.level++
        });
        state.parser.tokenize(state);
        state.push({
            type: "del_close",
            level: --state.level
        });
    }
    state.pos = state.posMax + 2;
    state.posMax = max;
    return true;
}
function ins(state, silent) {
    var found, pos, stack, max = state.posMax, start = state.pos, lastChar, nextChar;
    if (state.src.charCodeAt(start) !== 43) {
        return false;
    }
    if (silent) {
        return false;
    }
    if (start + 4 >= max) {
        return false;
    }
    if (state.src.charCodeAt(start + 1) !== 43) {
        return false;
    }
    if (state.level >= state.options.maxNesting) {
        return false;
    }
    lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
    nextChar = state.src.charCodeAt(start + 2);
    if (lastChar === 43) {
        return false;
    }
    if (nextChar === 43) {
        return false;
    }
    if (nextChar === 32 || nextChar === 10) {
        return false;
    }
    pos = start + 2;
    while(pos < max && state.src.charCodeAt(pos) === 43){
        pos++;
    }
    if (pos !== start + 2) {
        state.pos += pos - start;
        if (!silent) {
            state.pending += state.src.slice(start, pos);
        }
        return true;
    }
    state.pos = start + 2;
    stack = 1;
    while(state.pos + 1 < max){
        if (state.src.charCodeAt(state.pos) === 43) {
            if (state.src.charCodeAt(state.pos + 1) === 43) {
                lastChar = state.src.charCodeAt(state.pos - 1);
                nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
                if (nextChar !== 43 && lastChar !== 43) {
                    if (lastChar !== 32 && lastChar !== 10) {
                        stack--;
                    } else if (nextChar !== 32 && nextChar !== 10) {
                        stack++;
                    }
                    if (stack <= 0) {
                        found = true;
                        break;
                    }
                }
            }
        }
        state.parser.skipToken(state);
    }
    if (!found) {
        state.pos = start;
        return false;
    }
    state.posMax = state.pos;
    state.pos = start + 2;
    if (!silent) {
        state.push({
            type: "ins_open",
            level: state.level++
        });
        state.parser.tokenize(state);
        state.push({
            type: "ins_close",
            level: --state.level
        });
    }
    state.pos = state.posMax + 2;
    state.posMax = max;
    return true;
}
function mark(state, silent) {
    var found, pos, stack, max = state.posMax, start = state.pos, lastChar, nextChar;
    if (state.src.charCodeAt(start) !== 61) {
        return false;
    }
    if (silent) {
        return false;
    }
    if (start + 4 >= max) {
        return false;
    }
    if (state.src.charCodeAt(start + 1) !== 61) {
        return false;
    }
    if (state.level >= state.options.maxNesting) {
        return false;
    }
    lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
    nextChar = state.src.charCodeAt(start + 2);
    if (lastChar === 61) {
        return false;
    }
    if (nextChar === 61) {
        return false;
    }
    if (nextChar === 32 || nextChar === 10) {
        return false;
    }
    pos = start + 2;
    while(pos < max && state.src.charCodeAt(pos) === 61){
        pos++;
    }
    if (pos !== start + 2) {
        state.pos += pos - start;
        if (!silent) {
            state.pending += state.src.slice(start, pos);
        }
        return true;
    }
    state.pos = start + 2;
    stack = 1;
    while(state.pos + 1 < max){
        if (state.src.charCodeAt(state.pos) === 61) {
            if (state.src.charCodeAt(state.pos + 1) === 61) {
                lastChar = state.src.charCodeAt(state.pos - 1);
                nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
                if (nextChar !== 61 && lastChar !== 61) {
                    if (lastChar !== 32 && lastChar !== 10) {
                        stack--;
                    } else if (nextChar !== 32 && nextChar !== 10) {
                        stack++;
                    }
                    if (stack <= 0) {
                        found = true;
                        break;
                    }
                }
            }
        }
        state.parser.skipToken(state);
    }
    if (!found) {
        state.pos = start;
        return false;
    }
    state.posMax = state.pos;
    state.pos = start + 2;
    if (!silent) {
        state.push({
            type: "mark_open",
            level: state.level++
        });
        state.parser.tokenize(state);
        state.push({
            type: "mark_close",
            level: --state.level
        });
    }
    state.pos = state.posMax + 2;
    state.posMax = max;
    return true;
}
function isAlphaNum(code2) {
    return code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 90 || code2 >= 97 && code2 <= 122;
}
function scanDelims(state, start) {
    var pos = start, lastChar, nextChar, count, can_open = true, can_close = true, max = state.posMax, marker = state.src.charCodeAt(start);
    lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
    while(pos < max && state.src.charCodeAt(pos) === marker){
        pos++;
    }
    if (pos >= max) {
        can_open = false;
    }
    count = pos - start;
    if (count >= 4) {
        can_open = can_close = false;
    } else {
        nextChar = pos < max ? state.src.charCodeAt(pos) : -1;
        if (nextChar === 32 || nextChar === 10) {
            can_open = false;
        }
        if (lastChar === 32 || lastChar === 10) {
            can_close = false;
        }
        if (marker === 95) {
            if (isAlphaNum(lastChar)) {
                can_open = false;
            }
            if (isAlphaNum(nextChar)) {
                can_close = false;
            }
        }
    }
    return {
        can_open,
        can_close,
        delims: count
    };
}
function emphasis(state, silent) {
    var startCount, count, found, oldCount, newCount, stack, res, max = state.posMax, start = state.pos, marker = state.src.charCodeAt(start);
    if (marker !== 95 && marker !== 42) {
        return false;
    }
    if (silent) {
        return false;
    }
    res = scanDelims(state, start);
    startCount = res.delims;
    if (!res.can_open) {
        state.pos += startCount;
        if (!silent) {
            state.pending += state.src.slice(start, state.pos);
        }
        return true;
    }
    if (state.level >= state.options.maxNesting) {
        return false;
    }
    state.pos = start + startCount;
    stack = [
        startCount
    ];
    while(state.pos < max){
        if (state.src.charCodeAt(state.pos) === marker) {
            res = scanDelims(state, state.pos);
            count = res.delims;
            if (res.can_close) {
                oldCount = stack.pop();
                newCount = count;
                while(oldCount !== newCount){
                    if (newCount < oldCount) {
                        stack.push(oldCount - newCount);
                        break;
                    }
                    newCount -= oldCount;
                    if (stack.length === 0) {
                        break;
                    }
                    state.pos += oldCount;
                    oldCount = stack.pop();
                }
                if (stack.length === 0) {
                    startCount = oldCount;
                    found = true;
                    break;
                }
                state.pos += count;
                continue;
            }
            if (res.can_open) {
                stack.push(count);
            }
            state.pos += count;
            continue;
        }
        state.parser.skipToken(state);
    }
    if (!found) {
        state.pos = start;
        return false;
    }
    state.posMax = state.pos;
    state.pos = start + startCount;
    if (!silent) {
        if (startCount === 2 || startCount === 3) {
            state.push({
                type: "strong_open",
                level: state.level++
            });
        }
        if (startCount === 1 || startCount === 3) {
            state.push({
                type: "em_open",
                level: state.level++
            });
        }
        state.parser.tokenize(state);
        if (startCount === 1 || startCount === 3) {
            state.push({
                type: "em_close",
                level: --state.level
            });
        }
        if (startCount === 2 || startCount === 3) {
            state.push({
                type: "strong_close",
                level: --state.level
            });
        }
    }
    state.pos = state.posMax + startCount;
    state.posMax = max;
    return true;
}
var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;
function sub(state, silent) {
    var found, content, max = state.posMax, start = state.pos;
    if (state.src.charCodeAt(start) !== 126) {
        return false;
    }
    if (silent) {
        return false;
    }
    if (start + 2 >= max) {
        return false;
    }
    if (state.level >= state.options.maxNesting) {
        return false;
    }
    state.pos = start + 1;
    while(state.pos < max){
        if (state.src.charCodeAt(state.pos) === 126) {
            found = true;
            break;
        }
        state.parser.skipToken(state);
    }
    if (!found || start + 1 === state.pos) {
        state.pos = start;
        return false;
    }
    content = state.src.slice(start + 1, state.pos);
    if (content.match(/(^|[^\\])(\\\\)*\s/)) {
        state.pos = start;
        return false;
    }
    state.posMax = state.pos;
    state.pos = start + 1;
    if (!silent) {
        state.push({
            type: "sub",
            level: state.level,
            content: content.replace(UNESCAPE_RE, "$1")
        });
    }
    state.pos = state.posMax + 1;
    state.posMax = max;
    return true;
}
var UNESCAPE_RE$1 = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;
function sup(state, silent) {
    var found, content, max = state.posMax, start = state.pos;
    if (state.src.charCodeAt(start) !== 94) {
        return false;
    }
    if (silent) {
        return false;
    }
    if (start + 2 >= max) {
        return false;
    }
    if (state.level >= state.options.maxNesting) {
        return false;
    }
    state.pos = start + 1;
    while(state.pos < max){
        if (state.src.charCodeAt(state.pos) === 94) {
            found = true;
            break;
        }
        state.parser.skipToken(state);
    }
    if (!found || start + 1 === state.pos) {
        state.pos = start;
        return false;
    }
    content = state.src.slice(start + 1, state.pos);
    if (content.match(/(^|[^\\])(\\\\)*\s/)) {
        state.pos = start;
        return false;
    }
    state.posMax = state.pos;
    state.pos = start + 1;
    if (!silent) {
        state.push({
            type: "sup",
            level: state.level,
            content: content.replace(UNESCAPE_RE$1, "$1")
        });
    }
    state.pos = state.posMax + 1;
    state.posMax = max;
    return true;
}
function links(state, silent) {
    var labelStart, labelEnd, label, href, title, pos, ref, code2, isImage = false, oldPos = state.pos, max = state.posMax, start = state.pos, marker = state.src.charCodeAt(start);
    if (marker === 33) {
        isImage = true;
        marker = state.src.charCodeAt(++start);
    }
    if (marker !== 91) {
        return false;
    }
    if (state.level >= state.options.maxNesting) {
        return false;
    }
    labelStart = start + 1;
    labelEnd = parseLinkLabel(state, start);
    if (labelEnd < 0) {
        return false;
    }
    pos = labelEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for(; pos < max; pos++){
            code2 = state.src.charCodeAt(pos);
            if (code2 !== 32 && code2 !== 10) {
                break;
            }
        }
        if (pos >= max) {
            return false;
        }
        start = pos;
        if (parseLinkDestination(state, pos)) {
            href = state.linkContent;
            pos = state.pos;
        } else {
            href = "";
        }
        start = pos;
        for(; pos < max; pos++){
            code2 = state.src.charCodeAt(pos);
            if (code2 !== 32 && code2 !== 10) {
                break;
            }
        }
        if (pos < max && start !== pos && parseLinkTitle(state, pos)) {
            title = state.linkContent;
            pos = state.pos;
            for(; pos < max; pos++){
                code2 = state.src.charCodeAt(pos);
                if (code2 !== 32 && code2 !== 10) {
                    break;
                }
            }
        } else {
            title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
            state.pos = oldPos;
            return false;
        }
        pos++;
    } else {
        if (state.linkLevel > 0) {
            return false;
        }
        for(; pos < max; pos++){
            code2 = state.src.charCodeAt(pos);
            if (code2 !== 32 && code2 !== 10) {
                break;
            }
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
            start = pos + 1;
            pos = parseLinkLabel(state, pos);
            if (pos >= 0) {
                label = state.src.slice(start, pos++);
            } else {
                pos = start - 1;
            }
        }
        if (!label) {
            if (typeof label === "undefined") {
                pos = labelEnd + 1;
            }
            label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
            state.pos = oldPos;
            return false;
        }
        href = ref.href;
        title = ref.title;
    }
    if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        if (isImage) {
            state.push({
                type: "image",
                src: href,
                title,
                alt: state.src.substr(labelStart, labelEnd - labelStart),
                level: state.level
            });
        } else {
            state.push({
                type: "link_open",
                href,
                title,
                level: state.level++
            });
            state.linkLevel++;
            state.parser.tokenize(state);
            state.linkLevel--;
            state.push({
                type: "link_close",
                level: --state.level
            });
        }
    }
    state.pos = pos;
    state.posMax = max;
    return true;
}
function footnote_inline(state, silent) {
    var labelStart, labelEnd, footnoteId, oldLength, max = state.posMax, start = state.pos;
    if (start + 2 >= max) {
        return false;
    }
    if (state.src.charCodeAt(start) !== 94) {
        return false;
    }
    if (state.src.charCodeAt(start + 1) !== 91) {
        return false;
    }
    if (state.level >= state.options.maxNesting) {
        return false;
    }
    labelStart = start + 2;
    labelEnd = parseLinkLabel(state, start + 1);
    if (labelEnd < 0) {
        return false;
    }
    if (!silent) {
        if (!state.env.footnotes) {
            state.env.footnotes = {
            };
        }
        if (!state.env.footnotes.list) {
            state.env.footnotes.list = [];
        }
        footnoteId = state.env.footnotes.list.length;
        state.pos = labelStart;
        state.posMax = labelEnd;
        state.push({
            type: "footnote_ref",
            id: footnoteId,
            level: state.level
        });
        state.linkLevel++;
        oldLength = state.tokens.length;
        state.parser.tokenize(state);
        state.env.footnotes.list[footnoteId] = {
            tokens: state.tokens.splice(oldLength)
        };
        state.linkLevel--;
    }
    state.pos = labelEnd + 1;
    state.posMax = max;
    return true;
}
function footnote_ref(state, silent) {
    var label, pos, footnoteId, footnoteSubId, max = state.posMax, start = state.pos;
    if (start + 3 > max) {
        return false;
    }
    if (!state.env.footnotes || !state.env.footnotes.refs) {
        return false;
    }
    if (state.src.charCodeAt(start) !== 91) {
        return false;
    }
    if (state.src.charCodeAt(start + 1) !== 94) {
        return false;
    }
    if (state.level >= state.options.maxNesting) {
        return false;
    }
    for(pos = start + 2; pos < max; pos++){
        if (state.src.charCodeAt(pos) === 32) {
            return false;
        }
        if (state.src.charCodeAt(pos) === 10) {
            return false;
        }
        if (state.src.charCodeAt(pos) === 93) {
            break;
        }
    }
    if (pos === start + 2) {
        return false;
    }
    if (pos >= max) {
        return false;
    }
    pos++;
    label = state.src.slice(start + 2, pos - 1);
    if (typeof state.env.footnotes.refs[":" + label] === "undefined") {
        return false;
    }
    if (!silent) {
        if (!state.env.footnotes.list) {
            state.env.footnotes.list = [];
        }
        if (state.env.footnotes.refs[":" + label] < 0) {
            footnoteId = state.env.footnotes.list.length;
            state.env.footnotes.list[footnoteId] = {
                label,
                count: 0
            };
            state.env.footnotes.refs[":" + label] = footnoteId;
        } else {
            footnoteId = state.env.footnotes.refs[":" + label];
        }
        footnoteSubId = state.env.footnotes.list[footnoteId].count;
        state.env.footnotes.list[footnoteId].count++;
        state.push({
            type: "footnote_ref",
            id: footnoteId,
            subId: footnoteSubId,
            level: state.level
        });
    }
    state.pos = pos;
    state.posMax = max;
    return true;
}
var url_schemas = [
    "coap",
    "doi",
    "javascript",
    "aaa",
    "aaas",
    "about",
    "acap",
    "cap",
    "cid",
    "crid",
    "data",
    "dav",
    "dict",
    "dns",
    "file",
    "ftp",
    "geo",
    "go",
    "gopher",
    "h323",
    "http",
    "https",
    "iax",
    "icap",
    "im",
    "imap",
    "info",
    "ipp",
    "iris",
    "iris.beep",
    "iris.xpc",
    "iris.xpcs",
    "iris.lwz",
    "ldap",
    "mailto",
    "mid",
    "msrp",
    "msrps",
    "mtqp",
    "mupdate",
    "news",
    "nfs",
    "ni",
    "nih",
    "nntp",
    "opaquelocktoken",
    "pop",
    "pres",
    "rtsp",
    "service",
    "session",
    "shttp",
    "sieve",
    "sip",
    "sips",
    "sms",
    "snmp",
    "soap.beep",
    "soap.beeps",
    "tag",
    "tel",
    "telnet",
    "tftp",
    "thismessage",
    "tn3270",
    "tip",
    "tv",
    "urn",
    "vemmi",
    "ws",
    "wss",
    "xcon",
    "xcon-userid",
    "xmlrpc.beep",
    "xmlrpc.beeps",
    "xmpp",
    "z39.50r",
    "z39.50s",
    "adiumxtra",
    "afp",
    "afs",
    "aim",
    "apt",
    "attachment",
    "aw",
    "beshare",
    "bitcoin",
    "bolo",
    "callto",
    "chrome",
    "chrome-extension",
    "com-eventbrite-attendee",
    "content",
    "cvs",
    "dlna-playsingle",
    "dlna-playcontainer",
    "dtn",
    "dvb",
    "ed2k",
    "facetime",
    "feed",
    "finger",
    "fish",
    "gg",
    "git",
    "gizmoproject",
    "gtalk",
    "hcp",
    "icon",
    "ipn",
    "irc",
    "irc6",
    "ircs",
    "itms",
    "jar",
    "jms",
    "keyparc",
    "lastfm",
    "ldaps",
    "magnet",
    "maps",
    "market",
    "message",
    "mms",
    "ms-help",
    "msnim",
    "mumble",
    "mvn",
    "notes",
    "oid",
    "palm",
    "paparazzi",
    "platform",
    "proxy",
    "psyc",
    "query",
    "res",
    "resource",
    "rmi",
    "rsync",
    "rtmp",
    "secondlife",
    "sftp",
    "sgn",
    "skype",
    "smb",
    "soldat",
    "spotify",
    "ssh",
    "steam",
    "svn",
    "teamspeak",
    "things",
    "udp",
    "unreal",
    "ut2004",
    "ventrilo",
    "view-source",
    "webcal",
    "wtai",
    "wyciwyg",
    "xfire",
    "xri",
    "ymsgr"
];
var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z.\-]{1,25}):([^<>\x00-\x20]*)>/;
function autolink(state, silent) {
    var tail, linkMatch, emailMatch, url, fullUrl, pos = state.pos;
    if (state.src.charCodeAt(pos) !== 60) {
        return false;
    }
    tail = state.src.slice(pos);
    if (tail.indexOf(">") < 0) {
        return false;
    }
    linkMatch = tail.match(AUTOLINK_RE);
    if (linkMatch) {
        if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) {
            return false;
        }
        url = linkMatch[0].slice(1, -1);
        fullUrl = normalizeLink(url);
        if (!state.parser.validateLink(url)) {
            return false;
        }
        if (!silent) {
            state.push({
                type: "link_open",
                href: fullUrl,
                level: state.level
            });
            state.push({
                type: "text",
                content: url,
                level: state.level + 1
            });
            state.push({
                type: "link_close",
                level: state.level
            });
        }
        state.pos += linkMatch[0].length;
        return true;
    }
    emailMatch = tail.match(EMAIL_RE);
    if (emailMatch) {
        url = emailMatch[0].slice(1, -1);
        fullUrl = normalizeLink("mailto:" + url);
        if (!state.parser.validateLink(fullUrl)) {
            return false;
        }
        if (!silent) {
            state.push({
                type: "link_open",
                href: fullUrl,
                level: state.level
            });
            state.push({
                type: "text",
                content: url,
                level: state.level + 1
            });
            state.push({
                type: "link_close",
                level: state.level
            });
        }
        state.pos += emailMatch[0].length;
        return true;
    }
    return false;
}
function replace$1(regex, options) {
    regex = regex.source;
    options = options || "";
    return function self(name, val) {
        if (!name) {
            return new RegExp(regex, options);
        }
        val = val.source || val;
        regex = regex.replace(name, val);
        return self;
    };
}
var attr_name = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;
var unquoted = /[^"'=<>`\x00-\x20]+/;
var single_quoted = /'[^']*'/;
var double_quoted = /"[^"]*"/;
var attr_value = replace$1(/(?:unquoted|single_quoted|double_quoted)/)("unquoted", unquoted)("single_quoted", single_quoted)("double_quoted", double_quoted)();
var attribute = replace$1(/(?:\s+attr_name(?:\s*=\s*attr_value)?)/)("attr_name", attr_name)("attr_value", attr_value)();
var open_tag = replace$1(/<[A-Za-z][A-Za-z0-9]*attribute*\s*\/?>/)("attribute", attribute)();
var close_tag = /<\/[A-Za-z][A-Za-z0-9]*\s*>/;
var comment = /<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;
var processing = /<[?].*?[?]>/;
var declaration = /<![A-Z]+\s+[^>]*>/;
var cdata = /<!\[CDATA\[[\s\S]*?\]\]>/;
var HTML_TAG_RE = replace$1(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)("open_tag", open_tag)("close_tag", close_tag)("comment", comment)("processing", processing)("declaration", declaration)("cdata", cdata)();
function isLetter$2(ch) {
    var lc = ch | 32;
    return lc >= 97 && lc <= 122;
}
function htmltag(state, silent) {
    var ch, match, max, pos = state.pos;
    if (!state.options.html) {
        return false;
    }
    max = state.posMax;
    if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
    }
    ch = state.src.charCodeAt(pos + 1);
    if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter$2(ch)) {
        return false;
    }
    match = state.src.slice(pos).match(HTML_TAG_RE);
    if (!match) {
        return false;
    }
    if (!silent) {
        state.push({
            type: "htmltag",
            content: state.src.slice(pos, pos + match[0].length),
            level: state.level
        });
    }
    state.pos += match[0].length;
    return true;
}
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
function entity(state, silent) {
    var ch, code2, match, pos = state.pos, max = state.posMax;
    if (state.src.charCodeAt(pos) !== 38) {
        return false;
    }
    if (pos + 1 < max) {
        ch = state.src.charCodeAt(pos + 1);
        if (ch === 35) {
            match = state.src.slice(pos).match(DIGITAL_RE);
            if (match) {
                if (!silent) {
                    code2 = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
                    state.pending += isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
                }
                state.pos += match[0].length;
                return true;
            }
        } else {
            match = state.src.slice(pos).match(NAMED_RE);
            if (match) {
                var decoded = decodeEntity(match[1]);
                if (match[1] !== decoded) {
                    if (!silent) {
                        state.pending += decoded;
                    }
                    state.pos += match[0].length;
                    return true;
                }
            }
        }
    }
    if (!silent) {
        state.pending += "&";
    }
    state.pos++;
    return true;
}
var _rules$2 = [
    [
        "text",
        text
    ],
    [
        "newline",
        newline
    ],
    [
        "escape",
        escape
    ],
    [
        "backticks",
        backticks
    ],
    [
        "del",
        del
    ],
    [
        "ins",
        ins
    ],
    [
        "mark",
        mark
    ],
    [
        "emphasis",
        emphasis
    ],
    [
        "sub",
        sub
    ],
    [
        "sup",
        sup
    ],
    [
        "links",
        links
    ],
    [
        "footnote_inline",
        footnote_inline
    ],
    [
        "footnote_ref",
        footnote_ref
    ],
    [
        "autolink",
        autolink
    ],
    [
        "htmltag",
        htmltag
    ],
    [
        "entity",
        entity
    ]
];
function ParserInline() {
    this.ruler = new Ruler();
    for(var i1 = 0; i1 < _rules$2.length; i1++){
        this.ruler.push(_rules$2[i1][0], _rules$2[i1][1]);
    }
    this.validateLink = validateLink;
}
ParserInline.prototype.skipToken = function(state) {
    var rules2 = this.ruler.getRules("");
    var len = rules2.length;
    var pos = state.pos;
    var i1, cached_pos;
    if ((cached_pos = state.cacheGet(pos)) > 0) {
        state.pos = cached_pos;
        return;
    }
    for(i1 = 0; i1 < len; i1++){
        if (rules2[i1](state, true)) {
            state.cacheSet(pos, state.pos);
            return;
        }
    }
    state.pos++;
    state.cacheSet(pos, state.pos);
};
ParserInline.prototype.tokenize = function(state) {
    var rules2 = this.ruler.getRules("");
    var len = rules2.length;
    var end = state.posMax;
    var ok, i1;
    while(state.pos < end){
        for(i1 = 0; i1 < len; i1++){
            ok = rules2[i1](state, false);
            if (ok) {
                break;
            }
        }
        if (ok) {
            if (state.pos >= end) {
                break;
            }
            continue;
        }
        state.pending += state.src[state.pos++];
    }
    if (state.pending) {
        state.pushPending();
    }
};
ParserInline.prototype.parse = function(str, options, env, outTokens) {
    var state = new StateInline(str, this, options, env, outTokens);
    this.tokenize(state);
};
function validateLink(url) {
    var BAD_PROTOCOLS = [
        "vbscript",
        "javascript",
        "file",
        "data"
    ];
    var str = url.trim().toLowerCase();
    str = replaceEntities(str);
    if (str.indexOf(":") !== -1 && BAD_PROTOCOLS.indexOf(str.split(":")[0]) !== -1) {
        return false;
    }
    return true;
}
var defaultConfig = {
    options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkTarget: "",
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 20
    },
    components: {
        core: {
            rules: [
                "block",
                "inline",
                "references",
                "replacements",
                "smartquotes",
                "references",
                "abbr2",
                "footnote_tail"
            ]
        },
        block: {
            rules: [
                "blockquote",
                "code",
                "fences",
                "footnote",
                "heading",
                "hr",
                "htmlblock",
                "lheading",
                "list",
                "paragraph",
                "table"
            ]
        },
        inline: {
            rules: [
                "autolink",
                "backticks",
                "del",
                "emphasis",
                "entity",
                "escape",
                "footnote_ref",
                "htmltag",
                "links",
                "newline",
                "text"
            ]
        }
    }
};
var fullConfig = {
    options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkTarget: "",
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 20
    },
    components: {
        core: {
        },
        block: {
        },
        inline: {
        }
    }
};
var commonmarkConfig = {
    options: {
        html: true,
        xhtmlOut: true,
        breaks: false,
        langPrefix: "language-",
        linkTarget: "",
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 20
    },
    components: {
        core: {
            rules: [
                "block",
                "inline",
                "references",
                "abbr2"
            ]
        },
        block: {
            rules: [
                "blockquote",
                "code",
                "fences",
                "heading",
                "hr",
                "htmlblock",
                "lheading",
                "list",
                "paragraph"
            ]
        },
        inline: {
            rules: [
                "autolink",
                "backticks",
                "emphasis",
                "entity",
                "escape",
                "htmltag",
                "links",
                "newline",
                "text"
            ]
        }
    }
};
var config = {
    default: defaultConfig,
    full: fullConfig,
    commonmark: commonmarkConfig
};
function StateCore(instance, str, env) {
    this.src = str;
    this.env = env;
    this.options = instance.options;
    this.tokens = [];
    this.inlineMode = false;
    this.inline = instance.inline;
    this.block = instance.block;
    this.renderer = instance.renderer;
    this.typographer = instance.typographer;
}
function Remarkable(preset, options) {
    if (typeof preset !== "string") {
        options = preset;
        preset = "default";
    }
    if (options && options.linkify != null) {
        console.warn("linkify option is removed. Use linkify plugin instead:\n\nimport Remarkable from 'remarkable';\nimport linkify from 'remarkable/linkify';\nnew Remarkable().use(linkify)\n");
    }
    this.inline = new ParserInline();
    this.block = new ParserBlock();
    this.core = new Core();
    this.renderer = new Renderer();
    this.ruler = new Ruler();
    this.options = {
    };
    this.configure(config[preset]);
    this.set(options || {
    });
}
Remarkable.prototype.set = function(options) {
    assign(this.options, options);
};
Remarkable.prototype.configure = function(presets) {
    var self = this;
    if (!presets) {
        throw new Error("Wrong `remarkable` preset, check name/content");
    }
    if (presets.options) {
        self.set(presets.options);
    }
    if (presets.components) {
        Object.keys(presets.components).forEach(function(name) {
            if (presets.components[name].rules) {
                self[name].ruler.enable(presets.components[name].rules, true);
            }
        });
    }
};
Remarkable.prototype.use = function(plugin, options) {
    plugin(this, options);
    return this;
};
Remarkable.prototype.parse = function(str, env) {
    var state = new StateCore(this, str, env);
    this.core.process(state);
    return state.tokens;
};
Remarkable.prototype.render = function(str, env) {
    env = env || {
    };
    return this.renderer.render(this.parse(str, env), this.options, env);
};
Remarkable.prototype.parseInline = function(str, env) {
    var state = new StateCore(this, str, env);
    state.inlineMode = true;
    this.core.process(state);
    return state.tokens;
};
Remarkable.prototype.renderInline = function(str, env) {
    env = env || {
    };
    return this.renderer.render(this.parseInline(str, env), this.options, env);
};
function ast(str, options) {
    function isOpen(tok2) {
        return /_open$/.test(tok2.type);
    }
    function isClose(tok2) {
        return /_close$/.test(tok2.type);
    }
    function toType(tok2) {
        return tok2.type.replace(/_open$/, "");
    }
    var md = new Remarkable(options);
    var tokens = md.parse(str, md);
    var node = {
        type: "root",
        nodes: []
    };
    var nodes = [
        node
    ];
    var stack = [];
    var len = tokens.length;
    var idx = -1;
    function last() {
        return stack.length ? stack[stack.length - 1] : nodes[nodes.length - 1];
    }
    while((++idx) < len){
        var tok = tokens[idx];
        var prev = last();
        if (isOpen(tok)) {
            var token = {
                type: toType(tok),
                nodes: [
                    tok
                ]
            };
            prev.nodes.push(token);
            stack.push(token);
        } else if (isClose(tok)) {
            var parent = stack.pop();
            parent.nodes.push(tok);
        } else {
            prev.nodes.push(tok);
        }
    }
    return node;
}
const nest = (ast2, level = 1)=>{
    if (ast2.findIndex((block2)=>block2.type === "heading" && block2.nodes[0].hLevel === level
    ) === -1) {
        return ast2;
    }
    const headings = ast2.reduce((result, block2)=>{
        if (block2.type === "heading" && block2.nodes[0].hLevel === level) {
            result.state = block2.nodes[1].content;
        } else {
            result.dict[result.state] = [
                ...result.dict[result.state] || [],
                block2
            ];
        }
        return result;
    }, {
        dict: {
        },
        state: null
    }).dict;
    return Object.keys(headings).map((heading2)=>({
            heading: heading2,
            childs: nest(headings[heading2], level + 1)
        })
    );
};
const extractInline = (nodes, raw)=>{
    if (nodes[1] && nodes[1].type === "inline") {
        if (!raw && nodes[1].children && nodes[1].children[0].type === "link_open") {
            return {
                url: nodes[1].children[0].href,
                text: nodes[1].children[1].content
            };
        }
        const string = nodes[1].content;
        return string;
    }
    return nodes.filter((node)=>node.nodes
    ).flatMap((node)=>extractInline(node.nodes)
    );
};
const toDict = (nodes)=>Array.isArray(nodes) && nodes[0].heading ? Object.assign(...nodes.map(({ heading: heading2 , childs  })=>({
            [heading2]: childs ? toDict(childs) : null
        })
    )) : nodes
;
const extract = (nodes)=>{
    return nodes.map((node)=>{
        if (Array.isArray(node.childs)) {
            node.childs = extract(node.childs);
        }
        if ([
            "bullet_list",
            "ordered_list"
        ].includes(node.type)) {
            return extract(node.nodes.filter((node2)=>node2.type === "list_item"
            )).flat();
        }
        if (node.type === "list_item") {
            return extract(node.nodes.filter((node2)=>[
                    "paragraph",
                    "bullet_list",
                    "ordered_list"
                ].includes(node2.type)
            ));
        }
        if (node.nodes) {
            return extractInline(node.nodes);
        }
        return node;
    });
};
const _jsonifymd = (data, config2 = {
})=>{
    const output = ast(data);
    const headings = nest(output.nodes);
    if (config2.explicit) {
        return extract(headings);
    }
    return toDict(extract(headings));
};
const jsonifymd = {
    url: async (url, config2)=>{
        const response = await fetch(url);
        const data = await response.text();
        return _jsonifymd(data, config2);
    },
    text: (text2, config2)=>_jsonifymd(text2, config2)
};
export { jsonifymd as default };

